# 有哪些入行三五年后必须明白的道理

## 序言
Hello 各位读者朋友，今天分享一篇感悟，**希冀对读者的职业生涯有所帮助**。

对我比较熟悉的读者知道，过去发布的内容主要有**三个方面**：

* 源码、机制分析
* 好玩系列，分享方案探索经历和结论成果
* 枯燥的总结类文章

但从未分享过 "感悟" ，过去我觉得这种文章比较**矫情** ， 作者与读者所处的环境不同，也难以引起 `共情` ，往往难以达到分享的目的效果。
直到前段时间读到一句话：**"旁人不是被你劝服了，而是自己想开了"**。自此了悟，阅读他人感悟最重要的是 **跟随作者的叙事步伐进行一次 `精神修炼`，
收获全看各人缘法，而不是将作者的感悟拿来就用。**





道法术器源自道家。是道家进行哲学探知时的世界观和方法论。

本篇借用这一术语，来探究编程的一些问题，重点在于 `思考问题` 、`加深认知` 、`总结反思`，更好地解决问题以达到能力提升，而不是搞一些玄之又玄的东西。


## 道&与编程相关的道
> 老聃在道德经第一篇写到："道可道、非常道。名可名，非常名"。
> _常：恒，亘古客观存在，最原始的、最本真的_
> 河上公解之："道，可道也，非恒道也。名，可名也，非恒名也"

正如开篇所言，我们不是为了搞玄之又玄的东西，也不是去探讨哲学中的不可知论！河上公的解让我联想到了一则传言：

> 生活在北极的爱斯基摩人对白色有详细的区分，我们普通人眼中一片白茫茫的世界，在他们眼里却有着丰富的层次和色彩，他们可以用丰富的词汇
> 描述这些差异，譬如在阳光下的白色和阴影下的白色。他们之所以能看到我们视若无睹的东西，因为他们有相应的语言和命名。更科学一点讲，他们之所以
> 有这些词汇和命名，是先看到了这些东西，并且形成了普遍的认知，冠之以名并传承了下来。

我们不去探究这则传言的真实性，至少从它的内涵中可以得知，对于老聃而言，"恒道" 和 "恒名" 固然存在，却无法找到词汇去描述它，先民们并没有对它有
普遍的认知并冠之以名，你不去体悟它，哪怕造个名字你也无法理解它是啥，当你体悟并理解了它，叫什么名字反而不重要了。

诸如："代码简洁之道"，"项目快速迭代之道" 的说法都曾甚嚣尘上。但我个人认为这不是较为原始的道，最多是法门。

那么 `编程` 是在做什么事情呢？

我们用特定的语言编写可执行的程序、通过必要的编译（解释型语言不用编译），转换为字节码，最终变为机器码。

从人 `编写程序` 到 `CPU/GPU执行指令码` ，中间经历了很多步骤。

在Wikipedia中，关于 `code` 有如下解释：

> In communications and information processing,code is a system of rules to convert information

其重点在于信息的转变。众所周知，一般人理解不了机器码或者指令集，排除掉NLP、机器没法理解人类语言。而我们需要指挥机器为我们服务，需要将我们的意图转变为机器能够明白的机器码，这就是我们 `编写程序并编译`
的真是目的。

那么纵观整个过程，最重要的是什么呢？

是机器吗？是代码吗？NO！是人！

* 为了解决人的需求，人用自然语言描述了需求；
* 人用自己能够理解的编程语言实现了一个程序系统解决需求问题，编译后交给机器执行；
* 随着需求的演变，程序系统也需要升级，同样是人完成了从旧程序系统到新程序系统的演变；

而这些人中，最贴近编码环节的程序员。

此时，我们不难得出以下结论：编程之道中最重要的是 "以程序员为本" 。

但它太抽象了，我们补充一些具体的例子还体悟它：

* 程序员需要了解领域相关概念，反例：开发蓝牙相关功能，却连"SPP"、"BLE"等概念都不清楚；开发电商类系统，却连"下单"，"抢购"，"定金"等概念都不清楚
* 让程序员最大程度的理解上游的需求，反例：不提供原型或者更加专业的UML设计，仅给出边边角角的想法
* 程序员之间降低互相交流的门槛，反例：不使用统一的概念，不遵循编码规范，增加额外的阅读成本

透过这些例子，读者应该体会到了 "以程序员为本" 的道。

再具化一下 `编程之道` ， 按照道法自然的思想 ， 编程中的道应当契合编程的原始目的，并最大程度的方便过程的参与者。

下面再举两个小道一起体悟一下：

### 小道1

编程活动的目的是：让机器执行算法或指令，以解决问题，最终得到结果。

很显然：

* 程序不应当曲解问题
* 描述问题时，不应当遗漏客观存在的条件
* 对问题进行非等价转换时，不应当遗漏限制性条件

*PS:这些条则再明确一些，就是"法"*

否则程序会出现问题、或者朝着错误的方向演变。

### 小道2

结合编程活动参与者的知识体系和能力，做到最舒适的阅读理解程度：

* 不要引入过高的、不必要的复杂度，哪怕它看起来很"牛"
* 少写点没意义的注释，例如翻译方法名来证明自己英语很好
* 少引入说明文档外的词汇，来证明自己的词汇量
* 等等

*PS:这些条则再明确一些，就是"法"*

## 法

法有两种解释：

* 法律、规章、制度
* 方法

同样可以按照两种方式诠释：

* 在编程之道的统御下，所产生的规则集合
* 契合编程之道的方法（方法论）

我更倾向于第一种方式诠释，第二种更符合 "术" 的含义。

例如在面向对象编程范式（OOP）中的 `SOLID原则` ，就是法。

> 引申一下，中西方的文化和语言习惯存在一定的差别，先秦时期的用语非常地精炼，而西方对软件工程的一些描述已经是信息化时代了，不像前秦时期的
> 中文用语那么晦涩，且西方的语言习惯中，论述 "原则" 时会一并说明 "应该怎么做"。

*当然，我们没必要像孔乙己那样执着于茴香豆的茴字有四种写法，理解含义即可*

## 术

术是行为和技巧，用哲学中的词描述就是方法论，其重点在于："如何做"。一个问题被提出，在道的指导和法的约束下，应该如何做去解决它，这就是术。

举一个例子：

"在面向对象编程设计的过程中，需要保有扩展性，以应对现实情况的增加"，这是一个问题，
让问题具体一点：你为公司开发了一款即时聊天系统，用于内部沟通，目前仅发送即时消息，因为工作需要，需要增加一个途径：发送邮件。

在这个问题背后的道太多了，每个人都能说出点道道来，道应当每个人去体悟，而不是复制认知。但总归逃不开这几点：

* 设计上没做好就会让程序员很难受，代码难以维护，进一步变成代码不被维护
* 抽象！抽象！抽象！

据此，我们需要遵循一些法则：

* 代码设计有问题要及时重构，让程序员更容易理解，形成正向循环
* SOLID原则：
  * OCP：应当扩展类簇提供发邮件的能力，而不是修改发即时消息的类，硬塞发邮件的逻辑
  * SRP：即时消息相关的类都不应当由于增加发邮件而被修改
  * 里氏代换原则：合理抽象，问题不够明确不展开
  * DIP：重构原先的依赖关系，不再依赖细节，而是依赖抽象

在做这件事情的时候，可以使用的 "术" ：

* IOC/DI 即 控制反转或依赖注入，*它们是一体两面的，严格的讲，DI是实现IOC的一种方式*

对于比较难实现的 "术"，我们还需要一些工具来简化工作，这就要用到器。

## 器

器是工具，用来体现道的思想，简化问题，更快达成目标，是体现“器以载道”的应用。

在前文举得例子中，我们可以使用 `Dagger2` 、`Koin` 等工具，更简单、方便的实现IOC。