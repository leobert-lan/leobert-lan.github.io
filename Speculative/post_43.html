<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>初体验：动手搭建&quot;小清新式&quot;局域网文档系统 - leobert&#x27;s blog</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">目录</li><li class="chapter-item expanded "><a href="../Android/index.html"><strong aria-hidden="true">1.</strong> Android</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/View/index.html"><strong aria-hidden="true">1.1.</strong> View</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/View/post_1.html"><strong aria-hidden="true">1.1.1.</strong> 好玩系列：优雅的处理ButterKnife和KAE被废弃</a></li><li class="chapter-item expanded "><a href="../Android/View/post_6.html"><strong aria-hidden="true">1.1.2.</strong> 三思系列：View体系认知(一)，内容是如何正确被展现出来的--视觉呈现概览</a></li><li class="chapter-item expanded "><a href="../Android/View/post_7.html"><strong aria-hidden="true">1.1.3.</strong> 三思系列：为什么自定义View</a></li><li class="chapter-item expanded "><a href="../Android/Idea/post_9.html"><strong aria-hidden="true">1.1.4.</strong> 三思系列："声明式UI"和"命令式UI"，你的理解可能是错的</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/Drawable/index.html"><strong aria-hidden="true">1.2.</strong> Drawable</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/Drawable/post_2.html"><strong aria-hidden="true">1.2.1.</strong> 三思系列：重新认识Drawable</a></li><li class="chapter-item expanded "><a href="../Android/Drawable/post_4.html"><strong aria-hidden="true">1.2.2.</strong> 好玩系列：拥有它，XML文件少一半--更方便的处理View背景</a></li><li class="chapter-item expanded "><a href="../Android/Drawable/post_47.html"><strong aria-hidden="true">1.2.3.</strong> 迟来的续集--Drawable+Animator，将优雅进行到底</a></li><li class="chapter-item expanded "><a href="../Android/Drawable/post_49.html"><strong aria-hidden="true">1.2.4.</strong> 好玩系列：让ImageSpan动起来</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/Mechanism/Message/index.html"><strong aria-hidden="true">1.3.</strong> 消息机制</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/Mechanism/Message/post_8.html"><strong aria-hidden="true">1.3.1.</strong> 三思系列：Android的消息机制，一文吃透</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/Idea/post_14/index.html"><strong aria-hidden="true">1.4.</strong> 兼容</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/Idea/post_14.html"><strong aria-hidden="true">1.4.1.</strong> 好玩系列：让项目中的相册支持Heif格式图片</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/Glide/index.html"><strong aria-hidden="true">1.5.</strong> Glide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/Glide/post_15.html"><strong aria-hidden="true">1.5.1.</strong> 三思系列：Glide 4.X全方位认知 -- 模块职责概览</a></li><li class="chapter-item expanded "><a href="../Android/Glide/post_16.html"><strong aria-hidden="true">1.5.2.</strong> 三思系列：Glide 4.X加载过程一文掌握 | Glide（二）</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/KSP/index.html"><strong aria-hidden="true">1.6.</strong> KSP</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/KSP/post_24.html"><strong aria-hidden="true">1.6.1.</strong> 好玩系列 | 拥抱Kotlin Symbol Processing(KSP),项目实战</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/Base/index.html"><strong aria-hidden="true">1.7.</strong> 基础</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/Base/post_35.html"><strong aria-hidden="true">1.7.1.</strong> 孔乙己：你可知道页面和弹窗“通信“的方式有四种？</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/SysApp/index.html"><strong aria-hidden="true">1.8.</strong> 系统APP</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/SysApp/post_52.html"><strong aria-hidden="true">1.8.1.</strong> 使用日历丰富产品的用户体验</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/DI/index.html"><strong aria-hidden="true">1.9.</strong> Part4-依赖注入部分</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/DI/post_53.html"><strong aria-hidden="true">1.9.1.</strong> Hilt进阶--一文吃透Hilt自定义与跨壁垒</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../Compose/index.html"><strong aria-hidden="true">2.</strong> Jetpack Compose</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Compose/post_21.html"><strong aria-hidden="true">2.1.</strong> Jetpack Compose | 一文理解神奇的Modifier</a></li><li class="chapter-item expanded "><a href="../Compose/post_26.html"><strong aria-hidden="true">2.2.</strong> Jetpack Compose | 控件篇（一） -- Text、TextField、Button</a></li><li class="chapter-item expanded "><a href="../Compose/post_27.html"><strong aria-hidden="true">2.3.</strong> Jetpack Compose | 控件篇（二） -- Icon，Image</a></li><li class="chapter-item expanded "><a href="../Compose/post_28.html"><strong aria-hidden="true">2.4.</strong> Jetpack Compose | 控件篇（三） -- Switch、CheckBox、RadioButton</a></li><li class="chapter-item expanded "><a href="../Compose/post_29.html"><strong aria-hidden="true">2.5.</strong> Jetpack Compose | 控件篇（四）-- Box、Row、Column</a></li><li class="chapter-item expanded "><a href="../Compose/post_30.html"><strong aria-hidden="true">2.6.</strong> Jetpack Compose | 控件篇（五）-- Spacer、LazyRow、LazyColumn & 让Column可滑动</a></li></ol></li><li class="chapter-item expanded "><a href="../MultiThreading/index.html"><strong aria-hidden="true">3.</strong> Java多线程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../MultiThreading/post_33.html"><strong aria-hidden="true">3.1.</strong> 总纲</a></li><li class="chapter-item expanded "><a href="../MultiThreading/post_37.html"><strong aria-hidden="true">3.2.</strong> Java基础--图解JVM内存模型和JVM线程模型</a></li><li class="chapter-item expanded "><a href="../MultiThreading/post_38.html"><strong aria-hidden="true">3.3.</strong> Java多线程系列--掌控面试，一文吃透Synchronized锁</a></li><li class="chapter-item expanded "><a href="../MultiThreading/post_39.html"><strong aria-hidden="true">3.4.</strong> Java多线程基础--线程生命周期与线程协作详解</a></li><li class="chapter-item expanded "><a href="../MultiThreading/post_42.html"><strong aria-hidden="true">3.5.</strong> Java多线程基础--线程的创建与线程池管理</a></li><li class="chapter-item expanded "><a href="../MultiThreading/post_46.html"><strong aria-hidden="true">3.6.</strong> Java多线程系列--掌握Future，轻松获取异步任务结果</a></li><li class="chapter-item expanded "><a href="../MultiThreading/post_50.html"><strong aria-hidden="true">3.7.</strong> Java多线程系列--Fork&Join框架，分治的艺术</a></li><li class="chapter-item expanded "><a href="../MultiThreading/post_54.html"><strong aria-hidden="true">3.8.</strong> Java多线程系列--掌握CompletableFuture，驾驭异步编程</a></li></ol></li><li class="chapter-item expanded "><a href="../IO/index.html"><strong aria-hidden="true">4.</strong> Java IO系列</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../IO/post_55.html"><strong aria-hidden="true">4.1.</strong> Java IO 系列总纲</a></li><li class="chapter-item expanded "><a href="../IO/post_56.html"><strong aria-hidden="true">4.2.</strong> Java IO系列 | 经典 IO</a></li><li class="chapter-item expanded "><a href="../IO/post_57.html"><strong aria-hidden="true">4.3.</strong> Java IO 系列 | NIO-1.0一文速览</a></li><li class="chapter-item expanded "><a href="../IO/post_58.html"><strong aria-hidden="true">4.4.</strong> Java IO系列 | NIO-1.0拾遗、NIO-2.0 & 零拷贝必吹的牛皮</a></li><li class="chapter-item expanded "><a href="../IO/post_59.html"><strong aria-hidden="true">4.5.</strong> IO系列 | 一文掌握OKHTTP中的OKIO为什么这么OK</a></li></ol></li><li class="chapter-item expanded "><a href="../Gradle/index.html"><strong aria-hidden="true">5.</strong> Gradle</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Gradle/Modularization/post_18.html"><strong aria-hidden="true">5.1.</strong> 组件化：三思系列：组件化场景下module依赖优雅实践方案</a></li><li class="chapter-item expanded "><a href="../Gradle/Publish/post_17.html"><strong aria-hidden="true">5.2.</strong> MavenCentral发布：迁移到MavenCentral--再不行动起来，你的托管的library就没了</a></li><li class="chapter-item expanded "><a href="../Gradle/post_22.html"><strong aria-hidden="true">5.3.</strong> Gradle | 依赖管理最佳实践</a></li></ol></li><li class="chapter-item expanded "><a href="../Groovy/index.html"><strong aria-hidden="true">6.</strong> Groovy</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Groovy/why_write_groovy.html"><strong aria-hidden="true">6.1.</strong> 为什么撰写这个系列</a></li><li class="chapter-item expanded "><a href="../Groovy/post_23.html"><strong aria-hidden="true">6.2.</strong> Groovy：MOP一文打尽</a></li></ol></li><li class="chapter-item expanded "><a href="../Review/index.html"><strong aria-hidden="true">7.</strong> Review</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Review/post_10.html"><strong aria-hidden="true">7.1.</strong> 造完了这个轮子--Mocker，却让我感到很羞愧|项目复盘</a></li><li class="chapter-item expanded "><a href="../Review/post_40.html"><strong aria-hidden="true">7.2.</strong> 三思系列：前人用GreenDao留下的坑，全线被扣了绩效</a></li><li class="chapter-item expanded "><a href="../Review/post_44.html"><strong aria-hidden="true">7.3.</strong> 谈一谈在两个商业项目中使用MVI架构后的感悟</a></li><li class="chapter-item expanded "><a href="../Review/post_45.html"><strong aria-hidden="true">7.4.</strong> Review | 这三个坑你遇到了吗？</a></li></ol></li><li class="chapter-item expanded "><a href="../repo/index.html"><strong aria-hidden="true">8.</strong> 个人项目</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../repo/DaVinCi.html"><strong aria-hidden="true">8.1.</strong> DaVinCi,取代XML编写Shape或ColorStateList的方案</a></li><li class="chapter-item expanded "><a href="../Android/Idea/post_32.html"><strong aria-hidden="true">8.2.</strong> 好玩系列：白嫖一个优雅的类图生成工具</a></li><li class="chapter-item expanded "><a href="../Speculative/post_43.html" class="active"><strong aria-hidden="true">8.3.</strong> 初体验：动手搭建"小清新式"局域网文档系统</a></li><li class="chapter-item expanded "><a href="../repo/post_48.html"><strong aria-hidden="true">8.4.</strong> 研究良久，终于发现了他代码写的快且bug少的原因</a></li><li class="chapter-item expanded "><a href="../Speculative/post_61.html"><strong aria-hidden="true">8.5.</strong> 好玩系列 | 如果后端让你用SSE接收多次返回，那我们改造Retrofit吧</a></li></ol></li><li class="chapter-item expanded "><a href="../Review/DataStructure/index.html"><strong aria-hidden="true">9.</strong> 数据结构</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Review/DataStructure/post_11.html"><strong aria-hidden="true">9.1.</strong> 温故：线性表</a></li><li class="chapter-item expanded "><a href="../Review/DataStructure/post_12.html"><strong aria-hidden="true">9.2.</strong> 温故：栈</a></li><li class="chapter-item expanded "><a href="../Review/DataStructure/post_13.html"><strong aria-hidden="true">9.3.</strong> 温故：队列</a></li></ol></li><li class="chapter-item expanded "><a href="../Review/README2.html"><strong aria-hidden="true">10.</strong> 年终总结&计划</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Review/post_36.html"><strong aria-hidden="true">10.1.</strong> 2021年终总结</a></li><li class="chapter-item expanded "><a href="../Review/post_51.html"><strong aria-hidden="true">10.2.</strong> 关于画一个句号--基于2022年终总结的反思与分享</a></li><li class="chapter-item expanded "><a href="../Review/post_60.html"><strong aria-hidden="true">10.3.</strong> 突如其来的秋季反思</a></li><li class="chapter-item expanded "><a href="../Review/post_63.html"><strong aria-hidden="true">10.4.</strong> 2023年总结 寻找到源于内心深处的无穷力量</a></li><li class="chapter-item expanded "><a href="../Review/post_64.html"><strong aria-hidden="true">10.5.</strong> 2024年中思考，推倒樊笼重新出发</a></li></ol></li><li class="chapter-item expanded "><a href="../Note/index.html"><strong aria-hidden="true">11.</strong> 读书笔记</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Note/post_41.html"><strong aria-hidden="true">11.1.</strong> 读书笔记：《简约至上--交互式设计四策略》</a></li></ol></li><li class="chapter-item expanded "><a href="../Talk/index.html"><strong aria-hidden="true">12.</strong> 杂谈</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Talk/talk_1.html"><strong aria-hidden="true">12.1.</strong> 杂谈1-2022-11</a></li><li class="chapter-item expanded "><a href="../Talk/talk_2_2023-03.html"><strong aria-hidden="true">12.2.</strong> 杂篇（二）-- 认识并战胜焦虑</a></li><li class="chapter-item expanded "><a href="../Talk/talk_3_2024-08.html"><strong aria-hidden="true">12.3.</strong> 杂谈（三）-- 向钱看，你需要想明白企业在为什么而付钱</a></li></ol></li><li class="chapter-item expanded "><a href="../Thought/index.html"><strong aria-hidden="true">13.</strong> 半成熟的思考</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Thought/post_62.html"><strong aria-hidden="true">13.1.</strong> 好玩系列 | 当SPI 和 设计模式、依赖注入发生碰撞，可以擦出怎样的火花</a></li></ol></li><li class="chapter-item expanded "><a href="../info/index.html"><strong aria-hidden="true">14.</strong> 系列说明</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../info/about_view_series.html"><strong aria-hidden="true">14.1.</strong> 关于View系列</a></li><li class="chapter-item expanded "><a href="../info/about_sansi_series.html"><strong aria-hidden="true">14.2.</strong> 关于三思系列</a></li><li class="chapter-item expanded "><a href="../info/about_haowan_series.html"><strong aria-hidden="true">14.3.</strong> 关于好玩系列</a></li><li class="chapter-item expanded "><a href="../info/about_wengu_series.html"><strong aria-hidden="true">14.4.</strong> 关于温故系列</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">leobert&#x27;s blog</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="初体验动手搭建小清新式局域网文档系统"><a class="header" href="#初体验动手搭建小清新式局域网文档系统">初体验：动手搭建"小清新式"局域网文档系统</a></h1>
<blockquote>
<p>您所在的团队是否拥有良好的文档分享氛围？文档是否方便查询和阅读？更新文档是否非常繁琐？</p>
</blockquote>
<p>想象一下，如果您所在的团队拥有这样一套项目文档网站，是否 <strong>项目的长期维护会很轻松</strong> ？</p>
<p>就像Square公司的开源项目,通过聚合页引导至不同的项目 ：</p>
<p><img src="./post_43/square.png" alt="img.png" /></p>
<p>每个项目又拥有主题分明、聚合于目录导航下的网页文档，例如：</p>
<ul>
<li><a href="https://square.github.io/okhttp/">https://square.github.io/okhttp/</a></li>
<li><a href="https://square.github.io/retrofit/">https://square.github.io/retrofit/</a></li>
<li>...</li>
</ul>
<blockquote>
<p>诚然，通过 Github.IO 及类似方式，可以较为简单的部署一套在线静态文档网站。</p>
<p>但公司项目文档并不适合对外公开，您是否想在公司局域网范围内，自己动手搭建一套用于 <code>版本控制</code>、<code>自动部署</code>、<code>持续集成</code> 的网页文档呢？</p>
</blockquote>
<h2 id="以往的繁琐-与-如今的简明"><a class="header" href="#以往的繁琐-与-如今的简明">以往的繁琐 与 如今的简明</a></h2>
<p><img src="post_43/1.png" alt="" /></p>
<p>曾经，我像图中这样，在本地或EDM软件维护文档空间，经历繁琐地检索、排查找到文档，再进行分享、阅读。</p>
<p><img src="post_43/img.png" alt="img.png" /></p>
<p>而现在，我习惯像这样，访问网页，通过不超过3级的目录，直接定位到文档内容，进行阅读</p>
<h2 id="实现思路"><a class="header" href="#实现思路">实现思路</a></h2>
<p>核心思路：对重点内容编写轻量级文档，并以某种便于查找的索引方式聚合文档内容，将其托管于方便访问的网站。</p>
<p>典型的方式：</p>
<ul>
<li>使用Markdown形式的轻量级文档，撰写重点内容，每一篇都主题鲜明</li>
<li>按照主题与项目模块的之间的关系、主题之间的关联性，组织目录结构，形成 "索引"</li>
<li>是用Gitbook、博客生成器等软件，将其制作成静态网站</li>
<li>部署静态网站</li>
</ul>
<p>在此基础上，再加上自动部署、版本控制</p>
<p>涉及到的技能树，<em>其中蓝色高亮部分一般能让人眼前一亮</em>：</p>
<p><img src="./post_43/3.png" alt="" /></p>
<h2 id="判断是否需要继续阅读"><a class="header" href="#判断是否需要继续阅读">判断是否需要继续阅读</a></h2>
<p>可能您已经 <strong>满怀期待</strong> 地准备开始跟随博客 <strong>展开实践</strong>，但出于责任心，我建议您结合下述 <strong>流程图</strong> 和 <strong>参考经历</strong> 判断下 <strong>是否真的需要继续</strong> 。</p>
<p>如果您已经确定要了解笔者是如何实现这一系统的，可以直接进入下一个章节</p>
<p><img src="post_43/should_continue.png" alt="img.png" /></p>
<h3 id="供参考的例子"><a class="header" href="#供参考的例子">供参考的例子</a></h3>
<p><strong>A公司</strong></p>
<p>背景：</p>
<ul>
<li>研发团队百人规模，4-5条业务线，业务线之间存在一定数量的人员共享（例如移动端，web端后端救火队员）</li>
<li>业务线之间有（业务、技术）交流，流动人员需要接入、交出</li>
<li>除去服务端接口文档（YApi or Swagger），项目设计类文档一般托管于 <code>Confluence</code></li>
</ul>
<p>团队有强烈的 <strong>"基于文档交流、存档备份、查阅回顾、知识转移" 的需求</strong> ， <strong>有分享氛围</strong></p>
<p>遇到的典型困难：</p>
<ul>
<li>当不熟悉文档空间时，查找的难度大</li>
<li>维护文档空间内容索引难</li>
</ul>
<p><strong>B公司</strong></p>
<p>背景：</p>
<ul>
<li>业务线独立，互不干涉，基本没有技术沟通（私下的交流除外）</li>
<li>业务线研发团队30-40人规模</li>
<li>技术资料无明确要求</li>
</ul>
<p>仅在小组范围内存在 <strong>"碎片化"</strong> 的文档材料，可能托管于印象笔记、可能托管于项目代码库，可能在某电脑中</p>
<p>典型困难：</p>
<ul>
<li>聊胜于无，最终基本以查代码解决问题</li>
</ul>
<p><strong>C公司</strong></p>
<p>背景：</p>
<ul>
<li>涉足医疗行业</li>
<li>文档等资料的编写和管理发行遵照法规条款，受各种部门监管</li>
<li>使用EDM系统</li>
</ul>
<p>典型困难：</p>
<ul>
<li>各种文档的出发点契合法规需求，内容不一定满足研发人员的诉求（例如：往往我们需要详尽的类图、活动图、时序图、状态图、组件及对象生命周期关系，但文档一般只从系统角度给出程序流程图）</li>
<li>针对"查询设计细节点"而言，存在大量的内容噪声信息</li>
<li>文档空间大、内容多、检索难度高</li>
</ul>
<blockquote>
<p>从上述的三个案例来看，主要矛盾是文档内容不契合使用者诉求。</p>
<p>文档系统难用是次要矛盾。</p>
<p>在公司推行这一方案时，首先要确定主要矛盾能被解决，即团队愿意编写、维护一系列的文档（或内容资料）。
当团队拥有这些长期维护的文档、资料时，就可以着手解决系统不好用的问题。</p>
<p>否则不能有效推行，那此时只能退而求其次，尝试掌握额外的技能。</p>
</blockquote>
<h2 id="开始动手"><a class="header" href="#开始动手">开始动手</a></h2>
<h3 id="明确环境"><a class="header" href="#明确环境">明确环境</a></h3>
<p>按照我们的目标，可以确定，我们需要以下必要环境：</p>
<ul>
<li>一个局域网，不能有AP隔离、网段不能访问隔离（即设备间可以互相访问）</li>
<li>一台部署文档服务的机器</li>
<li>多台访问设备</li>
</ul>
<p><em>作者按：如果您已经开始在公司正式开始推行，大概率会申请到一台Linux虚机或者Docker；小范围尝试时，可能是使用自己的办公电脑，一般是Windows or macOS系统，Linux概率较低。</em></p>
<p><em>作者手边有一台 macOS10.15.7的机器，下文所有内容均以此版本为背景，注意：不同的操作系统可能会遇到不同的问题。</em></p>
<p>接下来我们需要搞定以下软件环境，<em>注意目前处于macOS 10.15.7环境下</em></p>
<ul>
<li>Gitlab 服务 及账号（至少具备创建、读取、提交项目的权限），版本无特定要求，用公司现成的即可</li>
<li>Docker 4.7.0 (77141)，未调查版本特定要求，该版本已确定可用，较新</li>
<li>Docker-ubuntu 镜像，未调查版本特定要求，可使用最新版本</li>
<li>Gitbook 3.2.3, 版本无特定要求，用于生成Gitbook，结合需求选用版本</li>
</ul>
<h3 id="docker"><a class="header" href="#docker">Docker</a></h3>
<p>接下来我们开始安装Docker，并从基本镜像开始搭建静态网站</p>
<h4 id="安装"><a class="header" href="#安装">安装</a></h4>
<p>首先<a href="https://www.docker.com/products/docker-desktop/">下载</a> 并安装Docker，这一步基本不会遇到问题</p>
<p>安装完成后，通过 <code>docker version</code> 命令，可以获得docker各个模块的版本信息</p>
<h4 id="获取ubuntu镜像"><a class="header" href="#获取ubuntu镜像">获取ubuntu镜像</a></h4>
<pre><code>docker image pull ubuntu:latest
</code></pre>
<p>以上命令可以获取官方镜像仓库中的最新的Ubuntu镜像</p>
<h4 id="生成容器"><a class="header" href="#生成容器">生成容器</a></h4>
<pre><code>docker run -p 80:80 --name doc -i -t ubuntu /bin/bash
</code></pre>
<p>通过以上命令可以 <strong>基于ubuntu镜像</strong> 得到一个 <strong>名为 doc 的容器</strong> ，映射本机80端口和容器的80端口，可使用bash。</p>
<pre><code>docker run [OPTIONS] IMAGE [COMMAND] [ARG...]
</code></pre>
<p><em>docker run 等价于 docker container run，在docker的迭代中，功能越来越多，增加了分组</em></p>
<p>注意：我在第一次体验docker时，没有处理好端口映射（随机端口分配），带来了很多问题，后面会给出专门的解决方案。</p>
<blockquote>
<p>读者朋友可以结合以下内容做一些尝试，体会下各种功能</p>
</blockquote>
<p>常用选项说明：</p>
<ul>
<li>-d, --detach=false， 指定容器运行于前台还是后台，默认为false</li>
<li>-i, --interactive=false， 打开STDIN，用于控制台交互</li>
<li>-t, --tty=false， 分配tty设备，该可以支持终端登录，默认为false</li>
<li>-u, --user=""， 指定容器的用户</li>
<li>-a, --attach=[]， 登录容器（必须是以docker run -d启动的容器）</li>
<li>-w, --workdir=""， 指定容器的工作目录</li>
<li>-c, --cpu-shares=0， 设置容器CPU权重，在CPU共享场景使用</li>
<li>-e, --env=[]， 指定环境变量，容器中可以使用该环境变量</li>
<li>-m, --memory=""， 指定容器的内存上限</li>
<li>-P, --publish-all=false， 指定容器暴露的端口</li>
<li>-p, --publish=[]， 指定容器暴露的端口</li>
<li>-h, --hostname=""， 指定容器的主机名</li>
<li>-v, --volume=[]， 给容器挂载存储卷，挂载到容器的某个目录</li>
<li>--volumes-from=[]， 给容器挂载其他容器上的卷，挂载到容器的某个目录</li>
<li>--cap-add=[]， 添加权限，权限清单详见：http://linux.die.net/man/7/capabilities</li>
<li>--cap-drop=[]， 删除权限，权限清单详见：http://linux.die.net/man/7/capabilities</li>
<li>--cidfile=""， 运行容器后，在指定文件中写入容器PID值，一种典型的监控系统用法</li>
<li>--cpuset=""， 设置容器可以使用哪些CPU，此参数可以用来容器独占CPU</li>
<li>--device=[]， 添加主机设备给容器，相当于设备直通</li>
<li>--dns=[]， 指定容器的dns服务器</li>
<li>--dns-search=[]， 指定容器的dns搜索域名，写入到容器的/etc/resolv.conf文件</li>
<li>--entrypoint=""， 覆盖image的入口点</li>
<li>--env-file=[]， 指定环境变量文件，文件格式为每行一个环境变量</li>
<li>--expose=[]， 指定容器暴露的端口，即修改镜像的暴露端口</li>
<li>--link=[]， 指定容器间的关联，使用其他容器的IP、env等信息</li>
<li>--lxc-conf=[]， 指定容器的配置文件，只有在指定--exec-driver=lxc时使用</li>
<li>--name=""， 指定容器名字，后续可以通过名字进行容器管理，links特性需要使用名字</li>
<li>--net="bridge"， 容器网络设置:
<ul>
<li>bridge 使用docker daemon指定的网桥</li>
<li>host //容器使用主机的网络</li>
<li>container:NAME_or_ID &gt;//使用其他容器的网路，共享IP和PORT等网络资源</li>
<li>none 容器使用自己的网络（类似--net=bridge），但是不进行配置</li>
</ul>
</li>
<li>--privileged=false， 指定容器是否为特权容器，特权容器拥有所有的capabilities</li>
<li>--restart="no"， 指定容器停止后的重启策略:
<ul>
<li>no：容器退出时不重启</li>
<li>on-failure：容器故障退出（返回值非零）时重启</li>
<li>always：容器退出时总是重启</li>
</ul>
</li>
<li>--rm=false， 指定容器停止后自动删除容器(不支持以docker run -d启动的容器)</li>
<li>--sig-proxy=true， 设置由代理接受并处理信号，但是SIGCHLD、SIGSTOP和SIGKILL不能被代理</li>
</ul>
<h4 id="为容器内的app安装nginx"><a class="header" href="#为容器内的app安装nginx">为容器内的APP安装nginx</a></h4>
<p>通过nginx可以很方便的代理静态站点，已经基于Ubuntu镜像，所以可以通过apt进行各类软件安装</p>
<p>先更新apt的资源，如果源出现问题，可以自行换源</p>
<pre><code>apt-get update
</code></pre>
<p>安装nginx</p>
<pre><code>apt-get install -y nginx
</code></pre>
<p>此处的过程一般不会出现问题</p>
<h4 id="为容器内的app安装vim"><a class="header" href="#为容器内的app安装vim">为容器内的APP安装Vim</a></h4>
<p>因为是通过终端操作，Vim是必须的。</p>
<p><em>值得注意的是,docker中使用vim只能使用最基本的指令，需要适应</em></p>
<pre><code>apt-get install -y vim
</code></pre>
<h4 id="修改nginx配置"><a class="header" href="#修改nginx配置">修改nginx配置</a></h4>
<p>此时，您可以先确定好静态网站内容的存放文件目录，笔者将其托管于Gitlab，并clone到了docker 容器中.</p>
<blockquote>
<p><code>apt-get install git</code> 安装git</p>
</blockquote>
<p>通过 <code> whereis</code> 命令找到nginx的安装位置 <code> whereis nginx</code> ，按照惯例：<strong>/etc 下存放配置文件</strong>，/sbin、/bin下是可执行文件</p>
<p>进入配置文件目录，使用VIM修改 <code>default</code> 文件内容</p>
<p>修改 root 配置，指定为静态网站根目录。</p>
<p>例如：</p>
<pre><code>##
# You should look at the following URL's in order to grasp a solid understanding
# ... 注释内容移除
##

# Default server configuration
#
server {
    listen 80 default_server;
    listen [::]:80 default_server;
    root /usr/local/work/doc/_book;


    server_name _;

    location / {
        # First attempt to serve request as file, then
        # as directory, then fall back to displaying a 404.
        try_files $uri $uri/ =404;
    }
}
</code></pre>
<p>保存。</p>
<p>输入 <code>nginx</code> 启动nginx ，<em>理论上环境变量已完善，若出现问题可自行配置环境变量</em></p>
<p>输入 <code>ps -ef</code> 可查看进程，确保nginx已经启动</p>
<h4 id="确认端口映射"><a class="header" href="#确认端口映射">确认端口映射</a></h4>
<p>进入mac的Terminal，可以新建也可以退出docker的交互式容器</p>
<blockquote>
<p>按序按ctrl+p,ctrl+q 可退出交互式容器</p>
</blockquote>
<p>使用 <code>docker ps</code> 命令查看运行中的容器的端口映射情况。 <code>docker ps -a</code> 可以查看全部容器的情况。</p>
<p>使用 <code>docker port "容器名"</code> 命令可以查看 容器内部端口 到 docker容器在mac上分配的端口</p>
<p>例如，上文中我们将80端口分配给静态网站，称之容器内部端口。而此docker容器运行一个依托于mac真机的虚拟平台上，mac真机为其分配了一个端口。</p>
<p>如果创建容器时没有指定端口或者启动时获取端口失败，docker容器会被分配一个端口，举个例子，可能是67890端口。</p>
<p>此时，通过访问 localhost:67890 已经可以访问到静态站内容</p>
<h4 id="通过端口映射解决"><a class="header" href="#通过端口映射解决">通过端口映射解决</a></h4>
<p>如上文所述，即便创建容器时指定了端口映射关系，也难以保障下次启动容器时还能获得一致的端口。</p>
<p>我们模拟一次docker重启</p>
<p>停止容器运行</p>
<pre><code>docker stop "容器名"
</code></pre>
<p>注意，重新启动容器应用命令为：</p>
<pre><code>docker start 容器名
</code></pre>
<p>而非 <code>docker run</code></p>
<p>如果没有配置nginx自动启动，则需要重启nginx，不进入交互式容器可使用命令：</p>
<pre><code>docker exec "容器名" nginx
</code></pre>
<p>顺带确认容器中运行的进程：</p>
<pre><code>docker top "容器名"
</code></pre>
<p>再次确认端口关系，可能会很不幸，假定已经改变为65432端口。但没有关系，挑一个喜欢的端口，例如 66666</p>
<p>进行端口映射。</p>
<blockquote>
<p>题外话，如果是Linux机器，我们可以使用iptables 命令处理转发</p>
</blockquote>
<p>有些早期的博客指导修改 /var/lib/docker/containers/[hash_of_the_container]/hostconfig.json 配置转发，但该版本的docker并没有该文件。</p>
<h5 id="通过macos的端口映射"><a class="header" href="#通过macos的端口映射">通过macOS的端口映射</a></h5>
<p><a href="https://blog.csdn.net/zealoussnow/article/details/89207260">可参考此博客</a></p>
<p>但是步骤太复杂了，如果不是系统性的运用转发机制，我这么懒的人一定会采用临时规则方案：</p>
<pre><code>echo "rdr pass proto tcp from any to any port {机器端口} -&gt; 127.0.0.1 port {docker 镜像端口}" | sudo pfctl -Ef -
</code></pre>
<p>结合我们假设的设定：</p>
<pre><code class="language-puml">echo "rdr pass proto tcp from any to any port 66666 -&gt; 127.0.0.1 port 65432" | sudo pfctl -Ef -
</code></pre>
<p>通过：</p>
<pre><code>sudo pfctl -F all -f /etc/pf.conf
</code></pre>
<p>可以删除临时规则</p>
<h3 id="gitbook-or-other"><a class="header" href="#gitbook-or-other">Gitbook or other</a></h3>
<p>在上文内容中，我们已经默认使用了 <a href="https://www.gitbook.com/">Gitbook</a> 生成文档静态网站, <a href="https://my.oschina.net/snowdreams1006/blog/3031933?hmsr=kaifa_aladdin">使用教程</a> 不再展开。</p>
<p>您也可以选用其他的软件工具生成网站</p>
<h3 id="如果存在通过路由器构建的子网"><a class="header" href="#如果存在通过路由器构建的子网">如果存在通过路由器构建的子网</a></h3>
<p>简单回顾物理拓扑：存在必不可少局域网和一台文档服务器。</p>
<p>在早期的体验阶段，我们选用了个人办公电脑架设文档服务器。</p>
<p>而出于方便办公的目的，我们很有可能自行购买了路有设备，<strong>通过路由器接入公司的局域网，将办公电脑、个人电脑、手机等接入路由器构建的子网</strong>。</p>
<p>此时，其他同事通过公司局域网访问该文档服务器就会 <strong>遇到麻烦</strong> ，不过很好解决，基于公司局域网的管理，一般个人分配的IP固定，<em>该场景下该IP对应路由器设备</em></p>
<p>分配一个路由器的端口作为访问文档服务的端口，通过路由器管理设置将该端口的访问定向转发到 <strong>部署文档服务器的机器</strong> 的文档服务端口，<em>上文中使用了66666端口</em></p>
<p><em>当然，这样处理的前提是路由器按照静态IP分配，否则需要时常维护映射关系。</em></p>
<h3 id="更新ci版本化"><a class="header" href="#更新ci版本化">更新、CI、版本化</a></h3>
<p>文档是需要长期维护的，必然会牵涉到更改、修订、新增。</p>
<p>在上文中，我们将生成的静态网站内容托管于Git，这是较差的做法，但可以在本地处理编译、生成静态网站资源时的 <strong>环境问题</strong> 而减少服务器的维护。</p>
<p>针对原始文档进行版本控制是必要的。引入健壮的环境维护机制后，在服务端进行静态网站资源编译、生成，是更佳的做法。</p>
<p>通过Git等VCS的帮助，已经拥有健全的版本管理方式，只需要采用相应的实践方式即可，例如参考Git最佳实践拆分发布、维护分支，通过tag维护发布版本</p>
<h4 id="自动获取更新部署"><a class="header" href="#自动获取更新部署">自动获取更新、部署</a></h4>
<p>以上文中的做法为例，此时仅需要 <strong>周期性的</strong> 获取Git仓库中发布分支的最新内容即可。</p>
<p>如果已经在服务端实施编译、生成，可以编写定时任务脚本进行CI，也可以进一步引入jenkins，增加构建任务，通过web-hook机制可以实现实时部署。</p>
<h4 id="同时获得多个版本"><a class="header" href="#同时获得多个版本">同时获得多个版本</a></h4>
<p>有时我们希望获得 <strong>文档、内容片段</strong> 在不同版本下的内容，在此方案基础上也容易实现。</p>
<p>针对不同的版本（tag），check-out 并编译、生成至 <strong>与版本一一映射</strong> 的文件目录，通过Nginx配置的方式即可实现。</p>
<p>此时，需要通过不同的URL访问不同的版本，这对于使用者并不友好，本着 <strong>以人为本</strong> 的原则，可以进行一次 <strong>优化</strong>：</p>
<blockquote>
<p>编写 "扫描" 程序或者脚本，扫出已经CheckOut、并在Nginx配置中有效的版本文件目录，<em>（一般做法是将各个版本的目录规整至同一路径下，将该路径作为站点Root目录）</em>
通过版本（tag）与文件目录名的映射关系、Git插件，取出版本Commit信息。聚合信息后按照模板生成入口页</p>
</blockquote>
<p>而 <strong>优化永无止境</strong> ，只要对文档、文档章节建立索引机制，将文档内容解析为AST，"比对文档章节在各个版本下的变化" 将可行，通过定制Gitbook插件的方式，
可将各章节在各个版本下的内容加以聚合、通过Spinner等方式切换阅读。</p>
<h2 id="结语"><a class="header" href="#结语">结语</a></h2>
<p>至此，我们已经完成了基础目标，而文档中提到的技能树，要全部点亮想必也需要一定的时间，尤其是结合 <code>Git</code>、<code>Markdown AST解析</code>、<code>模板引擎</code>等内容，自研一套软件用于网页生成。读者朋友们可以丰富自己的业余生活了。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../Android/Idea/post_32.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../repo/post_48.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../Android/Idea/post_32.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../repo/post_48.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
