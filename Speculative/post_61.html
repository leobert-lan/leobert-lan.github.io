<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>好玩系列 | 如果后端让你用SSE接收多次返回，那我们改造Retrofit吧 - leobert&#x27;s blog</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">目录</li><li class="chapter-item expanded "><a href="../Android/index.html"><strong aria-hidden="true">1.</strong> Android</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/View/index.html"><strong aria-hidden="true">1.1.</strong> View</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/View/post_1.html"><strong aria-hidden="true">1.1.1.</strong> 好玩系列：优雅的处理ButterKnife和KAE被废弃</a></li><li class="chapter-item expanded "><a href="../Android/View/post_6.html"><strong aria-hidden="true">1.1.2.</strong> 三思系列：View体系认知(一)，内容是如何正确被展现出来的--视觉呈现概览</a></li><li class="chapter-item expanded "><a href="../Android/View/post_7.html"><strong aria-hidden="true">1.1.3.</strong> 三思系列：为什么自定义View</a></li><li class="chapter-item expanded "><a href="../Android/Idea/post_9.html"><strong aria-hidden="true">1.1.4.</strong> 三思系列："声明式UI"和"命令式UI"，你的理解可能是错的</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/Drawable/index.html"><strong aria-hidden="true">1.2.</strong> Drawable</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/Drawable/post_2.html"><strong aria-hidden="true">1.2.1.</strong> 三思系列：重新认识Drawable</a></li><li class="chapter-item expanded "><a href="../Android/Drawable/post_4.html"><strong aria-hidden="true">1.2.2.</strong> 好玩系列：拥有它，XML文件少一半--更方便的处理View背景</a></li><li class="chapter-item expanded "><a href="../Android/Drawable/post_47.html"><strong aria-hidden="true">1.2.3.</strong> 迟来的续集--Drawable+Animator，将优雅进行到底</a></li><li class="chapter-item expanded "><a href="../Android/Drawable/post_49.html"><strong aria-hidden="true">1.2.4.</strong> 好玩系列：让ImageSpan动起来</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/Mechanism/Message/index.html"><strong aria-hidden="true">1.3.</strong> 消息机制</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/Mechanism/Message/post_8.html"><strong aria-hidden="true">1.3.1.</strong> 三思系列：Android的消息机制，一文吃透</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/Idea/post_14/index.html"><strong aria-hidden="true">1.4.</strong> 兼容</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/Idea/post_14.html"><strong aria-hidden="true">1.4.1.</strong> 好玩系列：让项目中的相册支持Heif格式图片</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/Glide/index.html"><strong aria-hidden="true">1.5.</strong> Glide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/Glide/post_15.html"><strong aria-hidden="true">1.5.1.</strong> 三思系列：Glide 4.X全方位认知 -- 模块职责概览</a></li><li class="chapter-item expanded "><a href="../Android/Glide/post_16.html"><strong aria-hidden="true">1.5.2.</strong> 三思系列：Glide 4.X加载过程一文掌握 | Glide（二）</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/KSP/index.html"><strong aria-hidden="true">1.6.</strong> KSP</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/KSP/post_24.html"><strong aria-hidden="true">1.6.1.</strong> 好玩系列 | 拥抱Kotlin Symbol Processing(KSP),项目实战</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/Base/index.html"><strong aria-hidden="true">1.7.</strong> 基础</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/Base/post_35.html"><strong aria-hidden="true">1.7.1.</strong> 孔乙己：你可知道页面和弹窗“通信“的方式有四种？</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/SysApp/index.html"><strong aria-hidden="true">1.8.</strong> 系统APP</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/SysApp/post_52.html"><strong aria-hidden="true">1.8.1.</strong> 使用日历丰富产品的用户体验</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/DI/index.html"><strong aria-hidden="true">1.9.</strong> Part4-依赖注入部分</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/DI/post_53.html"><strong aria-hidden="true">1.9.1.</strong> Hilt进阶--一文吃透Hilt自定义与跨壁垒</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../Compose/index.html"><strong aria-hidden="true">2.</strong> Jetpack Compose</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Compose/post_21.html"><strong aria-hidden="true">2.1.</strong> Jetpack Compose | 一文理解神奇的Modifier</a></li><li class="chapter-item expanded "><a href="../Compose/post_26.html"><strong aria-hidden="true">2.2.</strong> Jetpack Compose | 控件篇（一） -- Text、TextField、Button</a></li><li class="chapter-item expanded "><a href="../Compose/post_27.html"><strong aria-hidden="true">2.3.</strong> Jetpack Compose | 控件篇（二） -- Icon，Image</a></li><li class="chapter-item expanded "><a href="../Compose/post_28.html"><strong aria-hidden="true">2.4.</strong> Jetpack Compose | 控件篇（三） -- Switch、CheckBox、RadioButton</a></li><li class="chapter-item expanded "><a href="../Compose/post_29.html"><strong aria-hidden="true">2.5.</strong> Jetpack Compose | 控件篇（四）-- Box、Row、Column</a></li><li class="chapter-item expanded "><a href="../Compose/post_30.html"><strong aria-hidden="true">2.6.</strong> Jetpack Compose | 控件篇（五）-- Spacer、LazyRow、LazyColumn & 让Column可滑动</a></li></ol></li><li class="chapter-item expanded "><a href="../MultiThreading/index.html"><strong aria-hidden="true">3.</strong> Java多线程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../MultiThreading/post_33.html"><strong aria-hidden="true">3.1.</strong> 总纲</a></li><li class="chapter-item expanded "><a href="../MultiThreading/post_37.html"><strong aria-hidden="true">3.2.</strong> Java基础--图解JVM内存模型和JVM线程模型</a></li><li class="chapter-item expanded "><a href="../MultiThreading/post_38.html"><strong aria-hidden="true">3.3.</strong> Java多线程系列--掌控面试，一文吃透Synchronized锁</a></li><li class="chapter-item expanded "><a href="../MultiThreading/post_39.html"><strong aria-hidden="true">3.4.</strong> Java多线程基础--线程生命周期与线程协作详解</a></li><li class="chapter-item expanded "><a href="../MultiThreading/post_42.html"><strong aria-hidden="true">3.5.</strong> Java多线程基础--线程的创建与线程池管理</a></li><li class="chapter-item expanded "><a href="../MultiThreading/post_46.html"><strong aria-hidden="true">3.6.</strong> Java多线程系列--掌握Future，轻松获取异步任务结果</a></li><li class="chapter-item expanded "><a href="../MultiThreading/post_50.html"><strong aria-hidden="true">3.7.</strong> Java多线程系列--Fork&Join框架，分治的艺术</a></li><li class="chapter-item expanded "><a href="../MultiThreading/post_54.html"><strong aria-hidden="true">3.8.</strong> Java多线程系列--掌握CompletableFuture，驾驭异步编程</a></li></ol></li><li class="chapter-item expanded "><a href="../IO/index.html"><strong aria-hidden="true">4.</strong> Java IO系列</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../IO/post_55.html"><strong aria-hidden="true">4.1.</strong> Java IO 系列总纲</a></li><li class="chapter-item expanded "><a href="../IO/post_56.html"><strong aria-hidden="true">4.2.</strong> Java IO系列 | 经典 IO</a></li><li class="chapter-item expanded "><a href="../IO/post_57.html"><strong aria-hidden="true">4.3.</strong> Java IO 系列 | NIO-1.0一文速览</a></li><li class="chapter-item expanded "><a href="../IO/post_58.html"><strong aria-hidden="true">4.4.</strong> Java IO系列 | NIO-1.0拾遗、NIO-2.0 & 零拷贝必吹的牛皮</a></li><li class="chapter-item expanded "><a href="../IO/post_59.html"><strong aria-hidden="true">4.5.</strong> IO系列 | 一文掌握OKHTTP中的OKIO为什么这么OK</a></li></ol></li><li class="chapter-item expanded "><a href="../Gradle/index.html"><strong aria-hidden="true">5.</strong> Gradle</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Gradle/Modularization/post_18.html"><strong aria-hidden="true">5.1.</strong> 组件化：三思系列：组件化场景下module依赖优雅实践方案</a></li><li class="chapter-item expanded "><a href="../Gradle/Publish/post_17.html"><strong aria-hidden="true">5.2.</strong> MavenCentral发布：迁移到MavenCentral--再不行动起来，你的托管的library就没了</a></li><li class="chapter-item expanded "><a href="../Gradle/post_22.html"><strong aria-hidden="true">5.3.</strong> Gradle | 依赖管理最佳实践</a></li></ol></li><li class="chapter-item expanded "><a href="../Groovy/index.html"><strong aria-hidden="true">6.</strong> Groovy</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Groovy/why_write_groovy.html"><strong aria-hidden="true">6.1.</strong> 为什么撰写这个系列</a></li><li class="chapter-item expanded "><a href="../Groovy/post_23.html"><strong aria-hidden="true">6.2.</strong> Groovy：MOP一文打尽</a></li></ol></li><li class="chapter-item expanded "><a href="../Review/index.html"><strong aria-hidden="true">7.</strong> Review</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Review/post_10.html"><strong aria-hidden="true">7.1.</strong> 造完了这个轮子--Mocker，却让我感到很羞愧|项目复盘</a></li><li class="chapter-item expanded "><a href="../Review/post_40.html"><strong aria-hidden="true">7.2.</strong> 三思系列：前人用GreenDao留下的坑，全线被扣了绩效</a></li><li class="chapter-item expanded "><a href="../Review/post_44.html"><strong aria-hidden="true">7.3.</strong> 谈一谈在两个商业项目中使用MVI架构后的感悟</a></li><li class="chapter-item expanded "><a href="../Review/post_45.html"><strong aria-hidden="true">7.4.</strong> Review | 这三个坑你遇到了吗？</a></li></ol></li><li class="chapter-item expanded "><a href="../repo/index.html"><strong aria-hidden="true">8.</strong> 个人项目</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../repo/DaVinCi.html"><strong aria-hidden="true">8.1.</strong> DaVinCi,取代XML编写Shape或ColorStateList的方案</a></li><li class="chapter-item expanded "><a href="../Android/Idea/post_32.html"><strong aria-hidden="true">8.2.</strong> 好玩系列：白嫖一个优雅的类图生成工具</a></li><li class="chapter-item expanded "><a href="../Speculative/post_43.html"><strong aria-hidden="true">8.3.</strong> 初体验：动手搭建"小清新式"局域网文档系统</a></li><li class="chapter-item expanded "><a href="../repo/post_48.html"><strong aria-hidden="true">8.4.</strong> 研究良久，终于发现了他代码写的快且bug少的原因</a></li><li class="chapter-item expanded "><a href="../Speculative/post_61.html" class="active"><strong aria-hidden="true">8.5.</strong> 好玩系列 | 如果后端让你用SSE接收多次返回，那我们改造Retrofit吧</a></li></ol></li><li class="chapter-item expanded "><a href="../Review/DataStructure/index.html"><strong aria-hidden="true">9.</strong> 数据结构</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Review/DataStructure/post_11.html"><strong aria-hidden="true">9.1.</strong> 温故：线性表</a></li><li class="chapter-item expanded "><a href="../Review/DataStructure/post_12.html"><strong aria-hidden="true">9.2.</strong> 温故：栈</a></li><li class="chapter-item expanded "><a href="../Review/DataStructure/post_13.html"><strong aria-hidden="true">9.3.</strong> 温故：队列</a></li></ol></li><li class="chapter-item expanded "><a href="../Review/README2.html"><strong aria-hidden="true">10.</strong> 年终总结&计划</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Review/post_36.html"><strong aria-hidden="true">10.1.</strong> 2021年终总结</a></li><li class="chapter-item expanded "><a href="../Review/post_51.html"><strong aria-hidden="true">10.2.</strong> 关于画一个句号--基于2022年终总结的反思与分享</a></li><li class="chapter-item expanded "><a href="../Review/post_60.html"><strong aria-hidden="true">10.3.</strong> 突如其来的秋季反思</a></li><li class="chapter-item expanded "><a href="../Review/post_63.html"><strong aria-hidden="true">10.4.</strong> 2023年总结 寻找到源于内心深处的无穷力量</a></li><li class="chapter-item expanded "><a href="../Review/post_64.html"><strong aria-hidden="true">10.5.</strong> 2024年中思考，推倒樊笼重新出发</a></li></ol></li><li class="chapter-item expanded "><a href="../Note/index.html"><strong aria-hidden="true">11.</strong> 读书笔记</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Note/post_41.html"><strong aria-hidden="true">11.1.</strong> 读书笔记：《简约至上--交互式设计四策略》</a></li><li class="chapter-item expanded "><a href="../Talk/talk_4_2024-08.html"><strong aria-hidden="true">11.2.</strong> 读书笔记 - 《团队管理》精华摘要</a></li></ol></li><li class="chapter-item expanded "><a href="../Talk/index.html"><strong aria-hidden="true">12.</strong> 杂谈</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Talk/talk_1.html"><strong aria-hidden="true">12.1.</strong> 杂谈1-2022-11</a></li><li class="chapter-item expanded "><a href="../Talk/talk_2_2023-03.html"><strong aria-hidden="true">12.2.</strong> 杂篇（二）-- 认识并战胜焦虑</a></li><li class="chapter-item expanded "><a href="../Talk/talk_3_2024-08.html"><strong aria-hidden="true">12.3.</strong> 杂谈（三）-- 向钱看，你需要想明白企业在为什么而付钱</a></li></ol></li><li class="chapter-item expanded "><a href="../Thought/index.html"><strong aria-hidden="true">13.</strong> 半成熟的思考</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Thought/post_62.html"><strong aria-hidden="true">13.1.</strong> 好玩系列 | 当SPI 和 设计模式、依赖注入发生碰撞，可以擦出怎样的火花</a></li></ol></li><li class="chapter-item expanded "><a href="../info/index.html"><strong aria-hidden="true">14.</strong> 系列说明</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../info/about_view_series.html"><strong aria-hidden="true">14.1.</strong> 关于View系列</a></li><li class="chapter-item expanded "><a href="../info/about_sansi_series.html"><strong aria-hidden="true">14.2.</strong> 关于三思系列</a></li><li class="chapter-item expanded "><a href="../info/about_haowan_series.html"><strong aria-hidden="true">14.3.</strong> 关于好玩系列</a></li><li class="chapter-item expanded "><a href="../info/about_wengu_series.html"><strong aria-hidden="true">14.4.</strong> 关于温故系列</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">leobert&#x27;s blog</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="好玩系列--如果后端让你用sse接收多次返回那我们改造retrofit吧"><a class="header" href="#好玩系列--如果后端让你用sse接收多次返回那我们改造retrofit吧">好玩系列 | 如果后端让你用SSE接收多次返回，那我们改造Retrofit吧</a></h1>
<h2 id="前言"><a class="header" href="#前言">前言</a></h2>
<p>说来惭愧，最近都没写技术帖，每月写一篇原创的Flag也倒了，倒并非无内容可写，实则是因为懒惰， 虽然工作和生活牵扯了很多精力，但仍是有碎片化时间的。一篇关于DataBinding非常有趣的文章还在编写中，今天我们先看一篇轻松点的内容。</p>
<p>随着ChatGpt等生成式AI大火，SSE（Server Send Events）又回到了技术讨论当中，今天我们聊一聊，<strong>如果客户端需要获取服务端长耗时任务结果，有哪些实践方式</strong>。</p>
<blockquote>
<p>本篇博客将聚焦于4个方面：</p>
<ul>
<li>归纳获取服务端长耗时任务结果的常见实践方式</li>
<li>对SSE进行详细的讨论，尤其是其协议细节</li>
<li>实操：搭建SSE服务端、使用OKHttp搭建客户端</li>
<li>探索：对Retrofit进行了分析，扩展Retrofit使用SSE</li>
</ul>
</blockquote>
<h2 id="4种常见的实践方式"><a class="header" href="#4种常见的实践方式">4种常见的实践方式</a></h2>
<p>不外乎两种思路：</p>
<ul>
<li>客户端 polling</li>
<li>服务端 push</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ec3a01c5cc74032a71befa745dccea1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1366&amp;h=740&amp;s=71846&amp;e=png&amp;b=fffdfd" alt="4种方式.png" /></p>
<h3 id="客户端polling"><a class="header" href="#客户端polling">客户端polling</a></h3>
<p>不难理解，服务端处理一项任务，只有服务端才清晰地知道任务的状态，客户端可以通过 <strong>周期性主动轮询</strong> 直至获取任务的最终结果。</p>
<p>按照此类实践方式，可使用 <code>HTTP/HTTPs</code> 协议。</p>
<h4 id="short-polling"><a class="header" href="#short-polling">short polling</a></h4>
<p>客户端向服务端发起请求，如果服务端状态已经更新，返回结果并关闭链接；<strong>如果服务端状态尚未更新，返回一个特定的结果告知还在处理中，并关闭链接</strong></p>
<h4 id="long-polling"><a class="header" href="#long-polling">long polling</a></h4>
<p>和 <code>short polling</code> 类似，客户端向服务端发起请求，如果服务端状态已经更新，返回结果并关闭链接；</p>
<p>但如果服务端状态尚未更新，</p>
<ul>
<li>服务端会在超时时间内维持链接，进行等待，直至状态更新，返回结果并关闭链接；</li>
<li>若等待至超时也未更新状态，返回一个特定的结果告知还在处理中，并关闭链接</li>
</ul>
<h3 id="服务端push"><a class="header" href="#服务端push">服务端push</a></h3>
<p>这类实践方式中，不需要客户端采取"问"，而是当服务端状态更新时，自行通知客户端，典型的实践方式有：</p>
<ul>
<li>Server Send Events (SSE)</li>
<li>WebSocket</li>
</ul>
<h4 id="sse"><a class="header" href="#sse">SSE</a></h4>
<p>SSE是本文的讨论核心，从服务端发往客户端的消息，存在一个限制，即仅可以发送 <code>纯文本</code> 类型的消息。</p>
<p>SSE基于http协议的持久连接，<code>SSE</code> 具有 W3C 标准化的网络协议和 EventSource 客户端接口，属于 <code>HTML5</code> 标准套件。</p>
<p>有兴趣的读者可以访问 <a href="https://html.spec.whatwg.org/multipage/server-sent-events.html">扩展阅读</a> 了解协议细节</p>
<h4 id="websocket"><a class="header" href="#websocket">WebSocket</a></h4>
<p>定制性、扩展性最强的实践方案，有趣的话题实在太多，不做任何展开。</p>
<h2 id="sse协议细节"><a class="header" href="#sse协议细节">SSE协议细节</a></h2>
<p>不难理解，SSE形如消息订阅，由客户端主动发起订阅，双方维持链接，服务端向客户端推送message。</p>
<h3 id="header主要部分"><a class="header" href="#header主要部分">Header主要部分</a></h3>
<p>按照协议约定，<code>Method</code> 为 <code>GET</code>，并且需要在 <code>Header</code> 中包含以下内容：</p>
<ul>
<li>Accept: text/event-stream 指定Media Type</li>
<li>Cache-Control: no-cache 不使用cache</li>
<li>Connection: keep-alive 使用持久性连接</li>
</ul>
<p>以下是Header部分的示例：</p>
<pre><code class="language-text">GET /{path} HTTP/1.1
Accept: text/event-stream
Cache-Control: no-cache
Connection: keep-alive
</code></pre>
<p>服务端的响应Header至少包含：</p>
<ul>
<li>Content-Type: text/event-stream;charset=UTF-8 指定Media Type</li>
<li>Transfer-Encoding: chunked</li>
</ul>
<p>以下是响应Header部分的示例：</p>
<pre><code class="language-text">HTTP/1.1 200
Content-Type: text/event-stream;charset=UTF-8
Transfer-Encoding: chunked
</code></pre>
<h3 id="event-stream-解析"><a class="header" href="#event-stream-解析">Event-Stream 解析</a></h3>
<p>event-stream的内容(结构和字符)需满足以下 <a href="https://www.rfc-editor.org/rfc/rfc5234">ABNF</a> 语法范式约定</p>
<pre><code class="language-ABNF">stream        = [ bom ] *event
event         = *( comment / field ) end-of-line
comment       = colon *any-char end-of-line
field         = 1*name-char [ colon [ space ] *any-char ] end-of-line
end-of-line   = ( cr lf / cr / lf )

; characters
lf            = %x000A ; U+000A LINE FEED (LF)
cr            = %x000D ; U+000D CARRIAGE RETURN (CR)
space         = %x0020 ; U+0020 SPACE
colon         = %x003A ; U+003A COLON (:)
bom           = %xFEFF ; U+FEFF BYTE ORDER MARK
name-char     = %x0000-0009 / %x000B-000C / %x000E-0039 / %x003B-10FFFF
; a scalar value other than U+000A LINE FEED (LF), U+000D CARRIAGE RETURN (CR), or U+003A COLON (:)
any-char      = %x0000-0009 / %x000B-000C / %x000E-10FFFF
; a scalar value other than U+000A LINE FEED (LF) or U+000D CARRIAGE RETURN (CR)
</code></pre>
<p>需要逐行读取内容并进行解析，按照语法约定：<code>end-of-line = ( cr lf / cr / lf )</code>，CRLF、CR、LF都代表换行</p>
<ul>
<li>如果是空行，后续是新Event，可通俗理解为事件之间用空行分隔</li>
<li>如果是以 <code>:</code> <em>冒号，UniCode编码 U+003A</em> 开始，忽略此行</li>
<li>如果包含 <code>:</code> <em>冒号，UniCode编码 U+003A</em>，从第一个冒号开始分割
<ul>
<li>冒号前的内容为 <code>field</code></li>
<li>冒号后的内容为 <code>value</code>，如果冒号后的第一个字符为 <code>空格</code> U+0020，从 <code>value</code> 中移除</li>
</ul>
</li>
<li>非空但不包含 <code>:</code>, 内容全部作为 <code>field</code>, <code>value</code> 为空字符串</li>
</ul>
<p>field的约定：</p>
<ul>
<li>"event"：其value为 event type</li>
<li>"data"：其value为事件数据，解析后单独再尾部拼接 <code>LF</code></li>
<li>"id"：若其value不包含 <code>U+0000 即NULL</code>，值为事件的ID，否则忽略</li>
<li>"retry"：其value若只包含ASCII码表示的数值，认为是十进制数解析为Int，作为毫秒级的重连时间，<em>当链接断开，客户端应当在此时间后自动发起重连</em>，否则忽略</li>
<li>其他情况均忽略</li>
</ul>
<h3 id="last-event-id"><a class="header" href="#last-event-id">Last-Event-ID</a></h3>
<p>前文已经提到了如下内容：</p>
<ul>
<li>Header</li>
<li>Event-Stream中field为"id"、"retry"</li>
</ul>
<p>不难理解，当出现意外情况时，例如网络原因导致的链接断开，涉及到重连；显然，重连时一般不希望再获取已经收到的信息。</p>
<p>Header中存在 <code>Last-Event-ID</code> field约定，指定上次收到的Event的id，因Event有序，可避免冗余信息传输。</p>
<h2 id="纸上得来终觉浅"><a class="header" href="#纸上得来终觉浅">纸上得来终觉浅</a></h2>
<p>至此，协议部分的主要内容已经讨论完毕，让我们进入愉快的Demo环节。</p>
<h3 id="编写服务端"><a class="header" href="#编写服务端">编写服务端</a></h3>
<p>对部分读者而言，这部分可能有点超纲，但没有关系，已经准备好了Demo代码，各位只需要准备好Java环境和路由器即可。</p>
<p><a href="https://github.com/leobert-lan/SSE-Server-demo">代码仓库</a></p>
<p>在Demo中，准备了两条接口：</p>
<ul>
<li>http://{ip}:8080/sse/mvc/words , 模拟多次生成文本段落并推送至客户端</li>
<li>http://{ip}:8080/sse/mvc/folder-watch , 模拟文件夹监听</li>
</ul>
<p>启动服务后，可使用控制台和curl进行测试：</p>
<pre><code>curl -v http://localhost:8080/sse/mvc/words
</code></pre>
<h3 id="编写客户端"><a class="header" href="#编写客户端">编写客户端</a></h3>
<p>很显然，一个非新事物往往不需要普通开发者造轮子，<a href="https://github.com/square/okhttp/tree/master/okhttp-sse">OkHttp</a> 已经支持SSE</p>
<p>不同于大家熟知的 <code>Call</code>， Okhttp-SSE中封装了 <code>EventSource</code>，并通过 <code>Factory</code> 创建实例、发起请求：</p>
<p>一个朴素地使用示例如下：</p>
<pre><code class="language-java">class Demo {
    void demoCode() {

        OkHttpClient okHttpClient = new OkHttpClient();
        EventSource.Factory factory = EventSources.createFactory(okHttpClient);

        Request.Builder builder = new Request.Builder().get().url(url);

        builder.addHeader("Content-Type", "text/event-stream")
                .addHeader("Accept-Encoding", "")
                .addHeader("Accept", "text/event-stream")
                .addHeader("Cache-Control", "no-cache");

        builder.addHeader("Last-Event-ID", "2");

        Request request = builder.build();

        factory.newEventSource(request, new EventSourceListener() {
            //ignore
        });
    }
}
</code></pre>
<p>请注意，如果将其作为 <code>Call</code>，将无法获得多次推送的效果，在不出现错误或超时的情况下，形如一次响应较慢的Get请求。</p>
<p><a href="https://github.com/leobert-lan/SSE-android-Demo">demo代码仓库</a></p>
<h3 id="是否可以使用retrofit"><a class="header" href="#是否可以使用retrofit">是否可以使用Retrofit</a></h3>
<p>截至目前为止，Retrofit未对其进行适配，其实在多年前即展开过讨论，我找到了此条 <a href="https://github.com/square/retrofit/issues/1029">讨论issue</a></p>
<p>Retrofit的设计原理并不复杂：</p>
<blockquote>
<ul>
<li>通过运行时反射，建立动态代理，依据注解构建Okhttp的Call</li>
<li>通过CallAdapter，将Call的结果处理方式，进行不同的适配</li>
</ul>
</blockquote>
<p>但设计之初，仅设计了 <code>Retrofit.Call</code> 对 <code>Okhttp.Call</code> 进行Wrap，而 <code>EventSource</code> 并不继承 <code>Okhttp.Call</code>，当然，依据其特性也不应当继承自Call</p>
<p>鉴于此，若将 <code>EventSource</code> 强行包装为 <code>Retrofit.Call</code> 将会很容易引起错误，例如调用</p>
<ul>
<li><code>Response&lt;T&gt; execute() throws IOException;</code></li>
<li><code>void enqueue(Callback&lt;T&gt; callback);</code></li>
</ul>
<p>若在Retrofit中平行展开一条 <code>EventSource</code> 的处理逻辑，需要对库进行很多修改，并且考虑对生态的影响，并不划算。</p>
<p>但是使用者自己的行为是不受限的，自己结合项目情况开发，自己对其负责。</p>
<h2 id="动手写retrofit扩展库"><a class="header" href="#动手写retrofit扩展库">动手写Retrofit扩展库</a></h2>
<p>正如我上文所言，直接在Retrofit中进行扩展需要考虑对生态的影响，读者诸君可以详细阅读Jake Wharton 的post，其设计构思在考虑 "一致性" 问题。</p>
<p>但如果在Retrofit之外进行扩展，则可以回避生态问题，即便有非一致性设计，也可以不用直面。</p>
<p><a href="https://github.com/leobert-lan/SSE-android-Demo">代码仓库</a> 需切换到 <code>retrofit-sse</code> 分支！</p>
<p><strong><em>作者按：读者诸君请注意，在编写此文时，我尚未有充足的时间投入扩展库的设计与编写，代码库中的Sample代码，仅可作为指导，仍存在设计盲点，不要直接投入商用。</em></strong></p>
<p>很容易得出以下核心设计思路，<em>可看导图或下文的文字说明，较为啰嗦</em>：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/766af76c9b1a4ab1b386f0b2c930e65c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2916&amp;h=2272&amp;s=564681&amp;e=png&amp;b=fffefe" alt="扩展库.png" /></p>
<ul>
<li>将连续的Event内容转变为可观测的Source，例如Rxjava的观测源、LiveData、kotlin协程的Flow
<ul>
<li>内建 <code>EventSourceListener</code> 实现类，从回调触发源的更新</li>
<li>定义 <code>EventSourceAdapter</code>，用于将 <code>Okhttp-EventSource</code> 转变为 可观测的Source</li>
</ul>
</li>
<li>需要存在一种机制，依据Interface中Method定义的返回类型，获取 <code>EventSourceAdapter</code> 实例
<ul>
<li>应当有Factory、Factory注册池，亦可以考虑直接使用实例、实例注册池</li>
<li>需要利用反射</li>
<li>Factory注册池或Adapter实例注册池需能区分目标类型</li>
</ul>
</li>
<li>需要能够创建（<strong>完整功能应当为管理</strong>）<code>EventSource</code>
<ul>
<li>需可注册 <code>EventSource.Factory</code> 实例</li>
</ul>
</li>
<li>存在一条扩展路径，符合SSE时，走新设计；否则走原Retrofit设计
<ul>
<li>增加入口，例如 <code>RetrofitSSE</code>，承载以上设计，并包含 <code>Retrofit</code></li>
<li>扩展 <code>ServiceMethod&lt;?&gt; loadServiceMethod(Method method)</code>，新增SSE情况的执行路径</li>
<li>扩展 <code>ServiceMethod</code>，内建SSE情况的处理逻辑，即承载设计1、2</li>
</ul>
</li>
</ul>
<p>简要的代码如下：</p>
<h3 id="内建的eventsourcelistener----对应1"><a class="header" href="#内建的eventsourcelistener----对应1">内建的EventSourceListener -- 对应1</a></h3>
<blockquote>
<p>内建选择了Flow，可自行扩展其他，通过回调实现源的更新</p>
</blockquote>
<pre><code class="language-kotlin">class FlowAdapterEventListener(
    val channel: Channel&lt;Event&gt;,
) : EventSourceListener() {

    private val scope: CoroutineScope = CoroutineScope(Dispatchers.IO)

    override fun onEvent(eventSource: EventSource, id: String?, type: String?, data: String) {
        super.onEvent(eventSource, id, type, data)
        scope.launch {
            channel.send(Event(id, type, data))
        }
    }

    override fun onFailure(eventSource: EventSource, t: Throwable?, response: Response?) {
        super.onFailure(eventSource, t, response)
        scope.launch {
            channel.send(
                Event(null, null, "", t)
            )
            channel.close(t)
        }
    }
}
</code></pre>
<h3 id="定义eventsourceadapter----对应2"><a class="header" href="#定义eventsourceadapter----对应2">定义EventSourceAdapter -- 对应2</a></h3>
<pre><code class="language-kotlin">interface EventSourceAdapter&lt;T&gt; {
    fun adapt(request: Request, factory: EventSource.Factory): T

    abstract class Factory {
        abstract operator fun get(
            returnType: Type, annotations: Array&lt;Annotation&gt;, retrofitSSE: RetrofitSSE
        ): EventSourceAdapter&lt;*&gt;?
    }
}
</code></pre>
<h3 id="内建eventsourceadapter-和-factory----对应2"><a class="header" href="#内建eventsourceadapter-和-factory----对应2">内建EventSourceAdapter 和 Factory -- 对应2</a></h3>
<p>这是一个示例，以内建选择的Flow情况为例，展示Factory能区分目标类型，
Factory注册池遍历执行至非NULL返回时，认为得到目标类型的Factory</p>
<pre><code class="language-kotlin">class FlowAdapter : EventSourceAdapter&lt;Flow&lt;Event&gt;&gt; {

        override fun adapt(request: Request, factory: EventSource.Factory): Flow&lt;Event&gt; {

            val channel = Channel&lt;Event&gt;()
            return channel.receiveAsFlow()
                .shareIn(CoroutineScope(Dispatchers.IO), SharingStarted.Eagerly)
                .onSubscription {
                    factory.newEventSource(
                        request, FlowAdapterEventListener(channel)
                    )
                }
        }

        companion object {

            val Factory = object : Factory() {
                override fun get(
                    returnType: Type,
                    annotations: Array&lt;Annotation&gt;,
                    retrofitSSE: RetrofitSSE
                ): EventSourceAdapter&lt;*&gt;? {
                    if (Flow::class.java.isAssignableFrom(getRawType(returnType))) {
                        return FlowAdapter()
                    }
                    return null
                }

            }
        }
    }
</code></pre>
<h3 id="servicemethod扩展以及路径"><a class="header" href="#servicemethod扩展以及路径">ServiceMethod扩展以及路径</a></h3>
<p>新路径：</p>
<pre><code class="language-Java">abstract class ServiceMethodV2&lt;T&gt; extends ServiceMethod&lt;T&gt; {

    static &lt;T&gt; ServiceMethod&lt;T&gt; parseAnnotationsV2(RetrofitSSE retrofit, Method method) {
        RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit.retrofit, method);

        Type returnType = method.getGenericReturnType();
        if (Utils.hasUnresolvableType(returnType)) {
            throw methodError(/*ignore*/);
        }
        if (returnType == void.class) {
            throw methodError(method, "Service methods cannot return void.");
        }

        return HttpServiceMethodV2.parseAnnotations(retrofit, method, requestFactory);
    }
}
</code></pre>
<blockquote>
<p>扩展 <code>ServiceMethod</code>，内建SSE情况的处理逻辑，即承载设计1、2</p>
</blockquote>
<p>详见：<code>HttpServiceMethodV2</code>，代码较多，不做展开,当满足SSE情况时，走新逻辑，否则回归至 <code>HttpServiceMethod#parseAnnotations</code></p>
<h3 id="新入口"><a class="header" href="#新入口">新入口</a></h3>
<blockquote>
<ul>
<li>具备EventSource.Factory注册</li>
<li>具备EventSourceAdapter.Factory池，以及识别目标的能力</li>
<li>走新逻辑：<code>ServiceMethodV2.parseAnnotationsV2(this, method)</code></li>
</ul>
</blockquote>
<pre><code class="language-Java">
public final class RetrofitSSE {
    private final Map&lt;Method, ServiceMethod&lt;?&gt;&gt; serviceMethodCache = new ConcurrentHashMap&lt;&gt;();

    final Retrofit retrofit;

    @NotNull
    final EventSource.Factory eventSourceFactory;

    final List&lt;EventSourceAdapter.Factory&gt; eventSourceAdapterFactories = new ArrayList&lt;&gt;();

    public RetrofitSSE(Retrofit retrofit, @NotNull EventSource.Factory eventSourceFactory) {
        this.retrofit = retrofit;
        this.eventSourceFactory = eventSourceFactory;
    }


    @SuppressWarnings("unchecked") // Single-interface proxy creation guarded by parameter safety.
    public &lt;T&gt; T create(final Class&lt;T&gt; service) {
        //ignore
    }

    public RetrofitSSE addEventSourceAdapterFactory(EventSourceAdapter.Factory factory) {
        eventSourceAdapterFactories.add(Objects.requireNonNull(factory, "factory == null"));
        return this;
    }

    ServiceMethod&lt;?&gt; loadServiceMethod(Method method) {
        ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);
        if (result != null) return result;

        synchronized (serviceMethodCache) {
            result = serviceMethodCache.get(method);
            if (result == null) {
                result = ServiceMethodV2.parseAnnotationsV2(this, method);
                serviceMethodCache.put(method, result);
            }
        }
        return result;
    }


    public EventSourceAdapter&lt;?&gt; eventSourceAdapter(Type returnType, Annotation[] annotations) {
        return nextEventSourceAdapter(null, returnType, annotations);
    }


    public EventSourceAdapter&lt;?&gt; nextEventSourceAdapter(
            @Nullable EventSourceAdapter.Factory skipPast, Type returnType, Annotation[] annotations) {
        Objects.requireNonNull(returnType, "returnType == null");
        Objects.requireNonNull(annotations, "annotations == null");

        int start = eventSourceAdapterFactories.indexOf(skipPast) + 1;
        for (int i = start, count = eventSourceAdapterFactories.size(); i &lt; count; i++) {
            EventSourceAdapter&lt;?&gt; adapter = eventSourceAdapterFactories.get(i).get(returnType, annotations, this);
            if (adapter != null) {
                return adapter;
            }
        }

        throw new IllegalArgumentException(/*ignore*/);
    }
}

</code></pre>
<p><em>作者按：更多的代码细节，还请移步 <a href="https://github.com/leobert-lan/SSE-android-Demo">代码仓库</a> 需切换到 <code>retrofit-sse</code> 分支！</em></p>
<h2 id="结语"><a class="header" href="#结语">结语</a></h2>
<p>又到了说再见的时候，这篇文章中，我们一同完成了：</p>
<ul>
<li>获取服务端长耗时任务结果的常见实践方式的归纳</li>
<li>对SSE进行了详细的讨论，尤其是其协议细节</li>
<li>搭建SSE服务端、使用OKHttp搭建客户端，进行实操</li>
<li>对Retrofit进行了分析，探讨并发现了一条扩展路径，可通过Retrofit使用SSE</li>
</ul>
<p><strong>应当是一次有趣、好玩的历程！</strong></p>
<p>在结尾，还是再次提醒，<a href="https://github.com/leobert-lan/SSE-android-Demo">代码仓库</a> 中Retrofit-SSE的代码，并未经过严谨的设计论证并进行充分的测试，
我仅花费了数小时时间实现博客内容所需的最少设计，势必会存在BUG和设计不健全的内容，<strong>不要直接商用，以免影响绩效</strong>。</p>
<p>汇总链接如下：</p>
<p><a href="https://html.spec.whatwg.org/multipage/server-sent-events.html">SSE协议内容扩展阅读</a></p>
<p><a href="https://www.rfc-editor.org/rfc/rfc5234">ABNF语法RFC</a></p>
<p><a href="https://github.com/leobert-lan/SSE-android-Demo">服务端 SSE demo代码仓库</a></p>
<p><a href="https://github.com/square/retrofit/issues/1029">Retrofit关于SSE的讨论issue</a></p>
<p><a href="https://github.com/leobert-lan/SSE-android-Demo">Android代码仓库</a> 注意分支</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../repo/post_48.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../Review/DataStructure/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../repo/post_48.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../Review/DataStructure/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
