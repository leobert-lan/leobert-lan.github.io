<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>leobert&#x27;s blog</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">目录</li><li class="chapter-item expanded "><a href="Android/index.html"><strong aria-hidden="true">1.</strong> Android</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Android/View/index.html"><strong aria-hidden="true">1.1.</strong> View</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Android/View/post_1.html"><strong aria-hidden="true">1.1.1.</strong> 好玩系列：优雅的处理ButterKnife和KAE被废弃</a></li><li class="chapter-item expanded "><a href="Android/View/post_6.html"><strong aria-hidden="true">1.1.2.</strong> 三思系列：View体系认知(一)，内容是如何正确被展现出来的--视觉呈现概览</a></li><li class="chapter-item expanded "><a href="Android/View/post_7.html"><strong aria-hidden="true">1.1.3.</strong> 三思系列：为什么自定义View</a></li><li class="chapter-item expanded "><a href="Android/Idea/post_9.html"><strong aria-hidden="true">1.1.4.</strong> 三思系列："声明式UI"和"命令式UI"，你的理解可能是错的</a></li></ol></li><li class="chapter-item expanded "><a href="Android/Drawable/index.html"><strong aria-hidden="true">1.2.</strong> Drawable</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Android/Drawable/post_2.html"><strong aria-hidden="true">1.2.1.</strong> 三思系列：重新认识Drawable</a></li><li class="chapter-item expanded "><a href="Android/Drawable/post_4.html"><strong aria-hidden="true">1.2.2.</strong> 好玩系列：拥有它，XML文件少一半--更方便的处理View背景</a></li><li class="chapter-item expanded "><a href="Android/Drawable/post_47.html"><strong aria-hidden="true">1.2.3.</strong> 迟来的续集--Drawable+Animator，将优雅进行到底</a></li><li class="chapter-item expanded "><a href="Android/Drawable/post_49.html"><strong aria-hidden="true">1.2.4.</strong> 好玩系列：让ImageSpan动起来</a></li></ol></li><li class="chapter-item expanded "><a href="Android/Mechanism/Message/index.html"><strong aria-hidden="true">1.3.</strong> 消息机制</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Android/Mechanism/Message/post_8.html"><strong aria-hidden="true">1.3.1.</strong> 三思系列：Android的消息机制，一文吃透</a></li></ol></li><li class="chapter-item expanded "><a href="Android/Idea/post_14/index.html"><strong aria-hidden="true">1.4.</strong> 兼容</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Android/Idea/post_14.html"><strong aria-hidden="true">1.4.1.</strong> 好玩系列：让项目中的相册支持Heif格式图片</a></li></ol></li><li class="chapter-item expanded "><a href="Android/Glide/index.html"><strong aria-hidden="true">1.5.</strong> Glide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Android/Glide/post_15.html"><strong aria-hidden="true">1.5.1.</strong> 三思系列：Glide 4.X全方位认知 -- 模块职责概览</a></li><li class="chapter-item expanded "><a href="Android/Glide/post_16.html"><strong aria-hidden="true">1.5.2.</strong> 三思系列：Glide 4.X加载过程一文掌握 | Glide（二）</a></li></ol></li><li class="chapter-item expanded "><a href="Android/KSP/index.html"><strong aria-hidden="true">1.6.</strong> KSP</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Android/KSP/post_24.html"><strong aria-hidden="true">1.6.1.</strong> 好玩系列 | 拥抱Kotlin Symbol Processing(KSP),项目实战</a></li></ol></li><li class="chapter-item expanded "><a href="Android/Base/index.html"><strong aria-hidden="true">1.7.</strong> 基础</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Android/Base/post_35.html"><strong aria-hidden="true">1.7.1.</strong> 孔乙己：你可知道页面和弹窗“通信“的方式有四种？</a></li></ol></li><li class="chapter-item expanded "><a href="Android/SysApp/index.html"><strong aria-hidden="true">1.8.</strong> 系统APP</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Android/SysApp/post_52.html"><strong aria-hidden="true">1.8.1.</strong> 使用日历丰富产品的用户体验</a></li></ol></li><li class="chapter-item expanded "><a href="Android/DI/index.html"><strong aria-hidden="true">1.9.</strong> Part4-依赖注入部分</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Android/DI/post_53.html"><strong aria-hidden="true">1.9.1.</strong> Hilt进阶--一文吃透Hilt自定义与跨壁垒</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="Compose/index.html"><strong aria-hidden="true">2.</strong> Jetpack Compose</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Compose/post_21.html"><strong aria-hidden="true">2.1.</strong> Jetpack Compose | 一文理解神奇的Modifier</a></li><li class="chapter-item expanded "><a href="Compose/post_26.html"><strong aria-hidden="true">2.2.</strong> Jetpack Compose | 控件篇（一） -- Text、TextField、Button</a></li><li class="chapter-item expanded "><a href="Compose/post_27.html"><strong aria-hidden="true">2.3.</strong> Jetpack Compose | 控件篇（二） -- Icon，Image</a></li><li class="chapter-item expanded "><a href="Compose/post_28.html"><strong aria-hidden="true">2.4.</strong> Jetpack Compose | 控件篇（三） -- Switch、CheckBox、RadioButton</a></li><li class="chapter-item expanded "><a href="Compose/post_29.html"><strong aria-hidden="true">2.5.</strong> Jetpack Compose | 控件篇（四）-- Box、Row、Column</a></li><li class="chapter-item expanded "><a href="Compose/post_30.html"><strong aria-hidden="true">2.6.</strong> Jetpack Compose | 控件篇（五）-- Spacer、LazyRow、LazyColumn & 让Column可滑动</a></li></ol></li><li class="chapter-item expanded "><a href="MultiThreading/index.html"><strong aria-hidden="true">3.</strong> Java多线程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="MultiThreading/post_33.html"><strong aria-hidden="true">3.1.</strong> 总纲</a></li><li class="chapter-item expanded "><a href="MultiThreading/post_37.html"><strong aria-hidden="true">3.2.</strong> Java基础--图解JVM内存模型和JVM线程模型</a></li><li class="chapter-item expanded "><a href="MultiThreading/post_38.html"><strong aria-hidden="true">3.3.</strong> Java多线程系列--掌控面试，一文吃透Synchronized锁</a></li><li class="chapter-item expanded "><a href="MultiThreading/post_39.html"><strong aria-hidden="true">3.4.</strong> Java多线程基础--线程生命周期与线程协作详解</a></li><li class="chapter-item expanded "><a href="MultiThreading/post_42.html"><strong aria-hidden="true">3.5.</strong> Java多线程基础--线程的创建与线程池管理</a></li><li class="chapter-item expanded "><a href="MultiThreading/post_46.html"><strong aria-hidden="true">3.6.</strong> Java多线程系列--掌握Future，轻松获取异步任务结果</a></li><li class="chapter-item expanded "><a href="MultiThreading/post_50.html"><strong aria-hidden="true">3.7.</strong> Java多线程系列--Fork&Join框架，分治的艺术</a></li><li class="chapter-item expanded "><a href="MultiThreading/post_54.html"><strong aria-hidden="true">3.8.</strong> Java多线程系列--掌握CompletableFuture，驾驭异步编程</a></li></ol></li><li class="chapter-item expanded "><a href="IO/index.html"><strong aria-hidden="true">4.</strong> Java IO系列</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="IO/post_55.html"><strong aria-hidden="true">4.1.</strong> Java IO 系列总纲</a></li><li class="chapter-item expanded "><a href="IO/post_56.html"><strong aria-hidden="true">4.2.</strong> Java IO系列 | 经典 IO</a></li><li class="chapter-item expanded "><a href="IO/post_57.html"><strong aria-hidden="true">4.3.</strong> Java IO 系列 | NIO-1.0一文速览</a></li><li class="chapter-item expanded "><a href="IO/post_58.html"><strong aria-hidden="true">4.4.</strong> Java IO系列 | NIO-1.0拾遗、NIO-2.0 & 零拷贝必吹的牛皮</a></li><li class="chapter-item expanded "><a href="IO/post_59.html"><strong aria-hidden="true">4.5.</strong> IO系列 | 一文掌握OKHTTP中的OKIO为什么这么OK</a></li></ol></li><li class="chapter-item expanded "><a href="Gradle/index.html"><strong aria-hidden="true">5.</strong> Gradle</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Gradle/Modularization/post_18.html"><strong aria-hidden="true">5.1.</strong> 组件化：三思系列：组件化场景下module依赖优雅实践方案</a></li><li class="chapter-item expanded "><a href="Gradle/Publish/post_17.html"><strong aria-hidden="true">5.2.</strong> MavenCentral发布：迁移到MavenCentral--再不行动起来，你的托管的library就没了</a></li><li class="chapter-item expanded "><a href="Gradle/post_22.html"><strong aria-hidden="true">5.3.</strong> Gradle | 依赖管理最佳实践</a></li></ol></li><li class="chapter-item expanded "><a href="Groovy/index.html"><strong aria-hidden="true">6.</strong> Groovy</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Groovy/why_write_groovy.html"><strong aria-hidden="true">6.1.</strong> 为什么撰写这个系列</a></li><li class="chapter-item expanded "><a href="Groovy/post_23.html"><strong aria-hidden="true">6.2.</strong> Groovy：MOP一文打尽</a></li></ol></li><li class="chapter-item expanded "><a href="Review/index.html"><strong aria-hidden="true">7.</strong> Review</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Review/post_10.html"><strong aria-hidden="true">7.1.</strong> 造完了这个轮子--Mocker，却让我感到很羞愧|项目复盘</a></li><li class="chapter-item expanded "><a href="Review/post_40.html"><strong aria-hidden="true">7.2.</strong> 三思系列：前人用GreenDao留下的坑，全线被扣了绩效</a></li><li class="chapter-item expanded "><a href="Review/post_44.html"><strong aria-hidden="true">7.3.</strong> 谈一谈在两个商业项目中使用MVI架构后的感悟</a></li><li class="chapter-item expanded "><a href="Review/post_45.html"><strong aria-hidden="true">7.4.</strong> Review | 这三个坑你遇到了吗？</a></li></ol></li><li class="chapter-item expanded "><a href="repo/index.html"><strong aria-hidden="true">8.</strong> 个人项目</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="repo/DaVinCi.html"><strong aria-hidden="true">8.1.</strong> DaVinCi,取代XML编写Shape或ColorStateList的方案</a></li><li class="chapter-item expanded "><a href="Android/Idea/post_32.html"><strong aria-hidden="true">8.2.</strong> 好玩系列：白嫖一个优雅的类图生成工具</a></li><li class="chapter-item expanded "><a href="Speculative/post_43.html"><strong aria-hidden="true">8.3.</strong> 初体验：动手搭建"小清新式"局域网文档系统</a></li><li class="chapter-item expanded "><a href="repo/post_48.html"><strong aria-hidden="true">8.4.</strong> 研究良久，终于发现了他代码写的快且bug少的原因</a></li><li class="chapter-item expanded "><a href="Speculative/post_61.html"><strong aria-hidden="true">8.5.</strong> 好玩系列 | 如果后端让你用SSE接收多次返回，那我们改造Retrofit吧</a></li></ol></li><li class="chapter-item expanded "><a href="Review/DataStructure/index.html"><strong aria-hidden="true">9.</strong> 数据结构</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Review/DataStructure/post_11.html"><strong aria-hidden="true">9.1.</strong> 温故：线性表</a></li><li class="chapter-item expanded "><a href="Review/DataStructure/post_12.html"><strong aria-hidden="true">9.2.</strong> 温故：栈</a></li><li class="chapter-item expanded "><a href="Review/DataStructure/post_13.html"><strong aria-hidden="true">9.3.</strong> 温故：队列</a></li></ol></li><li class="chapter-item expanded "><a href="Review/README2.html"><strong aria-hidden="true">10.</strong> 年终总结&计划</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Review/post_36.html"><strong aria-hidden="true">10.1.</strong> 2021年终总结</a></li><li class="chapter-item expanded "><a href="Review/post_51.html"><strong aria-hidden="true">10.2.</strong> 关于画一个句号--基于2022年终总结的反思与分享</a></li><li class="chapter-item expanded "><a href="Review/post_60.html"><strong aria-hidden="true">10.3.</strong> 突如其来的秋季反思</a></li><li class="chapter-item expanded "><a href="Review/post_63.html"><strong aria-hidden="true">10.4.</strong> 2023年总结 寻找到源于内心深处的无穷力量</a></li><li class="chapter-item expanded "><a href="Review/post_64.html"><strong aria-hidden="true">10.5.</strong> 2024年中思考，推倒樊笼重新出发</a></li></ol></li><li class="chapter-item expanded "><a href="Note/index.html"><strong aria-hidden="true">11.</strong> 读书笔记</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Note/post_41.html"><strong aria-hidden="true">11.1.</strong> 读书笔记：《简约至上--交互式设计四策略》</a></li></ol></li><li class="chapter-item expanded "><a href="Talk/index.html"><strong aria-hidden="true">12.</strong> 杂谈</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Talk/talk_1.html"><strong aria-hidden="true">12.1.</strong> 杂谈1-2022-11</a></li><li class="chapter-item expanded "><a href="Talk/talk_2_2023-03.html"><strong aria-hidden="true">12.2.</strong> 杂篇（二）-- 认识并战胜焦虑</a></li><li class="chapter-item expanded "><a href="Talk/talk_3_2024-08.html"><strong aria-hidden="true">12.3.</strong> 杂谈（三）-- 向钱看，你需要想明白企业在为什么而付钱</a></li></ol></li><li class="chapter-item expanded "><a href="Thought/index.html"><strong aria-hidden="true">13.</strong> 半成熟的思考</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Thought/post_62.html"><strong aria-hidden="true">13.1.</strong> 好玩系列 | 当SPI 和 设计模式、依赖注入发生碰撞，可以擦出怎样的火花</a></li></ol></li><li class="chapter-item expanded "><a href="info/index.html"><strong aria-hidden="true">14.</strong> 系列说明</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="info/about_view_series.html"><strong aria-hidden="true">14.1.</strong> 关于View系列</a></li><li class="chapter-item expanded "><a href="info/about_sansi_series.html"><strong aria-hidden="true">14.2.</strong> 关于三思系列</a></li><li class="chapter-item expanded "><a href="info/about_haowan_series.html"><strong aria-hidden="true">14.3.</strong> 关于好玩系列</a></li><li class="chapter-item expanded "><a href="info/about_wengu_series.html"><strong aria-hidden="true">14.4.</strong> 关于温故系列</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">leobert&#x27;s blog</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h3 id="android"><a class="header" href="#android">Android</a></h3>
<p>Android 相关知识、常用工具的原理解析等</p>
<div style="break-before: page; page-break-before: always;"></div><p>Android View 体系</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="好玩系列优雅的处理butterknife和kae被废弃"><a class="header" href="#好玩系列优雅的处理butterknife和kae被废弃">好玩系列：优雅的处理ButterKnife和KAE被废弃</a></h1>
<p><em>最近反思了一下近期的工作，忽然就出现了一个想法，将平时干的好玩的事情，整理成一个系列，和大家分享一下，想来想去也没想好这个系列叫啥，索性就叫好玩系列得了。</em></p>
<p><strong>文中涉及的代码均在 <a href="https://github.com/leobert-lan/UIBinding">此处</a> 可以找到</strong></p>
<h2 id="前言"><a class="header" href="#前言">前言</a></h2>
<p>如果你的项目中使用了ButterKnife或者Kotlin-Android-Extention（KAE）插件，近半年你一定关注过如下信息：</p>
<blockquote>
<p>Attention: This tool is now deprecated. Please switch to view binding. Existing versions will continue to work, obviously, but only critical bug fixes for integration with AGP will be considered. Feature development and general bug fixes have stopped. -- ButterKnife</p>
</blockquote>
<blockquote>
<p>Resource IDs will be non-final in Android Gradle Plugin version 5.0, avoid using them in switch case statements
Inspection info:Avoid the usage of resource IDs where constant expressions are required.  A future version of the Android Gradle Plugin will generate R classes with non-constant IDs in order to improve the performance of incremental compilation.</p>
<p>Issue id: NonConstantResourceId -- lint</p>
</blockquote>
<blockquote>
<p>The 'kotlin-android-extensions' Gradle plugin is deprecated. Please use this migration guide (https://goo.gle/kotlin-android-extensions-deprecation) to start working with View Binding (https://developer.android.com/topic/libraries/view-binding) and the 'kotlin-parcelize' plugin.</p>
</blockquote>
<p>是的，这两个在Android中使用面很广的内容被标记为废弃了。</p>
<p>对于ButterKnife，被废弃的原因是：从AGP-5.0版本开始，R类生成的值不再是常量</p>
<p>对于KAE，问题如下：</p>
<ul>
<li>类型安全：res下的任何id都可以被访问，有可能因访问了非当前Layout下的id而出错，难以利用lint等静态代码校验</li>
<li>空安全：运行时可能出现NPE</li>
<li>兼容性：只能在kotlin中使用，java不友好</li>
<li>局限性：不能跨module使用</li>
</ul>
<p>按照官方或者社区的推荐，替代方案还是回归到findViewById or ViewBinding or DataBinding.</p>
<p>未来可能替代XML描述布局文件的技术：Compose还没有真正到来，而且一时半会也不可能把原先的内容全部迁移到Compose实现，所以我们还是要老老实实回归到上面的三个方案。</p>
<p>有些同学知识面广一点，立马想到了psi，通过分析代码文件的psi树，实现代码转换，直接搞一个插件来处理ButterKnife的迁移问题。</p>
<p><strong>当然，这篇文章并不准备去讲psi，虽然这是一个挺好玩的东西。下次有时间会专门写一个好玩的psi</strong></p>
<h2 id="思考1为什么要废弃butterknife"><a class="header" href="#思考1为什么要废弃butterknife">思考1：为什么要废弃ButterKnife</a></h2>
<p>因为AGP生成的R类资源值不再是常量，无论是library还是application，那么要继续再思考一个问题：library的R类资源也不是常量，原先ButterKnife是怎么处理的？
我们知道，Butterknife有运行时反射用法，也有编译期使用apt预生成代码的用法。bk提供了gradle插件，用于copy原始R类内容,生成R2类，R2复刻了R的内容，但均为常量。因为注解中的内容，是需要在编译期确定，它被要求为常量，并且在编译时被优化。但我们知道，通过字节码技术，可以修改很多东西，无论是一个常量的值，还是索性连类都给换了。
一旦这个值被修改，注解中的信息便为谬误。但因为R2的存在，我们可以通过常量值反向获取到常量的名字，从而去使用R类。</p>
<h2 id="思考2是不是butterknife所有的代码都没有意义了"><a class="header" href="#思考2是不是butterknife所有的代码都没有意义了">思考2：是不是Butterknife所有的代码都没有意义了？</a></h2>
<p>显然不是，因为findviewbyid还没用被革命性改变，bk中所有的核心代码还是有用的
如果你使用的apt方式，那么就有意思了，对于一个特定的target，bk生成的绑定代码完全是没有“废弃”风险的，我们完全可以拷贝其中的逻技，或者直接对生成类实行“拿来主义”
最终，我们只需要扔掉bk的gradle插件，注解和apt处理器，岁月静好。
如果你使用的是运行时反射方案，我不排斥运行时反射，虽然他会多耗一些时间，如果你不介意耗费更多的时间，完全可以改造bk的注解和逻辑，虽然它很好玩，但这并不是一个值得推荐的做法。</p>
<h2 id="思考3kae又是怎么帮助我们找到view的"><a class="header" href="#思考3kae又是怎么帮助我们找到view的">思考3：kae又是怎么帮助我们找到view的</a></h2>
<p>没错，还是通过findviewbyid，它被废弃并不是犯了什么大错，只是不在适应潮流，且有各种各样的小毛病。
我们以Fragment为例子，看一下编译器为我们植入的代码：</p>
<pre><code>public android.view.View _$_findCachedViewById(int var1) {
    if (this._$_findViewCache == null) {
       this._$_findViewCache = new HashMap();
    }

    android.view.View var2 = (android.view.View)this._$_findViewCache.get(var1);
    if (var2 == null) {
       android.view.View var10000 = this.getView();
       if (var10000 == null) {
          return null;
       }

       var2 = var10000.findViewById(var1);
       this._$_findViewCache.put(var1, var2);
    }

    return var2;
 }

 public void _$_clearFindViewByIdCache() {
    if (this._$_findViewCache != null) {
       this._$_findViewCache.clear();
    }

 }
</code></pre>
<p>以及：</p>
<pre><code>// $FF: synthetic method
public void onDestroyView() {
  super.onDestroyView();
  this._$_clearFindViewByIdCache();
}
</code></pre>
<pre><code>//源码
vMallAccountTitleBar.setTitle("我的钱包")

//反编译结果
((BarStyle4)this._$_findCachedViewById(id.vMallAccountTitleBar))
	.setTitle((CharSequence)"我的钱包");

</code></pre>
<p>可以很轻易的发现，具有多种场景下潜在的npe风险。本质上还是在使用findViewByID机制</p>
<h2 id="思考4是否可以最小程度重构实现从bk切换到databinding或者viewbinding"><a class="header" href="#思考4是否可以最小程度重构实现从bk切换到databinding或者viewbinding">思考4：是否可以最小程度重构实现从bk切换到databinding或者viewbinding</a></h2>
<p>首先还是要粗略提一下databinding和viewbinding。记忆中databinding技术先于viewbinding，是Google提供的声明式UI解决方案，这里必须要岔开一句：什么是声明式UI？</p>
<p>这里我用SQL举个例子类比， select * from t where 't.id' = 1， 这就是声明式，声明一个符合规则的定则，让对应的系统执行，得到目标结果。相应的，对立面就是命令式，命令式需要准确的指出每一步操作的具体指令，以完成一个特定的算法。</p>
<p>肤浅的总结，声明式是底层实现了一类行为的抽象，其核心的算法或者控制段均被封装，只需要控制输入，即可得到输出。而命令式则完全需要自行实现。</p>
<p>理解了这一点，我们就会意识到，databinding本身不应该对外暴露这些view，只是这么干的话，项目迁移成本就会变大，所以还是选择了开放，这也就有了后来的viewbinding。</p>
<p>言归正传，原先用bk，我们需要一个根view作为起始点，以实现视图绑定，基本是找到Activity#setContentView(Int id)后activity的decorview，或者是viewholder#getRoot()，或者是开发者inflate得到的一个view等等。</p>
<p>不难判断，<strong>如果彻底的修改代码，从基类出发应该是没什么方案。只能进行一件枯燥乏味的事情</strong></p>
<h2 id="思考5如果是kotlin语言下利用属性代理是否可以简化代码修改"><a class="header" href="#思考5如果是kotlin语言下利用属性代理是否可以简化代码修改">思考5：如果是kotlin语言下，利用属性代理是否可以简化代码修改</a></h2>
<blockquote>
<p>延伸：属性委托指的是一个类的某个属性值不是在类中直接进行定义，而是将其托付给一个代理类，从而实现对该类的属性统一管理。
属性委托语法格式：</p>
<p><code>val/var &lt;属性名&gt;: &lt;类型&gt; by &lt;表达式&gt;</code></p>
</blockquote>
<h2 id="实践1属性代理替代bk的注解"><a class="header" href="#实践1属性代理替代bk的注解">实践1：属性代理替代BK的注解</a></h2>
<p>先定一个小目标,我们会将注解形式变成类似以下代码的形式：</p>
<pre><code>val tvHello1 by bindView&lt;TextView&gt;(R.id.dialog)

val tvHello by bindView&lt;TextView&gt;(viewProvider, R.id.hello, lifecycle) {
    bindClick { changeText() }
}

val tvHellos by bindViews&lt;TextView&gt;(
    viewProvider,
    arrayListOf(R.id.hello1, R.id.hello2),
    lifecycle
) {
    this.forEach {
        it.bindClick { tv -&gt;
            Toast.makeText(tv.context, it.text.toString(), Toast.LENGTH_SHORT).show()
        }
    }
}
</code></pre>
<p>那么我们需要先定义一个属性代理类，并实现操作符，以bindView为例，</p>
<p>我们先缓一缓，定义一个基类，接受属性持有者的生命周期，<strong>以实现其生命周期走到特定节点时释放依赖</strong>。</p>
<pre><code>abstract class LifeCycledBindingDelegate&lt;F,T&gt;(lifecycle: Lifecycle): ReadOnlyProperty&lt;F,T&gt; {

    protected var property: T? = null

    init {
        lifecycle.onDestroyOnce { destroy() }
    }

    protected open fun destroy() {
        property = null
    }
}

internal class OnDestroyObserver(var lifecycle: Lifecycle?, val destroyed: () -&gt; Unit) :
    LifecycleEventObserver {
    override fun onStateChanged(source: LifecycleOwner, event: Lifecycle.Event) {
        val lifecycleState = source.lifecycle.currentState
        if (lifecycleState == Lifecycle.State.DESTROYED) {
            destroyed()
            lifecycle?.apply {
                removeObserver(this@OnDestroyObserver)
                lifecycle = null
            }
        }
    }
}

fun Lifecycle.onDestroyOnce(destroyed: () -&gt; Unit) {
    addObserver(OnDestroyObserver(this, destroyed))
}
</code></pre>
<p>这时候我们来处理findViewById的核心部分</p>
<pre><code>class BindView&lt;T:View&gt;(
    private val targetClazz: Class&lt;T&gt;,
    private val rootViewProvider: ViewProvider,
    @IdRes val resId: Int,
    lifecycle: Lifecycle,
    private var onBind: (T.() -&gt; Unit)?
):LifeCycledBindingDelegate&lt;Any,T&gt;(lifecycle) {


    override fun getValue(thisRef: Any, property: KProperty&lt;*&gt;): T {
        return this.property ?: let {

            val rootView = rootViewProvider.provide()
            val v = rootView.findViewById&lt;T&gt;(resId)
                ?: throw IllegalStateException(
                    "could not findViewById by id $resId," +
                            " given name: ${rootView.context.resources.getResourceEntryName(resId)}"
                )
            return v.apply {
                this@BindView.property = this
                onBind?.invoke(this)
                onBind = null
            }
        }
    }
}
</code></pre>
<p>我们需要几样东西以支持：</p>
<blockquote>
<p><code>View#&lt;T extends View&gt; T findViewById(@IdRes int id)</code></p>
</blockquote>
<p>对应了<strong>目标类</strong>，<strong>根View提供者</strong>，<strong>目标view的id</strong>，<strong>属性持有者的生命周期</strong>和<strong>初次属性初始化后的附加逻辑</strong></p>
<p>至于BindViews，我们如法炮制即可。</p>
<p>这时候会发现，这样使用太累了，对于Activity、Fragment、ViewHolder等常见的类而言，虽然他们提供根视图等内容的方式有所差别，但这种行为基本是可以抽象的。</p>
<p>以ComponentActivity为例，我们只需要定义扩展函数：</p>
<pre><code>inline fun &lt;reified T : View&gt; ComponentActivity.bindView(@LayoutRes resId: Int) =
    BindView&lt;T&gt;(
        targetClazz = T::class.java,
        rootViewProvider = object : ViewProvider {
            override fun provide(): View {
                return this@bindView.window.decorView
            }
        },
        resId = resId,
        lifecycle = this.lifecycle,
        onBind = null
    )
</code></pre>
<p>就可以<strong>比较方便的使用</strong>，剩下来的Fragment、ViewHolder之类的东西，讲起来太啰嗦了，都是<strong>如法炮制</strong>。</p>
<p>再定义一个大而全的：</p>
<pre><code>inline fun &lt;reified T : View&gt; Any.bindView(
    rootViewProvider: ViewProvider,
    @LayoutRes resId: Int,
    lifecycle: Lifecycle,
    noinline onBind: (T.() -&gt; Unit)?
) =
    BindView&lt;T&gt;(
        targetClazz = T::class.java,
        rootViewProvider = rootViewProvider,
        resId = resId,
        lifecycle = lifecycle,
        onBind = onBind
    )
</code></pre>
<p><strong>实际项目中想怎么用完全看实际就行了。</strong></p>
<h2 id="思考6让databinding和viewbinding拥有同样的特性是否有价值"><a class="header" href="#思考6让databinding和viewbinding拥有同样的特性是否有价值">思考6：让DataBinding和ViewBinding拥有同样的特性是否有价值</a></h2>
<p>当然是有价值的，一个大项目中，尤其是进行了模块化拆分，不同模块使用不同的技术是很正常的，DataBinding和ViewBinding并存的情况一定会发生，虽然我并没有真正遇到过同时使用的，<strong>并且并不清楚同时使用会不会有bug</strong></p>
<h2 id="实践2支持databinding和viewbinding"><a class="header" href="#实践2支持databinding和viewbinding">实践2：支持DataBinding和ViewBinding</a></h2>
<p>因为笔者项目中没有使用ViewBinding，我们就粗暴的只实现DataBinding了，其实都是获取Binding类实例而已，机制是一致的，<strong>ViewBinding可以如法炮制</strong></p>
<p>得益于我们上面定义的基类，我们可以直接干一个处理DataBinding的子类了</p>
<pre><code>class BindDataBinding&lt;T : ViewDataBinding&gt;(
    private val targetClazz: Class&lt;T&gt;,
    private val inflaterProvider: LayoutInflaterProvider,
    @LayoutRes val resId: Int,
    lifecycle: Lifecycle,
    private var onBind: (T.() -&gt; Unit)?
) : LifeCycledBindingDelegate&lt;Any, T&gt;(lifecycle) {

    override fun getValue(thisRef: Any, property: KProperty&lt;*&gt;): T {

        return this.property ?: let {

            val layoutInflater = inflaterProvider.provide()
            val bind = DataBindingUtil.bind&lt;T&gt;(layoutInflater.inflate(resId, null))
                ?: throw IllegalStateException(
                    "could not create binding ${targetClazz.name} by id $resId," +
                            " given name: ${layoutInflater.context.resources.getResourceEntryName(resId)}"
                )
            return bind.apply {
                this@BindDataBinding.property = this
                onBind?.invoke(this)
                onBind = null
            }
        }

    }
}
</code></pre>
<p>依葫芦画瓢，我们直接搞定inflate方式获取Binding。</p>
<p>仔细一想，<strong>这还不够</strong>，本来我们将布局改为DataBinding模板，有多种方案设置视图，使用属性代理，有一个目的是：让<strong>设置视图</strong>和<strong>得到Binding实例</strong>之间减少限制。</p>
<p>再干一个：</p>
<pre><code>class FindDataBinding&lt;T : ViewDataBinding&gt;(
    private val targetClazz: Class&lt;T&gt;,
    private val viewProvider: ViewProvider,
    lifecycle: Lifecycle,
    private var onBind: (T.() -&gt; Unit)?
) : LifeCycledBindingDelegate&lt;Any, T&gt;(lifecycle) {

    override fun getValue(thisRef: Any, property: KProperty&lt;*&gt;): T {

        return this.property ?: let {
            val view = viewProvider.provide()
            val bind = DataBindingUtil.bind&lt;T&gt;(view)
                ?: throw IllegalStateException(
                    "could not find binding ${targetClazz.name}"
                )
            return bind.apply {
                this@FindDataBinding.property = this
                onBind?.invoke(this)
                onBind = null
            }
        }
    }
}
</code></pre>
<p>我们又可以通过bind的方式，从一个View发现其binding了。<strong>寻找binding</strong>和<strong>设置视图</strong>的先后，就可以灵活选择了。</p>
<p>加上一些扩展方法后，我们就可以开心的使用了：</p>
<pre><code>class MainActivity2 : AppCompatActivity() ,ViewProvider{
    val binding by dataBinding&lt;ActivityMainBinding&gt;(this)

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        binding.hello.text = "fragment"
        binding.hello.bindClick {

        }
    }

    override fun provide(): View {
        return window.decorView.findViewById(R.id.ll_root)
    }
}
</code></pre>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<p>正如开篇提到的，好玩系列其出发点一定是好玩，它很可能是对一个问题展开的一次脑暴和尝试，不一定是一个真正成熟的特定问题通用解法。</p>
<p>这一篇，我们从Butterknife的废弃和KAE的废弃开始思考，回顾了两者的实现原理和被废弃的原因，再到寻找迁移方案，并进行了实践。抛开还未涉及到的PSI，基本可以画上一个阶段性句号了。</p>
<p>再次贴上代码链接：
<strong><a href="https://github.com/leobert-lan/UIBinding">UIBinding</a>，如果本文中的内容对你有一丝丝的帮助，希望可以得到点赞支持。</strong></p>
<p>补充：2021-1-25
再补充一段内容重点。</p>
<ul>
<li>对于Java编写的业务，不牵涉kae，只涉及bk，个人建议拷贝其生成类核心逻辑，再删除相关注解点。</li>
<li>对于kotlin编写的业务，bk内容可以和Java一样处理，kae相关内容考虑使用属性代理方式，增加全局变量。</li>
<li>这一波重构，并不适合在基类做手脚。</li>
<li>对于还没有迁移到databinding或者viewbinding的内容，配合属性代理迁移到databinding或者viewbinding也不麻烦。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="三思系列view体系认知一内容是如何正确被展现出来的--视觉呈现概览"><a class="header" href="#三思系列view体系认知一内容是如何正确被展现出来的--视觉呈现概览">三思系列：View体系认知(一)，内容是如何正确被展现出来的--视觉呈现概览</a></h1>
<h2 id="前言-1"><a class="header" href="#前言-1">前言</a></h2>
<blockquote>
<p>这是View体系认知子系列的第一篇，这一篇会探知Android中，是通过<code>怎么的设计</code>
让视图正确呈现在屏幕上的。</p>
</blockquote>
<p><a href="https://leobert-lan.github.io/info/about_sansi_series.html">关于三思系列</a></p>
<p><a href="https://github.com/leobert-lan/Blog/blob/main/info/%E5%85%B3%E4%BA%8EView%E7%B3%BB%E5%88%97.md">关于View系列</a>
极力建议读者了解一下 <code>为什么撰写这个系列</code></p>
<p>考虑到博客不适合做大量的代码展现，我会以 WorkShop 的形式展现这些代码。<a href="https://github.com/leobert-lan/ViewWorkShop">链接</a></p>
<p>我们知道，在GUI编程中，必然存在一套试图体系内容，Android中也有一套，抛开掉底层内容，和Compose中的内容， 我们这一篇，一同探究下 <code>Framework中</code>，View体系 <code>如何做视觉呈现</code>。</p>
<hr />
<p>补充：2021-02-22</p>
<p>感谢读者 <code>鲁班贼六</code>的建议，补充内容导图</p>
<p>这篇文章篇幅较长，在 View 的 measure 机制上花费了不少篇幅。本文尝试先抛开 <code>Android已有知识体系</code>，模拟 <code>从现实情况思考</code>，以建立认知体系的情况。</p>
<p>所以文章的内容编排和导图有一定出入。</p>
<p><img src="Android/View/./%E4%B8%89%E6%80%9D%E7%B3%BB%E5%88%97%EF%BC%9AView%E4%BD%93%E7%B3%BB%E8%AE%A4%E7%9F%A5(%E4%B8%80)/display_content.png" alt="正确显示一个任意界面" /></p>
<blockquote>
<p>注:本文中不涉及：</p>
<ul>
<li>Canvas绘制基础</li>
<li>屏幕渲染底层机制</li>
</ul>
</blockquote>
<p>我们会先思考，如何描述一个任意的界面，引出 View 继承体系，和 View-Tree 视图树。</p>
<p>再逆推一波：当界面被描述后，需要正确显示存在以下三步：</p>
<ul>
<li>将 <code>正确内容</code> 绘制在 <code>正确位置</code>
<ul>
<li>本文中，Widget的内容绘制略</li>
</ul>
</li>
<li>依据布局规则，确定布局位置。 <strong>注</strong>：<code>显示大小</code> 也可以算作 <code>布局规则</code> 的范畴</li>
<li>测量显示大小</li>
</ul>
<p>我们会先从现实情况出发，思考并设计一种可行的 <code>测量规则</code> ，并不断完善它，重点在于：</p>
<ul>
<li><code>理解</code> 这种设计是如何 <code>演化</code> 得来的</li>
<li><code>明白</code> 测量本身就和 <code>布局规则</code> 有关，<code>布局规则</code> 会影响到测量过程</li>
</ul>
<p>如果读者对 某些内容 已经打下 坚实的基础，建议 选择性泛读。</p>
<hr />
<h2 id="如何描述一个任意的界面"><a class="header" href="#如何描述一个任意的界面">如何描述一个任意的界面</a></h2>
<p>假如我们现在对Android的内容一无所知，如何<code>描述</code> 一个 <code>任意的界面</code>。</p>
<ul>
<li>无论我们要达成什么效果，必然存在<code>一个虚拟窗体</code>，和物理屏幕相对应</li>
<li>系统层面抽象的绘制呈现过程，一定需要通过 这个 <code>虚拟窗体</code>，而我们描述的界面内容，会被放在窗体中</li>
<li>按照 <code>面向对象思想</code> 和 <code>单一职责原则</code>，描述 <code>这个窗体</code> 的类，假定被称为 <code>Window</code>，一定和描述视图的类 <code>不是同一个</code>。假定视图类被称为 <code>View</code></li>
<li>Window可以获知内部View的信息</li>
</ul>
<p>在此基础上，</p>
<p>方案1：构建一个上帝类，它全知全能，能够 <code>记录</code> 和 <code>表达</code> 任意的"文字"、"图片"、"区块"等信息。</p>
<p>方案2：构建一个简单类 <code>View</code>，它有方式知道自己多大，并抽象了视图内容绘制，可以在内部放置子 <code>View</code>，并有方式确定如何放置；</p>
<p>显然，方案1不可取。我们<code>细化方案2</code>.</p>
<p>此时，我们做出了一个假设：<code>View</code>拥有3个能力</p>
<ul>
<li>测算自身大小</li>
<li>可以放置<code>子View</code>；并知道其所在位置，即拥有 <code>布局能力</code></li>
<li>准确的知道如何绘制自身所代表的内容</li>
</ul>
<p>在此基础上，我们就可以将 <code>任意界面</code> 拆分结构，这个结构可以用 <code>树</code> 来表达。</p>
<p><a id="id_tree_rule">目前我们约定：</a></p>
<ul>
<li>每个 <code>View</code> 只能有 <code>一个</code> 双亲</li>
<li>作为双亲的 <code>View</code>，仅用来描述 <code>布局信息</code></li>
<li>实际 <code>可视</code> 、 <code>可交互</code> 的 <code>View</code>， 描述其代表的内容信息</li>
</ul>
<p>于是 <code>描述任意界面</code> 的问题，就可以用 <code>描述一棵树</code> 来解决。</p>
<blockquote>
<p>注：目前这个约定还很粗糙，但是不影响我们进行问题认知</p>
</blockquote>
<blockquote>
<p>树的存储方法有3种：</p>
<ul>
<li>双亲表示法</li>
<li>孩子表示法</li>
<li>孩子兄弟表示法</li>
</ul>
<p>以及基于以上方法的改进版本</p>
</blockquote>
<p>为了更加方便地向上和向下检索，我们使用 <code>双亲孩子表示法</code> 这一改进版本。</p>
<h3 id="细化方案2viewgroup和widget各司其职"><a class="header" href="#细化方案2viewgroup和widget各司其职">细化方案2，ViewGroup和Widget，各司其职</a></h3>
<p>按照我们上面对<a href="Android/View/post_6.html#id_tree_rule">树的约定</a></p>
<p>我们按职责细分：</p>
<ul>
<li>
<p>一部分View 专注于对子View的布局能力，而不再表达 "文字"、"图片"等内容信息，我们将其抽象为子类 <code>ViewGroup</code>。因为没有具体表达
<code>如何放置子View</code>的 <code>规则</code>，所以它是<code>抽象类</code>。</p>
</li>
<li>
<p>将 <code>非包含子View</code> 的，表达"文字"、"图片"等特定信息的View，归纳为Widget。</p>
</li>
</ul>
<blockquote>
<p>小结：在上面的阶段性成果中，我们已经细化了方案，用树的形式，描述了界面的结构和内容。
存在一个预设的ViewGroup，作为树的根节点。</p>
</blockquote>
<p>下面我们先给出一些伪代码。</p>
<pre><code class="language-kotlin">open class View {
    var parent: View? = null

    //绘制能力
    protected open fun onDraw(canvas: Canvas) {

    }

    //布局能力
    protected open fun onLayout(changed: Boolean, l: Int, t: Int, r: Int, b: Int) {

    }

    //测量能力
    protected open fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {

    }
}

abstract class ViewGroup : View() {
    protected val children = arrayListOf&lt;View&gt;()

    abstract override fun onLayout(changed: Boolean, l: Int, t: Int, r: Int, b: Int)

    fun addView(view: View) {
        if (view.parent != null) {
            throw IllegalArgumentException("view has a parent")
        }
        children.add(view)
        view.parent = this
    }

}

</code></pre>
<h2 id="测量大小"><a class="header" href="#测量大小">测量大小</a></h2>
<p>接下来我们设计测量大小的能力，</p>
<p>假定有一个显示文字的View，他可以测算自身的大小，但这有3种可能：</p>
<ul>
<li>恰好装下文字内容</li>
<li>被指定了大小，但和第一种大小不一致，这又分两个情况：
<ul>
<li>人为指定的明确值</li>
<li>被限定的区域，比如无法超过屏幕大小</li>
</ul>
</li>
</ul>
<p>此时仔细思考一下，对于一个 <code>View-tree</code> 而言,<code>测量</code>每一个节点大小的<code>意义</code>是什么？</p>
<blockquote>
<p><code>准确的完成布局</code> 并 <code>完成自身的绘制</code></p>
</blockquote>
<p>但是有很重要的一点： <code>屏幕的大小</code>，屏幕的大小是 <code>固定的</code> 、 <code>明确的</code>，这意味着，界面能够单次展示的最大 区域已经固定。</p>
<p>同理，对于一个有 Parent 的 View，原则上来说，它的展示区域也被限定在 Parent的区域中。</p>
<p>但是仔细一想，这并 <code>不合理</code> 啊，有一种革命式的交互： <code>滑动</code> ，可以用有限的窗口，展示无限的内容。</p>
<p>所以，我们先记住 <a id="issue_1">一个情况</a>：</p>
<blockquote>
<p>不同类型的ViewGroup，对应着不同的布局特性，他们对待 子View 的态度也是不同的，可以表现为</p>
<ul>
<li>子View 可以 要求 比自身大 的展示大小，最终满不满足以及如何满足是之后的事情。</li>
<li>子View 可以 要求 比自身大 的展示大小，但是要了也不给。</li>
</ul>
</blockquote>
<p>这时我们可以总结一个结论，展示和绘制一个内容时，有两组大小需要被考虑：</p>
<ul>
<li>内容本身的大小</li>
<li>用于展示的区域大小</li>
</ul>
<p>同样的，当一个 View 或者 ViewGroup，称之为A 被置于 ViewGroup B 中时。</p>
<p>A的大小就是内容本身的大小，B的大小就是用于展示的区域大小，递归思考之后，整个View-Tree都是这样。</p>
<p>显然，测量工作从树的 <code>根节点开始</code>，按照经验，可以使用 <code>深度优先</code> 完成整个测量工作。</p>
<p>我们希望得到的，是每个 View 所对应的 <code>展示区域大小</code>。按照刚才举的例子分析实际情况，我们可以用三种方式来指定View的展示大小：</p>
<ul>
<li>一个明确值</li>
<li>相对值：刚好能够放下它的内容 -- <code>wrap_content</code></li>
<li>相对值：撑满 Parent 的空间 -- <code>match_parent</code></li>
</ul>
<p>并在测量时，得到准确的结果。</p>
<p>我们再思考这几个取值场景：</p>
<p>对于Child而言，</p>
<ul>
<li>设置了 展示大小为 <code>明确值</code>，毋庸置疑，测量时一定可以得到这个明确值</li>
<li>设置了 展示大小为 <code>match_parent</code>, 因为测量是从 Parent 到 Child， 所以，<code>对于Child</code> 而言,只要Parent的测量工作已经完成， 即 <code>Parent</code> 已经测算出自己的 <code>精确大小</code>，
那么Child使用 <code>match_parent</code> 是可以得到明确值的。但如果Parent没有完成测算，我们先不思考这个问题</li>
<li>设置了 <code>wrap_content</code>，显然，要先测算出 <code>其内容</code> 的大小，才能得到 <code>显示区域</code> 的 <code>明确值</code></li>
</ul>
<blockquote>
<p>注 上面这一段内容，非常重要，值得仔细思考。另：上述的内容中，我们先忽略掉 <code>可能存在</code> 的 <code>内边距</code>。</p>
</blockquote>
<p>刚才我们还有一些没有考虑的内容：</p>
<blockquote>
<p>Parent 没有完成测算，Child 设置了 <code>match_parent</code></p>
</blockquote>
<p>那么，至少我们可以确定 Parent <code>不可能</code> 指定了 <code>显示大小</code> 的 <code>明确值</code>，至于其他的情况，需要用数学归纳法 <code>讨论嵌套</code>，我们换个角度思考。</p>
<p><code>根节点</code> 的ViewGroup，我们可以得到 <code>显示大小</code> 的 <code>明确值</code>，按照刚才的讨论，其子View，使用 <code>match_parent</code> 或者 <code>明确值</code> 时，结合Parent 信息，可以得到 <code>明确值</code>；</p>
<p>只有当其为 <code>wrap_content</code> 时，需要继续测量其内容，再根据内容的大小，确定自身显示大小。</p>
<p>可以确定，当树中的一个节点为<code>wrap_content</code> 时，将<code>该节点</code>作为根节点，取出子树，当该子树的 <code>所有分支</code> 都能够找到满足 <code>条件R</code> 的节点时， 该根节点能够确定自身需要的显示大小。</p>
<blockquote>
<p><a id="issue_1_rule">条件R</a>为：该View</p>
<ul>
<li>指定 显示大小为 <code>match_parent</code> 或者 <code>明确值</code></li>
<li>或者其 <code>布局要求</code> 能够让 parent 大小撑满至一个 <code>明确值</code></li>
</ul>
</blockquote>
<p><strong>上面这一段内容有点长，适当消化一下</strong></p>
<p>此时，我们可以做出一点约定：</p>
<blockquote>
<p>Parent 多承担一点责任，结合自身情况，和Child情况，先确定一下，Child是否可以得到明确的显示大小，</p>
<ul>
<li>如果不可以，就将自身信息传递给Child，让它向下继续处理</li>
<li>如果可以，那么 Parent 可以得出Child的显示大小, <strong>注意</strong> <code>不同类型的Parent</code>，应该有<code>不同的计算方式</code>。 这在<a href="Android/View/post_6.html#issue_1">前面</a>提到过</li>
</ul>
</blockquote>
<h3 id="确定测量规则"><a class="header" href="#确定测量规则">确定测量规则</a></h3>
<p>经过上面的思考，我们可以拟定测量规则了。</p>
<ol>
<li>测量必然从一个<code>明确自身展示大小</code> 的 ViewGroup 开始</li>
<li>对于一个<code>子View</code> -- <code>A</code>，当其 <code>Parent</code> -- <code>P</code> 判断出 <code>A</code>
<ul>
<li>可以得到 <code>明确的</code> 显示大小时，将 该信息： <code>可准确得到结果</code> + <code>结果值</code> 传递给 子View A； <em>注意，结果值是 Parent 按照自身规则计算的，和子View要求的可能不一致</em></li>
<li>否则，将 P 的 <code>自身大小</code> 和 <code>你还需要继续测量以得到结果</code> 的信息传递给 子View A。</li>
</ul>
</li>
<li>对于一个Parent，如果它是 <code>wrap_content</code>，则需要在子View 的显示大小都确定时，再计算自身大小。</li>
<li>只要View-Tree中还 存在 <code>未确定</code> 自身 显示大小 的节点。就需要从根节点开始，继续遍历处理测量。</li>
</ol>
<p>让表达更加准确一些，<code>可准确得到结果</code> 用 <code>EXACTLY</code> 代替。 <code>你还需要继续测量以得到结果</code> 用 <code>AT_MOST</code> 代替。</p>
<p>不言自明，<code>AT_MOST</code> 意味着会给定一个最大值。意味着：家族中的直系长辈 已经帮它 限定了人身自由。</p>
<blockquote>
<p>方便准确表达，将他们称为 <code>测量模式</code>，简称 <code>mode</code> ：</p>
<ul>
<li><code>EXACTLY</code>：Parent 已经为 Child 决定了显示大小，按照规则，Child 应当使用 Parent 给定的值</li>
<li><code>AT_MOST</code>：Parent 已经为 Child 决定了最大显示大小，按照规则，Child 自行决定使用 <code>最大不超过该值</code> 的显示大小</li>
</ul>
</blockquote>
<blockquote>
<p>方便表达, 将 <code>显示大小</code> 简称为 <code>size</code></p>
<p>显示和屏幕像素数量有关，显然，该数量是自然数范畴。size 在绝大多数情况下，可以用 Int值 准确表达，极少数情况下，大到越界，但极不合理。</p>
</blockquote>
<p>若使用对象封装 <code>mode</code> 和 <code>size</code>，会出现大量的对象创建，这一点都不优雅，可以将 Int 分为 <code>高位区域</code> 和 <code>低位区域</code> 分别表达 <code>mode</code> 和 <code>size</code>
<strong>这也是Android中采用的设计</strong></p>
<p>考虑到 <code>测量模式</code> 中，还可能存在 Parent 不约束 Child 的情况。</p>
<p>我们使用一个 <code>32位Int</code> 的 <code>高2位</code> 标识 <code>mode</code>，<code>低30位</code> 标识 <code>size</code></p>
<h3 id="进一步优化以减少遍历"><a class="header" href="#进一步优化以减少遍历">进一步优化以减少遍历</a></h3>
<p>规则的第4点中，是通过 <code>迭代</code> 的方式，完成整个树中所有节点的测量，按照实际分析，我们可以用 <code>递归</code>
来简化。</p>
<blockquote>
<p>我们约定, 对于一个 设置了 <code>wrap_content</code> 的尾端节点，如果它没有实质的内容物，我们也认为它 <code>已经测量出了</code> 需要的展示大小</p>
</blockquote>
<p>那么在一次递归中，我们就可以完成整个树的测量。</p>
<p>在 <code>递</code> 的过程中，仅有设置为 <code>wrap_content</code> 的 Parent角色 无法完成准确测量，而 <code>尾端节点</code> 必然完成了自身的测量。</p>
<p>开始 <code>归</code> 的过程，我们可以确定，每 <code>归</code> 到一个 Parent，</p>
<ul>
<li>已经完成测量的继续 <code>归</code>，</li>
<li>没有完成测量的，它的 Children 都完成了测量，则按照 <code>wrap_content</code> 的定义，它必然可以完成测量，然后继续 <code>归</code></li>
</ul>
<p>最终整棵树完成测量。</p>
<h3 id="完善规则再添加一种mode"><a class="header" href="#完善规则再添加一种mode">完善规则，再添加一种mode</a></h3>
<p>前面我们提到了 <code>滑动</code> 这一交互形式，可以利用 <code>有限的</code> 展示空间，显示 <code>无限的</code> 内容。</p>
<p>即，我们会遇到一些场景，Child 并不会收到 Parent 的制约。更加准确的说，是 <code>内容</code> 不受到 <code>呈现主体</code> 在显示空间上的制约。</p>
<p>而这个场景，超越了 <code>EXACTLY</code> 和 <code>AT_MOST</code> 两种测量模式的功能，我们还需要一种配套的测量模式：</p>
<p><code>UNSPECIFIED</code>，即 Parent 不约束 Child，Child按照自身情况，自行测算。</p>
<blockquote>
<p>注：对于 <code>UNSPECIFIED</code> ，<code>不要</code> 强行结合场景，尤其是 <code>不要</code> 利用 <code>warp_content</code>或者 <code>match_parent</code>的概念去理解。他们虽然有一些关联，
但并不是一个范畴的内容，也不可以相互推导。</p>
<p>因此，我单独将其拎了出来。</p>
</blockquote>
<h3 id="编码以验证"><a class="header" href="#编码以验证">编码以验证</a></h3>
<blockquote>
<p>参考Android中FrameLayout的布局规则，它对于Child要求的大小为：
子View 可以 要求 比自身大 的展示大小，但是超过自身显示范围的不予显示。
所以，不 按照自身情况 调整 子View的 size</p>
</blockquote>
<p>先给View添加一些必要的内容：</p>
<pre><code class="language-kotlin">open class View {

    companion object {
        const val layout_width = "layout_width"
        const val layout_height = "layout_height"
        var debug = true
    }

    var tag: Any? = null

    var parent: View? = null

    val layoutParams: MutableMap&lt;String, Int&gt; = mutableMapOf()

    var measuredWidth: Int = WRAP_CONTENT

    var measuredHeight: Int = WRAP_CONTENT

    val heightMeasuredSize: Int
        get() = android.view.View.MeasureSpec.getSize(measuredHeight)

    val widthMeasuredSize: Int
        get() = android.view.View.MeasureSpec.getSize(measuredWidth)

    val heightMeasureMode: Int
        get() = android.view.View.MeasureSpec.getMode(measuredHeight)

    val widthMeasureMode: Int
        get() = android.view.View.MeasureSpec.getMode(measuredWidth)


    private var measured: Boolean = false

    fun isMeasured() = measured

    //绘制能力
    protected open fun onDraw(canvas: Canvas) {

    }

    //布局能力
    protected open fun onLayout(changed: Boolean, l: Int, t: Int, r: Int, b: Int) {

    }

    fun measure(widthMeasureSpec: Int, heightMeasureSpec: Int) {
        if (!measured) {
            onMeasure(widthMeasureSpec, heightMeasureSpec)
        }
    }

    //测量能力
    protected open fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {
        setMeasuredDimensionRaw(widthMeasureSpec, heightMeasureSpec)
        debugMeasureInfo()
    }

    protected fun debugMeasureInfo() {
        if (debug) {
            Log.d(
                "view-debug",
                "$tag has measured: $measured, w mode:${getMode(widthMeasureMode)}, w size: $widthMeasuredSize " +
                        "h mode:${getMode(heightMeasureMode)}, h size: $heightMeasuredSize "
            )
        }
    }

    protected fun setMeasuredDimension(measuredWidth: Int, measuredHeight: Int) {
        setMeasuredDimensionRaw(measuredWidth, measuredHeight)
    }

    private fun setMeasuredDimensionRaw(measuredWidth: Int, measuredHeight: Int) {
        this.measuredWidth = measuredWidth
        this.measuredHeight = measuredHeight
        measured = true
        if (debug) {
            Log.d(
                "view-debug",
                "$tag mark has measured: $measured"
            )
        }
    }
}
</code></pre>
<p>添加一个FrameLayout：</p>
<pre><code class="language-kotlin">class FrameLayout : ViewGroup() {
    override fun onLayout(changed: Boolean, l: Int, t: Int, r: Int, b: Int) {
    }

    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {
        //handle horizon
        val widthMode = View.MeasureSpec.getMode(widthMeasureSpec)
        var widthSize = View.MeasureSpec.getSize(widthMeasureSpec)

        var wMeasured = false
        var hMeasured = false
        when (widthMode) {
            View.MeasureSpec.EXACTLY -&gt; {
                // widthSize 即为Parent 为此决定的准确值，直接采用
                wMeasured = true
            }
            View.MeasureSpec.AT_MOST -&gt; {
                // 需要再次测量，但可以保存该信息了
                measuredWidth = widthMeasureSpec
            }
            else -&gt; {
                throw IllegalStateException("暂不支持测量模式：$widthMode")
            }
        }

        //同理处理 vertical方向

        val heightMode = View.MeasureSpec.getMode(heightMeasureSpec)
        var heightSize = View.MeasureSpec.getSize(heightMeasureSpec)

        when (heightMode) {
            View.MeasureSpec.EXACTLY -&gt; {
                hMeasured = true
            }
            View.MeasureSpec.AT_MOST -&gt; {
                measuredHeight = heightMeasureSpec
            }
            else -&gt; {
                throw IllegalStateException("暂不支持测量模式：$widthMode")
            }
        }

        if (hMeasured &amp;&amp; wMeasured) {
            setMeasuredDimension(widthMeasureSpec, heightMeasureSpec)
        }

        children.forEach {
            val childWidthMeasureSpec = makeMeasureSpec(widthMode, widthSize, it.layoutWidth)
            val childHeightMeasureSpec = makeMeasureSpec(heightMode, heightSize, it.layoutHeight)
            it.measure(childWidthMeasureSpec, childHeightMeasureSpec)
        }


        if (!hMeasured || !wMeasured) {
            var w = 0
            var h = 0
            children.forEach {
                if (!wMeasured)
                    w = maxOf(w, it.widthMeasuredSize)

                if (!hMeasured)
                    h = maxOf(h, it.heightMeasuredSize)
            }

            if (wMeasured)
                w = widthSize

            if (hMeasured)
                h = heightSize

            setMeasuredDimension(
                View.MeasureSpec.makeMeasureSpec(w, widthMode),
                View.MeasureSpec.makeMeasureSpec(h, heightMode),
            )
        }
        if (!allChildHasMeasured())
            throw IllegalStateException("child 未全部完成测量")

        debugMeasureInfo()
    }

    private fun makeMeasureSpec(mode: Int, size: Int, childSize: Int): Int {
        // 参考Android中FrameLayout的布局规则，它对于Child要求的大小为：
        // 子View 可以 要求 比自身大 的展示大小，但是超过自身显示范围的不予显示。
        // 所以，不 按照自身情况 调整 子View的 size
        val childMode = when (childSize) {
            WRAP_CONTENT -&gt; View.MeasureSpec.AT_MOST
            else -&gt; View.MeasureSpec.EXACTLY

        }

        val childSize2 = when (childSize) {
            WRAP_CONTENT -&gt; size
            MATCH_PARENT -&gt; size
            else -&gt; childSize
        }
        return View.MeasureSpec.makeMeasureSpec(childSize2, childMode)
    }

    private fun allChildHasMeasured(): Boolean {
        val i = children.iterator()
        while (i.hasNext()) {
            if (!i.next().isMeasured())
                return false
        }

        return true
    }

}
</code></pre>
<p>以上代码 结合前面的规则 理解下即可</p>
<p>目前还没有到LayoutParam的阶段，我们将 必要的布局信息 声明在 map 中存储。</p>
<p>我们适当添加添加一些助手类，以建立View-tree</p>
<pre><code class="language-kotlin">enum class Mode(val v: Int) {

    /**
     * Measure specification mode: The parent has not imposed any constraint
     * on the child. It can be whatever size it wants.
     */
    UNSPECIFIED(0 shl 30),

    /**
     * Measure specification mode: The parent has determined an exact size
     * for the child. The child is going to be given those bounds regardless
     * of how big it wants to be.
     */
    EXACTLY(1 shl 30),

    /**
     * Measure specification mode: The child can be as large as it wants up
     * to the specified size.
     */
    AT_MOST(2 shl 30)
}

class A {
    companion object {
        fun getMode(v: Int): Mode {
            Mode.values().forEach {
                if (it.v == v)
                    return it
            }
            throw IllegalStateException()
        }
    }
}
</code></pre>
<p>以上代码不言自明</p>
<pre><code class="language-kotlin">typealias Decor&lt;T&gt; = (v: T) -&gt; Unit

val MATCH_PARENT: Int = android.view.ViewGroup.LayoutParams.MATCH_PARENT
val WRAP_CONTENT = android.view.ViewGroup.LayoutParams.WRAP_CONTENT

var View.layoutWidth: Int
    get() {
        return layoutParams[View.layout_width] ?: WRAP_CONTENT
    }
    set(value) {
        layoutParams[View.layout_width] = value
    }

var View.layoutHeight: Int
    get() {
        return layoutParams[View.layout_height] ?: WRAP_CONTENT
    }
    set(value) {
        layoutParams[View.layout_height] = value
    }


fun root(): ViewGroup = FrameLayout().apply {
    this.layoutWidth = 1080
    this.layoutHeight = 1920
}

inline fun ViewGroup?.frameLayout(decor: Decor&lt;FrameLayout&gt;): ViewGroup {
    val child = FrameLayout()
    child.let(decor)
    return this?.apply { addView(child) } ?: child
}

inline fun ViewGroup.view(decor: Decor&lt;View&gt;): ViewGroup {
    val child = View()
    child.let(decor)
    return this.apply { addView(child) }
}
</code></pre>
<p>用以实现树结构描述的助手，不言自明</p>
<p>偷个懒，不设计单元测试了，构建一个结构：</p>
<pre><code class="language-kotlin">class ViewTest {

    @Test
    fun testMeasure() {

        val tree = root().frameLayout { v1 -&gt;

            v1.tag = "v1"
            v1.layoutWidth = MATCH_PARENT
            v1.layoutHeight = WRAP_CONTENT

            v1.frameLayout { frameLayout -&gt;
                frameLayout.tag = "v2"
                frameLayout.layoutWidth = MATCH_PARENT
                frameLayout.layoutHeight = WRAP_CONTENT

                frameLayout.view {
                    it.tag = "v3"
                    it.layoutWidth = 200
                    it.layoutHeight = 300
                }

                frameLayout.frameLayout {
                    it.tag = "v4"
                    it.layoutWidth = WRAP_CONTENT
                    it.layoutHeight = WRAP_CONTENT
                }
            }
        }

        tree.tag = "root"


        tree.measure(
            View.MeasureSpec.makeMeasureSpec(1080, View.MeasureSpec.EXACTLY),
            View.MeasureSpec.makeMeasureSpec(1920, View.MeasureSpec.EXACTLY)
        )
        assert(tree is FrameLayout)
        assertEquals(true, (tree as FrameLayout).allChildHasMeasured())
    }
}
</code></pre>
<p>直接看一下日志输出的信息：</p>
<pre><code class="language-shell">I/TestRunner: started: testMeasure(osp.leobert.blog.code.ViewTest)
D/view-debug: root mark has measured: true
D/view-debug: v3 mark has measured: true
D/view-debug: v3 has measured: true, w mode:EXACTLY, w size: 200 h mode:EXACTLY, h size: 300 
D/view-debug: v4 mark has measured: true
D/view-debug: v4 has measured: true, w mode:AT_MOST, w size: 0 h mode:AT_MOST, h size: 0 
D/view-debug: v2 mark has measured: true
D/view-debug: v2 has measured: true, w mode:EXACTLY, w size: 1080 h mode:AT_MOST, h size: 300 
D/view-debug: v1 mark has measured: true
D/view-debug: v1 has measured: true, w mode:EXACTLY, w size: 1080 h mode:AT_MOST, h size: 300 
D/view-debug: root has measured: true, w mode:EXACTLY, w size: 1080 h mode:EXACTLY, h size: 1920 
I/TestRunner: finished: testMeasure(osp.leobert.blog.code.ViewTest)
</code></pre>
<p>考虑到 一组 Parent 和 Child 有9种组合，我们全部验证一下。限于篇幅就不放代码和结果了</p>
<hr />
<blockquote>
<p>小结：上面通过很长一段篇幅，让我们在 <code>抛开Android的知识</code> 的前提下：</p>
<blockquote>
<ol>
<li>思考了如何设计一套系统，用以描述任意的界面</li>
</ol>
</blockquote>
<p>根据经验确定了使用 <code>视图树</code> 的方式，进行界面的描述，并意识到，应用 <code>不同的类</code> 来封装不同的功能，相互配合，完成界面描述工作。</p>
<blockquote>
<ol start="2">
<li>思考了描述尺寸的 <code>两种方式</code> 、<code>三种取值类型</code>，并延伸出 <code>测量</code> <code>视图树</code> 每个节点的 <code>显示大小</code> 问题。</li>
</ol>
</blockquote>
<p>从现实角度出发，得出一种测量方式，并进行了优化，得出结论：</p>
<ul>
<li>
<p>测量过程从 Parent 到 Child。Parent 结合自身情况和 Child的情况，为 Child 决定测量的<code>模式</code> 即 <code>mode</code>， 以及 <code>EXACTLY</code> 模式下的精准值 和 <code>AT_MOST</code> 模式下的 <code>最大值</code> 参考值</p>
<ul>
<li>从 Parent 到 Child 表现为：测量的入口为 <code>measure()</code>，其中封装了调用自身<code>onMeasure()</code> 的逻辑, 具体ViewGroup 类覆写 <code>onMeasure()</code> 并调用 Child的 <code>measure()</code> 方法,传递测量过程</li>
<li>显示大小的 <code>测量</code> 和 <code>布局规则</code> 有关</li>
</ul>
</li>
<li>
<p>通过一次递归即可测量出视图树每个节点的显示大小</p>
</li>
</ul>
<p>至此，我们对这套测量机制已经有了足够的认知，但是请注意，它还没有被完善。</p>
</blockquote>
<h2 id="确定布局位置"><a class="header" href="#确定布局位置">确定布局位置</a></h2>
<p>在前面，我们思考了一套可行的测量方案，其中我们提到：<a href="Android/View/post_6.html#issue_1">一个情况</a></p>
<p>并且，提出了<a href="Android/View/post_6.html#issue_1_rule">条件R</a>, 我们在其中提到了一个概念： <code>布局规则</code></p>
<p>结合我们的经验，不同的GUI中，都会有布局规则体系。为了解决可能出现的布局需求，均抽象了不同的布局类，以实现不同的规则。</p>
<p>前面我们也提到了，不同的规则下，ViewGroup 对 子View 的测量是不同的。</p>
<p>这很合理，<code>测量的目的</code> 是为了 <code>正确布局</code>，不同的布局规则，具有特定的测量规则。</p>
<h3 id="使用-layoutparams-描述布局规则和信息"><a class="header" href="#使用-layoutparams-描述布局规则和信息">使用 LayoutParams 描述布局规则和信息</a></h3>
<p>在前面，我们参考Android 建立了 FrameLayout 类，实现了 <code>帧布局</code> 的规则， 当然，这一种规则还不足以处理各种界面布局需求，还有更多的ViewGroup子类 等着我们实现。</p>
<blockquote>
<p>换个说法：当 一个View 被 添加到 一个ViewGroup 中时，需要按照该ViewGroup的布局规则，阐述自身的布局信息.
必要信息不可缺省</p>
</blockquote>
<p>显然，</p>
<ul>
<li>按照面向对象思想，布局规则簇 应该被封装为类，称之为 <code>LayoutParams</code>。</li>
<li>按照单一职责原则，不同的布局规则，对应不同的ViewGroup子类，也对应不同的 <code>LayoutParams</code>类，显然这是一一对应的</li>
<li>按照依赖倒置原则，View 的 layoutParam 依赖于 抽象，而不是某个规则的具体类；</li>
<li>按照里氏代换原则，LayoutParams的继承关系，和ViewGroup的继承关系应当是对应的；</li>
</ul>
<p>按照经验，我们会写出如下代码，一个 <code>必须指定宽高规则</code> 的 <code>ViewGroup.LayoutParams 基类</code>。</p>
<p>而视图 <code>可以</code> 存在 <code>内、外边距</code>，这可以被认为是 <code>基本规则</code>。</p>
<p>继续为FrameLayout 加上 <code>重力</code> 规则。</p>
<p>我们很快写出如下代码：</p>
<pre><code class="language-kotlin">abstract class ViewGroup : View() {
    open class LayoutParams(var width: Int, var height: Int) {

    }

    open class MarginLayoutParams(width: Int, height: Int) : LayoutParams(width, height) {
        var leftMargin = 0

        var topMargin = 0

        var rightMargin = 0

        var bottomMargin = 0
    }
}

class FrameLayout : ViewGroup() {
    class LayoutParams(width: Int, height: Int) : ViewGroup.MarginLayoutParams(width, height) {
        val UNSPECIFIED_GRAVITY = -1

        var gravity = UNSPECIFIED_GRAVITY
    }

    override fun onLayout(changed: Boolean, l: Int, t: Int, r: Int, b: Int) {
    }

    override fun checkLayoutParams(layoutParams: ViewGroup.LayoutParams): Boolean {
        return layoutParams is LayoutParams
    }

    override fun generateDefaultLayoutParams(): ViewGroup.LayoutParams {
        return LayoutParams(MATCH_PARENT, MATCH_PARENT)
    }
}
</code></pre>
<p>并对原先的Demo工程进行重构， <em>限于篇幅，略去相关代码</em></p>
<blockquote>
<p>注：按照里氏代换原则，我们定义的 LayoutParams 体系在使用中时，可能会遇到 <code>输入不符合期望</code> 的问题。此时我们需要了解一下：
<code>契约式设计</code>：</p>
<blockquote>
<p>使用契约式设计，类中的方法需要声明前置条件和后置条件。前置条件为真，则方法才能被执行。而在方法调用完成之前，方法本身将确保后置条件也成立。</p>
</blockquote>
<p>于是，在ViewGroup 体系中，设计了：</p>
<ul>
<li>checkLayoutParams(layoutParams: ViewGroup.LayoutParams): Boolean</li>
<li>generateDefaultLayoutParams(): ViewGroup.LayoutParams</li>
</ul>
<p>我们可以采用两种契约：</p>
<ul>
<li>输入的LayoutParams 必须满足约束，否则抛出异常</li>
<li>输入的LayoutParams 需要满足约束，否则使用默认规则</li>
</ul>
</blockquote>
<h3 id="获得布局规则信息按照viewgroup-的布局规则进行布局"><a class="header" href="#获得布局规则信息按照viewgroup-的布局规则进行布局">获得布局规则信息、按照ViewGroup 的布局规则进行布局</a></h3>
<blockquote>
<p>至此，我们已经理解了：</p>
<ul>
<li>使用视图树描述一个任意视图</li>
<li>用不同的 ViewGroup 子类描述不同的布局，他们具有特定的布局规则；用不同的 Widget 展现不同的内容</li>
<li>一种 测量<code>视图树各个节点</code> 的 <code>显示大小</code> 的测量方式</li>
<li>不同的规则，决定了显示大小测算的细节有所不同</li>
<li>使用LayoutParams 描述布局规则信息</li>
</ul>
</blockquote>
<p>在此基础上，我们需要接受设定：</p>
<blockquote>
<p>存在一个机制，可以正确地解析 <code>视图树各个节点</code> 中申明的 <code>布局规则信息</code>，这些信息，会存储在正确的
LayoutParams 对象中，被对应的节点所持有，以待使用。</p>
<p>这个机制，我们先忽略。</p>
</blockquote>
<p>按照刚才获得的经验，布局和测量的过程类似，</p>
<p>我们定义 <code>layout()</code> 和 <code>onLayout()</code> 方法</p>
<pre><code class="language-kotlin">open class View {
    open fun layout(l: Int, t: Int, r: Int, b: Int) {
        //todo
    }

    //布局能力
    protected open fun onLayout(changed: Boolean, l: Int, t: Int, r: Int, b: Int) {

    }
}
</code></pre>
<p>对于参数，约定为：</p>
<ul>
<li>l Left position, relative to parent</li>
<li>t Top position, relative to parent</li>
<li>r Right position, relative to parent</li>
<li>b Bottom position, relative to parent</li>
</ul>
<p>在完成了 <code>大小测试</code> 和 <code>布局规则解析</code> 的前提下，这些相对值的计算并不复杂。</p>
<p>我们约定，实际的布局逻辑，在onLayout中完成，而layout方法，用于实现 <code>前置条件</code>，onLayout调用 和 <code>状态维护</code></p>
<p>对于 ViewGroup 而言，需要遍历Children，为每个 Child，使用其显示大小信息&amp;布局规则信息，确定其布局位置，即 l,t,r,b 四个参数值。
调用 Child 的 layout() 方法。</p>
<p>对于 Widget 而言，则是需要决定Content的展示区域，因为 Content 不再是 View，不再需要继续向下调用 layout 方法。</p>
<p>至此，所有的准备工作均已完成，接下来，就是绘制工作。</p>
<h2 id="最后一步绘制在正确位置"><a class="header" href="#最后一步绘制在正确位置">最后一步，绘制在正确位置</a></h2>
<p>在此之前，我们已经得到了视图树每个节点的正确位置，此时，只需要将内容绘制在对应位置，即可通过屏幕呈现在用户眼前。</p>
<p>按照之前的经验，我们定义：</p>
<ul>
<li>draw(canvas:Canvas) 方法，封装整个绘制流程</li>
<li>onDraw(canvas:Canvas) 方法，实现内容的绘制</li>
<li>如果在ViewGroup中覆写onDraw(canvas:Canvas) 同时 实现 <code>自身内容的绘制</code>，<em>例如背景</em> ，和 <code>分发 Child 的绘制</code>，这并不符合开闭原则
故而添加 dispatchDraw(canvas: Canvas) 用以实现 <code>分发 Child 的绘制</code></li>
</ul>
<p>其实到此为止，我们已经对 <code>正确展示内容</code> 有了比较完善的认知，绘制的内容，理解不复杂，但内容很庞杂，本篇就不再展开了。</p>
<h2 id="展望"><a class="header" href="#展望">展望</a></h2>
<p>本身还计划再写如下内容的：</p>
<ul>
<li>和Framework中的实现思路进行对比</li>
<li>编码验证布局规则 等</li>
</ul>
<p>限于篇幅，这些内容被择掉了。不过我会将一些 <code>编码验证</code>的内容以 <a href="https://github.com/leobert-lan/ViewWorkShop">WorkShop</a> 的形式展现。</p>
<p>下一篇，会对 <code>View</code>体系的 <code>交互</code> 功能进行探索。<code>点关注不迷路</code>。</p>
<blockquote>
<p>注：关于WorkShop的内容，原定计划是配合博客中的知识体系，独立建立一套 <code>简单的</code>，<code>可视交互</code> 系统。用以验证和帮助理解 Android-View 体系的知识。</p>
<p>希望今年的业务时间还能比较充裕。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="三思系列为什么要自定义view"><a class="header" href="#三思系列为什么要自定义view">三思系列：为什么要自定义View</a></h1>
<h2 id="前言-2"><a class="header" href="#前言-2">前言</a></h2>
<blockquote>
<p>或许你掌握了 <code>measure的细节</code> ，<code>layout机制</code> ，<code>事件传递机制</code> ，<code>canvas各种API</code> ，但是，你们想过这个问题吗？</p>
<p>这一篇，不仅仅是对一个面试必会题的解析，更是透过这个问题的思考，寻找 <code>最佳实践</code> ，<code>拓展思维角度</code> ， <code>少走弯路</code></p>
</blockquote>
<blockquote>
<p>三思系列是我最新的学习、总结形式，着重于:<strong>问题分析</strong>、<strong>技术积累</strong>、<strong>视野拓展</strong>，<a href="https://leobert-lan.github.io/info/about_sansi_series.html">关于三思系列</a></p>
</blockquote>
<blockquote>
<p><a href="https://github.com/leobert-lan/Blog/blob/main/info/%E5%85%B3%E4%BA%8EView%E7%B3%BB%E5%88%97.md">关于View系列</a>
View系列旨在通过 <code>对现实问题</code> 的思考，建立完善的 <code>View体系认知</code>，极力建议读者了解一下 <code>我为什么撰写、分享这个系列</code></p>
</blockquote>
<p>先给出思考这个问题的 <code>脑图</code> ，文章内容会按照思考过程展开</p>
<p><img src="Android/View/./%E4%B8%89%E6%80%9D%E7%B3%BB%E5%88%97%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%87%AA%E5%AE%9A%E4%B9%89View/guide.png" alt="guide" /></p>
<p>思考这类问题，<code>为什么要这样干</code> 是最基本，作为三思系列的成员，本篇还将对以下内容点进行展开论述：</p>
<ul>
<li>怎么干 -- <code>How to do</code></li>
<li>是否一定要这样干 -- <code>适用场景</code></li>
<li>如果不这样干，还可以怎么干 -- <code>Best Practice</code></li>
<li>各种干法的 <code>注意事项</code></li>
</ul>
<h2 id="从view体系出现的目的说起"><a class="header" href="#从view体系出现的目的说起">从View体系出现的目的说起</a></h2>
<p>作为 <code>GUI</code> <em>Graphical User Interface，图形用户接口</em> 类型的程序 <code>framework</code>，<code>View体系</code>是其 <code>必不可少</code> 的一部分。参与了两件重要的事情：</p>
<ul>
<li><code>描述</code>、<code>呈现</code> 界面</li>
<li>参与 <code>人机交互</code></li>
</ul>
<blockquote>
<p>笼统的讲，当 <code>现有</code> 的 <code>View体系</code>内的 <code>控件簇</code> 无法满足合理需求时，可以在遵从 framework <code>内在</code> 的 <code>规则</code> 、<code>机制</code> ，进行扩展，以满足需求。</p>
</blockquote>
<p>从这个角度看，扩展可以有两个方面：</p>
<ul>
<li>扩展 <code>显示</code> 功能</li>
<li>扩展 <code>交互</code> 功能</li>
</ul>
<h2 id="扩展显示功能"><a class="header" href="#扩展显示功能">扩展显示功能</a></h2>
<p>我们知道，这又分为3种：</p>
<ul>
<li>通过一组控件，共同完成特定的功能，</li>
<li>扩展布局规则</li>
<li>扩展内容显示</li>
</ul>
<h3 id="最简单的一组控件完成特定功能"><a class="header" href="#最简单的一组控件完成特定功能">最简单的，一组控件完成特定功能</a></h3>
<blockquote>
<p>举个例子： <code>输入框</code> 右侧加一个 模态的<code>图片</code>，输入框有内容时显示，无内容时隐藏。图片显示一个❌，点击时清除输入框的内容</p>
</blockquote>
<p>经过简单的封装，我们可以很快的完成这样的功能。</p>
<p>Android的UI描述并不那么方便，为了方便，往往会定义一个ViewGroup的子类，来描述这个 <code>控件组</code>。
但是 <code>组合优于继承</code>，这样的做法让人有点 <code>膈应</code>，不能算作是最佳实践。-- 这一点对应了脑图中的 <code>扩展类簇1</code></p>
<p>相比于这样干，我更建议使用 <code>Facade模式</code> 进行逻辑封装，采用<code>xml方式</code> 声明这个控件组，或者封装 <code>命令式构建函数</code>构建这个控件组。</p>
<h3 id="继承viewgroup扩展布局规则"><a class="header" href="#继承viewgroup扩展布局规则">继承ViewGroup，扩展布局规则</a></h3>
<p>Android中ViewGroup来封装布局规则，并提供了一套Layout。</p>
<p>当这些布局规则 <code>无法满足</code> 我们的需求时，我们可以通过 <code>自定义ViewGroup</code> 的方式来实现 <code>自定义布局规则</code>。</p>
<p>当然，Android发展到如今，已经 <code>很难</code> 找到一个<code>相对抽象</code>的布局规则，却没有被官方支持。</p>
<p>若确有必要，扩展布局规则时需要处理：</p>
<ul>
<li>封装规则描述，并实现 <code>契约式编程设计</code>
<ul>
<li>定义LayoutParams，封装规则的细节点描述</li>
<li>覆写 checkLayoutParams 以实现规则校验，<code>契约式编程设计</code></li>
<li>覆写 generateLayoutParams(AttributeSet attrs) 以实现 <code>从xml属性生成LayoutParams</code></li>
<li>覆写 generateLayoutParams(ViewGroup.LayoutParams p) 以实现 <code>当规则不满足契约</code>时，生成一个满足契约的LayoutParams，注意：可以从原LayoutParams中
采纳一些内容。</li>
<li>覆写 generateDefaultLayoutParams 以实现生成符合契约的 <code>默认布局规则</code>，如果返回null，在<code>addView(View)</code> 时，会引起运行时异常</li>
</ul>
</li>
<li>在 <code>onMeasure</code> 方法中处理测量的逻辑，以实现 <code>确定自身大小</code> 和 <code>触发子View测量</code>
<ul>
<li>接受 <code>Parent</code> 给到自身的 <code>尺寸测量信息</code>，如果测量模式是 <code>EXACTLY</code>，即可直接确定自身对应维度的尺寸；如果是 <code>AT_MOST</code> 或者 <code>UNSPECIFIED</code>，
则需要先测量子View，再确定自身。</li>
<li>按照布局特性，自身的 <code>尺寸测量信息</code>，和子View的布局规则属性值，确定 <code>子View</code> 的 <code>尺寸测量信息</code>，调用 <code>子View</code> 的 <code>measure</code> 方法触发测量</li>
</ul>
</li>
<li>在 <code>onLayout</code> 方法中，处理布局，使用子View的 <code>尺寸测量值</code> 和 <code>LayoutParams规则值</code>，计算子View 的布局位置，并调用 <code>子View</code> 的 <code>layout</code>
方法触发子View布局</li>
<li>如果有特定需求，可以在 <code>onDraw</code> 中进行绘制，例如绘制分隔线</li>
</ul>
<h3 id="继承view扩展内容显示能力"><a class="header" href="#继承view扩展内容显示能力">继承View，扩展内容显示能力</a></h3>
<p>一般来说，少数情况下，<code>继承View</code> 或者 <code>特定的Widget</code> 是为了扩展 <code>布局尺寸上的特性</code>，这基本是从 <code>measure机制</code> 上入手。除此之外，一些场景下，
可以通过 <code>继承View</code> 实现 <code>自定义内容绘制</code>。</p>
<p>例如，显示图表的View。</p>
<p>这种场景下，一般需要处理：</p>
<ul>
<li>尺寸测量流程中，<code>Content</code>的尺寸测量，并在 <code>onMeasure</code> 中实现：测量模式为 <code>AT_MOST</code> 或 <code>UNSPECIFIED</code> 时，利用Content的大小确定显示尺寸。</li>
<li>绘制流程中，<code>onDraw</code> 中实现内容的绘制</li>
</ul>
<blockquote>
<p>注意: 如果并不牵涉到 <code>交互</code>，这并不是唯一方案，<code>自定义Drawable</code>的方案，也是很棒的方案。</p>
</blockquote>
<p>借用 <code>PhotoView</code> 举个例子，如果交互局限为：<code>双指缩放</code>，<code>拖拽</code>，<code>单击</code>，<code>双击</code>。</p>
<p>那么通过 <code>OnTouchListener</code> + <code>GestureDetector</code> + <code>自定义Drawable</code>， 对于绝大多数场景，都可以胜任。</p>
<h2 id="扩展交互功能"><a class="header" href="#扩展交互功能">扩展交互功能</a></h2>
<p>在这个方向上，主要还是和 <code>事件处理</code> 体系有关。在 <code>View体系</code> 中，存在<code>三个方法</code> 和这个过程直接相关：</p>
<ul>
<li>dispatchTouchEvent</li>
<li>onInterceptTouchEvent</li>
<li>onTouchEvent</li>
</ul>
<p>对于 <code>onInterceptTouchEvent</code>，<code>非ViewGroup</code> 的 <code>View子类</code> 是不参与的，因为这部分View，已经是事件处理的末端。</p>
<p>话分两头。</p>
<h3 id="对于viewgroup"><a class="header" href="#对于viewgroup">对于ViewGroup</a></h3>
<p>扩展的目的一般有二：</p>
<ul>
<li>在恰当的场景下，拦截事件并自身处理，处理逻辑在 <code>onTouch</code> 中实现</li>
<li>处理可能存在的 <code>事件处理冲突</code>，当然，按照Android的规则，利用 <code>requestDisallowInterceptTouchEvent</code> 可以要求 <code>直系的</code> 所有 <code>Parent</code> 不拦截事件。
但难免有意外，可以通过 <code>onInterceptTouchEvent</code> 来决定是否自身拦截处理事件，或者更加复杂的场景。</li>
</ul>
<h3 id="对于view而言"><a class="header" href="#对于view而言">对于View而言</a></h3>
<p>扩展的目的在于 <code>定义事件的含义</code></p>
<blockquote>
<p>举个例子，继承View实现一个字母表导航控件，<code>点击</code>、<code>滑动</code> 被定义为切换到 <code>对应的字母</code> 进行导航</p>
</blockquote>
<p>我们需要在 <code>onTouchEvent</code> 中进行处理。</p>
<hr />
<p>在前面，我们提到了 <code>PhotoView</code> 的例子，如果：<code>事件</code> 的含义 <code>足够抽象</code>，例如，对View 进行了：</p>
<ul>
<li>单击</li>
<li>双击</li>
<li>拖拽</li>
<li>缩放</li>
</ul>
<p>而不是 <code>点击了View的特定区域</code>，<code>滑动至View的特定位置</code> 等。 我们可以利用 <code>Android屏幕事件处理机制</code> 中的 <code>OnTouchListener</code> 来获取事件信息，
并进行处理。在这种做法中，利用 <code>GestureDetector</code> 可以大大降低这一过程的难度。</p>
<h2 id="总结-1"><a class="header" href="#总结-1">总结</a></h2>
<p>这一篇中，我们比较 <code>随性</code> 的思考了 <code>为什么要自定义View</code> 的问题，并展开了：</p>
<ul>
<li>为什么需要这么干</li>
<li>具体做法</li>
<li>是否有其他方案，并简单交代了 <code>哪种方案更适合</code></li>
</ul>
<p>这篇文章比较短，但是这部分内容的背后，还是值得继续深究、挖掘的</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="三思系列声明式ui和命令式ui你的理解可能是错的"><a class="header" href="#三思系列声明式ui和命令式ui你的理解可能是错的">三思系列："声明式UI"和"命令式UI"，你的理解可能是错的</a></h1>
<blockquote>
<p>三思系列是我最新的学习、总结形式，着重于:<strong>问题分析</strong>、<strong>技术积累</strong>、<strong>视野拓展</strong>，<a href="https://leobert-lan.github.io/info/about_sansi_series.html">关于三思系列</a></p>
</blockquote>
<h2 id="前言-3"><a class="header" href="#前言-3">前言</a></h2>
<p>最近，<code>Jetpack Compose</code> 发布了 <code>Beta</code> 版本，可以说是千呼万唤始出来。</p>
<p>在一个 <code>现象级事物</code> 出现时，关于它的讨论会很热。我注意到，最近有一大批关于Compose的文章涌现了出来，并且有很多的讨论，这很棒。</p>
<p>但是，值得一提的是，我发现很多人对于 <code>声明式UI</code> 、 <code>命令式UI</code> 的认知，可能出现了一点偏差。</p>
<p>当然，我也 <code>不是</code> 像 <strong>马丁老爷子</strong> 或者 <strong>Jack Wharton</strong> 那样的 <code>专家</code>，对于这个问题，只能是同大家 <code>一道探索</code>。</p>
<h2 id="声明式-和-命令式-含义探索"><a class="header" href="#声明式-和-命令式-含义探索">声明式 和 命令式 含义探索</a></h2>
<p>按照经验，中文往往比英文具有 <code>更强的表达力</code> ，这也意味着：中文的 <code>凝练度更高</code>，也更容易产生理解误差，我们结合英文一起看</p>
<ul>
<li>声明式 declarative</li>
</ul>
<blockquote>
<p><strong>a declarative <a href="https://www.ldoceonline.com/dictionary/sentence">sentence</a> has the form of a <a href="https://www.ldoceonline.com/dictionary/statement">statement</a></strong>.</p>
<p>statement: 4条释义，看第一条</p>
<ul>
<li><strong>something you say or write, especially publicly or officially, to let people know your intentions or opinions, or to record facts</strong></li>
<li>其他三条略</li>
</ul>
</blockquote>
<ul>
<li>命令式 <a href="https://www.ldoceonline.com/dictionary/imperative">imperative</a></li>
</ul>
<blockquote>
<p><em>technical</em>, an imperative verb is one that expresses an order, such as ‘stand up’</p>
</blockquote>
<p>如果从 <code>语境</code> 上来看，<code>声明</code> 是面向一个环境、一个群体表达某些规则，而 <code>命令</code> 所面向的，是一个明确的对象群，在指使他们做一些事情。</p>
<p>举个可能不太恰当的例子：</p>
<blockquote>
<ul>
<li>
<p>我军优待俘虏，缴枪投降不杀，这是对敌军的声明</p>
</li>
<li>
<p>营长命令各战斗单位，打扫战场，一连收缴武器弹药，二连负责收押俘虏。这是命令式</p>
</li>
</ul>
</blockquote>
<p>我发现，讨论 <code>声明式</code> 和 <code>命令式</code> 时，需要先界定好 <code>讨论范围</code>。这一点非常重要，一旦超越了范围，讨论就会出现错误。</p>
<p>放在计算机领域中讨论这两者时，需要先界定好 <code>层</code>。</p>
<p>我们知道，程序设计中，以及在计算机设计中，都是 <code>分层</code> 的。<code>下层</code> 的内容交给 <code>上层</code> 使用时，需要使用到 <code>接口</code>，</p>
<blockquote>
<p><em>这个接口，不仅仅是我们编程中的API的概念</em></p>
</blockquote>
<p>甚至，接口的表现形式是一种 <code>语言</code>。</p>
<p>接口被定义时，其表意即已固定，当其表意：</p>
<ul>
<li>越倾向于 <code>现实表达</code> 时，呈现为 <code>声明式</code></li>
<li>越倾向于 <code>执行过程</code> 时，呈现为 <code>命令式</code></li>
</ul>
<h2 id="ui"><a class="header" href="#ui">UI</a></h2>
<blockquote>
<p>User Interface 的简称，直译为用户界面</p>
</blockquote>
<p>UI系统需要处理两个范畴的事情：</p>
<ul>
<li>内容呈现、反馈</li>
<li>用户交互</li>
</ul>
<p>另外，还需要程序 <code>构建</code> 出UI。</p>
<p>我们需要从这 <code>三个角度</code> 来看。</p>
<h2 id="构建ui时的-命令式-和-声明式"><a class="header" href="#构建ui时的-命令式-和-声明式">构建UI时的 命令式 和 声明式</a></h2>
<p>我们在Android原有的知识领域中看这个问题。</p>
<p>我们知道，这部分内容设计时是遵守 OOP 的，存在一整套 <code>View 类簇</code>。而界面由具体的功能类组建出 <code>视图树</code>。</p>
<p>我们需要讨论的，就是 <code>视图树</code> 的 <code>构建</code>。我们知道：</p>
<blockquote>
<p><code>ViewGroup</code> 存在一系列 <code>addView</code> 方法，通过它们，最终实现 <code>树结构</code></p>
</blockquote>
<p>这套 <code>接口</code> ，倾向于 <code>执行过程</code>，直接使用这套接口去构建，就是 <code>命令式</code> 的构建。</p>
<p>而在此基础上，封装了 <code>LayoutInflater</code>，将 <code>xml语法</code> 表达的 <code>结构树</code> 转换为 <code>视图树</code>， 此时我们使用的 <code>接口</code> ，其表现形式是 <code>xml语言</code>。</p>
<p>按照特定的规则，我们 <code>直接描述</code> 了 <code>期望的结果</code>，这更倾向于 <code>现实表达</code>，这样的构建方式，就是 <code>声明式</code></p>
<blockquote>
<p><code>View</code> 存在一系列的 <code>布局属性</code>，一些直接持有，一些被LayoutParams封装而间接持有。</p>
</blockquote>
<p>在 <code>视图树</code> 的节点构建过程中，还需要处理 <code>布局属性</code>。</p>
<p>按照刚才的讨论，我们很容易得出：</p>
<ul>
<li>直接使用 <code>View的API</code> 或者 <code>LayoutParams的API</code>，或者直接对属性赋值，可以断言是 <code>命令式</code> 范畴。</li>
<li>而在布局文件中，声明对应的属性值，可以断言是 <code>声明式</code> 范畴</li>
</ul>
<blockquote>
<p>小结：本段内容，我们讨论了构建UI的两种做法。并讨论了其所属的范畴。</p>
</blockquote>
<h2 id="android体系最基础的内容中内容呈现交互"><a class="header" href="#android体系最基础的内容中内容呈现交互">Android体系最基础的内容中，内容呈现&amp;交互</a></h2>
<p>在最基础的内容中，讨论 <code>内容呈现</code> 和 <code>交互</code> 部分使用的API，是 <code>命令式</code> 的，还是 <code>声明式</code> 的，这 <code>非常的无聊</code>。</p>
<h3 id="内容呈现时的-命令式-与-声明式"><a class="header" href="#内容呈现时的-命令式-与-声明式">内容呈现时的 命令式 与 声明式</a></h3>
<p>在 <code>View</code> 提供的 <code>接口</code> 中，例如：</p>
<ul>
<li>TextView#setText(Charsequence cs)</li>
<li>ImageView#setImageDrawable(Drawable d)</li>
</ul>
<p>等，更加偏向于 <code>执行过程</code> 。</p>
<p>但是注意，<em>此时 <code>执行过程</code> 和 <code>现实表达</code> 的界限已经有点模糊了</em> 。我们不必 <code>牵强附会</code>。</p>
<p>读一下这两句话：</p>
<ul>
<li>我们通过调用相应API设置了需要显示的内容</li>
<li>我们在布局文件中指明了视图显示时需要呈现的内容</li>
</ul>
<h3 id="交互时的-命令式-与-声明式"><a class="header" href="#交互时的-命令式-与-声明式">交互时的 命令式 与 声明式</a></h3>
<p>我们知道，Android View 体系中，封装了一系列 <code>Listener</code>，通过 <code>接口回调</code>，让程序可以 <code>监听</code> 到用户发出的 <code>交互指令</code>。</p>
<p>除此之外，在 <code>最基础内容</code> 中，仅有简陋的 <code>click</code> 属性可以声明点击事件的 <code>消费函数</code></p>
<hr />
<p>此时，我们 <code>放大着眼点</code> 。我们处理视觉呈现和交互时，面向的两个重要对象</p>
<pre><code>          信息展示
   | ================ |
   |     内容呈现     \|/
|=====|           |=====|   
| 实体 |           | UI  |
|=====|           |=====|
  /|\      交互       |
   | ================ | 
          状态变更
            
</code></pre>
<p>这两者之间存在两条线：</p>
<ul>
<li><code>代表信息</code> 的 <code>实体</code> -&gt; <code>UI</code>, 这是 <code>内容呈现</code> ，实质是：在UI上做 <code>信息展示</code></li>
<li><code>UI</code> -&gt; <code>代表信息</code> 的 <code>实体</code> ，这是 <code>交互</code> ，实质是：在信息实体上做 <code>状态变更</code>，即变更信息</li>
</ul>
<p>我们在实现这两条线时：</p>
<ul>
<li>如果<code>直接利用</code> 了倾向于 <code>现实表达</code> 的高阶框架封装，那这个框架就是 <code>声明式</code>的框架；</li>
<li>如果仅使用 <code>低阶</code>的 <code>view层api</code> ，自行实现了逻辑，那就是 <code>命令式</code> 的编程，毕竟也没用啥框架；</li>
</ul>
<blockquote>
<p>评价一套 <code>UI工具体系</code> 是否是 <code>声明式</code> 的，要从这三个方面看，如果在三个方面均进行了封装，提供的 <code>接口</code> 都偏向于 <code>现实表达</code>，那是成熟完善的 <code>声明式UI</code> 框架。</p>
</blockquote>
<p>看几个例子：</p>
<ul>
<li>直接使用 <code>View体系的接口</code> 构建UI、处理显示和交互，这是 <code>命令式编程</code></li>
<li>使用 <code>LayoutInflater</code> 工具和 <code>xml表达的布局文件</code>。绝大多数情况下，还需要通过<code>映射关系</code>，找到View对象；并进一步 <code>根据业务逻辑</code> ，操作 <code>View对象</code> 实现内容呈现和交互逻辑。
这是 <code>声明式构建</code>，<code>命令式编程</code> 处理显示和交互。这套工具并不是完善的 <code>声明式UI开发工具</code></li>
<li>使用 <code>LayoutInflater</code> 工具 + <code>DataBinding工具包</code> 和 <code>xml表达的布局文件</code>。<code>DataBingding</code> + <code>LayoutInflater</code>是一套完善的 <code>声明式UI框架</code></li>
<li><code>Compose</code>，完善的 <code>声明式UI框架</code></li>
</ul>
<h2 id="思考为什么当初xml布局方式受到官方推荐"><a class="header" href="#思考为什么当初xml布局方式受到官方推荐">思考：为什么当初XML布局方式受到官方推荐</a></h2>
<p>很大一方面是Java语言特性的原因，最开始，都是使用Java语言编写业务逻辑，而基于Java，很难直接定义DSL</p>
<blockquote>
<p>注：<code>Java语言很难直接定义DSL</code> 这一点我并没有做严格的调研考证，如果有谬误，请指出。</p>
<p>而基于Groovy等语言开发符合 <code>DSL</code> 的 <code>声明式UI框架</code>，必然要引入Groovy，这在当时也和 <code>主流</code> 格格不入，虽然Google很喜欢创新。</p>
</blockquote>
<p>所以，官方提出了 <code>布局</code> 和 <code>业务</code> 分开，这样也有很多好处：</p>
<ul>
<li>业务逻辑的 <code>模块内聚性</code> 和 <code>复用度</code> 可提升</li>
<li>开发者可以提升专注度</li>
<li><code>xml树</code> 和 <code>view树</code> 之间 <code>关系明了</code>，借助成熟内容，快速开发出 <code>预览工具</code></li>
</ul>
<h2 id="思考为什么xml布局方式走在被淘汰的路上"><a class="header" href="#思考为什么xml布局方式走在被淘汰的路上">思考：为什么XML布局方式走在被淘汰的路上</a></h2>
<p>因为使用XML布局的方式存在 <code>先天弱点</code> ，它和 <code>业务逻辑</code> 天生生活在两个世界。</p>
<p>这意味着，必然存在一个 <code>加载器</code> 或者 <code>转换器</code>，在 <code>运行时</code> 或者 <code>编译时</code>，将 <code>xml语法</code> 所描述的 <code>声明式布局</code> 转换到 <code>业务逻辑</code> 所在的世界。</p>
<p>所以，并不是 <code>DataBinding</code> 这一 <code>声明式UI框架</code> 不够优秀，而是 xml 和 业务逻辑代码 之间天生的屏障不够 <code>人道主义</code>。</p>
<p>而推行 <code>kotlin first</code> 也有一段时间了，基于kotlin，开发 <code>DSL</code> 工具包非常的方便。</p>
<h2 id="延伸响应式ui框架"><a class="header" href="#延伸响应式ui框架">延伸：响应式UI框架</a></h2>
<p>这也是 Modern Development 中非常热门的一个词，<code>响应式</code> 是对特点的一种描述，方法论是：<code>事件驱动，Event-Driven</code>，<code>发布订阅者模式</code>。</p>
<p>这个概念，和前面提到的 <code>声明式UI框架</code> 和 <code>命令式UI编程</code> 没有必然的联系，它所表达的是： <code>代表信息的实体</code> 和 <code>UI</code> 之间的互操作是符合 <code>响应式</code> 特征的。</p>
<p>但可以想象，要实现响应式，其接口变现特征，天然倾向于 <code>现实表达</code>；如果是倾向于 <code>操作过程</code>，可以断言其抽象程度非常低。</p>
<h2 id="扣题勘误"><a class="header" href="#扣题勘误">扣题：勘误</a></h2>
<p>再看到这些说法，我们可以判断出它们存在 <code>谬误</code>：</p>
<ul>
<li>基于xml无法实现声明式UI</li>
<li>xml被淘汰是因为无法实现声明式UI</li>
<li>基于xml布局方式都是命令式</li>
<li>声明式一定会取代命令式，你看xml都要被淘汰了</li>
<li>用代码写的就是命令式UI</li>
</ul>
<p>等。</p>
<p>再多聊两句，一套曾经热门的技术，一定有其热门的原因和背景，它走向消亡，往往是其 <code>面向的问题</code> 和 <code>场景</code> ，在事物发展过程中，越来越少见。</p>
<p><code>声明式</code> 和 <code>命令式</code> 各有优劣。按照规律，高阶封装更 <code>人道主义</code> ，解决高复杂度问题时，也容易实现 <code>降维打击</code>。
但这也意味着机器付出的代价更高一点。</p>
<p>总之，脱离了环境背景讨论谁胜谁负，往往是耍流氓。</p>
<h2 id="总结-2"><a class="header" href="#总结-2">总结</a></h2>
<p>这一篇，我们用比较 <code>随性</code> 的文字，对 <code>声明式UI</code> 进行了一次脑暴，进而讨论其概念的实质。我相信，经过这次脑暴，对这一套概念体系的理解会更加 <code>深刻</code> 、
<code>准确</code> 。相应的，学习新内容时也会 <code>更加轻松</code>、<code>事半功倍</code></p>
<blockquote>
<p>进一步延伸, 在学习Compose，思考Compose的优劣时，势必会上升到 <code>OOP</code> 和 <code>FP</code> 两大编程范式的讨论。这一篇不再展开。</p>
<p>点赞关注收藏，从此不迷路。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h3 id="drawable"><a class="header" href="#drawable">Drawable</a></h3>
<ul>
<li><a href="Android/Drawable/./post_2.html">三思系列：重新认识Drawable</a></li>
<li><a href="Android/Drawable/./post_4.html">好玩系列：拥有它，XML文件少一半--更方便的处理View背景</a></li>
<li><a href="Android/Drawable/./post_47.html">迟来的续集--Drawable+Animator，将优雅进行到底</a></li>
<li><a href="Android/Drawable/./post_49.html">好玩系列：让ImageSpan动起来</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="三思系列重新认识drawable"><a class="header" href="#三思系列重新认识drawable">三思系列：重新认识Drawable</a></h1>
<h2 id="前言-4"><a class="header" href="#前言-4">前言</a></h2>
<p><a href="https://leobert-lan.github.io/info/about_sansi_series.html">关于三思系列</a></p>
<p>前一段时间看到宏洋公众号推送了一篇关于splash页面动效的文章，具体为：将一个英文单词拆分为多个字母，散落在屏幕中，然后按照一定的路径回归，最终展示一段流光效果，完成splash页面。</p>
<p>当时文章中提到的做法是自定义View的实现。当时脑海中灵光一闪，感觉还是用Drawable来干这个事情更加合适。</p>
<p>记忆中，我曾经整理过一篇Drawable基础内容的文章，可惜丢失了，在开始干这件事情之前，我们把这一块内容再完整的梳理一遍。</p>
<p>这篇文章会比较长，先给出导图</p>
<p><img src="Android/Drawable/post_2/Drawable_guide.png" alt="guide.png" /></p>
<h2 id="drawable的设计意图"><a class="header" href="#drawable的设计意图">Drawable的设计意图</a></h2>
<blockquote>
<p>A Drawable is a general abstraction for "something that can be drawn."  Most often you will deal with Drawable as the type of resource retrieved for drawing things to the screen; the Drawable class provides a generic API for dealing with an underlying visual resource that may take a variety of forms. Unlike a View, a Drawable does not have any facility to receive events or otherwise interact with the user.</p>
</blockquote>
<p>这是SDK文档中的内容，大致含义呢：drawable是对于"<strong>可以被绘制的内容</strong>"的<strong>抽象</strong>。 多数情况下，我们将获取的资源作为Drawable绘制在屏幕上，
Drawable类提供了一个通用API，用于处理可能采用多种类型的底层可视资源。 不像View，Drawable<strong>没有</strong>任何接收事件或以其他方式与用户交互的功能。</p>
<p>为了简化绘制，Drawable中为使用者提供了一定的机制操作绘制：</p>
<blockquote>
<ul>
<li>
<p>The {@link #setBounds} method <var>must</var> be called to tell the
&gt; Drawable where it is drawn and how large it should be. All Drawables
&gt; should respect the requested size, often simply by scaling their
&gt; imagery. A client can find the preferred size for some Drawables with
&gt; the {@link #getIntrinsicHeight} and {@link #getIntrinsicWidth} methods.</p>
</li>
<li>
<p>The {@link #getPadding} method can return from some Drawables
&gt; information about how to frame content that is placed inside of them.
&gt; For example, a Drawable that is intended to be the frame for a button
&gt; widget would need to return padding that correctly places the label
&gt; inside of itself.</p>
</li>
<li>
<p>The {@link #setState} method allows the client to tell the Drawable
&gt; in which state it is to be drawn, such as "focused", "selected", etc.
&gt; Some drawables may modify their imagery based on the selected state.</p>
</li>
<li>
<p>The {@link #setLevel} method allows the client to supply a single
&gt; continuous controller that can modify the Drawable is displayed, such as
&gt; a battery level or progress level. Some drawables may modify their
&gt; imagery based on the current level.</p>
</li>
<li>
<p>A Drawable can perform animations by calling back to its client
&gt; through the {@link Callback} interface. All clients should support this
&gt; interface (via {@link #setCallback}) so that animations will work. A
&gt; simple way to do this is through the system facilities such as
&gt; {@link android.view.View#setBackground(Drawable)} and
&gt; {@link android.widget.ImageView}.</p>
</li>
</ul>
</blockquote>
<p>继续简要翻译一下重要内容</p>
<ul>
<li>setBounds 方法必须被调用，它告知了Drawable应该被绘制的位置和大小</li>
<li>getPadding 方法可以获知一些Drawable绘制时的内边距信息</li>
<li>setState 方法允许使用者告知Drawable应当在哪些状态时绘制，例如获取了焦点，被选中等</li>
<li>setLevel 方法允许调用者提供一个连续的控制器，可以修改显示的可绘制内容， 例如电池电量或进度。一些Drawable可能会根据当前的level改变其图像</li>
<li>Drawable可以展现动画，通过设置Callback接口回调给他的使用者，所有的使用者，需要通过 setCallback方法提供回调函数支持以让动画工作。一个简便方式是通过一些系统设施例如：View#setBackground 和
ImageView</li>
</ul>
<blockquote>
<p>注：Drawable展现动画部分，这里翻译的比较晦涩，具体细节见：Drawable Api概览</p>
</blockquote>
<p>小结：Android SDK中抽象了Drawable体系，不同于View体系，它仅负责描述可绘制的内容，不可进行用户交互，其子类将描述各类可绘制内容的特性。</p>
<h2 id="sdk中的drawable子类概览"><a class="header" href="#sdk中的drawable子类概览">SDK中的Drawable子类概览</a></h2>
<blockquote>
<p>注：经过多次思考，我最终把这一段的草稿删除了，这部分体系实在是太大，浅写无异于copy官方文档，深挖就会影响文章关注的重点。
如果对系统中提供的Drawable子类感兴趣的，建议深入源码看一下。</p>
</blockquote>
<h2 id="drawable-api概览"><a class="header" href="#drawable-api概览">Drawable Api概览</a></h2>
<p>在开头的设计意图探索中，我们已经阅读了几个关键API：<code>setBound</code>，<code>getPadding</code>，<code>setState</code>，<code>setLevel</code>，<code>setCallback</code>的信息</p>
<p>还有<code>getBound</code>，<code>copyBound</code>等获取边界信息的API，RippleDrawable和一些自定义的Drawable还覆写了<code>getDirtyBounds</code>，用以获取它可能涉及到的范围边界</p>
<p>横向的方向相关：<code>setLayoutDirection</code>，<code>getLayoutDirection</code>，<code>onLayoutDirectionChanged</code></p>
<p>透明度相关：<code>setAlpha</code>，<code>getAlpha</code></p>
<p>着色和颜色filter相关：<code>setColorFilter</code>，<code>getColorFilter</code>，<code>clearColorFilter</code>，
<code>setTint</code>，<code>setTintList</code>，<code>setTintMode</code>，<code>setTintBlendMode</code></p>
<p>尺寸测量：<code>getIntrinsicWidth</code>，<code>getIntrinsicHeight</code>，<code>getMinimumWidth</code>，<code>getMinimumHeight</code>
当作为背景使用时，getMinimumXXX用于告知View建议使用的最小宽高。getIntrinsicXXX是获取一个Drawable的内在的、固有的宽高，这个值和设备屏幕密度是有关系的。</p>
<p>自我独立：<code>mutate</code>，和缓存机制有关，调用得到一个新的Drawable，这样自己的状态就不会影响到其他使用处。</p>
<p>重绘相关：<code>setCallback(@Nullable Callback cb)</code>，<code>getCallback()</code>，<code>invalidateSelf()</code>，
<code>scheduleSelf(@NonNull Runnable what, long when)</code>，<code>unscheduleSelf(@NonNull Runnable what)</code></p>
<p>上面我们提到这一组API会详细说一下。以AnimationDrawable为例，这是一个动画Drawable，</p>
<pre><code class="language-java">class AnimationDrawable {
    private void setFrame(int frame, boolean unschedule, boolean animate) {
        if (frame &gt;= mAnimationState.getChildCount()) {
            return;
        }
        mAnimating = animate;
        mCurFrame = frame;
        selectDrawable(frame);
        if (unschedule || animate) {
            unscheduleSelf(this);
        }
        if (animate) {
            // Unscheduling may have clobbered these values; restore them
            mCurFrame = frame;
            mRunning = true;
            scheduleSelf(this, SystemClock.uptimeMillis() + mAnimationState.mDurations[frame]);
        }
    }
}
</code></pre>
<p>设置某一帧之后，如果是使用动画，则会调用scheduleSelf，时间戳是下一帧应该出现的时间戳。</p>
<pre><code class="language-java">class Drawable {
    public void scheduleSelf(@NonNull Runnable what, long when) {
        final Callback callback = getCallback();
        if (callback != null) {
            callback.scheduleDrawable(this, what, when);
        }
    }
}
</code></pre>
<p>如果存在Callback，则调用Callback#scheduleDrawable。</p>
<p>以View的代码为例</p>
<pre><code class="language-java">class View {
    public void scheduleDrawable(@NonNull Drawable who, @NonNull Runnable what, long when) {
        if (verifyDrawable(who) &amp;&amp; what != null) {
            final long delay = when - SystemClock.uptimeMillis();
            if (mAttachInfo != null) {
                mAttachInfo.mViewRootImpl.mChoreographer.postCallbackDelayed(
                        Choreographer.CALLBACK_ANIMATION, what, who,
                        Choreographer.subtractFrameDelay(delay));
            } else {
                // Postpone the runnable until we know
                // on which thread it needs to run.
                getRunQueue().postDelayed(what, delay);
            }
        }
    }
}
</code></pre>
<p>很简单，验证合法性之后定时执行Runnable，Runnable的内容：</p>
<pre><code class="language-java">class AnimationDrawable {
    public void run() {
        nextFrame(false);
    }

    private void nextFrame(boolean unschedule) {
        int nextFrame = mCurFrame + 1;
        final int numFrames = mAnimationState.getChildCount();
        final boolean isLastFrame = mAnimationState.mOneShot &amp;&amp; nextFrame &gt;= (numFrames - 1);

        // Loop if necessary. One-shot animations should never hit this case.
        if (!mAnimationState.mOneShot &amp;&amp; nextFrame &gt;= numFrames) {
            nextFrame = 0;
        }

        setFrame(nextFrame, unschedule, !isLastFrame);
    }
}
</code></pre>
<p>显示下一帧，逻辑非常清晰，不再进行解析。</p>
<blockquote>
<p>小结: 这一段我们对Drawable的API进行了简单的梳理，略去了大量关于创建的API以及和开发不太紧密的API，完成了一次概览。
更完善的认知需要再仔细研读源码内容，限于篇幅不再展开。</p>
</blockquote>
<h2 id="drawableinflater"><a class="header" href="#drawableinflater">DrawableInflater</a></h2>
<p>顾名思义，这是一个Drawable加载器，和LayoutInflater类似，从一种满足特定语法的语法式中解析出实例对象，显然，在Android中它用来处理xml语法的drawable资源文件。</p>
<p>看一下文档：</p>
<pre><code class="language-java">/**
 * Instantiates a drawable XML file into its corresponding
 * {@link android.graphics.drawable.Drawable} objects.
 * &lt;p&gt;
 * For performance reasons, inflation relies heavily on pre-processing of
 * XML files that is done at build time. Therefore, it is not currently possible
 * to use this inflater with an XmlPullParser over a plain XML file at runtime;
 * it only works with an XmlPullParser returned from a compiled resource (R.
 * &lt;em&gt;something&lt;/em&gt; file.)
 *
 * @hide Pending API finalization.
 */
</code></pre>
<p>需要注意，从性能角度上，这种创建严重依赖于构建时的预处理，因此，目前不可能利用它和 <strong>XmlPullParser</strong> 一起 <strong>在运行时解析一个xml文件</strong> 并创建对象实例 只适用于那些已经在资源编译阶段返回的XmlPullParser</p>
<p>我们知道，一个受检的xml document，会被解析为语法树，得到树中的标签节点和属性信息。</p>
<p>我们阅读DrawableInflater的代码，有两段关于创建Drawable具体实例的内容，这是根据tag创建实例的代码</p>
<pre><code class="language-java">class DrawableInflater {
    private Drawable inflateFromTag(@NonNull String name) {
        switch (name) {
            case "selector":
                return new StateListDrawable();
            case "animated-selector":
                return new AnimatedStateListDrawable();
            case "level-list":
                return new LevelListDrawable();
            case "layer-list":
                return new LayerDrawable();
            case "transition":
                return new TransitionDrawable();
            case "ripple":
                return new RippleDrawable();
            case "adaptive-icon":
                return new AdaptiveIconDrawable();
            case "color":
                return new ColorDrawable();
            case "shape":
                return new GradientDrawable();
            case "vector":
                return new VectorDrawable();
            case "animated-vector":
                return new AnimatedVectorDrawable();
            case "scale":
                return new ScaleDrawable();
            case "clip":
                return new ClipDrawable();
            case "rotate":
                return new RotateDrawable();
            case "animated-rotate":
                return new AnimatedRotateDrawable();
            case "animation-list":
                return new AnimationDrawable();
            case "inset":
                return new InsetDrawable();
            case "bitmap":
                return new BitmapDrawable();
            case "nine-patch":
                return new NinePatchDrawable();
            case "animated-image":
                return new AnimatedImageDrawable();
            default:
                return null;
        }
    }
}
</code></pre>
<p>如果您已经在第二小节自行对Drawable的子类进行了概览，应该对这些内容不陌生了。</p>
<p>以Android项目模板为例，工程会创建一个启动图标：</p>
<pre><code class="language-xml">
&lt;vector xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:aapt="http://schemas.android.com/aapt"
        android:width="108dp"
        android:height="108dp"
        android:viewportWidth="108"
        android:viewportHeight="108"&gt;
    &lt;path
        android:pathData="M31,63.928c0,0 6.4,-11 12.1,-13.1c7.2,-2.6 26,-1.4 26,-1.4l38.1,38.1L107,108.928l-32,-1L31,63.928z"&gt;
        &lt;aapt:attr name="android:fillColor"&gt;
            &lt;gradient
                android:endX="85.84757"
                android:endY="92.4963"
                android:startX="42.9492"
                android:startY="49.59793"
                android:type="linear"&gt;
                &lt;item
                    android:color="#44000000"
                    android:offset="0.0"/&gt;
                &lt;item
                    android:color="#00000000"
                    android:offset="1.0"/&gt;
            &lt;/gradient&gt;
        &lt;/aapt:attr&gt;
    &lt;/path&gt;
    &lt;path
        android:fillColor="#FFFFFF"
        android:fillType="nonZero"
        android:pathData="M65.3,45.828l3.8,-6.6c0.2,-0.4 0.1,-0.9 -0.3,-1.1c-0.4,-0.2 -0.9,-0.1 -1.1,0.3l-3.9,6.7c-6.3,-2.8 -13.4,-2.8 -19.7,0l-3.9,-6.7c-0.2,-0.4 -0.7,-0.5 -1.1,-0.3C38.8,38.328 38.7,38.828 38.9,39.228l3.8,6.6C36.2,49.428 31.7,56.028 31,63.928h46C76.3,56.028 71.8,49.428 65.3,45.828zM43.4,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2c-0.3,-0.7 -0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C45.3,56.528 44.5,57.328 43.4,57.328L43.4,57.328zM64.6,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2s-0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C66.5,56.528 65.6,57.328 64.6,57.328L64.6,57.328z"
        android:strokeWidth="1"
        android:strokeColor="#00000000"/&gt;
&lt;/vector&gt;
</code></pre>
<p>其实就是机器人头的图标，它会被加载为<code>VectorDrawable</code></p>
<p>我们反推一下，调用者为：</p>
<pre><code class="language-java">class DrawableInflater {
    @NonNull
    public Drawable inflateFromXml(@NonNull String name, @NonNull XmlPullParser parser,
                                   @NonNull AttributeSet attrs, @Nullable Theme theme)
            throws XmlPullParserException, IOException {
        return inflateFromXmlForDensity(name, parser, attrs, 0, theme);
    }


    @NonNull
    Drawable inflateFromXmlForDensity(@NonNull String name, @NonNull XmlPullParser parser,
                                      @NonNull AttributeSet attrs, int density, @Nullable Theme theme)
            throws XmlPullParserException, IOException {
        // Inner classes must be referenced as Outer$Inner, but XML tag names
        // can't contain $, so the &lt;drawable&gt; tag allows developers to specify
        // the class in an attribute. We'll still run it through inflateFromTag
        // to stay consistent with how LayoutInflater works.
        if (name.equals("drawable")) {
            name = attrs.getAttributeValue(null, "class");
            if (name == null) {
                throw new InflateException("&lt;drawable&gt; tag must specify class attribute");
            }
        }

        //注意这里 --1
        Drawable drawable = inflateFromTag(name);
        if (drawable == null) {
            //注意这里 --2
            drawable = inflateFromClass(name);
        }
        drawable.setSrcDensityOverride(density);
        //注意这里 --3
        drawable.inflate(mRes, parser, attrs, theme);
        return drawable;
    }
}
</code></pre>
<p>上面标记了3处注意点， 第一处即为内置的顶层drawable创建</p>
<p>第二处我们稍后再看</p>
<p>第三处将parser，属性和主题交给生成的Drawable继续解析。不同的Drawable子类按照自身特性实现自己的解析需求。</p>
<p>以<code>LevelListDrawable</code>为例，我们知道它内部还可以添加Drawable作为不同的level，这是通过递归调用解析创建实现的， 最终追溯源码至Drawable</p>
<pre><code class="language-java">public class LevelListDrawable {
    private void inflateChildElements(Resources r, XmlPullParser parser, AttributeSet attrs,
                                      Theme theme) throws XmlPullParserException, IOException {
        //略
        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT
                &amp;&amp; ((depth = parser.getDepth()) &gt;= innerDepth
                || type != XmlPullParser.END_TAG)) {
            //略

            Drawable dr;
            if (drawableRes != 0) {
                dr = r.getDrawable(drawableRes, theme);
            } else {
                //略
                //注意此处
                dr = Drawable.createFromXmlInner(r, parser, attrs, theme);
            }
            mLevelListState.addLevel(low, high, dr);
        }
        onLevelChange(getLevel());
    }
}


public class Drawable {

    public static Drawable createFromXmlInner(@NonNull Resources r, @NonNull XmlPullParser parser,
                                              @NonNull AttributeSet attrs, @Nullable Theme theme)
            throws XmlPullParserException, IOException {
        return createFromXmlInnerForDensity(r, parser, attrs, 0, theme);
    }

    @NonNull
    static Drawable createFromXmlInnerForDensity(@NonNull Resources r,
                                                 @NonNull XmlPullParser parser, @NonNull AttributeSet attrs, int density,
                                                 @Nullable Theme theme) throws XmlPullParserException, IOException {
        return r.getDrawableInflater().inflateFromXmlForDensity(parser.getName(), parser, attrs,
                density, theme);
    }
}
</code></pre>
<p>我们再看第二处，当特定的tag未被匹配时，会使用反射方式尝试创建Drawable：</p>
<pre><code class="language-java">class DrawableInflater {
    @NonNull
    private Drawable inflateFromClass(@NonNull String className) {
        try {
            Constructor&lt;? extends Drawable&gt; constructor;
            synchronized (CONSTRUCTOR_MAP) {
                constructor = CONSTRUCTOR_MAP.get(className);
                if (constructor == null) {
                    final Class&lt;? extends Drawable&gt; clazz =
                            mClassLoader.loadClass(className).asSubclass(Drawable.class);
                    constructor = clazz.getConstructor();
                    CONSTRUCTOR_MAP.put(className, constructor);
                }
            }
            return constructor.newInstance();
        }
        //略
        catch (XXX e) {
        }
    }
}
</code></pre>
<blockquote>
<p>Custom drawables</p>
<p>All versions of Android allow the Drawable class to be extended and used at run time in place
of framework-provided drawable classes. Starting in API 24, custom drawables classes may also be used in XML.
Note: Custom drawable classes are only accessible from within
your application package. Other applications will not be able to load them.</p>
</blockquote>
<p>文档中有这样一段话，自定义的Drawable一直是可行的，但仅Api&gt;=24时才能够用XML定义这样的资源。虽然没有仔细追溯版本源码，但应该和此处有关。</p>
<blockquote>
<p>小结：我们简单阅读了DrawableInflater的源码，了解了Android如何从xml资源得到Drawable对象。需要注意的是，我们没有阅读Resource#getDrawable
的相关源码，这一块内容也很有意思，建议读者有时间自行阅读下。</p>
</blockquote>
<h2 id="自定义一个drawable"><a class="header" href="#自定义一个drawable">自定义一个Drawable</a></h2>
<p>终于来到这个环节了，为了更好的进行这个环节，我们新建一个WorkShop项目，我会按照文章中每一个小目标提出的一个小目标建立提交。
<a href="https://github.com/leobert-lan/DrawableWorkShop">DrawableWorkShop</a></p>
<h3 id="version-1-一个能绘制的自定义drawable"><a class="header" href="#version-1-一个能绘制的自定义drawable">version 1 一个能绘制的自定义Drawable</a></h3>
<p>这里我们尽可能的简单，目标就是绘制一个字母，先定义类：</p>
<pre><code class="language-kotlin">class LetterDrawable : Drawable() {
    val tag = "LetterDrawable"

    var letter: Char = 'A'

    val paint = Paint().apply {
        textSize = 60f
        color = Color.CYAN
    }

    override fun draw(canvas: Canvas) {
        Log.d(tag, "on draw")
        canvas.drawText(letter.toString(), 60f, 60f, paint)
    }

    override fun setAlpha(alpha: Int) {
        //ignore
    }

    override fun setColorFilter(colorFilter: ColorFilter?) {
        //ignore
    }

    override fun getOpacity(): Int {
        return PixelFormat.TRANSLUCENT
    }
}
</code></pre>
<p>字号字色，绘制字母的位置和内容都直接写死，</p>
<p>定义资源：</p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;osp.leobert.android.drawableworkshop.drawable.LetterDrawable
    xmlns:android="http://schemas.android.com/apk/res/android"
&gt;

&lt;/osp.leobert.android.drawableworkshop.drawable.LetterDrawable&gt;
</code></pre>
<p>直接使用：得到结果：</p>
<p><img src="Android/Drawable/post_2/version_1.png" alt="version_1" /></p>
<h3 id="version-2-支持颜色和字号等可配"><a class="header" href="#version-2-支持颜色和字号等可配">version 2 支持颜色和字号等可配</a></h3>
<p>我们将单个字符改为String，添加color和textSize成员变量，并将改动设置到paint</p>
<p>添加属性定义：</p>
<pre><code class="language-xml">
&lt;resources xmlns:tools="http://schemas.android.com/tools"&gt;

    &lt;declare-styleable name="letter_drawable"&gt;
        &lt;attr name="android:text" format="string|reference"/&gt;
        &lt;attr name="color" format="color|reference"/&gt;
        &lt;attr name="android:textSize" format="dimension|reference"/&gt;

    &lt;/declare-styleable&gt;

&lt;/resources&gt;
</code></pre>
<p>这样我们就可以进行资源配置和解析</p>
<p>按照我们之前阅读的代码，我们需要覆写<code>inflate</code>以实现属性解析</p>
<pre><code class="language-kotlin">class LetterDrawable {
    override fun inflate(
        r: Resources,
        parser: XmlPullParser,
        attrs: AttributeSet,
        theme: Resources.Theme?
    ) {
        super.inflate(r, parser, attrs, theme)
        val a: TypedArray = obtainAttributes(r, theme, attrs, R.styleable.letter_drawable)
        letter = a.getString(R.styleable.letter_drawable_android_text) ?: "A"

        textSize = a.getDimension(R.styleable.letter_drawable_android_textSize, 60f)
        color = a.getColor(R.styleable.letter_drawable_color, Color.CYAN)

        a.recycle()

        paint.color = color
        paint.textSize = textSize
    }

    private class Size(val type: Int) : ReadWriteProperty&lt;LetterDrawable, Float?&gt; {
        private var prop: Float? = null
        override fun getValue(thisRef: LetterDrawable, property: KProperty&lt;*&gt;): Float? {
            return prop ?: thisRef.run {
                val rect = Rect()
                this.paint.getTextBounds(this.letter, 0, this.letter.length, rect)
                val s = when (type) {
                    0 -&gt; rect.width()
                    else -&gt; rect.height()
                }.toFloat()
                prop = s
                prop
            }
        }

        override fun setValue(thisRef: LetterDrawable, property: KProperty&lt;*&gt;, value: Float?) {
            prop = value
        }

    }

    private var width by Size(0)
    private var height by Size(1)

    override fun draw(canvas: Canvas) {
        Log.d(tag, "on draw,$letter , $height")
        canvas.drawText(letter, 0f, height ?: 60f, paint)
    }
}
</code></pre>
<p>并且我们利用属性代理来封装计算宽高的细节（<em>只是利用了小技巧，可以减少不必要的重复测量</em>）</p>
<p>修改我们资源：</p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;osp.leobert.android.drawableworkshop.drawable.LetterDrawable
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:textSize="40sp"
    app:color="#ff3c06"
    android:text="@string/letters"&gt;


&lt;/osp.leobert.android.drawableworkshop.drawable.LetterDrawable&gt;

</code></pre>
<p>运行后我们得到这样的结果：
<img src="Android/Drawable/post_2/version_2.png" alt="version_2" /></p>
<h3 id="version-3-正确处理宽高"><a class="header" href="#version-3-正确处理宽高">version 3: 正确处理宽高</a></h3>
<p>我们发现Drawable的位置是有问题的，对于TextView，并没有在文字之上（drawableTop）， 对于ImageView，并没有居中（默认 ScaleType.FIT_CENTER）。</p>
<pre><code class="language-kotlin">class LetterDrawable {
    var letter: String = "A"
        set(value) {
            field = value
            width = null
            height = null
            invalidateSelf()
        }

    var color: Int = Color.CYAN
        set(value) {
            field = value
            paint.color = value
            invalidateSelf()
        }

    var textSize: Float = 60f
        set(value) {
            field = value
            width = null
            height = null
            paint.textSize = value
            invalidateSelf()
        }

    override fun getIntrinsicHeight(): Int {
        return height?.toInt() ?: -1
    }

    override fun getIntrinsicWidth(): Int {
        return width?.toInt() ?: -1
    }
}
</code></pre>
<p>并且当颜色、文字、字号变更时触发重新计算和重绘</p>
<p>看一下结果：
<img src="Android/Drawable/post_2/version_3.png" alt="version_3" /></p>
<blockquote>
<p>注：更多和Canvas和Paint的内容忽略，Padding和文字边距等细节忽略</p>
</blockquote>
<blockquote>
<p>小结：这一小节到此基本可以结束了，我们用了三步实现了一个简单自定义Drawable，
并且在比较常见的场景下进行了效果演示。读者可以在此基础上在对于padding等属性进行尝试，
以及尝试绘制自己感兴趣的内容。</p>
</blockquote>
<h2 id="自定义一个动画drawable"><a class="header" href="#自定义一个动画drawable">自定义一个动画Drawable</a></h2>
<p>这一次，我们尝试让字从分散，开始聚拢，最终排列成一行。因为它的draw规则更加特殊，我们新建一个Drawable进行演示。</p>
<p>还是在原来的项目上，version 直接递增</p>
<h3 id="version-4-先让一个字母动起来"><a class="header" href="#version-4-先让一个字母动起来">version 4: 先让一个字母动起来</a></h3>
<blockquote>
<p>目标：让字母从一个随机的初始位置，匀速运动到终点位置。约定最终将文字绘制在中心</p>
</blockquote>
<p>我们建立一个新的类AnimLetterDrawable，迁移LetterDrawable中的主要逻辑，并实现<code>Runnable</code>接口，以实现<strong>schedule</strong> 时的主要逻辑； 实现<code>Animatable2</code>接口并完成动画相关逻辑</p>
<pre><code class="language-kotlin">class AnimLetterDrawable : Drawable(), Animatable2, Runnable {
    private var frameIndex = 0

    private val totalFrames = 30 * 3 //3 second, 30frames per second
    
    private val animationCallbacks: MutableSet&lt;Animatable2.AnimationCallback&gt; = linkedSetOf()

    private var mAnimating: Boolean = false

    private fun setFrame(frame: Int, unschedule: Boolean, animate: Boolean) {
        if (frame &gt;= totalFrames) {
            return
        }
        mAnimating = animate
        frameIndex = frame

        if (unschedule || animate) {
            unscheduleSelf(this)
        }
        if (animate) {
            // Unscheduling may have clobbered these values; restore them
            frameIndex = frame

            scheduleSelf(this, SystemClock.uptimeMillis() + durationPerFrame)
        }
        invalidateSelf()
    }

    private fun nextFrame(unschedule: Boolean) {
        var nextFrame: Int = frameIndex + 1
        val isLastFrame = nextFrame + 1 == totalFrames
        if (nextFrame + 1 &gt; totalFrames) {
            nextFrame = totalFrames - 1
        }

        setFrame(nextFrame, unschedule, !isLastFrame)
    }

    private val durationPerFrame = 3000 / totalFrames

    override fun start() {
        Log.d(tag, "start called")
        mAnimating = true

        if (!isRunning) {
            // Start from 0th frame.
            setFrame(
                frame = 0, unschedule = false, animate = false
            )
        } else {
            setFrame(
                frame = 0, unschedule = false, animate = true
            )
        }
    }

    override fun stop() {
        mAnimating = false

        if (isRunning) {
            frameIndex = 0
            //un-schedule it at first
            unscheduleSelf(this)

            setFrame(0, unschedule = true, animate = false)
        }
    }

    override fun isRunning(): Boolean {
        return mAnimating
    }

    override fun registerAnimationCallback(callback: Animatable2.AnimationCallback) {
        animationCallbacks.add(callback)
    }

    override fun unregisterAnimationCallback(callback: Animatable2.AnimationCallback): Boolean {
        return animationCallbacks.remove(callback)
    }

    override fun clearAnimationCallbacks() {
        animationCallbacks.clear()
    }

    override fun run() {
        Log.d(tag, "callback by schedule")
        if (isRunning) {
            nextFrame(false)
        } else {
            //safe call
            setFrame(0, unschedule = true, animate = false)
        }
    }
}
</code></pre>
<p><strong>这一段代码虽然有点长，但是逻辑很简单，阅读文章过程中，可以忽略这部分代码的细节</strong>。</p>
<p>显然，我们还需要实现：<strong>正确绘制每一帧</strong></p>
<p>在约定的目标中，每个字母从一个 <strong>随机的初始位置</strong>，<strong>匀速运动</strong> 到 <strong>终点位置</strong>。那么，对于任意一个字母，只需要确定 <strong>四个参数</strong>，即可确定其 <strong>位置</strong></p>
<ul>
<li>总帧数</li>
<li>当前帧数</li>
<li>字母起始位置</li>
<li>字母结束位置</li>
</ul>
<blockquote>
<p>延伸：上面的例子中，我们约定了轨迹是直线，延伸开来，其实我们只需要一个 <code>location = f(time)</code> 的函数和<code>time</code>值即可确定其位置。</p>
<p>一般情况下，我们需要关心轨迹方程，和加速度公式。有加速度公式，我们按照时间积分得到<code>速度-时间</code>函数，再按照时间积分，得到 <code>移动距离-时间</code>函数，
在有轨迹方程和起始点的情况下，就可以找到任意时间的位置，得到 <code>location = f(time)</code> 函数</p>
</blockquote>
<p>当然，因为我们的场景足够简单，<code>起始点</code>和<code>终点</code>确定的<code>线段</code>即为路径，运动为<code>匀速</code>，<code>当前时间</code> 通过 <code>当前帧</code>,<code>每帧时间</code>确定，达到总动画时长（最后一帧）时
达到终点</p>
<ul>
<li><code>x = startX + (endX - startX) * time / totalTime</code></li>
<li><code>y = startY + (endY - startY) * time / totalTime</code></li>
</ul>
<p>附上计算相关的源码： 运动过程中我是适当处理了文字的透明度</p>
<pre><code class="language-kotlin">class AnimLetterDrawable : Drawable(), Animatable2, Runnable {
    private val originalLetterLocations = SparseArray&lt;PointF&gt;()

    private val finalLetterLocations = SparseArray&lt;PointF&gt;()

    override fun draw(canvas: Canvas) {
        Log.d(tag, "on draw,$letters , $height,$frameIndex")

        val progress = if (totalFrames &gt; 1) {
            frameIndex.toFloat() / (totalFrames - 1).toFloat()
        } else {
            1f
        }

        paint.alpha = min(255, (255 * progress).toInt() + 100)

        for (i in letters.indices) {
            val endPoint: PointF = finalLetterLocations.get(i)
            val startPoint: PointF = originalLetterLocations.get(i)
            val x: Float = startPoint.x + (endPoint.x - startPoint.x) * progress
            val y: Float = startPoint.y + (endPoint.y - startPoint.y) * progress
            canvas.drawText(letters[i].toString(), x, y, paint)
        }

    }

    override fun onBoundsChange(bounds: Rect) {
        super.onBoundsChange(bounds)
        Log.d(tag, "onBoundsChange, $bounds")

        height = bounds.height().toFloat()
        width = bounds.width().toFloat()

        calcLetterStartEndLocations()

        invalidateSelf()
    }

    private fun calcLetterStartEndLocations() {
        originalLetterLocations.clear()
        finalLetterLocations.clear()

        val height = this.height ?: throw IllegalStateException("height cannot be null")
        val width = this.width ?: throw IllegalStateException("width cannot be null")

        val centerY: Float = height / 2f + paint.textSize / 2

        val totalLength = paint.measureText(letters)
        val startX = (width - totalLength) / 2

        var currentStartX = startX

        for (i in letters.indices) {
            val str: String = letters[i].toString()
            val currentLength: Float = paint.measureText(str)


            originalLetterLocations.put(
                i, PointF(
                    Math.random().toFloat() * width, Math.random()
                        .toFloat() * height
                )
            )

            finalLetterLocations.put(i, PointF(currentStartX, centerY))
            // TODO: 2021/2/1 consider padding for letters inner
            currentStartX += currentLength

        }
    }
}
</code></pre>
<p>最终我们看一下效果： 大约从第四秒开始点击了start，中间点击了stop，随后又点击了start</p>
<p><img src="Android/Drawable/post_2/version_4.gif" alt="version_4" /></p>
<blockquote>
<p>注：gif丢失了一定的连贯性，可以看一下录制的视频
<a href="https://github.com/leobert-lan/Blog/blob/main/Android/Drawable/post_2/version_4.webm">链接</a>
因为起始位置是随机的，所以每次的效果都会有差别</p>
</blockquote>
<h3 id="version-5-让所有的字母都动起来"><a class="header" href="#version-5-让所有的字母都动起来">version 5 让所有的字母都动起来</a></h3>
<p>其实细心的读者应该发现了，上面<code>Version 4</code>的代码已经可以让每个字母都动起来了。
先来试一下效果，把Drawable资源的text改成Leobert，看一下效果:</p>
<p><img src="Android/Drawable/post_2/version_5.gif" alt="version_5" /></p>
<p>录制视频：<a href="https://github.com/leobert-lan/Blog/blob/main/Android/Drawable/post_2/version_5.webm">链接</a></p>
<p>可能有些读者这时候已经在思考，继续添加各种配置支持项，改变初始点的随机位置算法，计算过程中更加细致的考虑字号、文字留白等等等等细节了。</p>
<p><strong>打住</strong>，我们的目标是重新梳理Drawable中的知识，而不是实现一个特定的Drawable。到这里，我们已经实现了一个自定义的动画Drawable。</p>
<h2 id="最终总结和反思"><a class="header" href="#最终总结和反思">最终总结和反思</a></h2>
<p>这篇文章中，我们梳理了Drawable的设计意图，自行梳理了Drawable子类概览，梳理了Drawable的API概览，练习了自定义Drawable。</p>
<p>我们再思考几个问题：</p>
<blockquote>
<p>自定义View和自定义Drawable的区别是什么</p>
</blockquote>
<p>前者是对于视图的自定义，后者是对于绘制的自定义。<code>两者有一定的关联性</code>，因为视图也是需要通过视觉呈现给用户的，有很大一部和<code>绘制相关</code>；</p>
<p>但自定义View不仅仅可以<code>自定义绘制</code>，还可以<code>自定义交互</code>，这一点是自定义Drawable不具备的。如果我们仅仅是期望对绘制进行自定义，选择自定义Drawable<code>即可</code>；</p>
<p>相比于自定义View，自定义Drawable在应用内的<code>适用性更广</code>，它<code>具体</code>描述了一种<code>绘制</code>，所以，只要存在<code>绘制</code>机制的地方，理论上就可以使用它。</p>
<blockquote>
<p>各种"花里胡哨"的效果都可以这样干吗</p>
</blockquote>
<p>可以但不是所有的都建议。一些简单的场景，例如<code>一种点击特效</code>、<code>一种Progress效果</code> 是建议这样处理的。</p>
<p>一些复杂的场景，例如启动图、固定的酷炫的转场等，是不建议这样处理的。<code>不是说不建议用自定义Drawable处理</code>，而是<code>不建议</code>
再用<code>代码</code>去<code>直接描述Draw的内容</code>。</p>
<p>对于复杂内容，可以对其内容进行抽象和分类，一般来说，我们可以从：</p>
<ul>
<li>静态、动态</li>
<li>矢量描述、非矢量描述</li>
</ul>
<p><code>两个维度</code>区分一个要绘制的内容；</p>
<p>对于静态的，或者矢量描述的内容，已经有相关的类进行抽象描述。而对于动态的非矢量描述的绘制内容，
它们往往<code>复杂</code>，而且很<code>具体</code>，用纯代码进行描述太糟糕了。应当建立抽象体系并结合中间物来描述它们。</p>
<p>以大名鼎鼎的Lottie为例，设计使用AE创作动画文件，并导出成lottie的动画文件：</p>
<ul>
<li>不可矢量描述的、唯一命名的图</li>
<li>json格式封装的所有帧信息</li>
</ul>
<p>那么只需要描述：</p>
<ul>
<li>解析文件</li>
<li>加载帧信息</li>
<li>展示帧，即绘制帧</li>
<li>按照动画时间和帧信息schedule</li>
</ul>
<p>即可。内容设计这种事情，就交给UI和UX了</p>
<p>从技术梳理和博客的角度看，这篇文章的内容已经结束了，从商业投产的角度看，这篇文章的内容远没有结束</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="好玩系列拥有它xml文件少一半--更方便的处理view背景"><a class="header" href="#好玩系列拥有它xml文件少一半--更方便的处理view背景">好玩系列：拥有它，XML文件少一半--更方便的处理View背景</a></h1>
<h2 id="前言-5"><a class="header" href="#前言-5">前言</a></h2>
<p><a href="https://github.com/leobert-lan/Blog/blob/main/info/%E5%85%B3%E4%BA%8E%E5%A5%BD%E7%8E%A9%E7%B3%BB%E5%88%97.md">关于好玩系列</a></p>
<p>这是一项已经被我们项目<code>实验性投产</code>将近一年的方案，虽然还处于实验性阶段，但<code>稳定性</code>和<code>实用性</code>都不错。</p>
<p><a href="https://github.com/leobert-lan/DaVinCi">DaVinCi 仓库链接</a></p>
<blockquote>
<p>问题背景：Android 中普遍使用XML来定义资源，对于视图的背景样式而言，需要定义大量的
<code>GradientDrawable</code>、<code>StateListDrawable</code> 资源等。当项目体量很大时。这些资源就会出现难管理的问题。</p>
</blockquote>
<p>诚然，从<code>最佳实践</code>角度出发，<strong>对项目中的资源进行合理地命名以满足查询索引规则，按照设计风格定义对应的Style，视图定义时利用Style约束其样式</strong>。这才是
<code>优秀的做法</code>。但是，事与愿违，按照国内的从业者现状看，大多数处理大型项目的团队都<code>没有</code>做好这一点的<code>必要条件</code>。</p>
<p>在展开实践之前，我们不妨反思下为何会如此，不外乎：</p>
<ul>
<li>缺乏或者频繁变动顶层<code>设计语言</code>，<em>这个词可能并不太准确</em></li>
<li>以往的页面已经在线上运行了，设计新的页面簇改变了设计风格时，没有安排原有内容的统一修改并给到时间。</li>
<li>以上两条导致全栈Style混乱</li>
<li>当Style超过3种风格时，开发团队一般选择<code>毁灭吧，我累了</code>，谁动全栈风格跟谁急。</li>
</ul>
<p>OK，既然都选择了毁灭吧,那为什么不选择一种更加舒适的方式来处理常见的背景问题。</p>
<h2 id="挑选目标--最常用的drawable资源"><a class="header" href="#挑选目标--最常用的drawable资源">挑选目标--最常用的Drawable资源</a></h2>
<p>经过一番草率的筛选，我们很快锁定了目标：selector、shape</p>
<p>举个例子，窥一斑而见全豹：</p>
<p><img src="Android/Drawable/post_4/img_a_lot_of_drawable.png" alt="大量的资源" /></p>
<p>这还只是一小部分，相信各位的项目中也会有这样的痛点吧。</p>
<p>且不谈 <code>命名规则</code> 是否合情合理，这是一种很反人类的设定，就像你忘记了密码，申请重置，按照一系列的密码规则， 终于设定了一个 <code>让你惴惴不安</code> 担心 <code>再次忘记</code> 的密码后，提交提示：不能和原密码一致。</p>
<p>对Drawable体系有一定了解的话，我们知道 selector、shape 分别对应：</p>
<ul>
<li><code>StateListDrawable</code></li>
<li><code>GradientDrawable</code></li>
</ul>
<p><em>如果对Drawable体系还不太清楚的话，<a href="Android/Drawable/post_2.html">可以简要阅读一下我之前的一篇博客：三思系列：重新认识Drawable</a></em></p>
<h2 id="换一种定义资源解析资源的方式"><a class="header" href="#换一种定义资源解析资源的方式">换一种定义资源、解析资源的方式</a></h2>
<p>布局文件中使用这些Drawable资源时，在View被创建后，会解析配置的属性，而Drawable相关的资源，会被DrawableInflater加载并运用。</p>
<p>这一点就不展开了。毫无疑问，如果要替换掉基于xml的资源定义方式，我们只能采用一个新的方式。但是，我们并<code>没有打算</code> 抛弃使用xml文件定义布局资源</p>
<p>且不卖关子，当时搜索枯肠，要满足：</p>
<ul>
<li>丢弃单独文件定义</li>
<li>方便，不需要查手册</li>
</ul>
<p>两个要素，只想到两个关键词： <code>DSL</code>，<code>OO</code>，没错，<code>领域特定语言</code> 和 <code>面向对象</code>。</p>
<p>严格来说，这两者基本是互斥的。</p>
<p>但是很抱歉，这里必须要先打住，要先讲点别的，然后再回到这个话题。</p>
<blockquote>
<p>注，后面很大一段篇幅，会用于：</p>
<ul>
<li>解释抛弃自定义View和属性的方案</li>
<li>使用Builder简化Drawable构造过程</li>
<li>DSL简介</li>
<li>用DSL解决这个问题</li>
</ul>
<p>个人认为 <code>使用自定义文法</code> 和 <code>解释器</code>处理文法解析 是一件挺好玩的事情，值得玩一玩，
但限于我的水平，这段内容读起来可能很晦涩，如果不是非常感兴趣，可以直接跳过到：<a href="Android/Drawable/post_4.html#anchor2">到底是DSL还是OO</a></p>
</blockquote>
<h3 id="抛弃了自定义view和属性的方式"><a class="header" href="#抛弃了自定义view和属性的方式">抛弃了自定义View和属性的方式</a></h3>
<p>在开始时，我考虑过这种方案。但是使用 <code>自定义的</code> <code>LayoutInflater</code> 或者 <code>hook</code> 系统LayoutInflater 都是可能影响到某些 <code>黑科技</code>的</p>
<p>就算不考虑干扰到其他黑科技，也需要严格的处理各种属性组合，并提供完善的查询手册，这很 <code>不人道主义</code>，</p>
<p>而基于十几个属性组合场景自定义lint规则，这 <code>很烦</code> ，一点都 <code>不好玩</code></p>
<p>所以这个方案直接被否决</p>
<h2 id="工欲善其事必先利其器drawable对象构建工具----drawable-builder"><a class="header" href="#工欲善其事必先利其器drawable对象构建工具----drawable-builder">工欲善其事必先利其器，Drawable对象构建工具 -- Drawable Builder</a></h2>
<p>因为 <code>StateListDrawable</code> 和 <code>GradientDrawable</code> 的内部细节都是比较多的，这句话等价于：构建这两者的实例对象比较复杂。</p>
<p>这很符合Builder模式的使用场景，我们先设计一个Builder来处理这两者的构建，并在构建过程中检验信息</p>
<blockquote>
<p>这是一件比较枯燥的事情，代码略。详见DaVinCiCore.kt</p>
</blockquote>
<p>在我们完善的考虑了 各种state下： 形状，渐变的角度、方式，填充，描边，尺寸，指定的drawable等之后，我们可以 "很方便" 的创建Drawable啦！</p>
<h2 id="一套适应场景的dsl----定义规则"><a class="header" href="#一套适应场景的dsl----定义规则">一套适应场景的DSL -- 定义规则</a></h2>
<p>在内容展开之前，我们再回顾一下DSL的基础。</p>
<p><code>DSL</code>即 <code>Domain Specified Language</code> 、<code>领域专用语言</code>。</p>
<p>Wikipedia中关于这个词条的描述：</p>
<blockquote>
<p>A specialized computer language designed for a specific task.</p>
</blockquote>
<p>为了解决 <code>某类</code> <code>特定问题</code> 而设计的一种 <code>特殊</code> 的计算机语言</p>
<p>而马丁老爷子关于它的描述，看起来就很高深了，但我更喜欢这一个描述：</p>
<blockquote>
<p>A computer programming language of limited expressiveness focused on a particular domain.</p>
</blockquote>
<p>一种 <code>抑制表达能力</code> 以 <code>专注于</code> <code>特定领域</code> 的计算机语言。</p>
<p>这种抑制，让它专注于特定的领域，而抛弃了其他的领域，以达到更加高效、准确的目的。</p>
<p>我们知道，xml协议的<code>扩展性非常强</code>，而这种扩展性，让它的<code>解析</code>变得非常的<code>繁琐</code>，继而带来了效率问题。Android中，为了 <code>兼顾</code> xml的 <code>扩展性</code> 和 使用的 <code>效率问题</code>， 定制了各类Inflater以处理特定的问题。</p>
<p>显然，我们这次不打算在巨人的肩膀上更进一步，而是要在特定问题上，剑走偏锋。</p>
<p>按照我们积累的知识，要构建一个 <code>GradientDrawable</code>，可能用到：</p>
<ul>
<li>形状 shape</li>
<li>纯色填充色 solidColor</li>
<li>圆角相关：
<ul>
<li>cornersRadius</li>
<li>cornersBottomLeftRadius</li>
<li>cornersBottomRightRadius</li>
<li>cornersTopLeftRadius</li>
<li>cornersTopRightRadius</li>
</ul>
</li>
<li>填充渐变：
<ul>
<li>渐变方向角 gradientAngle</li>
<li>渐变中点x gradientCenterX</li>
<li>渐变中点y gradientCenterY</li>
<li>渐变起始颜色 gradientStartColor</li>
<li>渐变中点颜色 gradientCenterColor</li>
<li>渐变终点颜色 gradientEndColor</li>
</ul>
</li>
<li>渐变形式 gradient</li>
<li>形式为 RADIAL_GRADIENT时的 gradientRadius</li>
<li>useLevel</li>
<li>padding</li>
<li>sizeWidth</li>
<li>sizeHeight</li>
<li>描边宽度 strokeWidth</li>
<li>描边颜色 strokeColor</li>
<li>虚线段宽度 strokeDashWidth</li>
<li>虚线段间距 strokeDashGap</li>
</ul>
<p>当然，我们还需要考虑到 <code>不同的状态</code>，和一些 <code>细节</code> ，这里先不展开</p>
<p>此时我们有两个选择方向，让我们的DSL类似于：</p>
<pre><code>shape:[
    gradient:[type:linear;startColor:#ff3c08;endColor:#353538 ];
    st:[Oval];
    corners:[40 dp];
    stroke:[width:4 dp;color:rc / colorAccent ]
]
</code></pre>
<p><em>ps，因为目标固定为设置background，所以语法式中忽略这种描述</em></p>
<p>或者类似于sql的insert语句。</p>
<p>不过后者的 <code>字段</code> 太多，实在不适合阅读，而且SQL的 <code>表达能力</code> 相对于我们要处理的问题，还是过强了一点。</p>
<p>ok，我们再仔细设计一下规则。</p>
<p>终结符：</p>
<ul>
<li><code>[</code> <code>]</code>,当前域的子句均置于其中，例：</li>
</ul>
<pre><code class="language-kotlin">域:[子域1:[值]]

shape:[st:[Oval]]
</code></pre>
<ul>
<li><code>;</code>,当前域有多个子域时，子域之间用 <code>;</code> 分隔</li>
</ul>
<p>非终结符：</p>
<ul>
<li>shape: 代表创建一个GradientDrawable</li>
<li>st: 代表shape类型，枚举值为
<ul>
<li>Rectangle</li>
<li>Oval</li>
<li>Line</li>
<li>Ring</li>
</ul>
</li>
<li>corners: 圆角相关设置，值置于[]中，一个值代表4个角，4个值代表 左上、右上、右下、左下 四个值对应设置</li>
<li>solid: 纯色填充，[]内为色值，色值表达见后</li>
<li>gradient:渐变色，子命令置于 [] 中
<ul>
<li>type：渐变类型，枚举为：
<ul>
<li>linear</li>
<li>radial</li>
<li>sweep</li>
</ul>
</li>
<li>startColor: 起始色</li>
<li>centerColor: 中间色</li>
<li>endColor: 结束色</li>
<li>centerX: 中点x</li>
<li>centerY: 中点y</li>
<li>angle: 渐变角度</li>
</ul>
</li>
<li>stroke: 描边，子命令置于 [] 中
<ul>
<li>width: 描边宽度</li>
<li>color: 描边颜色</li>
<li>dashWidth: 虚线宽</li>
<li>dashGap: 虚线间距</li>
</ul>
</li>
<li>size: 尺寸
<ul>
<li>width:</li>
<li>height:</li>
</ul>
</li>
<li>padding: 内边距
<ul>
<li>left</li>
<li>top</li>
<li>right</li>
<li>bottom</li>
</ul>
</li>
</ul>
<p>特殊规则：</p>
<ul>
<li>尺寸描述：纯数字代表px，数值+dp 代表dp值，<code>w</code>代表 <code>wrap_content</code>，<code>m</code> 代表 <code>match_parent</code></li>
<li>颜色表达："#ffffff"等色值字符串，代表ARGB值的 int 值，"rc/资源名" 表达资源引用， 以及用"@idName"来获取目标View的tag，tag值需为颜色字符串或者ARGB色</li>
</ul>
<p>为了适当减少类的数量，我们约定：</p>
<ul>
<li>不拥有子域的域弱化为属性，以<code>属性名:属性值</code>的方式表达，而不再需要 <code>[]</code> 符号</li>
<li>当某个域的属性只存在一个或者已经被约定时，可以忽略其属性名，直接使用属性值</li>
</ul>
<blockquote>
<p>注:重新整理时，我发现最开始编码的 <code>ShapeType</code> 和 <code>Corners</code> 没有重新按照上述约定修正，
这是一处遗忘修改的bug，准确的讲，是将子域弱化为属性时，期望略去终结符而带来的文法规则缺陷，读者<strong>不要深究</strong>。</p>
<p>出现这个bug的根本原因是：我当时想减少小类数量，并
一定程度上降低解析复杂度，将非终结符识别标记 和终结符 <code>[</code> 组合在了一起，替代原先的非终结符识别标记使用。</p>
</blockquote>
<blockquote>
<p>注2：主体是 GradientDrawable ，为什么用 Shape去对应？因为国内普遍存在的文章中，绝大多数都已经将
Gradient 对应为"颜色的梯度渐变"，而将这一资源文件定义为 "形状"、带"填充"和"描边"的形状。而Android的资源定义语法中，
也是类似的。大家也都习惯了，索性尊重习惯。</p>
</blockquote>
<h2 id="解释器----处理表达式解析"><a class="header" href="#解释器----处理表达式解析">解释器 -- 处理表达式解析</a></h2>
<blockquote>
<p>在GOF的设计模式中，<code>解释器模式</code> ( <code>Interpreter Pattern</code> ) 提供了 <code>评估</code> 语言的 <code>语法</code> 或 <code>表达式</code> 的方式，它属于 <code>行为型模式</code>。</p>
</blockquote>
<p>需要注意，其实在这个问题的实际场景中，一条语句，子句出现的频率可能并不会太高，但解释器模式 <code>依旧是场景适用</code> 的。</p>
<p>我们再回顾一下解释器模式的 <code>优缺点</code>：</p>
<p>优点：</p>
<ul>
<li>可扩展性比较好，灵活。</li>
<li>易于实现简单文法。</li>
</ul>
<p>缺点：</p>
<ul>
<li>对于复杂的文法比较难维护</li>
<li>可能引起类膨胀</li>
<li>采用递归调用方法，层级过深，可能出现效率问题</li>
</ul>
<h3 id="定义上下文"><a class="header" href="#定义上下文">定义上下文</a></h3>
<p><img src="Android/Drawable/post_4/img_uml_davinci.png" alt="uml_davinci" /></p>
<p>其中 <code>core:DaVinCiCore</code> 是上面提到的构建者，未遵循习惯命名法。
<code>view:View</code> 是要操作的View。</p>
<p><strong>源码枯燥，略</strong></p>
<h3 id="抽象表达式"><a class="header" href="#抽象表达式">抽象表达式</a></h3>
<p><img src="Android/Drawable/post_4/img_uml_davinciexp.png" alt="uml_davinci" /></p>
<pre><code class="language-kotlin">sealed class DaVinCiExpression(var daVinCi: DaVinCi? = null) {

    // 节点名称
    protected var tokenName: String? = null

    // 文本内容
    protected var text: String? = null

    //实际属性是否需要从text解析，手动创建并给了专有属性的，设为false，就不会被覆盖了
    protected var parseFromText = true

    abstract fun injectThenParse(daVinCi: DaVinCi?)

    /*
     * 执行方法
     */
    abstract fun interpret()

    open fun startTag(): String = ""

    companion object {
        @JvmStatic
        fun shape(): Shape = Shape(true)

        const val sLogTag = "DaVinCi"

        const val END = "]"

        const val NEXT = "];"

        const val sResourceColor = "rc/"
    }
}
</code></pre>
<h3 id="终结符处理"><a class="header" href="#终结符处理">终结符处理</a></h3>
<p>只需要处理兄弟域的关系即可，例如，我们知道 solid 和 stroke 就是兄弟域，</p>
<pre><code class="language-kotlin"> protected class ListExpression(daVinCi: DaVinCi? = null, private val manual: Boolean = false) :
    DaVinCiExpression(daVinCi) {
    private val list: ArrayList&lt;DaVinCiExpression&gt; = ArrayList()

    fun append(exp: DaVinCiExpression) {
        list.add(exp)
    }

    override fun injectThenParse(daVinCi: DaVinCi?) {
        this.daVinCi = daVinCi
        if (manual) {
            list.forEach { it.injectThenParse(daVinCi) }
            return
        }

        // 在ListExpression解析表达式中,循环解释语句中的每一个单词,直到终结符表达式或者异常情况退出
        daVinCi?.let {
            var i = 0
            while (i &lt; 100) { // true,语法错误时有点可怕，先上限100
                if (it.currentToken == null) { // 获取当前节点如果为 null 则表示缺少]表达式
                    println("Error: The Expression Missing ']'! ")
                    break
                } else if (it.equalsWithCommand(END)) {
                    it.next()
                    // 解析正常结束
                    break
                } else if (it.equalsWithCommand(NEXT)) {
                    //进入同级别下一个解析
                    it.next()
                } else { // 建立Command 表达式
                    try {
                        val expressions: DaVinCiExpression = CommandExpression(it)
                        list.add(expressions)
                    } catch (e: Exception) {
                        if (DaVinCi.enableDebugLog) Log.e(sLogTag, "语法解析有误", e)
                        break
                    }
                }
                i++
            }
            if (i == 100) {
                if (DaVinCi.enableDebugLog) Log.e(sLogTag, "语法解析有误，进入死循环，强制跳出")
            }
        }
    }

    override fun interpret() { // 循环list列表中每一个表达式 解释执行
        list.forEach { it.interpret() }
    }

    override fun toString(): String {
        val b = StringBuilder()

        val iMax: Int = list.size - 1
        if (iMax == -1) return ""
        var i = 0
        while (true) {
            b.append(list[i].toString())
            if (i == iMax) return b.toString()
            b.append("; ")
            i++
        }
    }
}
</code></pre>
<h3 id="非终结符的规则处理"><a class="header" href="#非终结符的规则处理">非终结符的规则处理</a></h3>
<pre><code class="language-kotlin">
open class CommandExpression(daVinCi: DaVinCi? = null, val manual: Boolean = false) :
    DaVinCiExpression(daVinCi) {
    private var expressions: DaVinCiExpression? = null

    init {
        //因为是嵌套层，且作为父类了，避免递归
        if (this::class == CommandExpression::class)
            onParse(daVinCi)
    }

    override fun injectThenParse(daVinCi: DaVinCi?) {
        onParse(daVinCi)
    }

    protected fun toPx(str: String, context: Context): Int? {
        //略
    }

    protected fun parseColor(text: String?): Int? {
        //略
    }

    protected fun parseInt(text: String?, default: Int?): Int? {
        //略
    }

    protected fun parseFloat(text: String?, default: Float?): Float? {
        //略
    }

    protected fun getTag(context: Context?, resName: String): String? {
        //略
    }

    protected fun getColor(context: Context?, resName: String?): Int? {
        //略
    }

    @Throws(Exception::class)
    private fun onParse(daVinCi: DaVinCi?) {
        this.daVinCi = daVinCi
        if (manual) return
        daVinCi?.let {
            expressions = when (it.currentToken) {
                Corners.tag -&gt; Corners(it)
                Solid.tag -&gt; Solid(it)
                ShapeType.tag -&gt; ShapeType(it)
                Stroke.tag -&gt; Stroke(it)
                Size.tag -&gt; Size(it)
                Padding.tag -&gt; Padding(it)
                Gradient.tag -&gt; Gradient(it)
                else -&gt; throw Exception("cannot parse ${it.currentToken}")
            }
        }
    }

    protected fun asPrimitiveParse(start: String, daVinCi: DaVinCi?) {
        this.daVinCi = daVinCi
        daVinCi?.let {
            tokenName = it.currentToken
            it.next()
            if (start == tokenName) {
                this.text = it.currentToken
                it.next()
            } else {
                it.next()
            }
        }
    }

    override fun interpret() {
        expressions?.interpret()
    }

    override fun toString(): String {
        return "$expressions"
    }
}
</code></pre>
<p>以solid为例：</p>
<pre><code class="language-kotlin">class Solid(daVinCi: DaVinCi? = null, manual: Boolean = false) :
    CommandExpression(daVinCi, manual) {
    @ColorInt
    internal var colorInt: Int? = null //这是解析出来的，不要乱赋值

    companion object {
        const val tag = "solid:["
    }

    init {
        injectThenParse(daVinCi)
    }

    override fun injectThenParse(daVinCi: DaVinCi?) {
        this.daVinCi = daVinCi

        if (manual) {
            if (parseFromText)
                colorInt = parseColor(text)
            return
        }
        colorInt = null
        asPrimitiveParse(tag, daVinCi)
        colorInt = parseColor(text)

    }

    override fun interpret() {
        if (tag == tokenName || manual) {
            daVinCi?.let {
                colorInt?.let { color -&gt;
                    it.core.setSolidColor(color)
                }
            }
        }
    }

    override fun toString(): String {
        return "$tag ${if (parseFromText) text else colorInt?.run { text }} $END"
    }
}
</code></pre>
<p>同理，我们处理完：</p>
<ul>
<li>Corners</li>
<li>ShapeType</li>
<li>Stroke</li>
<li>Size</li>
<li>Padding</li>
<li>Gradient</li>
</ul>
<p>即可。</p>
<h4 id="最重要的shape"><a class="header" href="#最重要的shape">最重要的Shape</a></h4>
<p>至此，我们只需要再解析 <code>shape:[]</code> 即可完成工作。</p>
<p>很简单，只要我们识别出来，其子域的描述子句均可被提取出来，<em>利用 <code>;</code> 分割子句</em>，那么我们只需要用 <code>ListExpression</code> 即可储存子句。</p>
<p>代码略</p>
<blockquote>
<p>注，至此，我们完成了文法的定义和解析处理，注意，目前所有的主体都是 GradientDrawable，他的文法已经足够复杂了，</p>
<p>StateListDrawable 所对应的各种状态
我们不在文法中进行扩展了，否则单条语句的长度会非常可怕。</p>
</blockquote>
<h2 id="到底是dsl还是oo"><a class="header" href="#到底是dsl还是oo"><a id="anchor2">到底是DSL还是OO</a></a></h2>
<blockquote>
<p>前面我们谈到了这个问题，要满足</p>
<ul>
<li>丢弃单独文件定义</li>
<li>方便，不需要查手册</li>
</ul>
<p>两个要素，只想到两个关键词： <code>DSL</code>，<code>OO</code>，即 <code>领域特定语言</code> 和 <code>面向对象</code>。</p>
</blockquote>
<p>当时我们切到了其他话题，并顺带着已经把 <code>DSL方案</code> 的核心实现了。</p>
<p>我们注意到，如果使用DSL，直接使用 <code>字符串形式</code> 的 <code>表达语句</code>，这 <code>很不人道主义</code>。</p>
<blockquote>
<p>我们不太可能像web技术那样，再走一条 css 方式的道路</p>
</blockquote>
<p>那么，我们目前做的都是鸡肋吗？</p>
<p>这个问题，笔者我目前也无法回答，因为我站得高度还不够高。</p>
<p>但是，这不影响我们继续探究：如何使用OO思想，让构建变得更加简单</p>
<h3 id="在文法符号的相关类基础上面向对象"><a class="header" href="#在文法符号的相关类基础上面向对象">在文法符号的相关类基础上，面向对象</a></h3>
<p>在前面的工作中，我们定义了一堆 <code>终结符</code> 和 <code>非终结符</code> 对应的类，而其语法树结构，是通过直接反解
一段 <code>文法表达式字符串</code> 得到的。</p>
<p>反过来想，我们直接面向对象操作，也可以直接构建出期望的语法树。</p>
<p>只要有正确的语法树，执行后一样可以得到期望的结果。</p>
<p><strong>想通这一点，编码就很容易了，这里我们略去相关源码。</strong></p>
<blockquote>
<p>注：至此，究竟是 <code>面向对象</code> 构建语法树处理问题，还是使用 <code>文法表达式字符串</code> 构建语法树，已经不再重要。
其本质都是构建语法树以描述Drawable的构建规则，只不过是在两个世界中的不同表达形式</p>
</blockquote>
<h3 id="最后一步巧借东风借助databinding直接在xml中使用"><a class="header" href="#最后一步巧借东风借助databinding直接在xml中使用">最后一步，巧借东风，借助DataBinding，直接在xml中使用</a></h3>
<p>我们知道，利用DataBinding，可以直接在xml中实现声明使用</p>
<p>再结合 <code>BindingAdapter</code> 机制，我们就可以实现 <code>声明背景</code> 的目标。</p>
<pre><code class="language-kotlin">
@BindingAdapter(
    "daVinCi_bg", "daVinCi_bg_pressed", "daVinCi_bg_unpressed",
    "daVinCi_bg_checkable", "daVinCi_bg_uncheckable", "daVinCi_bg_checked", "daVinCi_bg_unchecked",
    requireAll = false
)
fun View.daVinCi(
    normal: DaVinCiExpression? = null,
    pressed: DaVinCiExpression? = null, unpressed: DaVinCiExpression? = null,
    checkable: DaVinCiExpression? = null, uncheckable: DaVinCiExpression? = null,
    checked: DaVinCiExpression? = null, unchecked: DaVinCiExpression? = null
) {
    val daVinCi = DaVinCi(null, this)
    //用于多次构建
    val daVinCiLoop = DaVinCi(null, this)

    normal?.let {
        daVinCi.apply {
            currentToken = normal.startTag()
        }
        if (DaVinCi.enableDebugLog) Log.d(sLogTag, "${this.logTag()} daVinCi normal:$normal")

        normal.injectThenParse(daVinCi)
        normal.interpret()
    }

    pressed?.let {
        simplify(daVinCiLoop, it, "pressed", this)
        daVinCi.core.setPressedDrawable(daVinCiLoop.core.build())
        daVinCiLoop.core.clear()
    }

    unpressed?.let {
        simplify(daVinCiLoop, it, "unpressed", this)
        daVinCi.core.setUnPressedDrawable(daVinCiLoop.core.build())
        daVinCiLoop.core.clear()
    }

    checkable?.let {
        simplify(daVinCiLoop, it, "checkable", this)
        daVinCi.core.setCheckableDrawable(daVinCiLoop.core.build())
        daVinCiLoop.core.clear()
    }

    uncheckable?.let {
        simplify(daVinCiLoop, it, "uncheckable", this)
        daVinCi.core.setUnCheckableDrawable(daVinCiLoop.core.build())
        daVinCiLoop.core.clear()
    }

    checked?.let {
        simplify(daVinCiLoop, it, "checked", this)
        daVinCi.core.setCheckedDrawable(daVinCiLoop.core.build())
        daVinCiLoop.core.clear()
    }

    unchecked?.let {
        simplify(daVinCiLoop, it, "unchecked", this)
        daVinCi.core.setUnCheckedDrawable(daVinCiLoop.core.build())
        daVinCiLoop.core.clear()
    }


    //下面的略
    //    private var enabledDrawable: Drawable? = null
    //    private var unEnabledDrawable: Drawable? = null
    //    private var selectedDrawable: Drawable? = null
    //    private var focusedDrawable: Drawable? = null
    //    private var focusedHovered: Drawable? = null
    //    private var focusedActivated: Drawable? = null
    //    private var unSelectedDrawable: Drawable? = null
    //    private var unFocusedDrawable: Drawable? = null
    //    private var unFocusedHovered: Drawable? = null
    //    private var unFocusedActivated: Drawable? = null

    ViewCompat.setBackground(this, daVinCi.core.build())
}
</code></pre>
<p>示例：</p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;layout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"&gt;

    &lt;data&gt;

        &lt;variable
            name="a"
            type="String" /&gt;

        &lt;import type="osp.leobert.android.davinci.DaVinCiExpression" /&gt;

    &lt;/data&gt;

    &lt;androidx.core.widget.NestedScrollView
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        tools:context=".MainActivity"&gt;

        &lt;LinearLayout
            daVinCi_bg="@{DaVinCiExpression.shape().solid(`#eaeaea`)}"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:padding="10dp"&gt;

            &lt;TextView
                android:id="@+id/test"
                daVinCi_bg="@{DaVinCiExpression.shape().corner(60).solid(`@i2`).stroke(`4dp`,`@i2`)}"
                android:layout_width="match_parent"
                android:layout_height="100dp"
                android:layout_marginTop="10dp"
                android:background="@drawable/test"
                android:gravity="center"
                android:text="@string/app_name"&gt;

                &lt;tag
                    android:id="@id/i1"
                    android:value="@color/colorPrimaryDark" /&gt;

                &lt;tag
                    android:id="@id/i2"
                    android:value="@color/colorAccent" /&gt;
            &lt;/TextView&gt;

            &lt;Button
                daVinCi_bg_pressed="@{DaVinCiExpression.shape().corner(`10dp,15dp,20dp,30dp`).stroke(`4dp`,`@i2`).gradient(`#26262a`,`#ff0699`,0)}"
                daVinCi_bg_unpressed="@{DaVinCiExpression.shape().corner(60).solid(`@i1`).stroke(`4dp`,`@i2`)}"
                android:layout_width="match_parent"
                android:layout_height="100dp"
                android:gravity="center"
                android:text="Hello World!"&gt;

                &lt;tag
                    android:id="@id/i1"
                    android:value="@color/colorPrimaryDark" /&gt;

                &lt;tag
                    android:id="@id/i2"
                    android:value="@color/colorAccent" /&gt;
            &lt;/Button&gt;

            &lt;TextView
                android:id="@+id/test2"
                daVinCi_bg="@{DaVinCiExpression.shape().corner(`10dp,15dp,20dp,30dp`).stroke(`4dp`,`@i2`).gradient(`#26262a`,`#ff0699`,0)}"
                android:layout_width="match_parent"
                android:layout_height="100dp"
                android:layout_marginTop="10dp"
                android:background="@drawable/test"
                android:gravity="center"
                android:text="@string/app_name"&gt;

                &lt;tag
                    android:id="@id/i1"
                    android:value="@color/colorPrimaryDark" /&gt;

                &lt;tag
                    android:id="@id/i2"
                    android:value="@color/colorAccent" /&gt;
            &lt;/TextView&gt;

            &lt;CheckBox
                daVinCi_bg="@{DaVinCiExpression.shape().corner(60).solid(`@i2`).stroke(`4dp`,`@i2`)}"
                daVinCi_bg_pressed="@{DaVinCiExpression.shape().corner(`10dp,15dp,20dp,30dp`).stroke(`4dp`,`@i2`).gradient(`#26262a`,`#ff0699`,0)}"
                android:layout_width="match_parent"
                android:layout_height="100dp"
                android:layout_marginTop="10dp"
                android:background="@drawable/test"
                android:gravity="center"
                android:text="错误示范：daVinCi_bg只能单独使用，一旦有其他的，就需要使用相应的成对的"&gt;

                &lt;tag
                    android:id="@id/i1"
                    android:value="@color/colorPrimaryDark" /&gt;

                &lt;tag
                    android:id="@id/i2"
                    android:value="@color/colorAccent" /&gt;
            &lt;/CheckBox&gt;

            &lt;CheckBox
                daVinCi_bg_checked="@{DaVinCiExpression.shape().corner(60).solid(`@i2`).stroke(`4dp`,`@i2`)}"
                daVinCi_bg_unchecked="@{DaVinCiExpression.shape().corner(`10dp,15dp,20dp,30dp`).stroke(`4dp`,`@i2`).gradient(`#26262a`,`#ff0699`,0)}"
                android:layout_width="match_parent"
                android:layout_height="100dp"
                android:layout_marginTop="10dp"
                android:background="@drawable/test"
                android:gravity="center"
                android:text="check状态"&gt;

                &lt;tag
                    android:id="@id/log_tag"
                    android:value="测试log tag" /&gt;

                &lt;tag
                    android:id="@id/i1"
                    android:value="@color/colorPrimaryDark" /&gt;

                &lt;tag
                    android:id="@id/i2"
                    android:value="@color/colorAccent" /&gt;

                &lt;tag
                    android:id="@id/i3"
                    android:value="@string/app_name" /&gt;
            &lt;/CheckBox&gt;

        &lt;/LinearLayout&gt;

    &lt;/androidx.core.widget.NestedScrollView&gt;

&lt;/layout&gt;
</code></pre>
<p>粗糙的Demo效果，见笑了： <em>感谢读者<code>鲁班贼六</code>同学提醒我补充效果图</em></p>
<p><img src="Android/Drawable/post_4/demo2.png" alt="demo" /></p>
<p>甚至可以玩杂耍，直接使用字符串形式的DSL内容：</p>
<pre><code class="language-kotlin">binding.test2.setOnClickListener {
    it.daVinCi("shape:[ gradient:[ type:linear;startColor:#ff3c08;endColor:#353538 ];" +
            " st:[ Oval ]; corners:[ 40dp ]; stroke:[ width:4dp;color:rc/colorAccent ] ]")
}
</code></pre>
<p>注意，这个方式不推荐使用，很不利于维护，就是 <code>杂耍</code>，可以直接更新背景：</p>
<p><img src="Android/Drawable/post_4/demo3.png" alt="demo3" /></p>
<h2 id="总结和展望"><a class="header" href="#总结和展望">总结和展望</a></h2>
<p>这一篇，我们从一个问题：</p>
<blockquote>
<p>xml定义的资源文件难以管理、维护</p>
</blockquote>
<p>开始，尝试性的提出了一种 替代xml 定义背景资源文件的方式。并进行了知识展开和拓展。
最终实现了期望目标。</p>
<p>但是，使用 <code>xml文件</code> 或者其他形式的文件来定义资源，是有它的道理的，虽然，这种方式的弊端已经被长久诟病，
并且在新兴技术中，资源和代码的存在位置已经开始交融。</p>
<p>我们知道，Compose这一革命性技术，新事物想要完全替代旧事物，不是一朝一夕的事情，旧事物不会突然消失。</p>
<p>本文中的方案，我将其视为一次 <code>好玩</code> ，<code>跟时髦</code> 的尝试。并且我个人认为，这一方案还是有存在价值的。</p>
<p>而在此基础上，还可以继续开展 style定义和使用，<code>ColorStateList</code> 文法表达式。</p>
<p>今天是除夕，祝大家除夕快乐。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="迟来的续集--drawableanimator将优雅进行到底"><a class="header" href="#迟来的续集--drawableanimator将优雅进行到底">迟来的续集--Drawable+Animator，将优雅进行到底</a></h1>
<h2 id="前言-6"><a class="header" href="#前言-6">前言</a></h2>
<p>2021年初，读过一篇关于splash页面动效的推送文章，作者讲解了如何实现一个闪屏页效果：</p>
<blockquote>
<p>将一个英文单词拆分为多个字母，散落在屏幕中，然后按照一定的路径回归，最终展示一段流光效果。</p>
<p>通过自定义View的方式予以实现。</p>
</blockquote>
<p>当时我脑中闪过一个念头：他的实现很棒，但如果不需要点触、手势交互，使用Drawable实现更好。并由此编写了一篇文章：<a href="https://juejin.cn/post/6924240361317466125">三思系列：重新认识Drawable</a>
, 并在不久之后通过 <a href="https://juejin.cn/post/6934222774139518984">三思系列：为什么要自定义View</a> 一文阐释了对于 "自定义View适用场景" 的个人拙见。</p>
<p>简单通过思维导图回顾 <a href="https://juejin.cn/post/6924240361317466125">三思系列：重新认识Drawable</a> 一文的内容：
<img src="Android/Drawable/./post_2/Drawable_guide.png" alt="" /></p>
<p><em>阅读原文大约需要10-15分钟</em></p>
<p>文中，我们最终以该方案实现了 "自定义一个动画Drawable" ： <code>unscheduleSelf()</code> / <code>scheduleSelf()</code> 机制 <code>停止回调/设置定时回调</code> + <code>invalidateSelf()</code> 机制进行刷新绘制；
方案的本质是 <strong>在预设时间点绘制关键帧</strong> 。仔细观察后不难发现问题：<strong>效果并不顺滑</strong> 。效果如下：</p>
<img width="216" height="384" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e60cc97c4b04c9a9c520b955f76fbae~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp"/>
<p>视频：<a href="https://github.com/leobert-lan/Blog/blob/main/Android/Drawable/post_2/version_5.webm">链接</a></p>
<p>彼时，文章的主旨为重新认识Drawable，<strong>并未对此展开讨论并进一步优化</strong>。 本篇文章作为迟来的续集，将会 <strong>对问题展开讨论、探索优化方案、追究原理、并进一步拓宽思路</strong>。按照此方式展开将迎来久违的三思系列。</p>
<p><a href="https://leobert-lan.github.io/info/about_sansi_series.html">关于三思系列</a></p>
<h2 id="思危问题本质"><a class="header" href="#思危问题本质">思危：问题本质</a></h2>
<p>上文已经提到，我们通过 <code>unscheduleSelf()</code> / <code>scheduleSelf()</code> 机制 停止回调/设置定时回调，重新绘制关键帧。那么 <code>scheduleSelf()</code> 的本质又是什么？</p>
<p>阅读代码可知，源码中通过接口回调的设计，将功能的实现剥离：</p>
<pre><code class="language-java">class Drawable {
    public void scheduleSelf(@NonNull Runnable what, long when) {
        final Callback callback = getCallback();
        if (callback != null) {
            callback.scheduleDrawable(this, what, when);
        }
    }

    public final void setCallback(@Nullable Callback cb) {
        mCallback = cb != null ? new WeakReference&lt;&gt;(cb) : null;
    }

    @Nullable
    public Callback getCallback() {
        return mCallback != null ? mCallback.get() : null;
    }

    public interface Callback {
        void invalidateDrawable(@NonNull Drawable who);

        void scheduleDrawable(@NonNull Drawable who, @NonNull Runnable what, long when);

        void unscheduleDrawable(@NonNull Drawable who, @NonNull Runnable what);
    }
}
</code></pre>
<p>继续寻找 <code>Callback</code> 实现类：<em>重点关注 scheduleDrawable 即可</em></p>
<pre><code class="language-java">public class View implements Drawable.Callback {
    public void invalidateDrawable(@NonNull Drawable drawable) {
        if (verifyDrawable(drawable)) {
            final Rect dirty = drawable.getDirtyBounds();
            final int scrollX = mScrollX;
            final int scrollY = mScrollY;

            invalidate(dirty.left + scrollX, dirty.top + scrollY,
                    dirty.right + scrollX, dirty.bottom + scrollY);
            rebuildOutline();
        }
    }

    //看这里
    public void scheduleDrawable(@NonNull Drawable who, @NonNull Runnable what, long when) {
        if (verifyDrawable(who) &amp;&amp; what != null) {
            final long delay = when - SystemClock.uptimeMillis();
            if (mAttachInfo != null) {
                mAttachInfo.mViewRootImpl.mChoreographer.postCallbackDelayed(
                        Choreographer.CALLBACK_ANIMATION, what, who,
                        Choreographer.subtractFrameDelay(delay));
            } else {
                // Postpone the runnable until we know
                // on which thread it needs to run.
                getRunQueue().postDelayed(what, delay);
            }
        }
    }

    public void unscheduleDrawable(@NonNull Drawable who, @NonNull Runnable what) {
        if (verifyDrawable(who) &amp;&amp; what != null) {
            if (mAttachInfo != null) {
                mAttachInfo.mViewRootImpl.mChoreographer.removeCallbacks(
                        Choreographer.CALLBACK_ANIMATION, what, who);
            }
            getRunQueue().removeCallbacks(what);
        }
    }

    public void unscheduleDrawable(Drawable who) {
        if (mAttachInfo != null &amp;&amp; who != null) {
            mAttachInfo.mViewRootImpl.mChoreographer.removeCallbacks(
                    Choreographer.CALLBACK_ANIMATION, null, who);
        }
    }

}
</code></pre>
<p>简单解释程序逻辑如下：如果 "该Drawable作用于自身" 且 "Runnable非空"，计算回调的delay，如果View已经添加到Window，则交给Choreographer，否则丢入缓存队列。</p>
<p>而缓存队列的内容将在View添加到Window时交给 <code>Choreographer</code></p>
<pre><code class="language-java">public class View {
    void dispatchAttachedToWindow(AttachInfo info, int visibility) {
        //ignore

        // Transfer all pending runnables.
        if (mRunQueue != null) {
            mRunQueue.executeActions(info.mHandler);
            mRunQueue = null;
        }

        //ignore
    }
}
</code></pre>
<blockquote>
<p>读者诸君，如果您熟悉Android的 <code>屏幕刷新机制</code> 和 <code>消息机制</code> ，一定不会对 <code>Choreographer</code> 感到陌生</p>
</blockquote>
<p>Choreographer 直译为编舞者，暗含了 "编制视图变化效果" 的隐喻，其本质依旧是利用 VSync+Handler消息机制。<strong>delay Callback的设计存在毫秒级的误差</strong>。</p>
<p><em>作者按：本篇不再展开讨论Android的消息机制，以下仅给出 <code>基于消息机制的界面绘制设计</code> 关键部分流程图：</em></p>
<p><img src="Android/Drawable/./post_47/ui_msg_img.png" alt="img.png" /></p>
<p>结合前面的代码分析，<code>scheduleDrawable</code> 的流程可以参考此图理解。</p>
<p><em>作者按，虽然仍有差异，但机制一致，可参考理解</em></p>
<h3 id="验证"><a class="header" href="#验证">验证</a></h3>
<blockquote>
<p>Talk is cheap, show you the code</p>
</blockquote>
<p>在 <code>View</code> 中有一段代码和 <code>scheduleDrawable</code> 高度相似：</p>
<pre><code class="language-java">class View {
    public void postOnAnimationDelayed(Runnable action, long delayMillis) {
        final AttachInfo attachInfo = mAttachInfo;
        if (attachInfo != null) {
            attachInfo.mViewRootImpl.mChoreographer.postCallbackDelayed(
                    Choreographer.CALLBACK_ANIMATION, action, null, delayMillis);
        } else {
            // Postpone the runnable until we know
            // on which thread it needs to run.
            getRunQueue().postDelayed(action, delayMillis);
        }
    }
}
</code></pre>
<p>注意：<code>scheduleDrawable</code> 基于执行的目标时间 <code>when</code>，和当前系统时钟计算了delay，又额外调整了delay时间, <code>Choreographer.subtractFrameDelay(delay)</code>，_
它是隐藏API_</p>
<pre><code class="language-java">public final class Choreographer {
    private static final long DEFAULT_FRAME_DELAY = 10;
    // The number of milliseconds between animation frames.
    private static volatile long sFrameDelay = DEFAULT_FRAME_DELAY;

    public static long subtractFrameDelay(long delayMillis) {
        final long frameDelay = sFrameDelay;
        return delayMillis &lt;= frameDelay ? 0 : delayMillis - frameDelay;
    }
}
</code></pre>
<p>设计一个简单的验证代码：</p>
<pre><code class="language-kotlin">class Demo {
    //...

    fun test() {
        val btn = findViewById&lt;Button&gt;(R.id.btn)
        var index = 0
        var s = System.currentTimeMillis()

        val action: Runnable = object : Runnable {
            override fun run() {
                Log.e("lmsg", "$index, offset time ${System.currentTimeMillis() - s - index * 30}")
                index++
                if (index &lt; 100) {
                    btn.postOnAnimationDelayed(
                        this,
                        30L - 10L /*hide api:android.view.Choreographer#subtractFrameDelay*/
                    )
                } else {
                    Log.e("lmsg", "finish, total time ${System.currentTimeMillis() - s}")

                }
            }
        }

        btn.setOnClickListener {
            index = 0
            s = System.currentTimeMillis()
            it.postOnAnimationDelayed(action, 0L)
        }
    }
}
</code></pre>
<p>参考一下结果：<em>注意执行结果不会幂等，但整体表现为超出预期时长</em></p>
<p><img src="Android/Drawable/./post_47/result_1.png" alt="" /></p>
<h2 id="思退使用animator改进"><a class="header" href="#思退使用animator改进">思退：使用Animator改进</a></h2>
<p>Android 在 <code>Android 3.0，API11</code> 中提供了更强大的动画 <code>Animator</code>，借助其中的 <code>ValueAnimator</code>，可以很方便的 <code>编排</code> 动画。</p>
<p><em>即便尚未分析原理，只要使用过属性动画，也知道它具有非常丝滑的效果</em></p>
<p>以上还都是推测，接下来进行实测。</p>
<h3 id="实现"><a class="header" href="#实现">实现</a></h3>
<p>刨去一致部分，我们需要完成以下两点：</p>
<ul>
<li>创建 <code>ValueAnimator</code> 实例，并按照动画需求设置 <code>时长</code>、<code>插值器</code>、<code>UpdateListener</code> 等</li>
<li>若没有额外需要，可将 <code>Animatable2</code> 弱化为 <code>Animatable</code>，仅保留动画控制API，通过 <code>ValueAnimator</code> 实例委托实现API业务逻辑。</li>
</ul>
<p>核心代码如下： <em>完整代码可从github获取：<a href="https://github.com/leobert-lan/DrawableWorkShop">DrawableWorkShop</a></em></p>
<pre><code class="language-kotlin">class AnimLetterDrawable2 : Drawable(), Animatable {
    // 相似部分略去

    private val totalFrames = 30 * 3 //3 second, 30frames per second

    private val valueAnimator = ValueAnimator.ofInt(totalFrames).apply {
        duration = 3000L

        this.interpolator = LinearInterpolator()

        addUpdateListener {
            setFrame(it.animatedValue as Int)
        }
    }

    private var frameIndex = 0


    private fun setFrame(frame: Int) {
        if (frame &gt;= totalFrames) {
            return
        }
        frameIndex = frame
        invalidateSelf()
    }

    override fun start() {
        Log.d(tag, "start called")
        valueAnimator.start()
    }

    override fun stop() {
        valueAnimator.cancel()
        setFrame(0)
    }

    override fun isRunning(): Boolean {
        return valueAnimator.isRunning
    }

}
</code></pre>
<h3 id="效果和关键代码对比"><a class="header" href="#效果和关键代码对比">效果和关键代码对比</a></h3>
<img width="216" height="384" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f38dfc6780fd45c38edccc91fcd6d0ea~tplv-k3u1fbpfcp-watermark.image?"/>
<p>gif的效果太差，可以在 <a href="https://github.com/leobert-lan/DrawableWorkShop/blob/main/DrawableWorkShop/animator%E6%95%88%E6%9E%9C.webm">github项目仓库</a>
中获取 webm视频</p>
<p>关键代码差异：</p>
<p>在原方案中，我们计算了下一帧的播放时间点，借助 <code>scheduleSelf</code> -&gt; <code>View#scheduleDrawable</code> 进行了刷新</p>
<pre><code class="language-kotlin">class AnimLetterDrawable {
    private fun setFrame(frame: Int, unschedule: Boolean, animate: Boolean) {
        if (frame &gt;= totalFrames) {
            return
        }
        mAnimating = animate
        frameIndex = frame

        if (unschedule || animate) {
            unscheduleSelf(this)
        }
        if (animate) {
            // Unscheduling may have clobbered these values; restore them
            frameIndex = frame

            scheduleSelf(this, SystemClock.uptimeMillis() + durationPerFrame)
        }
        invalidateSelf()
    }
}
</code></pre>
<p>而新方案中，我们借助ValueAnimator的更新回调函数直接刷新，显示预定帧</p>
<pre><code class="language-kotlin">class AnimLetterDrawable2 {
    private val valueAnimator = ValueAnimator.ofInt(totalFrames).apply {
        duration = 3000L

        this.interpolator = LinearInterpolator()

        addUpdateListener {
            setFrame(it.animatedValue as Int)
        }
    }

    private fun setFrame(frame: Int) {
        if (frame &gt;= totalFrames) {
            return
        }
        frameIndex = frame
        invalidateSelf()
    }
}
</code></pre>
<h2 id="animator的原理"><a class="header" href="#animator的原理">Animator的原理</a></h2>
<p>此时，再来思索一番，为何 <code>Animator</code> 的实现效果明显丝滑呢？</p>
<blockquote>
<p>思危：是否和scheduleDrawable相比使用了不一样的底层机制？</p>
</blockquote>
<h3 id="源码跟进"><a class="header" href="#源码跟进">源码跟进</a></h3>
<p>单纯阅读文章内的代码会很枯燥，建议读者诸君对文中列出的源码进行泛读，抓住思路后再精读一遍源码。</p>
<p>以下将有6个关键点，可厘清其原理</p>
<ul>
<li>1，start方法 -- 找到动画被驱动的核心</li>
<li>2， AnimationHandler#addAnimationFrameCallback(AnimationFrameCallback)</li>
<li>3，<code>mAnimationCallbacks</code> 何时移除元素</li>
<li>4，<code>AnimationHandler#doAnimationFrame</code> 方法的逻辑</li>
<li>5，向前看，何人调用FrameCallback -- 驱动动画的底层逻辑</li>
<li>6，向后看，ValueAnimator#doAnimationFrame -- 丝滑的原因</li>
</ul>
<h4 id="1start方法"><a class="header" href="#1start方法">1，start方法</a></h4>
<pre><code class="language-java">class ValueAnimator {

    public void start() {
        start(false);
    }

    private void start(boolean playBackwards) {
        if (Looper.myLooper() == null) {
            throw new AndroidRuntimeException("Animators may only be run on Looper threads");
        }
        //略去一部分
        addAnimationCallback(0); //这里是核心

        if (mStartDelay == 0 || mSeekFraction &gt;= 0 || mReversing) {
            startAnimation();
            if (mSeekFraction == -1) {
                setCurrentPlayTime(0);
            } else {
                setCurrentFraction(mSeekFraction);
            }
        }
    }

    private void addAnimationCallback(long delay) {
        //startWithoutPulsing 才会return
        if (!mSelfPulse) {
            return;
        }
        getAnimationHandler().addAnimationFrameCallback(this, delay); //这里是核心
    }
}
</code></pre>
<p>简单阅读，可以排除掉 <code>startAnimation</code> <code>setCurrentPlayTime</code> <code>setCurrentFraction</code>，他们均不是动画回调的核心，只是在进行必要地初始化和FLAG状态维护。</p>
<p>真正的核心是：<code>getAnimationHandler().addAnimationFrameCallback(this, delay);</code></p>
<p>注意：AnimationHandler 存在线程单例设计:</p>
<pre><code class="language-java">
//使用方：
class ValueAnimator {
    public AnimationHandler getAnimationHandler() {
        return mAnimationHandler != null ? mAnimationHandler : AnimationHandler.getInstance();
    }
}

//ThreadLocal线程单例设计
class AnimationHandler {
    public final static ThreadLocal&lt;AnimationHandler&gt; sAnimatorHandler = new ThreadLocal&lt;&gt;();
    private boolean mListDirty = false;

    public static AnimationHandler getInstance() {
        if (sAnimatorHandler.get() == null) {
            sAnimatorHandler.set(new AnimationHandler());
        }
        return sAnimatorHandler.get();
    }
}
</code></pre>
<h4 id="2-animationhandleraddanimationframecallbackanimationframecallback"><a class="header" href="#2-animationhandleraddanimationframecallbackanimationframecallback">2, AnimationHandler#addAnimationFrameCallback(AnimationFrameCallback)</a></h4>
<p>方法逻辑中，有两处需要关注：</p>
<ul>
<li><strong>如果无 <code>AnimationFrameCallback</code> 回调实例</strong> ， <em>说明没有在运行中的动画</em> ，<strong>则挂载 <code>Choreographer.FrameCallback mFrameCallback</code></strong> ， 为更新动画（_
调用动画的AnimationFrameCallback回调接口_）做准备。</li>
<li><strong>在动画的 <code>AnimationFrameCallback</code> 回调实例未被注册的情况下</strong>，注册该回调实例</li>
</ul>
<p>看完这一段源码，读者诸君一定会对以下两点产生兴趣，我们在下文展开：</p>
<ul>
<li><code>doAnimationFrame</code> 方法的逻辑</li>
<li><code>mAnimationCallbacks</code> 何时移除元素</li>
</ul>
<p>先看源码：</p>
<pre><code class="language-java">public class AnimationHandler {
    private final Choreographer.FrameCallback mFrameCallback = new Choreographer.FrameCallback() {
        @Override
        public void doFrame(long frameTimeNanos) {
            doAnimationFrame(getProvider().getFrameTime());

            //这不就破案了，只要还有动画的 AnimationFrameCallback，就挂载 mFrameCallback

            if (mAnimationCallbacks.size() &gt; 0) {
                getProvider().postFrameCallback(this);
            }
        }
    };

    private AnimationFrameCallbackProvider getProvider() {
        if (mProvider == null) {
            mProvider = new MyFrameCallbackProvider();
        }
        return mProvider;
    }

    public void addAnimationFrameCallback(final AnimationFrameCallback callback, long delay) {
        if (mAnimationCallbacks.size() == 0) {
            getProvider().postFrameCallback(mFrameCallback);
        }
        if (!mAnimationCallbacks.contains(callback)) {
            mAnimationCallbacks.add(callback);
        }

        //注意，delay为0，阅读时可以忽略这段逻辑
        if (delay &gt; 0) {
            mDelayedCallbackStartTime.put(callback, (SystemClock.uptimeMillis() + delay));
        }
    }
}
</code></pre>
<h4 id="3manimationcallbacks-何时移除元素"><a class="header" href="#3manimationcallbacks-何时移除元素">3，<code>mAnimationCallbacks</code> 何时移除元素</a></h4>
<p>AnimationHandler中 "清理" <code>mAnimationCallbacks</code> 的设计 : 先设置null，再择机集中清理null，维护链表结构。<em>可以避免循环过程中移除元素带来的潜在bug、以及避免频繁调整链表空间带来的损耗</em></p>
<p>关键代码为：<code>android.animation.AnimationHandler#removeCallback</code>，它有两处调用点，看完下面这一段源码后再行分析。</p>
<pre><code class="language-java">class AnimationHandler {
    public void removeCallback(AnimationFrameCallback callback) {
        mCommitCallbacks.remove(callback);
        mDelayedCallbackStartTime.remove(callback);
        int id = mAnimationCallbacks.indexOf(callback);
        if (id &gt;= 0) {
            mAnimationCallbacks.set(id, null);
            mListDirty = true;
        }
    }

    private void cleanUpList() {
        if (mListDirty) {
            for (int i = mAnimationCallbacks.size() - 1; i &gt;= 0; i--) {
                if (mAnimationCallbacks.get(i) == null) {
                    mAnimationCallbacks.remove(i);
                }
            }
            mListDirty = false;
        }
    }
}
</code></pre>
<p><code>removeCallback</code> 存在一个直接调用，进而可找到两个间接调用点：</p>
<ul>
<li><code>endAnimation</code> 停止动画时, 主动停止以及计算出动画已结束</li>
<li><code>doAnimationFrame</code> 中发现动画已经被暂停</li>
</ul>
<p><em>再看一下源码：</em></p>
<pre><code class="language-java">class ValueAnimator {
    private void removeAnimationCallback() {
        if (!mSelfPulse) {
            return;
        }
        //直接调用-1
        getAnimationHandler().removeCallback(this);
    }

    private void endAnimation() {
        if (mAnimationEndRequested) {
            return;
        }
        //间接调用-1
        removeAnimationCallback();
        //略去
    }

    public final boolean doAnimationFrame(long frameTime) {
        if (mStartTime &lt; 0) {
            // First frame. If there is start delay, start delay count down will happen *after* this
            // frame.
            mStartTime = mReversing
                    ? frameTime
                    : frameTime + (long) (mStartDelay * resolveDurationScale());
        }

        // Handle pause/resume
        if (mPaused) {
            mPauseTime = frameTime;
            //间接调用-2
            removeAnimationCallback();
            return false;
        }
        //略
    }
}
</code></pre>
<h4 id="4animationhandlerdoanimationframe-方法的逻辑"><a class="header" href="#4animationhandlerdoanimationframe-方法的逻辑">4，<code>AnimationHandler#doAnimationFrame</code> 方法的逻辑</a></h4>
<p>一共有三个业务目的：</p>
<ul>
<li>筛选，调用回调</li>
<li>处理 CommitCallback 情况</li>
<li>清理 <code>mAnimationCallbacks</code> 详见3</li>
</ul>
<pre><code class="language-java">class AnimationHandler {
    private void doAnimationFrame(long frameTime) {
        long currentTime = SystemClock.uptimeMillis();
        final int size = mAnimationCallbacks.size();
        for (int i = 0; i &lt; size; i++) {
            final AnimationFrameCallback callback = mAnimationCallbacks.get(i);

            // `为何会有null？` 请看3 `mAnimationCallbacks` 何时移除元素
            if (callback == null) {
                continue;
            }

            //如果是延迟执行的callback，在未到预定时间时为false
            if (isCallbackDue(callback, currentTime)) {

                // 回调，实际逻辑：android.animation.ValueAnimator#doAnimationFrame
                callback.doAnimationFrame(frameTime);

                // 此处值得再写一篇文章
                if (mCommitCallbacks.contains(callback)) {
                    getProvider().postCommitCallback(new Runnable() {
                        @Override
                        public void run() {
                            commitAnimationFrame(callback, getProvider().getFrameTime());
                        }
                    });
                }
            }
        }
        cleanUpList();
    }

    private void commitAnimationFrame(AnimationFrameCallback callback, long frameTime) {
        if (!mDelayedCallbackStartTime.containsKey(callback) &amp;&amp;
                mCommitCallbacks.contains(callback)) {
            callback.commitAnimationFrame(frameTime);
            mCommitCallbacks.remove(callback);
        }
    }
}
</code></pre>
<blockquote>
<p>作者按：值得一提的是，AnimationHandler中定义了所谓的 <code>OneShotCommitCallback</code> ，均添加到 <code>mCommitCallbacks</code>中。</p>
<p>ValueAnimator 中曾利用它调整动画起始帧回调</p>
<p>SDK 24 、25 中明确存在，从26直至32均未发现使用。注意，我此次翻阅源码时较为粗略，仍需详查 <code>android.animation.ValueAnimator#addOneShotCommitCallback</code> 方可定论，如有谬误还请读者指出，避免误导。</p>
</blockquote>
<h4 id="5向前看何人调用framecallback"><a class="header" href="#5向前看何人调用framecallback">5，向前看，何人调用FrameCallback</a></h4>
<p>跟进 <code>getProvider().postFrameCallback(mFrameCallback);</code> 发现是暗度陈仓</p>
<pre><code class="language-java">class AnimationHandler {
    private AnimationFrameCallbackProvider getProvider() {
        if (mProvider == null) {
            mProvider = new MyFrameCallbackProvider();
        }
        return mProvider;
    }

    private class MyFrameCallbackProvider implements AnimationFrameCallbackProvider {

        final Choreographer mChoreographer = Choreographer.getInstance();

        @Override
        public void postFrameCallback(Choreographer.FrameCallback callback) {
            mChoreographer.postFrameCallback(callback);
        }

        @Override
        public void postCommitCallback(Runnable runnable) {
            mChoreographer.postCallback(Choreographer.CALLBACK_COMMIT, runnable, null);
        }

        @Override
        public long getFrameTime() {
            return mChoreographer.getFrameTime();
        }

        @Override
        public long getFrameDelay() {
            return Choreographer.getFrameDelay();
        }

        @Override
        public void setFrameDelay(long delay) {
            Choreographer.setFrameDelay(delay);
        }
    }
}
</code></pre>
<p>又见 <code>Choreographer</code> ，这回应该不陌生了，跟进代码：</p>
<pre><code class="language-java">class Choreographer {
    public void postFrameCallback(FrameCallback callback) {
        postFrameCallbackDelayed(callback, 0);
    }

    public void postFrameCallbackDelayed(FrameCallback callback, long delayMillis) {
        if (callback == null) {
            throw new IllegalArgumentException("callback must not be null");
        }

        postCallbackDelayedInternal(CALLBACK_ANIMATION,
                callback, FRAME_CALLBACK_TOKEN, delayMillis);
    }
}
</code></pre>
<p>值得注意的是：此次使用的是：<code>CALLBACK_ANIMATION</code></p>
<p><code>Choreographer</code> 中将Callback一共 <strong>分为5类</strong></p>
<ul>
<li>CALLBACK_INPUT = 0;</li>
<li>CALLBACK_ANIMATION = 1;</li>
<li>CALLBACK_INSETS_ANIMATION = 2;</li>
<li>CALLBACK_TRAVERSAL = 3;</li>
<li>CALLBACK_COMMIT = 4;</li>
</ul>
<p>回调时的顺序也是如此。</p>
<p>读者诸君可还记得前文给出的 <code>基于消息机制处理UI绘制</code> 的关键流程图？其中多次出现关键字样：<code>TRAVERSAL</code>，对应此处的 <code>CALLBACK_TRAVERSAL</code>，它负责界面布局和绘制相关的业务。</p>
<p>而在上文 <code>View#scheduleDrawable</code> 的分析中，发现它使用的类型为：<code>Choreographer.CALLBACK_ANIMATION</code>，<strong>和 Animator 是一致的！</strong></p>
<blockquote>
<p>至此，我们悬着的心可以放下，Animator 和 View#scheduleDrawable 相比，使用了同样的底层机制</p>
</blockquote>
<p>但是我们的疑问尚未得到答案，再顺着整个流程向后看。</p>
<h4 id="6向后看valueanimatordoanimationframe"><a class="header" href="#6向后看valueanimatordoanimationframe">6，向后看，ValueAnimator#doAnimationFrame</a></h4>
<p><em>作者按，以API25之后的源码解析，以下源码为API30，注意24之前、24&amp;25，均存在差异，主要体现为首帧的开始。省略部分不重要的源码细节</em></p>
<p><em>不难发现，重点部分为：<code>animateBasedOnTime(currentTime)</code></em></p>
<pre><code class="language-java">class ValueAnimator {
    public final boolean doAnimationFrame(long frameTime) {
        if (mStartTime &lt; 0) {
            // First frame. If there is start delay, start delay count down will happen *after* this
            // frame.
            mStartTime = mReversing
                    ? frameTime
                    : frameTime + (long) (mStartDelay * resolveDurationScale());
        }

        // Handle pause/resume
        //省略 暂停、恢复的处理

        if (!mRunning) {
            //省略，判断是否可以开始播放首帧
        }

        if (mLastFrameTime &lt; 0) {
            //省略，处理动画是否seek的情况
        }
        mLastFrameTime = frameTime;

        // The frame time might be before the start time during the first frame of
        // an animation.  The "current time" must always be on or after the start
        // time to avoid animating frames at negative time intervals.  In practice, this
        // is very rare and only happens when seeking backwards.
        final long currentTime = Math.max(frameTime, mStartTime);

        //此处为重点
        boolean finished = animateBasedOnTime(currentTime);

        //完毕的处理
        if (finished) {
            endAnimation();
        }
        return finished;
    }
}
</code></pre>
<p>继续抓住重点：<code>animateBasedOnTime(currentTime)</code></p>
<pre><code class="language-java">class ValueAnimator {
    boolean animateBasedOnTime(long currentTime) {
        boolean done = false;
        if (mRunning) {
            //确定lastFraction、fraction
            final long scaledDuration = getScaledDuration();
            
            //差别在这里 
            final float fraction = scaledDuration &gt; 0 ?
                    (float) (currentTime - mStartTime) / scaledDuration : 1f;
            final float lastFraction = mOverallFraction;

            //确定轮播迭代标记
            final boolean newIteration = (int) fraction &gt; (int) lastFraction;
            final boolean lastIterationFinished = (fraction &gt;= mRepeatCount + 1) &amp;&amp;
                    (mRepeatCount != INFINITE);

            // 确定 done
            if (scaledDuration == 0) {
                // 0 duration animator, ignore the repeat count and skip to the end
                done = true;
            } else if (newIteration &amp;&amp; !lastIterationFinished) {
                // Time to repeat
                if (mListeners != null) {
                    int numListeners = mListeners.size();
                    for (int i = 0; i &lt; numListeners; ++i) {
                        mListeners.get(i).onAnimationRepeat(this);
                    }
                }
            } else if (lastIterationFinished) {
                done = true;
            }

            //确定fraction 重点1
            mOverallFraction = clampFraction(fraction);
            float currentIterationFraction = getCurrentIterationFraction(
                    mOverallFraction, mReversing);

            //重点2
            animateValue(currentIterationFraction);
        }
        return done;
    }
}
</code></pre>
<p>此处有两处重点：</p>
<ul>
<li>确定 currentIterationFraction</li>
<li>animateValue 执行动画帧</li>
</ul>
<p>看重点1：<em>泛读即可，主要理解fraction的设计</em></p>
<pre><code class="language-java">class ValueAnimator {
    private float clampFraction(float fraction) {
        if (fraction &lt; 0) {
            fraction = 0;
        } else if (mRepeatCount != INFINITE) {
            fraction = Math.min(fraction, mRepeatCount + 1);
        }
        return fraction;
    }

    //重点1 整数部分代表iteration，小数部分代表当前iteration的fraction
    private float getCurrentIterationFraction(float fraction, boolean inReverse) {
        fraction = clampFraction(fraction);
        int iteration = getCurrentIteration(fraction);
        float currentFraction = fraction - iteration;
        return shouldPlayBackward(iteration, inReverse)
                ? 1f - currentFraction
                : currentFraction;
    }

    //依据是fraction和iteration的设计：
    //    Calculates current iteration based on the overall fraction. 
    //    The overall fraction will be in the range of [0, mRepeatCount + 1]. 
    //    Both current iteration and fraction in the current iteration can be derived from it.
    private int getCurrentIteration(float fraction) {
        fraction = clampFraction(fraction);
        // If the overall fraction is a positive integer, we consider the current iteration to be
        // complete. In other words, the fraction for the current iteration would be 1, and the
        // current iteration would be overall fraction - 1.
        double iteration = Math.floor(fraction);
        if (fraction == iteration &amp;&amp; fraction &gt; 0) {
            iteration--;
        }
        return (int) iteration;
    }

    //和动画正向、反向播放有关，可先忽略
    private boolean shouldPlayBackward(int iteration, boolean inReverse) {
        if (iteration &gt; 0 &amp;&amp; mRepeatMode == REVERSE &amp;&amp;
                (iteration &lt; (mRepeatCount + 1) || mRepeatCount == INFINITE)) {
            // if we were seeked to some other iteration in a reversing animator,
            // figure out the correct direction to start playing based on the iteration
            if (inReverse) {
                return (iteration % 2) == 0;
            } else {
                return (iteration % 2) != 0;
            }
        } else {
            return inReverse;
        }
    }
}
</code></pre>
<p>看重点2：</p>
<pre><code class="language-java">class ValueAnimator {
    void animateValue(float fraction) {
        //插值器重新计算fraction -- 优雅的设计
        fraction = mInterpolator.getInterpolation(fraction);
        mCurrentFraction = fraction;
        int numValues = mValues.length;
        
        //PropertyValuesHolder 计算value -- 又是一个优雅的设计
        for (int i = 0; i &lt; numValues; ++i) {
            mValues[i].calculateValue(fraction);
        }
        
        //回调，onAnimationUpdate 常用到 getAnimatedValue，和 calculateValue 对应
        if (mUpdateListeners != null) {
            int numListeners = mUpdateListeners.size();
            for (int i = 0; i &lt; numListeners; ++i) {
                mUpdateListeners.get(i).onAnimationUpdate(this);
            }
        }
    }
}
</code></pre>
<h3 id="阶段性小结"><a class="header" href="#阶段性小结">阶段性小结</a></h3>
<p>源码内容着实很多，经过刚才的源码重点拆解，也已梳理出大致流程。</p>
<p>回归到我们阅读源码前的问题：</p>
<blockquote>
<p>Animator 是否和scheduleDrawable相比使用了不一样的底层机制？</p>
<p>否, 均使用了 <strong>Choreographer</strong> <em>[ˌkɔːriˈɑːɡrəfər],记住它的读写</em> + <strong>Vsync</strong> + <strong>Android 消息机制</strong> ，且回调类型一致，均为 <code>CALLBACK_ANIMATION</code></p>
<p>为何更加丝滑？</p>
<p>动画内部调用频次 ≥ 原方案，回调时依据时间计算帧号的算法更加准确合理</p>
</blockquote>
<p><code>ValueAnimator#animateBasedOnTime</code> 中，使用了准确、合理的计算方式 ：<code>final float fraction = scaledDuration &gt; 0 ? (float) (currentTime - mStartTime) / scaledDuration : 1f;</code></p>
<p>而先前文章中的代码，并没有依据当前实际时间调整帧。</p>
<h2 id="思变打开思路"><a class="header" href="#思变打开思路">思变：打开思路</a></h2>
<p>至此，动画的核心奥秘已经揭开，似乎一切已尽在不言中，轮子也均已完备，也并不需要再额外实现一套插值器、估值器逻辑。</p>
<p>既然如此，我们不再对第一篇中的例子进行以下改进："依据时间调整帧"，"提升回调频率"。</p>
<p><em>作者按：如果下次计划写插值器、估值器的文章，可能以逐步完善造轮子的方式进行内容展开</em></p>
<p>那么本篇的核心内容，除了面试或者给同事科普外，还能带来什么呢？</p>
<p>整体回顾一下，并打开思路：</p>
<ol>
<li>我们从一个实例出发进行完善，并收获一个经验：可以通过 Drawable+Animator，将动画内容推广到任意View做显示，<em>如果没有必要，可以少做一些自定义View的事情</em>。</li>
<li>分析了Drawable更新内容的底层实现，是否可以将这种动画效果推广到更多地方呢？例如 <code>TextView的DrawableStart</code>、<code>ImageSpan</code>，<strong>是否都能正确显示动效呢</strong>？，<strong>如果不能要怎么做？</strong></li>
<li>我们分析动画被驱动的过程中，遇到一个宝藏 <code>Choreographer</code>，是否可以拿来干点有趣的事情？例如：<strong>FPS监测</strong></li>
<li>将ValueAnimator的核心机制复刻，在别的平台搞点好玩的东西😂</li>
<li>在<code>视觉呈现内容</code> 与 <code>时间</code> 的函数关系确定时，使用 <code>ValueAnimator</code> 作为核心驱动，将问题变为一个纯数学问题，例如 <code>点迹动效绘制</code>，<code>全景图锚点A到锚点B之间的渐变</code></li>
<li>融合以上内容，自定义一套数据协议，解析后，所见皆可动起来</li>
</ol>
<h2 id="闲话一二"><a class="header" href="#闲话一二">闲话一二</a></h2>
<p>文中出现的源码，除去AOSP部分，均收录于仓库中：<a href="https://github.com/leobert-lan/DrawableWorkShop">DrawableWorkShop</a></p>
<p>最近还处于瓶颈之中，我花了大约半年的时间，让自己 "慢" 下来，却还没有做到真正松弛下来，礼记中言："张而不弛，文武弗能也；弛而不张，文武弗为也；一张一弛，文武之道也。"</p>
<p>有两个方面的瓶颈，让我颇为难受：</p>
<ul>
<li>"输出质量的高期望" 与 "输入、知识体系存货达不到更高层次" 之间的矛盾带来的内容瓶颈</li>
<li>"不同读者需要的知识深度不同" 与 "博客内容提纲不能照顾到各个深度" 之间的矛盾带来的编写瓶颈</li>
</ul>
<p>我还需要调整好节奏、捋一捋下一个五年，再进行知识重整合，才能先驰后张，输出更有意义的内容，这能解决第一个瓶颈问题。但第二个瓶颈问题，确实没找到办法。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="好玩系列让imagespan动起来"><a class="header" href="#好玩系列让imagespan动起来">好玩系列：让ImageSpan动起来</a></h1>
<h2 id="前言-7"><a class="header" href="#前言-7">前言</a></h2>
<p>前不久，我写过一篇文章：<a href="https://juejin.cn/post/7155690991721119781">迟来的续集--Drawable+Animator，将优雅进行到底</a> , 并在其中留下一个思考题："
用 动画Drawable 是否可以让 ImageSpan 直接动起来"</p>
<p>相信大家也进行了尝试，并且不出意外地出现了意外！即便使用可以动起来的Drawable构建ImageSpan，也没有让他动起来！</p>
<img width="220" alt="问题不大" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8310c4177171446a92661e4e576df8ae~tplv-k3u1fbpfcp-watermark.image?"/>
<p>今天我们将在一个愉快的氛围下，让ImageSpan动起来，并进行一些更深层次的探索，不出意外，这将是Drawable相关文章的终结篇。</p>
<p>另外，有几篇相关文章可以作为扩展阅读：</p>
<ul>
<li><a href="https://juejin.cn/post/6924240361317466125">三思系列：重新认识Drawable</a></li>
<li><a href="https://juejin.cn/post/6934222774139518984">三思系列：为什么要自定义View </a></li>
</ul>
<h2 id="是否用得上"><a class="header" href="#是否用得上">是否用得上</a></h2>
<blockquote>
<p>"学而时习之，不亦说乎" -- 《论语-学而》</p>
</blockquote>
<p>Span是Android中实现富文本的一种方式，读者诸君请注意，<strong>是一种方式而不是唯一方式！</strong>
除却Span机制，依旧有其他形式展现富文本。</p>
<p>但不可否认：Span是非常轻量的一种方式，虽然这种 <code>脱离展示容器的轻量</code> 使得它的设计并不简单，
导致了简单使用它时很方便，重度使用它时 <strong>难以如指臂使</strong> ，并会遭遇性能瓶颈。</p>
<blockquote>
<p>以Juejin为例，只要我持续创作读者感兴趣的内容，我相信终有一天会解锁Lv10级作者，那么：</p>
<p>"在APP上给我颁发一个会闪烁的徽章，并追加在昵称后，以显示身份"，包括不限于：我的主页、文章作者栏、评论区、文章中 @我 的地方</p>
<p>这个功能似乎很合情合理😆。</p>
</blockquote>
<p>用ImageSpan方案实现这一需求也很合理，并且这一解析、展示方案可以多处复用，并不需要四处精心维护布局。<em>虽然juejin并未这样做😂</em></p>
<p><em>简单盘算后，今天的知识一定有使用的前景，稳赚不亏！</em></p>
<h2 id="制造一个翻车现场"><a class="header" href="#制造一个翻车现场">制造一个翻车现场</a></h2>
<p>还是借助先前的项目：<a href="https://github.com/leobert-lan/DrawableWorkShop">DrawableWorkShop</a> ，先制作一个翻车现场。</p>
<p>在上一篇文章中，我们已经完成了动画Drawable，正好利用它生成ImageSpan。我们再增加DrawableStart 用作对比。</p>
<p>关键代码如下：</p>
<pre><code class="language-kotlin">val tvSpan = findViewById&lt;TextView&gt;(R.id.tv_span)

val drawable = createADrawable()
val imgSpan = ImageSpan(drawable)

val ss = SpannableString("ImageSpan *")
ss.setSpan(imgSpan, 10, 11, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE)
tvSpan.text = ss

val drawableStart = createADrawable()
tvSpan.setCompoundDrawables(drawableStart, null, null, null)

tvSpan.setOnClickListener {
    drawable.start()
    drawableStart.start()
}

fun createADrawable(): AnimLetterDrawable2 {
    val drawable = AnimLetterDrawable2()
    drawable.textSize = 20f
    drawable.letters = "span"
    drawable.setBounds(0, 0, 100, 100)
    return drawable
}
</code></pre>
<p>点击TextView开启动画，好，果然翻车了！ImageSpan并未动起来，而DrawableStart动起来了。</p>
<h2 id="温故而知新----原因分析"><a class="header" href="#温故而知新----原因分析">温故而知新 -- 原因分析</a></h2>
<p>在前两篇相关文章中，我们已经窥探到动画的原理：</p>
<blockquote>
<p>按照特定的时间序列绘制对应帧，利用视觉暂留形成动画效果</p>
</blockquote>
<p>无论是控件的属性动画、还是Drawable动画，其本质均为此。在前两篇文章中，我们分别用了两种方式驱动Drawable形成动画效果，稍作复习：</p>
<ul>
<li>基于 <code>Drawable#scheduleSelf</code> API，向宿主View <code>Post</code> 一个延迟执行的 <code>Runnable</code> 业务逻辑为重新绘制。在Handler消息机制的驱动下, <code>Choreographer</code> 实现了动画基本原理</li>
<li>基于 <code>ValueAnimator</code>，按照时序执行回调，业务逻辑为重新绘制。依旧是借助Handler消息机制的驱动, <code>Choreographer</code> 实现动画基本原理。</li>
</ul>
<p>此时，可以做出大胆的假设：<strong>问题本质是没有正确重新绘制</strong>。</p>
<p>在前文中，我们已经知道，Drawable重新绘制的核心是 <code>invalidateSelf()</code>：</p>
<pre><code class="language-java">class Drawable {
    public void invalidateSelf() {
        final Callback callback = getCallback();
        if (callback != null) {
            callback.invalidateDrawable(this);
        }
    }
}
</code></pre>
<p>而该API借助了 <code>Drawable.Callback</code> 委托实现。</p>
<p>Debug之后可以发现，<strong>配合ImageSpan使用时，Drawable并未持有Callback实例</strong> 。</p>
<p>对比参考TextView设置DrawableStart的相关核心代码，忽略掉无关细节，其中调用了 <code>Drawable#setCallback(this)</code> ：</p>
<pre><code class="language-java">class TextView {
    private void setRelativeDrawablesIfNeeded(Drawable start, Drawable end) {
        boolean hasRelativeDrawables = (start != null) || (end != null);
        if (hasRelativeDrawables) {
            //ignore 
            if (start != null) {
                //ignore

                //重点
                start.setCallback(this);

                //ignore
            } else {
                dr.mDrawableSizeStart = dr.mDrawableHeightStart = 0;
            }
            if (end != null) {
                //ignore
                end.setCallback(this);

                //ignore
            } else {
                dr.mDrawableSizeEnd = dr.mDrawableHeightEnd = 0;
            }
            //ignore
        }
    }
}
</code></pre>
<p>至此，推测得到验证。</p>
<h2 id="直面问题----以最简单的代码让imagespan动起来"><a class="header" href="#直面问题----以最简单的代码让imagespan动起来">直面问题 -- 以最简单的代码让ImageSpan动起来</a></h2>
<p>才思敏捷的读者可能已经想到，给ImageSpan内部的Drawable设置Callback不就可以了吗？就像这样：</p>
<pre><code class="language-kotlin"> tvSpan.setOnClickListener {
    //设置Callback
    drawable.callback = it

    drawable.start()
    //屏蔽掉DrawableStart的干扰
    // drawableStart.start()
}
</code></pre>
<img width="220" alt="没有问题" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ecbfafbe0104f23b8db06e31446195a~tplv-k3u1fbpfcp-watermark.image?"/>
<p>当你自信满满的尝试了一下，哎呀，又TM翻车了！！！</p>
<img width="220" alt="全是问题" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4959e7c21de4b7e8d41173c53210dbc~tplv-k3u1fbpfcp-watermark.image?"/>
<h3 id="翻车原因"><a class="header" href="#翻车原因">翻车原因</a></h3>
<p>让我们再复习一下：</p>
<pre><code class="language-java">public class View {
    public void invalidateDrawable(@NonNull Drawable drawable) {
        //看这里的校验
        if (verifyDrawable(drawable)) {
            final Rect dirty = drawable.getDirtyBounds();
            final int scrollX = mScrollX;
            final int scrollY = mScrollY;

            //这里是刷新
            invalidate(dirty.left + scrollX, dirty.top + scrollY,
                    dirty.right + scrollX, dirty.bottom + scrollY);
            rebuildOutline();
        }
    }

    protected boolean verifyDrawable(@NonNull Drawable who) {
        // Avoid verifying the scroll bar drawable so that we don't end up in
        // an invalidation loop. This effectively prevents the scroll bar
        // drawable from triggering invalidations and scheduling runnables.
        return who == mBackground || (mForegroundInfo != null &amp;&amp; mForegroundInfo.mDrawable == who)
                || (mDefaultFocusHighlight == who);
    }
}
</code></pre>
<p>很显然，ImageSpan内包含的Drawable和TextView之间并无直接关联！</p>
<p><em>注意,TextView的判断逻辑存在重载，仅背景、聚焦效果、DrawableStart、DrawableTop、DrawableEnd、DrawableBottom 是有关联的：</em></p>
<pre><code class="language-java">class TextView {
    protected boolean verifyDrawable(@NonNull Drawable who) {
        final boolean verified = super.verifyDrawable(who);
        if (!verified &amp;&amp; mDrawables != null) {
            for (Drawable dr : mDrawables.mShowing) {
                if (who == dr) {
                    return true;
                }
            }
        }
        return verified;
    }
}
</code></pre>
<h3 id="暗度陈仓绕过校验"><a class="header" href="#暗度陈仓绕过校验">暗度陈仓，绕过校验</a></h3>
<p>才思敏捷的读者朋友一定想到了："既然是校验出的问题，那我绕过校验不就好了"，很快掏出了代码V2：</p>
<pre><code class="language-kotlin">tvSpan.setOnClickListener {
//            drawable.callback = it //这种方式无效，Drawable和TextView之间无关联
    drawable.callback = object : Drawable.Callback {
        override fun invalidateDrawable(who: Drawable) {
            //直接刷，绕过校验
            it.invalidate()
        }

        override fun scheduleDrawable(who: Drawable, what: Runnable, `when`: Long) {
            it.scheduleDrawable(who, what, `when`)
        }

        override fun unscheduleDrawable(who: Drawable, what: Runnable) {
            it.unscheduleDrawable(who, what)
        }

    }
    drawable.start()
//            drawableStart.start()
}
</code></pre>
<img width="220" alt="没有问题" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ecbfafbe0104f23b8db06e31446195a~tplv-k3u1fbpfcp-watermark.image?"/>
<p>果然，它动起来了！</p>
<p><em>作者按：让ImageSpan动起来的核心知识，到此已经结束，但知识的探索还未结束，下面将打开Span世界的大门</em></p>
<h2 id="优雅永恒的追求"><a class="header" href="#优雅永恒的追求">优雅，永恒的追求</a></h2>
<blockquote>
<p>我一直追求编程中的一种优雅：</p>
<ul>
<li>复杂度按必要程度分层展开，避免 没有必要的详细导致难以理解的复杂</li>
<li>井然有序，当代码不得不做出改变时，不因代码间没必要的耦合，加大变化难度</li>
</ul>
<p>而我们目前面对的问题，恰恰就是一个好机会，可以顺势研究源码，汲取知识，在此基础上，封装代码，更优雅地解决问题；并且在研究的过程中，可以摸索到其它知识模块。</p>
<p>这恰好可以通往第三境 <em>对于 <code>人生追求三境</code> ，我会在下一个杂篇和读者们交流一下心得</em></p>
</blockquote>
<h3 id="直接使用会带来的问题"><a class="header" href="#直接使用会带来的问题">直接使用会带来的问题</a></h3>
<h4 id="1虽然有效但耦合过重业务代码中不得不暴露过多无关代码"><a class="header" href="#1虽然有效但耦合过重业务代码中不得不暴露过多无关代码">1.虽然有效，但耦合过重，业务代码中不得不暴露过多无关代码</a></h4>
<p>我们已经使ImageSpan动起来了，那我多搞几个动态徽章没有问题吧。</p>
<p>将核心代码复刻，很快就得到了以下代码</p>
<img width="220" alt="没有问题" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ecbfafbe0104f23b8db06e31446195a~tplv-k3u1fbpfcp-watermark.image?"/>
<pre><code class="language-kotlin">val tvSpan2 = findViewById&lt;TextView&gt;(R.id.tv_span2)
val infoBuilder = SpannableStringBuilder().append("Leobert")

val madels = arrayListOf&lt;String&gt;("Lv.10", "持续创造", "笔耕不追", "夜以继日")
val drawables: List&lt;AnimLetterDrawable2&gt; = madels.map { madel -&gt;
    appendMadel(infoBuilder, madel).let { drawable -&gt;
        drawable.callback = object : Drawable.Callback {
            override fun invalidateDrawable(who: Drawable) {
                tvSpan2.invalidate()
            }
            //ignore
        }
        drawable
    }
}

tvSpan2.text = infoBuilder
tvSpan2.setOnClickListener {
    drawables.forEach {
        it.start()
    }
}

fun appendMadel(builder: SpannableStringBuilder, madel: String): AnimLetterDrawable2 {
    val drawable = AnimLetterDrawable2()
    //ignore

    val imgSpan = ImageSpan(drawable)
    val ss = SpannableString(" *")
    ss.setSpan(imgSpan, 1, 2, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE)
    builder.append(ss)

    //ignore，追加了一处ClickSpan，可以直观观测点击触发

    return drawable
}
</code></pre>
<p>您已经发现，为了让功能有效，我们不得不小心的设置回调，一旦有所疏漏，就会带来Bug。</p>
<blockquote>
<p>务必注意，仅用于显示时，我们尚可以说服自己不负责任地忽略 "不移除回调" 带来的负面影响，诸如无效刷新、内存泄露。</p>
<p>而在编辑时（如EditText中使用，并删除图片）、以及RecycleView中TextView复用（推广到可替换呈现内容的情况）
则不得不移除回调。否则轻则造成性能损耗和内存泄露，重则立现 UI bug。</p>
</blockquote>
<p><strong>可以想象，这样的代码太过于丑陋，过多的无关代码暴露在业务实现中</strong>。</p>
<h4 id="2影响复用"><a class="header" href="#2影响复用">2.影响复用</a></h4>
<p>Callback的唯一性导致ImageSpan不能被有效复用，还需要进行一定的改造。</p>
<p>虽然在理论上已经推断出这种做法会影响Drawable复用（以及Span的复用、进一步推广到Spannable的复用），仍旧以代码验证一下推论：</p>
<pre><code class="language-kotlin">val tvSpan3 = findViewById&lt;TextView&gt;(R.id.tv_span3)
// 沿用上文中构建的Spannable，它已经通过Callback和tvSpan2高度耦合，
// 我们希望这样的代码就可以完成目标，但显然目前无法完成
tvSpan3.text = infoBuilder
tvSpan3.setOnClickListener {
    drawables.forEach {
        it.start()
    }
}
tvSpan3.movementMethod = LinkMovementMethod.getInstance()
</code></pre>
<p>读者诸君可使用WorkShop自行尝试，不出意外的翻车了吧。</p>
<h3 id="1解决callback对复用的限制"><a class="header" href="#1解决callback对复用的限制">1.解决Callback对复用的限制</a></h3>
<p>显然，我们无法修改SDK的内容，但可以使用组合模式。</p>
<p>先定义一个回调接口，依赖抽象以解耦。</p>
<pre><code class="language-kotlin">interface OnRefreshListener {
    /**
     * will be called when a inner drawable of the span want to invalidate.
     *
     * @return true if the listener want to be called in future.
     * false otherwise
     */
    fun onRefresh(): Boolean
}
</code></pre>
<p>定义组合，仍旧以接口定义，以提升灵活度：</p>
<pre><code class="language-kotlin">interface OnRefreshListeners : OnRefreshListener {
    fun addRefreshListener(callback: OnRefreshListener)
    fun removeRefreshListener(callback: OnRefreshListener)
}
</code></pre>
<p>我们可以顺其自然的定义一个组合Callback实现如下：</p>
<pre><code class="language-kotlin">class DrawableCallbackComposer : OnRefreshListeners, Drawable.Callback {
    private val mRefreshListeners: MutableCollection&lt;OnRefreshListener&gt; = mutableListOf()

    override fun addRefreshListener(callback: OnRefreshListener) {
        mRefreshListeners.add(callback)
    }

    override fun removeRefreshListener(callback: OnRefreshListener) {
        mRefreshListeners.remove(callback)
    }

    override fun onRefresh(): Boolean {
        val stillActivatedAfterRefresh = mRefreshListeners.filter {
            it.onRefresh()
        }
        mRefreshListeners.clear()
        mRefreshListeners.addAll(stillActivatedAfterRefresh)
        return true
    }

    override fun unscheduleDrawable(who: Drawable, what: Runnable) {
    }

    override fun invalidateDrawable(who: Drawable) {
        onRefresh()
    }

    override fun scheduleDrawable(who: Drawable, what: Runnable, `when`: Long) {
    }
}
</code></pre>
<p>接下来就可以使用 <code>DrawableCallbackComposer</code> 来扩展复用度，但显然，我们并不愿意到处裸露 <code>DrawableCallbackComposer</code> 的操作，继续考虑封装和隐藏。</p>
<h3 id="2李代桃僵利用代理"><a class="header" href="#2李代桃僵利用代理">2.李代桃僵，利用代理</a></h3>
<p>如果我们拥有一个代理层，它帮助 Drawable 处理 <code>DrawableCallbackComposer</code> 的 <code>子节点 OnRefreshListener</code> 注册与解注册，并且最终表现为一个 Drawable，那么 <code>裸露的控制代码</code>
将替换为简单的 <code>依赖注入中的实例提供</code></p>
<p>基于接口的灵活性，我们可以顺其自然的定义如下 <code>DrawableProxy</code> 类。</p>
<p><em>它能够直接代理原Drawable关于绘制的全部内容，又追加了 使用 DrawableCallbackComposer 和 回调注册解注册的必要控制逻辑</em></p>
<pre><code class="language-kotlin">class DrawableProxy
@JvmOverloads constructor(
    proxy: Drawable? = null,
    private val drawableCallbackComposer: DrawableCallbackComposer = DrawableCallbackComposer()
) : Drawable(),
    ResizeDrawable,
    Drawable.Callback by drawableCallbackComposer,
    OnRefreshListeners by drawableCallbackComposer {

    private var proxySafety: Drawable = proxy?.also { it.callback = drawableCallbackComposer } ?: this
        set(drawable) {
            field.callback = null
            drawable.callback = drawableCallbackComposer
            field = drawable
            needResize = true
            invalidateDrawable(this)
        }

    fun setProxy(drawable: Drawable) {
        this.proxySafety = drawable
    }

    fun clearProxy() {
        this.proxySafety = this
    }

    override var needResize: Boolean = false

    /*以下是代理实现，无需过度关心*/

    override fun getIntrinsicWidth(): Int {
        return proxySafety.intrinsicWidth
    }

    override fun getIntrinsicHeight(): Int {
        return proxySafety.intrinsicHeight
    }

    override fun draw(canvas: Canvas) {
        proxySafety.draw(canvas)
    }

    override fun setAlpha(alpha: Int) {
        proxySafety.alpha = alpha
    }

    override fun setColorFilter(cf: ColorFilter?) {
        proxySafety.colorFilter = cf
    }

    override fun getOpacity(): Int {
        return proxySafety.opacity
    }

    override fun onBoundsChange(bounds: Rect) {
        super.onBoundsChange(bounds)
        needResize = false
    }

    override fun setBounds(bounds: Rect) {
        super.setBounds(bounds)
        proxySafety.bounds = bounds
    }

    override fun setBounds(left: Int, top: Int, right: Int, bottom: Int) {
        super.setBounds(left, top, right, bottom)
        proxySafety.setBounds(left, top, right, bottom)
    }

}
</code></pre>
<p>至此，我们将使用<code>DrawableProxy</code> 替代原先的 AnimDrawable,用以构建Span实例。</p>
<p>接下来可以将注意力转移到："实现、添加 OnRefreshListener"，通过调用宿主TextView的刷新，显示动画帧。</p>
<h3 id="继续使用spanwatcher解放双手"><a class="header" href="#继续使用spanwatcher解放双手">继续使用SpanWatcher解放双手</a></h3>
<p>行至此处，您一定不甘心再在业务代码中裸露此类控制代码：</p>
<pre><code class="language-kotlin">drawable?.addRefreshListener(object : OnRefreshListener {
    override fun onRefresh(): Boolean {
        //ignore 诸如生命周期断定 。。。
        view.invalidate()
        return true
    }
})
</code></pre>
<p>哪怕您将它封装成一个静态API以供业务代码中调用，也难以达到您对 追求"优雅" 的要求底线了。</p>
<p>而SDK中已经确定了这位天选打工人 <code>SpanWatcher</code>，看一下它的定义：</p>
<pre><code class="language-java">/**
 * When an object of this type is attached to a Spannable,
 * its methods will be called to notify it that other 
 * markup objects have been added, changed, or removed.
 * */
</code></pre>
<p>翻译如下：</p>
<blockquote>
<p>当 <code>SpanWatcher</code> 类型的实例被添加到 <code>Spannable</code> 之后，一旦发生 （Span）标记被 添加、改变、移除时，
实例相应的 API方法 会被调用，起到通知效果。</p>
</blockquote>
<p>藉此，我们可以顺其自然地简化处理回调的注册与解注册</p>
<p><em>读者诸君，此时还请再想一想，它能完美的解决问题吗？</em></p>
<pre><code class="language-kotlin">class AnimImageSpanWatcher(view: View) : SpanWatcher, OnRefreshListener {
    private var mLastRefreshStamp: Long = 0
    private val mViewWeakReference: WeakReference&lt;View&gt; = WeakReference(view)

    override fun onSpanAdded(text: Spannable, what: Any, start: Int, end: Int) {
        if (what is RefreshSpan) {
            val drawable = what.getInvalidateDrawable()
            drawable?.addRefreshListener(this)
        }
    }

    override fun onSpanRemoved(text: Spannable, what: Any, start: Int, end: Int) {
        if (what is RefreshSpan) {
            val drawable = what.getInvalidateDrawable()
            drawable?.removeRefreshListener(this)
        }
    }

    override fun onSpanChanged(text: Spannable, what: Any, ostart: Int, oend: Int, nstart: Int, nend: Int) {

    }

    override fun onRefresh(): Boolean {
        val view = mViewWeakReference.get() ?: return false

        //ignore 生命周期有效性判断

        val currentTime = System.currentTimeMillis()
        //加一层过滤，避免刷新过于频繁
        if (currentTime - mLastRefreshStamp &gt; REFRESH_INTERVAL) {
            mLastRefreshStamp = currentTime
            view.invalidate()
        }
        return true
    }

    companion object {
        private const val REFRESH_INTERVAL = 60
    }
}
</code></pre>
<blockquote>
<p>作者按：感谢 <a href="https://juejin.cn/user/835284568906152">长安皈故里</a> 的提醒，我遗漏了部分代码。</p>
</blockquote>
<pre><code>interface RefreshSpan {
    fun getInvalidateDrawable(): OnRefreshListeners?
}
</code></pre>
<p>行至此处，还剩下关键的一步：借助TextView自身的机制，让这些类正常工作！</p>
<h3 id="使用-spannablefactory-梦幻联动"><a class="header" href="#使用-spannablefactory-梦幻联动">使用 <code>Spannable.Factory</code> 梦幻联动</a></h3>
<p>不清楚读者诸君是否 <strong>精心研读</strong> 过 <code>TextView</code> 的源码，当然，本篇并不打算展开分析，TextView 中有一个API：</p>
<pre><code class="language-java">class TextView {
    /**
     * Sets the Factory used to create new Spannable
     */
    public final void setSpannableFactory(Spannable.Factory factory) {
        mSpannableFactory = factory;
        setText(mText);
    }
}
</code></pre>
<p>通过API实现，您可以发现，它会重新调用 setText API，并利用该 Factory 创建用于显示的 Spannable</p>
<p><code>Spannable.Factory</code>：</p>
<pre><code class="language-java">/**
 * Factory used by TextView to create new Spannables.
 * You can subclass it to provide something other than SpannableString.
 */
public static class Factory {
    //ignore

    /**
     * Returns a new SpannableString from the specified CharSequence.
     * You can override this to provide a different kind of Spannable.
     */
    public Spannable newSpannable(CharSequence source) {
        return new SpannableString(source);
    }
}
</code></pre>
<p>值得注意：</p>
<blockquote>
<p>设计Spannable的拷贝时，理所当然存在一些Span不希望被拷贝，于是设计有该机制，实现 <code>NoCopySpan</code> 的标记（span）不会被拷贝</p>
</blockquote>
<p>于是，可实现类似如下工厂类，完成最后的联动。</p>
<pre><code class="language-kotlin">class CustomSpannableFactory(private val mNoCopySpans: List&lt;NoCopySpan&gt;) : Spannable.Factory() {

    override fun newSpannable(source: CharSequence): Spannable {
        val spannableStringBuilder = SpannableStringBuilder()
        mNoCopySpans.forEach {
            spannableStringBuilder.setSpan(
                it, 0, 0,
                Spanned.SPAN_INCLUSIVE_INCLUSIVE or Spanned.SPAN_PRIORITY
            )
        }
        spannableStringBuilder.append(source)
        return spannableStringBuilder
    }
}
</code></pre>
<p>最终，以伪代码实现展现调用细节如下：</p>
<pre><code class="language-kotlin">val tvSpan = findViewById&lt;TextView&gt;(R.id.tv_span)

//第一部分
//如上文，创建一个动画Drawable
val drawable = createADrawable()
//基于代理，利用它简化Drawable.Callback的处理
val proxyDrawable = DrawableProxy(drawable)
//您可以认为这就是一个实现了RefreshSpan的ImageSpan，
//内部做了等高处理等，这些和文章主题无关，简要代码附于下文
val imgSpan = AnimIsohypseImageSpan(proxyDrawable)

//第二部分
//构建一个演示用的Spannable
val ss = SpannableString("ImageSpan *")
ss.setSpan(imgSpan, 10, 11, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE)
tvSpan.text = ss

//第三部分
//使用Watcher简化回调设置
val watchers = ArrayList&lt;NoCopySpan&gt;()
watchers.add(AnimImageSpanWatcher(tvSpan))
//使用自定义Factory实现联动
tvSpan.setSpannableFactory(CustomSpannableFactory(watchers))

//演示手动触发动画
tvSpan.setOnClickListener {
    drawable.start()
}
</code></pre>
<blockquote>
<p>作者按：感谢 <a href="https://juejin.cn/user/835284568906152">长安皈故里</a> 的提醒，我遗漏了部分代码。</p>
</blockquote>
<p>另外还有一部分代码，仅用于参考，读者诸君需要结合自身项目实际情况进行类簇的扩展</p>
<pre><code>//DrawableProxy中用到
interface ResizeDrawable {
    var needResize: Boolean
}

interface IntegratedSpan

//等高
open class IsohypseImageSpan : ImageSpan, IntegratedSpan {
    //构造器和等高计算、绘制等略

    open fun getResizedDrawable(): Drawable {
        val d = drawable
        if (drawableHeight == 0) {
            return d
        }
        if (!resized) {
            resized = true
            d.bounds = Rect(
                0, 0,
                (1f * drawableHeight.toFloat() * d.intrinsicWidth.toFloat() / d.intrinsicHeight).toInt(),
                drawableHeight
            )
        }
        return d
    }
}

//配合自定义的SpanWatcher
open class AnimIsohypseImageSpan : IsohypseImageSpan, RefreshSpan {
    //构造器略

    override fun getInvalidateDrawable(): OnRefreshListeners? {
        val d = getResizedDrawable()
        return if (d is OnRefreshListeners) {
            d
        } else {
            null
        }
    }
}

//用于有重计算高度的需求
class ResizeIsoheightImageSpan : AnimIsohypseImageSpan, RefreshSpan {
    //构造器略

    override fun getResizedDrawable(): Drawable {
        val d = drawable
        if (drawableHeight == 0) {
            return d
        }
        if (d is ResizeDrawable &amp;&amp; (d.needResize || !resized)) {
            resizeSpan(d)
        } else if (!resized) {
            resizeSpan(d)
        }
        return d
    }

    private fun resizeSpan(d: Drawable) {
        resized = true
        d.bounds = Rect(0, 0,
                (1f * drawableHeight * d.intrinsicWidth / d.intrinsicHeight).toInt(),
                drawableHeight)
    }
}
</code></pre>
<p>实际上，在工程中应用时：</p>
<ul>
<li>第一部分我们会使用工厂类+依赖注入工具，在业务层屏蔽掉细节</li>
<li>第二部分略，如何构建Spannable并在业务层屏蔽该细节与本文无关</li>
<li>第三部分也可以屏蔽掉一些细节</li>
</ul>
<p>可以想象的到，业务层变得纯粹了，而组件的 Ability 层（<em>这是笔者自行杜撰的命名，用于描述自定义的控件、及其拓展功能的类</em>）也会非常干净，均可以做到依赖抽象，按需使用，简化耦合。</p>
<h3 id="敲响警钟"><a class="header" href="#敲响警钟">敲响警钟</a></h3>
<p>一般来说，文章写到这，基本是结束的节奏，可能您也憋了好长一口气才看到这里，想着可以缓一口气了。</p>
<p>然而有个坏消息不得不告诉您：<strong>其实问题并没有完全解决</strong>！</p>
<img width="220" alt="全是问题" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4959e7c21de4b7e8d41173c53210dbc~tplv-k3u1fbpfcp-watermark.image?"/>
<p>回顾一下前文，有这样一段：</p>
<blockquote>
<p>务必注意，仅用于显示时，我们尚可以说服自己不负责任地忽略 "不移除回调" 带来的负面影响，诸如无效刷新、内存泄露。</p>
<p>而在编辑时（如EditText中使用，并删除图片）、以及RecycleView中TextView复用（推广到可替换呈现内容的情况）
则不得不移除回调。否则轻则造成性能损耗和内存泄露，重则立现 UI bug。</p>
</blockquote>
<p>我们已经解决了一部分问题：</p>
<ul>
<li>简化注册回调，让Spannable可以被多个View有效复用，展现出动画。并且在工程性问题上做的不错。</li>
<li>移除Span时，对回调进行解注册。可回看 <code>AnimImageSpanWatcher</code> 代码</li>
<li>使用者认为自身不再需要被回调更新时，解除回调。可回看 <code>OnRefreshListener</code> 代码，注意，该情况完全交给业务管控。</li>
<li>弱引用，不妨碍使用者及宿主Activity被回收</li>
<li>等</li>
</ul>
<p>但有一个重要的问题：RecycleView中TextView复用（推广到可替换呈现内容的情况）没有考虑。</p>
<p><em>作者按：注意，EditText在编辑时的特性、选中特性、Span机制本身的特性问题，没有在本篇中展开。这不代表它们不存在！</em></p>
<h2 id="持续思考非常重要的结语"><a class="header" href="#持续思考非常重要的结语">持续思考&amp;非常重要的结语</a></h2>
<p><em>作者按：本篇的篇幅已经很长了，所以还请没有看过瘾的读者们见谅，考虑到大多数读者的阅读感受，我们需要在此结束了</em></p>
<p>但尚遗留3个问题需要持续思考：</p>
<ol>
<li>RecycleView中，控件复用了，问题该如何解决？</li>
</ol>
<p>当然，我们可以简化问题模型，用 <code>RecycleView中TextView复用</code> 来表现太重了，我们可以简化为：</p>
<blockquote>
<p>一个TextView展现 Spannable-A，随后展现 Spannable-B，</p>
</blockquote>
<ol start="2">
<li>使用EditText编辑时，是否会有新的问题，例如：删除时先选中的需求，删除完之后，又应当如何解决</li>
<li>以上做法已经是最优了吗？还能不能继续优化</li>
</ol>
<p><em>因为我认为以上代码尚存在优化空间，并且推测您的项目中已经使用了Span机制的扩展以实现某些需求；</em></p>
<p><em>而我尚不打算花费大量的时间编写用于兼容用途的功能类。所以我并未将这部分代码传入仓库，避免您直接当做库项目使用，导致原功能模块不可用。</em></p>
<p><em>如果您很迫切的需要将其移植到项目中，文中的代码已经涵盖所有重点，但请务必自行测试相关功能模块，做好兼容工作。</em></p>
<div style="break-before: page; page-break-before: always;"></div><p>Android 消息机制</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="三思系列android的消息机制一文吃透"><a class="header" href="#三思系列android的消息机制一文吃透">三思系列：Android的消息机制，一文吃透</a></h1>
<blockquote>
<p>三思系列是我最新的学习、总结形式，着重于:<strong>问题分析</strong>、<strong>技术积累</strong>、<strong>视野拓展</strong>，<a href="https://leobert-lan.github.io/info/about_sansi_series.html">关于三思系列</a></p>
</blockquote>
<p>这次，真的可以一文吃透：</p>
<ul>
<li>Java层消息队列的设计</li>
<li>Java层Looper分发</li>
<li>Native层消息队列和Java层消息队列的关系</li>
<li>Native层Looper分发</li>
<li>消息</li>
<li>epoll</li>
</ul>
<h2 id="前言-8"><a class="header" href="#前言-8">前言</a></h2>
<p>作为Android中 <code>至关重要</code> 的机制之一，十多年来，分析它的文章不断，大量的内容已经被挖掘过了。所以：</p>
<ul>
<li>已经对这一机制比较 <code>熟稔</code> 的读者，在这篇文章中，看不到 <code>新东西</code> 了。</li>
<li>还不太熟悉消息机制的读者，可以在文章的基础上，继续挖一挖。</li>
</ul>
<p>但是，经过简单的检索和分析，<code>大部分</code> 的文章是围绕：</p>
<ul>
<li>Handler，Looper，MQ的关系</li>
<li>上层的Handler，Looper、MQ 源码分析</li>
</ul>
<p>展开的。单纯的从这些角度学习的话，并不能 <code>完全理解</code> 消息机制。</p>
<p>这篇文章本质还是 <code>一次脑暴</code> ，一来 <code>避免脑暴跑偏</code> ，二来帮助读者 <code>捋清内容脉络</code> 。先放出脑图：</p>
<p><img src="Android/Mechanism/Message/%E4%B8%89%E6%80%9D%E7%B3%BB%E5%88%97%EF%BC%9AAndroid%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%EF%BC%8C%E4%B8%80%E6%96%87%E5%90%83%E9%80%8F/guide.png" alt="guide" /></p>
<h2 id="脑暴os解决进程间通信问题"><a class="header" href="#脑暴os解决进程间通信问题">脑暴：OS解决进程间通信问题</a></h2>
<p>程序世界中，存在着大量的 <code>通信</code> 场景。搜索我们的知识，解决 <code>进程间通信</code> 问题有以下几种方式：</p>
<p><em>这段内容可以泛读，了解就行，不影响往下阅读</em></p>
<blockquote>
<ul>
<li>
<p>管道</p>
<ul>
<li>普通管道pipe：一种 <code>半双工</code> 的通信方式，数据只能 <code>单向流动</code> ，而且只能在具有 <code>亲缘关系</code> 的进程间使用。</li>
<li>命令流管道s_pipe: <code>全双工</code>，可以同时双向传输</li>
<li>命名管道FIFO：<code>半双工</code> 的通信方式，<code>允许</code> 在 <code>无亲缘关系</code> 的进程间通信。</li>
</ul>
</li>
<li>
<p>消息队列 MessageQueue：</p>
</li>
</ul>
<p><code>消息的链表</code>，<code>存放在内核</code> 中 并由 <code>消息队列标识符</code> 标识。
消息队列克服了 <code>信号传递信息少</code>、<code>管道</code> 只能承载 <code>无格式字节流</code> 以及 <code>缓冲区大小受限</code> 等缺点。</p>
<ul>
<li>共享存储 SharedMemory：</li>
</ul>
<p>映射一段 <code>能被其他进程所访问</code> 的内存，这段共享内存由 <code>一个进程创建</code>，但 <code>多个进程都可以访问</code>。
共享内存是 <code>最快的 IPC 方式</code>，它是针对 <code>其他</code> 进程间通信方式 <code>运行效率低</code> 而专门设计的。
往往与其他通信机制一同使用，如 <code>信号量</code> 配合使用，来实现进程间的同步和通信。</p>
<ul>
<li>信号量 Semaphore：</li>
</ul>
<p>是一个 <code>计数器</code> ，可以用来控制多个进程对共享资源的访问。它常作为一种 <code>锁机制</code>，防止某进程正在访问共享资源时，
其他进程也访问该资源，实现 <code>资源的进程独占</code>。因此，主要作为 <code>进程间</code> 以及 <code>同一进程内线程间</code> 的同步手段。</p>
<ul>
<li>套接字Socket：</li>
</ul>
<p>与其他通信机制不同的是，它可以 <code>通过网络</code> ，在 <code>不同机器之间</code> 进行进程通信。</p>
<ul>
<li>信号 signal：</li>
</ul>
<p>用于通知接收进程 <code>某事件已发生</code>。机制比较复杂。</p>
</blockquote>
<p>我们可以想象，Android之间也有大量的 <code>进程间通信场景</code>，OS必须采用 <code>至少一种</code> 机制，以实现进程间通信。</p>
<p>仔细研究下去，我们发现，Android OS用了不止一种方式。而且，Android 还基于 <code>OpenBinder</code> 开发了 <code>Binder</code> 用于 <code>用户空间</code> 内的进程间通信。</p>
<p>关于 <strong>为什么不直接使用Linux中现有的进程间通信方式</strong> ，可以看看<a href="https://www.zhihu.com/question/39440766/answer/89210950">这篇知乎问答</a></p>
<p><a href="https://www.jianshu.com/p/1b25bc6b861e">这篇文章</a> 也简单探讨了 "内核空间内的消息队列"</p>
<p>这里我们留一个问题以后探究：</p>
<blockquote>
<p>Android 有没有使用 Linux内核中的MessageQueue机制 干事情</p>
</blockquote>
<p>基于消息队列的消息机制设计有很多优势，Android 在很多通信场景内，采用了这一设计思路。</p>
<h2 id="消息机制的三要素"><a class="header" href="#消息机制的三要素">消息机制的三要素</a></h2>
<p>不管在哪，我们谈到消息机制，都会有这三个要素：</p>
<ul>
<li><code>消息队列</code></li>
<li><code>消息循环（分发）</code></li>
<li><code>消息处理</code></li>
</ul>
<p><code>消息队列</code> ，是 <code>消息对象</code> 的队列，基本规则是 <code>FIFO</code>。</p>
<p><code>消息循环（分发）</code>， 基本是通用的机制，利用 <code>死循环</code> 不断的取出消息队列头部的消息，派发执行</p>
<p><code>消息处理</code>，这里不得不提到 <code>消息</code> 有两种形式：</p>
<ul>
<li>Enrichment 自身信息完备</li>
<li>Query-Back 自身信息不完备，需要回查</li>
</ul>
<p>这两者的取舍，主要看系统中 <code>生成消息的开销</code> 和 <code>回查信息的开销</code> 两者的博弈。</p>
<p>在信息完备后，接收者即可处理消息。</p>
<h2 id="android-framework中的消息队列"><a class="header" href="#android-framework中的消息队列">Android Framework中的消息队列</a></h2>
<p>Android 的Framework中的消息队列有两个：</p>
<ul>
<li>Java层  <code>frameworks/base/core/java/android/os/MessageQueue.java</code></li>
<li>Native层 <code>frameworks/base/core/jni/android_os_MessageQueue.cpp</code></li>
</ul>
<p>Java层的MQ并不是 <code>List</code> 或者 <code>Queue</code> 之类的 Jdk内的数据结构实现。</p>
<p>Native层的源码我下载了一份 Android 10 的 <a href="https://github.com/leobert-lan/Blog/blob/main/Android/Mechanism/Message/code/android_os_MessageQueue.cpp">源码</a> ，并不长，大家可以完整的读一读。</p>
<blockquote>
<p>并不难理解：<code>用户空间</code> 会接收到来自 <code>内核空间</code> 的 <code>消息</code> ， 从 <code>下图</code> 我们可知，这部分消息先被 <code>Native层</code> 获知，所以：</p>
<ul>
<li>通过 <code>Native层</code> 建立消息队列，它拥有消息队列的各种基本能力</li>
<li>利用<code>JNI</code> 打通 <code>Java层</code> 和 <code>Native层</code> 的 <code>Runtime屏障</code>，在Java层 <code>映射</code> 出消息队列</li>
<li>应用建立在Java层之上，在Java层中实现消息的 <code>分发</code> 和 <code>处理</code></li>
</ul>
<p>PS：在Android 2.3那个时代，消息队列的实现是在Java层的，至于10年前为何改成了 native实现，
推测和CPU空转有关，笔者没有继续探究下去，如果有读者了解，希望可以留言帮我解惑。</p>
</blockquote>
<p><img src="https://developer.android.google.cn/guide/platform/images/android-stack_2x.png" alt="" /></p>
<p><em>PS:还有一张经典的 <code>系统启动架构图</code> 没有找到，这张图更加直观</em></p>
<h3 id="代码解析"><a class="header" href="#代码解析">代码解析</a></h3>
<p>我们简单的 阅读、分析 下Native中的MQ源码</p>
<p>Native层消息队列的创建：</p>
<pre><code class="language-cpp">static jlong android_os_MessageQueue_nativeInit(JNIEnv* env, jclass clazz) {
    NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue();
    if (!nativeMessageQueue) {
        jniThrowRuntimeException(env, "Unable to allocate native queue");
        return 0;
    }

    nativeMessageQueue-&gt;incStrong(env);
    return reinterpret_cast&lt;jlong&gt;(nativeMessageQueue);
}
</code></pre>
<p>很简单，创建一个Native层的消息队列，如果创建失败，抛异常信息,返回0，否则将指针转换为Java的long型值返回。当然，会<code>被Java层的MQ所持有</code>。</p>
<p><code>NativeMessageQueue</code> 类的构造函数</p>
<pre><code class="language-cpp">NativeMessageQueue::NativeMessageQueue() :
        mPollEnv(NULL), mPollObj(NULL), mExceptionObj(NULL) {
    mLooper = Looper::getForThread();
    if (mLooper == NULL) {
        mLooper = new Looper(false);
        Looper::setForThread(mLooper);
    }
}
</code></pre>
<p>这里的Looper是native层Looper，通过静态方法 <code>Looper::getForThread()</code> 获取对象实例，如果未获取到，则创建实例，并通过静态方法设置。</p>
<p>看一下Java层MQ中会使用到的native方法</p>
<pre><code class="language-java">class MessageQueue {
    private long mPtr; // used by native code

    private native static long nativeInit();

    private native static void nativeDestroy(long ptr);

    private native void nativePollOnce(long ptr, int timeoutMillis); /*non-static for callbacks*/

    private native static void nativeWake(long ptr);

    private native static boolean nativeIsPolling(long ptr);

    private native static void nativeSetFileDescriptorEvents(long ptr, int fd, int events);
}
</code></pre>
<p>对应签名：</p>
<pre><code class="language-cpp">static const JNINativeMethod gMessageQueueMethods[] = {
    /* name, signature, funcPtr */
    { "nativeInit", "()J", (void*)android_os_MessageQueue_nativeInit },
    { "nativeDestroy", "(J)V", (void*)android_os_MessageQueue_nativeDestroy },
    { "nativePollOnce", "(JI)V", (void*)android_os_MessageQueue_nativePollOnce },
    { "nativeWake", "(J)V", (void*)android_os_MessageQueue_nativeWake },
    { "nativeIsPolling", "(J)Z", (void*)android_os_MessageQueue_nativeIsPolling },
    { "nativeSetFileDescriptorEvents", "(JII)V",
            (void*)android_os_MessageQueue_nativeSetFileDescriptorEvents },
};
</code></pre>
<p><code>mPtr</code> 是Native层MQ的内存地址在Java层的映射。</p>
<h4 id="java层判断mq是否还在工作"><a class="header" href="#java层判断mq是否还在工作">Java层判断MQ是否还在工作：</a></h4>
<pre><code class="language-java">private boolean isPollingLocked() {
    // If the loop is quitting then it must not be idling.
    // We can assume mPtr != 0 when mQuitting is false.
    return !mQuitting &amp;&amp; nativeIsPolling(mPtr);
}
</code></pre>
<pre><code class="language-cpp">static jboolean android_os_MessageQueue_nativeIsPolling(JNIEnv* env, jclass clazz, jlong ptr) {
    NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr);
    return nativeMessageQueue-&gt;getLooper()-&gt;isPolling();
}
</code></pre>
<pre><code class="language-cpp">/**
 * Returns whether this looper's thread is currently polling for more work to do.
 * This is a good signal that the loop is still alive rather than being stuck
 * handling a callback.  Note that this method is intrinsically racy, since the
 * state of the loop can change before you get the result back.
 */
bool isPolling() const;
</code></pre>
<h4 id="唤醒-native层mq"><a class="header" href="#唤醒-native层mq">唤醒 Native层MQ：</a></h4>
<pre><code class="language-cpp">static void android_os_MessageQueue_nativeWake(JNIEnv* env, jclass clazz, jlong ptr) {
    NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr);
    nativeMessageQueue-&gt;wake();
}

void NativeMessageQueue::wake() {
    mLooper-&gt;wake();
}
</code></pre>
<h4 id="native层poll"><a class="header" href="#native层poll">Native层Poll：</a></h4>
<pre><code class="language-cpp">static void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jobject obj,
        jlong ptr, jint timeoutMillis) {
    NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr);
    nativeMessageQueue-&gt;pollOnce(env, obj, timeoutMillis);
}

void NativeMessageQueue::pollOnce(JNIEnv* env, jobject pollObj, int timeoutMillis) {
    mPollEnv = env;
    mPollObj = pollObj;
    mLooper-&gt;pollOnce(timeoutMillis);
    mPollObj = NULL;
    mPollEnv = NULL;

    if (mExceptionObj) {
        env-&gt;Throw(mExceptionObj);
        env-&gt;DeleteLocalRef(mExceptionObj);
        mExceptionObj = NULL;
    }
}
</code></pre>
<p>这里比较重要，我们先大概看下 Native层的Looper是 <code>如何分发消息</code> 的</p>
<pre><code class="language-cpp">//Looper.h

int pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData);
inline int pollOnce(int timeoutMillis) {
    return pollOnce(timeoutMillis, NULL, NULL, NULL);
}

//实现

int Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) {
    int result = 0;
    for (;;) {
        while (mResponseIndex &lt; mResponses.size()) {
            const Response&amp; response = mResponses.itemAt(mResponseIndex++);
            int ident = response.request.ident;
            if (ident &gt;= 0) {
                int fd = response.request.fd;
                int events = response.events;
                void* data = response.request.data;
#if DEBUG_POLL_AND_WAKE
                ALOGD("%p ~ pollOnce - returning signalled identifier %d: "
                        "fd=%d, events=0x%x, data=%p",
                        this, ident, fd, events, data);
#endif
                if (outFd != NULL) *outFd = fd;
                if (outEvents != NULL) *outEvents = events;
                if (outData != NULL) *outData = data;
                return ident;
            }
        }

        if (result != 0) {
#if DEBUG_POLL_AND_WAKE
            ALOGD("%p ~ pollOnce - returning result %d", this, result);
#endif
            if (outFd != NULL) *outFd = 0;
            if (outEvents != NULL) *outEvents = 0;
            if (outData != NULL) *outData = NULL;
            return result;
        }

        result = pollInner(timeoutMillis);
    }
}

</code></pre>
<p>先处理Native层滞留的Response，然后调用pollInner。这里的细节比较复杂，稍后我们在 <a href="Android/Mechanism/Message/post_8.html#native_looper">Native Looper解析</a> 中进行脑暴。</p>
<blockquote>
<p>先于此处细节分析，我们知道，调用一个方法，这是<code>阻塞的</code> ，用大白话描述即在方法返回前，调用者在 <code>等待</code>。</p>
</blockquote>
<p>Java层调动 <code>native void nativePollOnce(long ptr, int timeoutMillis);</code> 过程中是阻塞的。</p>
<p>此时我们再阅读下Java层MQ的消息获取：代码比较长，直接在代码中进行要点注释。</p>
<p>在看之前，我们先单纯从 <code>TDD的角度</code> 思考下，有哪些 <code>主要场景</code> ：<em>当然，这些场景不一定都合乎Android现有的设计</em></p>
<ul>
<li>消息队列是否在工作中
<ul>
<li>工作中，期望返回消息</li>
<li>不工作，期望返回null</li>
</ul>
</li>
<li>工作中的消息队列 <code>当前</code> 是否有消息
<ul>
<li>不存在消息，阻塞 or 返回null？-- 如果返回null，则在外部需要需要 <code>保持空转</code> 或者 <code>唤醒机制</code>，以支持正常运作。从封装角度出发，应当 <code>保持空转</code>，自己解决问题</li>
<li>存在消息
<ul>
<li>特殊的 <code>内部功能性消息</code>，期望MQ内部自行处理</li>
<li>已经到处理时间的消息， <strong>返回消息</strong></li>
<li>未到处理时间，<em>如果都是排过序的</em>，期望 <code>空转保持阻塞</code> or <code>返回静默并设置唤醒</code>？ 按照前面的讨论，是期望 <code>保持空转</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-java">class MessageQueue {
    Message next() {
        // Return here if the message loop has already quit and been disposed.
        // This can happen if the application tries to restart a looper after quit
        // which is not supported.
        // 1. 如果 native消息队列指针映射已经为0，即虚引用，说明消息队列已经退出，没有消息了。
        // 则返回 null
        final long ptr = mPtr;
        if (ptr == 0) {
            return null;
        }

        int pendingIdleHandlerCount = -1; // -1 only during first iteration
        int nextPollTimeoutMillis = 0;
        
        // 2. 死循环，当为获取到需要 `分发处理` 的消息时，保持空转
        for (;;) {
            if (nextPollTimeoutMillis != 0) {
                Binder.flushPendingCommands();
            }

            // 3. 调用native层方法，poll message，注意，消息还存在于native层
            nativePollOnce(ptr, nextPollTimeoutMillis);

            synchronized (this) {
                // Try to retrieve the next message.  Return if found.
                final long now = SystemClock.uptimeMillis();
                Message prevMsg = null;
                Message msg = mMessages;
                
                //4. 如果发现 barrier ，即同步屏障，则寻找队列中的下一个可能存在的异步消息
                if (msg != null &amp;&amp; msg.target == null) {
                    // Stalled by a barrier.  Find the next asynchronous message in the queue.
                    do {
                        prevMsg = msg;
                        msg = msg.next;
                    } while (msg != null &amp;&amp; !msg.isAsynchronous());
                }
                
                if (msg != null) {
                    // 5. 发现了消息，
                    // 如果是还没有到约定时间的消息，则设置一个 `下次唤醒` 的最大时间差
                    // 否则 `维护单链表信息` 并返回消息
                    
                    if (now &lt; msg.when) {
                        // Next message is not ready.  Set a timeout to wake up when it is ready.
                        nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
                    } else {
                        // 寻找到了 `到处理时间` 的消息。 `维护单链表信息` 并返回消息
                        // Got a message.
                        mBlocked = false;
                        if (prevMsg != null) {
                            prevMsg.next = msg.next;
                        } else {
                            mMessages = msg.next;
                        }
                        msg.next = null;
                        if (DEBUG) Log.v(TAG, "Returning message: " + msg);
                        msg.markInUse();
                        return msg;
                    }
                } else {
                    // No more messages.
                    nextPollTimeoutMillis = -1;
                }

                // 处理 是否需要 停止消息队列                
                // Process the quit message now that all pending messages have been handled.
                if (mQuitting) {
                    dispose();
                    return null;
                }

                // 维护 接下来需要处理的 IDLEHandler 信息，
                // 如果没有 IDLEHandler，则直接进入下一轮消息获取环节
                // 否则处理 IDLEHandler
                // If first time idle, then get the number of idlers to run.
                // Idle handles only run if the queue is empty or if the first message
                // in the queue (possibly a barrier) is due to be handled in the future.
                if (pendingIdleHandlerCount &lt; 0
                        &amp;&amp; (mMessages == null || now &lt; mMessages.when)) {
                    pendingIdleHandlerCount = mIdleHandlers.size();
                }
                if (pendingIdleHandlerCount &lt;= 0) {
                    // No idle handlers to run.  Loop and wait some more.
                    mBlocked = true;
                    continue;
                }

                if (mPendingIdleHandlers == null) {
                    mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];
                }
                mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);
            }

            // 处理 IDLEHandler
            // Run the idle handlers.
            // We only ever reach this code block during the first iteration.
            for (int i = 0; i &lt; pendingIdleHandlerCount; i++) {
                final IdleHandler idler = mPendingIdleHandlers[i];
                mPendingIdleHandlers[i] = null; // release the reference to the handler

                boolean keep = false;
                try {
                    keep = idler.queueIdle();
                } catch (Throwable t) {
                    Log.wtf(TAG, "IdleHandler threw exception", t);
                }

                if (!keep) {
                    synchronized (this) {
                        mIdleHandlers.remove(idler);
                    }
                }
            }

            // Reset the idle handler count to 0 so we do not run them again.
            pendingIdleHandlerCount = 0;

            // While calling an idle handler, a new message could have been delivered
            // so go back and look again for a pending message without waiting.
            nextPollTimeoutMillis = 0;
        }
    }
}
</code></pre>
<h4 id="java层压入消息"><a class="header" href="#java层压入消息">Java层压入消息</a></h4>
<p>这就比较简单了，当消息本身合法，且消息队列还在工作中时。
依旧从 <code>TDD角度</code> 出发：</p>
<ul>
<li>如果消息队列没有头，期望直接作为头</li>
<li>如果有头
<ul>
<li><code>消息处理时间</code> 先于 <code>头消息</code> 或者是需要立即处理的消息，则作为新的头</li>
<li>否则按照 <code>处理时间</code> 插入到合适位置</li>
</ul>
</li>
</ul>
<pre><code class="language-java"> boolean enqueueMessage(Message msg, long when) {
        if (msg.target == null) {
            throw new IllegalArgumentException("Message must have a target.");
        }

        synchronized (this) {
            if (msg.isInUse()) {
                throw new IllegalStateException(msg + " This message is already in use.");
            }

            if (mQuitting) {
                IllegalStateException e = new IllegalStateException(
                        msg.target + " sending message to a Handler on a dead thread");
                Log.w(TAG, e.getMessage(), e);
                msg.recycle();
                return false;
            }

            msg.markInUse();
            msg.when = when;
            Message p = mMessages;
            boolean needWake;
            if (p == null || when == 0 || when &lt; p.when) {
                // New head, wake up the event queue if blocked.
                msg.next = p;
                mMessages = msg;
                needWake = mBlocked;
            } else {
                // Inserted within the middle of the queue.  Usually we don't have to wake
                // up the event queue unless there is a barrier at the head of the queue
                // and the message is the earliest asynchronous message in the queue.
                needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();
                Message prev;
                for (;;) {
                    prev = p;
                    p = p.next;
                    if (p == null || when &lt; p.when) {
                        break;
                    }
                    if (needWake &amp;&amp; p.isAsynchronous()) {
                        needWake = false;
                    }
                }
                msg.next = p; // invariant: p == prev.next
                prev.next = msg;
            }

            // We can assume mPtr != 0 because mQuitting is false.
            if (needWake) {
                nativeWake(mPtr);
            }
        }
        return true;
    }
</code></pre>
<p><code>同步屏障 barrier</code>后面单独脑暴， 其他部分就先不看了</p>
<h2 id="java层消息分发"><a class="header" href="#java层消息分发">Java层消息分发</a></h2>
<p>这一节开始，我们脑暴消息分发，前面我们已经看过了 <code>MessageQueue</code> ，消息分发就是 <code>不停地</code> 从 <code>MessageQueue</code> 中取出消息，并指派给处理者。
完成这一工作的，是Looper。</p>
<p>在前面，我们已经知道了，Native层也有Looper，但是<code>不难理解</code>：</p>
<ul>
<li>消息队列需要 <code>桥梁</code> 连通 Java层和Native层</li>
<li>Looper只需要 <code>在自己这一端</code>，处理自己的消息队列分发即可</li>
</ul>
<p>所以，我们看Java层的消息分发时，看Java层的Looper即可。</p>
<p>关注三个主要方法：</p>
<ul>
<li>出门上班</li>
<li>工作</li>
<li>下班回家</li>
</ul>
<h3 id="出门上班-prepare"><a class="header" href="#出门上班-prepare">出门上班 prepare</a></h3>
<pre><code class="language-java">class Looper {

    public static void prepare() {
        prepare(true);
    }

    private static void prepare(boolean quitAllowed) {
        if (sThreadLocal.get() != null) {
            throw new RuntimeException("Only one Looper may be created per thread");
        }
        sThreadLocal.set(new Looper(quitAllowed));
    }
}
</code></pre>
<p>这里有两个注意点：</p>
<ul>
<li>已经出了门，除非再进门，否则没法再出门了。同样，一个线程有一个Looper就够了，只要它还活着，就没必要再建一个。</li>
<li>责任到人，一个Looper服务于一个Thread，这需要 <code>注册</code> ，代表着 <code>某个Thread</code> 已经由自己服务了。利用了ThreadLocal，因为多线程访问集合，<code>总需要考虑 竞争</code>，这很不人道主义，干脆分家，每个Thread操作自己的内容互不干扰，也就没有了竞争，于是封装了 <code>ThreadLocal</code></li>
</ul>
<h3 id="上班-loop"><a class="header" href="#上班-loop">上班 loop</a></h3>
<p>注意工作性质是 <code>分发</code>，并不需要自己处理</p>
<ul>
<li>没有 <code>注册</code> 自然就找不到负责这份工作的人。</li>
<li>已经在工作了就不要催，催了会导致工作出错，顺序出现问题。</li>
<li>工作就是不断的取出 <code>老板</code>-- <code>MQ</code> 的 <code>指令</code> -- <code>Message</code>，并交给 <code>相关负责人</code> -- <code>Handler</code> 去处理，并记录信息</li>
<li><code>007</code>，不眠不休，<code>当MQ再也不发出消息了</code>，没活干了，大家都散了吧，下班回家</li>
</ul>
<pre><code class="language-java">class Looper {
    public static void loop() {
        final Looper me = myLooper();
        if (me == null) {
            throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread.");
        }
        if (me.mInLoop) {
            Slog.w(TAG, "Loop again would have the queued messages be executed"
                    + " before this one completed.");
        }

        me.mInLoop = true;
        final MessageQueue queue = me.mQueue;

        // Make sure the identity of this thread is that of the local process,
        // and keep track of what that identity token actually is.
        Binder.clearCallingIdentity();
        final long ident = Binder.clearCallingIdentity();

        // Allow overriding a threshold with a system prop. e.g.
        // adb shell 'setprop log.looper.1000.main.slow 1 &amp;&amp; stop &amp;&amp; start'
        final int thresholdOverride =
                SystemProperties.getInt("log.looper."
                        + Process.myUid() + "."
                        + Thread.currentThread().getName()
                        + ".slow", 0);

        boolean slowDeliveryDetected = false;

        for (;;) {
            Message msg = queue.next(); // might block
            if (msg == null) {
                // No message indicates that the message queue is quitting.
                return;
            }

            // This must be in a local variable, in case a UI event sets the logger
            final Printer logging = me.mLogging;
            if (logging != null) {
                logging.println("&gt;&gt;&gt;&gt;&gt; Dispatching to " + msg.target + " " +
                        msg.callback + ": " + msg.what);
            }
            // Make sure the observer won't change while processing a transaction.
            final Observer observer = sObserver;

            final long traceTag = me.mTraceTag;
            long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;
            long slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs;
            if (thresholdOverride &gt; 0) {
                slowDispatchThresholdMs = thresholdOverride;
                slowDeliveryThresholdMs = thresholdOverride;
            }
            final boolean logSlowDelivery = (slowDeliveryThresholdMs &gt; 0) &amp;&amp; (msg.when &gt; 0);
            final boolean logSlowDispatch = (slowDispatchThresholdMs &gt; 0);

            final boolean needStartTime = logSlowDelivery || logSlowDispatch;
            final boolean needEndTime = logSlowDispatch;

            if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) {
                Trace.traceBegin(traceTag, msg.target.getTraceName(msg));
            }

            final long dispatchStart = needStartTime ? SystemClock.uptimeMillis() : 0;
            final long dispatchEnd;
            Object token = null;
            if (observer != null) {
                token = observer.messageDispatchStarting();
            }
            long origWorkSource = ThreadLocalWorkSource.setUid(msg.workSourceUid);
            try {
                //注意这里
                msg.target.dispatchMessage(msg);
                if (observer != null) {
                    observer.messageDispatched(token, msg);
                }
                dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0;
            } catch (Exception exception) {
                if (observer != null) {
                    observer.dispatchingThrewException(token, msg, exception);
                }
                throw exception;
            } finally {
                ThreadLocalWorkSource.restore(origWorkSource);
                if (traceTag != 0) {
                    Trace.traceEnd(traceTag);
                }
            }
            if (logSlowDelivery) {
                if (slowDeliveryDetected) {
                    if ((dispatchStart - msg.when) &lt;= 10) {
                        Slog.w(TAG, "Drained");
                        slowDeliveryDetected = false;
                    }
                } else {
                    if (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, "delivery",
                            msg)) {
                        // Once we write a slow delivery log, suppress until the queue drains.
                        slowDeliveryDetected = true;
                    }
                }
            }
            if (logSlowDispatch) {
                showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, "dispatch", msg);
            }

            if (logging != null) {
                logging.println("&lt;&lt;&lt;&lt;&lt; Finished to " + msg.target + " " + msg.callback);
            }

            // Make sure that during the course of dispatching the
            // identity of the thread wasn't corrupted.
            final long newIdent = Binder.clearCallingIdentity();
            if (ident != newIdent) {
                Log.wtf(TAG, "Thread identity changed from 0x"
                        + Long.toHexString(ident) + " to 0x"
                        + Long.toHexString(newIdent) + " while dispatching to "
                        + msg.target.getClass().getName() + " "
                        + msg.callback + " what=" + msg.what);
            }

            msg.recycleUnchecked();
        }
    }
}

</code></pre>
<h3 id="下班-quitquitsafely"><a class="header" href="#下班-quitquitsafely">下班 quit/quitSafely</a></h3>
<p>这是比较粗暴的行为，MQ离开了Looper就没法正常工作了，即下班即意味着辞职</p>
<pre><code class="language-java">class Looper {
    public void quit() {
        mQueue.quit(false);
    }
    
    public void quitSafely() {
        mQueue.quit(true);
    }
}
</code></pre>
<h2 id="消息处理-handler"><a class="header" href="#消息处理-handler">消息处理 Handler</a></h2>
<p>这里就比较清晰了。API基本分为以下几类：</p>
<p>面向使用者：</p>
<ul>
<li>创建Message，通过Message的 <code>享元模式</code></li>
<li>发送消息，注意postRunnable也是一个消息</li>
<li>移除消息，</li>
<li>退出等</li>
</ul>
<p>面向消息处理：</p>
<pre><code class="language-java">class Handler {
    /**
     * Subclasses must implement this to receive messages.
     */
    public void handleMessage(@NonNull Message msg) {
    }

    /**
     * Handle system messages here.
     * Looper分发时调用的API
     */
    public void dispatchMessage(@NonNull Message msg) {
        if (msg.callback != null) {
            handleCallback(msg);
        } else {
            if (mCallback != null) {
                if (mCallback.handleMessage(msg)) {
                    return;
                }
            }
            handleMessage(msg);
        }
    }
}
</code></pre>
<p>如果有 <code>Handler callback</code>，则交给callback处理，否则自己处理，如果没覆写 <code>handleMessage</code> ，消息相当于被 drop 了。</p>
<p>消息发送部分可以结合下图梳理：</p>
<p><img src="Android/Mechanism/Message/%E4%B8%89%E6%80%9D%E7%B3%BB%E5%88%97%EF%BC%9AAndroid%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%EF%BC%8C%E4%B8%80%E6%96%87%E5%90%83%E9%80%8F/send_msg.webp" alt="send_msg" /></p>
<hr />
<blockquote>
<p>阶段性小结,至此，我们已经对 <code>Framework层的消息机制</code> 有一个完整的了解了。
前面我们梳理了：</p>
<ul>
<li>Native层 和 Java层均有消息队列，并且通过JNI和指针映射，存在对应关系</li>
<li>Native层 和 Java层MQ <code>消息获取时的大致过程</code></li>
<li>Java层 Looper 如何工作</li>
<li>Java层 Handler 大致概览</li>
</ul>
<p>根据前面梳理的内容，可以总结：从 <code>Java Runtime</code> 看：</p>
<ul>
<li>消息队列机制服务于 <code>线程级别</code>，即一个线程有一个工作中的消息队列即可，当然，也可以没有。
即，一个Thread <code>至多有</code> 一个工作中的Looper。</li>
<li>Looper 和 Java层MQ <code>一一对应</code></li>
<li>Handler 是MQ的入口，也是 <code>消息</code> 的处理者</li>
<li>消息-- <code>Message</code> 应用了 <code>享元模式</code>，自身信息足够，满足 <code>自洽</code>，创建消息的开销性对较大，所以利用享元模式对消息对象进行复用。</li>
</ul>
</blockquote>
<p>下面我们再继续探究细节，解决前面语焉不详处留下的疑惑：</p>
<ul>
<li>消息的类型和本质</li>
<li>Native层Looper 的pollInner</li>
</ul>
<hr />
<h2 id="消息的类型和本质"><a class="header" href="#消息的类型和本质">消息的类型和本质</a></h2>
<p>message中的几个重要成员变量：</p>
<pre><code class="language-java">class Message {
   
    public int what;
    
    public int arg1;
    
    public int arg2;
    
    public Object obj;

    public Messenger replyTo;

    /*package*/ int flags;
    
    public long when;

    /*package*/ Bundle data;

    /*package*/ Handler target;

    /*package*/ Runnable callback;

}
</code></pre>
<p>其中 target是 <code>目标</code>，如果没有目标，那就是一个特殊的消息： <code>同步屏障</code> 即 <code>barrier</code>；</p>
<p>what 是消息标识
arg1 和 arg2 是开销较小的 <code>数据</code>，如果 <code>不足以表达信息</code>  则可以放入 <code>Bundle data</code> 中。</p>
<p>replyTo 和 obj 是跨进程传递消息时使用的，暂且不看。</p>
<p>flags 是 message 的状态标识，例如 <code>是否在使用中</code>，<code>是否是同步消息</code></p>
<blockquote>
<p>上面提到的同步屏障，即 barrier，其作用是拦截后面的 <code>同步消息</code> 不被获取，在前面阅读Java层MQ的next方法时读到过。</p>
<p>我们还记得，next方法中，使用死循环，尝试读出一个满足处理条件的消息，如果取不到，因为死循环的存在，调用者（Looper）会被一直阻塞。</p>
</blockquote>
<p>此时可以印证一个结论，消息按照 <code>功能分类</code> 可以分为 <code>三种</code>：</p>
<ul>
<li>普通消息</li>
<li>同步屏障消息</li>
<li>异步消息</li>
</ul>
<p>其中同步消息是一种内部机制。设置屏障之后需要在合适时间取消屏障，否则会导致 <code>普通消息永远无法被处理</code>，而取消时，需要用到设置屏障时返回的token。</p>
<h2 id="native层looper"><a class="header" href="#native层looper"><a id="native_looper">Native层Looper</a></a></h2>
<p>相信大家都对 <code>Native层</code> 的Looper产生兴趣了，想看看它在Native层都干些什么。</p>
<p>对完整源码感兴趣的可以看 <a href="https://github.com/leobert-lan/Blog/blob/main/Android/Mechanism/Message/code/Looper.cpp">这里</a> ，下面我们节选部分进行阅读。</p>
<p>前面提到了Looper的pollOnce，处理完搁置的Response之后，会调用pollInner获取消息</p>
<pre><code class="language-cpp">int Looper::pollInner(int timeoutMillis) {
#if DEBUG_POLL_AND_WAKE
    ALOGD("%p ~ pollOnce - waiting: timeoutMillis=%d", this, timeoutMillis);
#endif

    // Adjust the timeout based on when the next message is due.
    if (timeoutMillis != 0 &amp;&amp; mNextMessageUptime != LLONG_MAX) {
        nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);
        int messageTimeoutMillis = toMillisecondTimeoutDelay(now, mNextMessageUptime);
        if (messageTimeoutMillis &gt;= 0
                &amp;&amp; (timeoutMillis &lt; 0 || messageTimeoutMillis &lt; timeoutMillis)) {
            timeoutMillis = messageTimeoutMillis;
        }
#if DEBUG_POLL_AND_WAKE
        ALOGD("%p ~ pollOnce - next message in %lldns, adjusted timeout: timeoutMillis=%d",
                this, mNextMessageUptime - now, timeoutMillis);
#endif
    }

    // Poll.
    int result = ALOOPER_POLL_WAKE;
    mResponses.clear();
    mResponseIndex = 0;

    struct epoll_event eventItems[EPOLL_MAX_EVENTS];
    
    //注意 1
    int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);

    // Acquire lock.
    mLock.lock();

// 注意 2
    // Check for poll error.
    if (eventCount &lt; 0) {
        if (errno == EINTR) {
            goto Done;
        }
        ALOGW("Poll failed with an unexpected error, errno=%d", errno);
        result = ALOOPER_POLL_ERROR;
        goto Done;
    }

// 注意 3
    // Check for poll timeout.
    if (eventCount == 0) {
#if DEBUG_POLL_AND_WAKE
        ALOGD("%p ~ pollOnce - timeout", this);
#endif
        result = ALOOPER_POLL_TIMEOUT;
        goto Done;
    }

//注意 4
    // Handle all events.
#if DEBUG_POLL_AND_WAKE
    ALOGD("%p ~ pollOnce - handling events from %d fds", this, eventCount);
#endif

    for (int i = 0; i &lt; eventCount; i++) {
        int fd = eventItems[i].data.fd;
        uint32_t epollEvents = eventItems[i].events;
        if (fd == mWakeReadPipeFd) {
            if (epollEvents &amp; EPOLLIN) {
                awoken();
            } else {
                ALOGW("Ignoring unexpected epoll events 0x%x on wake read pipe.", epollEvents);
            }
        } else {
            ssize_t requestIndex = mRequests.indexOfKey(fd);
            if (requestIndex &gt;= 0) {
                int events = 0;
                if (epollEvents &amp; EPOLLIN) events |= ALOOPER_EVENT_INPUT;
                if (epollEvents &amp; EPOLLOUT) events |= ALOOPER_EVENT_OUTPUT;
                if (epollEvents &amp; EPOLLERR) events |= ALOOPER_EVENT_ERROR;
                if (epollEvents &amp; EPOLLHUP) events |= ALOOPER_EVENT_HANGUP;
                pushResponse(events, mRequests.valueAt(requestIndex));
            } else {
                ALOGW("Ignoring unexpected epoll events 0x%x on fd %d that is "
                        "no longer registered.", epollEvents, fd);
            }
        }
    }
Done: ;

// 注意 5
    // Invoke pending message callbacks.
    mNextMessageUptime = LLONG_MAX;
    while (mMessageEnvelopes.size() != 0) {
        nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);
        const MessageEnvelope&amp; messageEnvelope = mMessageEnvelopes.itemAt(0);
        if (messageEnvelope.uptime &lt;= now) {
            // Remove the envelope from the list.
            // We keep a strong reference to the handler until the call to handleMessage
            // finishes.  Then we drop it so that the handler can be deleted *before*
            // we reacquire our lock.
            { // obtain handler
                sp&lt;MessageHandler&gt; handler = messageEnvelope.handler;
                Message message = messageEnvelope.message;
                mMessageEnvelopes.removeAt(0);
                mSendingMessage = true;
                mLock.unlock();

#if DEBUG_POLL_AND_WAKE || DEBUG_CALLBACKS
                ALOGD("%p ~ pollOnce - sending message: handler=%p, what=%d",
                        this, handler.get(), message.what);
#endif
                handler-&gt;handleMessage(message);
            } // release handler

            mLock.lock();
            mSendingMessage = false;
            result = ALOOPER_POLL_CALLBACK;
        } else {
            // The last message left at the head of the queue determines the next wakeup time.
            mNextMessageUptime = messageEnvelope.uptime;
            break;
        }
    }

    // Release lock.
    mLock.unlock();

//注意 6
    // Invoke all response callbacks.
    for (size_t i = 0; i &lt; mResponses.size(); i++) {
        Response&amp; response = mResponses.editItemAt(i);
        if (response.request.ident == ALOOPER_POLL_CALLBACK) {
            int fd = response.request.fd;
            int events = response.events;
            void* data = response.request.data;
#if DEBUG_POLL_AND_WAKE || DEBUG_CALLBACKS
            ALOGD("%p ~ pollOnce - invoking fd event callback %p: fd=%d, events=0x%x, data=%p",
                    this, response.request.callback.get(), fd, events, data);
#endif
            int callbackResult = response.request.callback-&gt;handleEvent(fd, events, data);
            if (callbackResult == 0) {
                removeFd(fd);
            }
            // Clear the callback reference in the response structure promptly because we
            // will not clear the response vector itself until the next poll.
            response.request.callback.clear();
            result = ALOOPER_POLL_CALLBACK;
        }
    }
    return result;
}
</code></pre>
<p>上面标记了注意点</p>
<ul>
<li>1 epoll机制，等待 <code>mEpollFd</code> 产生事件, 这个等待具有超时时间。</li>
<li>2，3，4 是等待的三种结果，<code>goto</code> 语句可以直接跳转到 <code>标记</code> 处</li>
<li>2 检测poll <code>是否出错</code>，如果有，跳转到 Done</li>
<li>3 检测pool <code>是否超时</code>，如果有，跳转到 Done</li>
<li>4 处理epoll后所有的事件</li>
<li>5 处理 pending 消息的回调</li>
<li>6 处理 所有 Response的回调</li>
</ul>
<p>并且我们可以发现返回的结果有以下几种：</p>
<ul>
<li>ALOOPER_POLL_CALLBACK</li>
</ul>
<p>有 <code>pending message</code> 或者 <code>request.ident</code> 值为 <code>ALOOPER_POLL_CALLBACK</code> 的 Response被处理了。
如果没有：</p>
<ul>
<li>ALOOPER_POLL_WAKE 正常唤醒</li>
<li>ALOOPER_POLL_ERROR epoll错误</li>
<li>ALOOPER_POLL_TIMEOUT epoll超时</li>
</ul>
<p>查找了一下枚举值:</p>
<pre><code class="language-java">ALOOPER_POLL_WAKE = -1,
ALOOPER_POLL_CALLBACK = -2,
ALOOPER_POLL_TIMEOUT = -3,
ALOOPER_POLL_ERROR = -4
</code></pre>
<hr />
<blockquote>
<p>阶段性小结, 我们对 <code>消息</code> 和 <code>Native层的pollInner</code> 进行了一次脑暴，引出了epoll机制。</p>
<p>其实Native层的 <code>Looper分发</code>还有不少值得脑暴的点，但我们先缓缓，已经迫不及待的要对 <code>epoll</code>机制进行脑暴了。</p>
</blockquote>
<hr />
<p>##脑暴：Linux中的I/O模型</p>
<blockquote>
<p>这部分内容，推荐一篇文章：<a href="https://blog.csdn.net/hguisu/article/details/38638183#t12">使用 libevent 和 libev 提高网络应用性能——I/O模型演进变化史</a> 作者 hguisu</p>
<p>PS:本段中，存在部分图片直接引用自该文，我偷了个懒，没有去找原版内容并标记出处</p>
</blockquote>
<p>阻塞I/O模型图：在调用recv()函数时，发生在内核中等待数据和复制数据的过程</p>
<p><img src="https://img-blog.csdnimg.cn/20190525214406514.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hndWlzdQ==,size_16,color_FFFFFF,t_70" alt="阻塞I/O模型" /></p>
<p>实现非常的 <code>简单</code>，但是存在一个问题，阻塞导致线程无法执行其他任何计算，如果是在网络编程背景下，需要使用多线程提高处理并发的能力。</p>
<p><strong>注意，不要用 Android中的 <code>点击屏幕等硬件被触发事件</code> 去对应这里的 <code>网络并发</code>，这是两码事。</strong></p>
<p>如果采用了 <code>多进程</code> 或者 <code>多线程</code> 实现 <code>并发应答</code>，模型如下：</p>
<p><img src="https://img-blog.csdn.net/20140818224818116?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGd1aXN1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="应答模型" /></p>
<p>到这里，我们看的都是 I/O 阻塞 模型。</p>
<blockquote>
<p>脑暴，阻塞为调用方法后一直在等待返回值，线程内执行的内容就像 <code>卡顿</code> 在这里。</p>
</blockquote>
<p>如果要消除这种卡顿，那就不能调用方法等待I/O结果，而是要 <code>立即返回</code> ！</p>
<p>举个例子：</p>
<ul>
<li>去西装店定制西装，确定好款式和尺寸后，你坐在店里一直等着，等到做好了拿给你，这就是阻塞型的，这能等死你；</li>
<li>去西装店定制西装，确定好款式和尺寸后，店员告诉你别干等着，好多天呢，等你有空了来看看，这就是非阻塞型的。</li>
</ul>
<p>改变为非阻塞模型后，应答模型如下：</p>
<p><img src="https://img-blog.csdn.net/20140825233622500" alt="应答模型——非阻塞" /></p>
<p>不难理解，这种方式需要顾客去 <code>轮询</code> 。对客户不友好，但是对店家可是一点损失都没有，还让等候区没那么挤了。</p>
<p>有些西装店进行了改革，对客户更加友好了:</p>
<blockquote>
<p>去西装店定制西装，确定好款式和尺寸后，留下联系方式，等西服做好了联系客户，让他来取。</p>
</blockquote>
<p>这就变成了 <code>select</code> or <code>poll</code> 模型：</p>
<p><img src="https://img-blog.csdnimg.cn/20190603172255403.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ndWlzdS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="select模型" /></p>
<p><strong>注意</strong>：进行改革的西装店需要增加一个员工，<em>图中标识的用户线程</em>，他的工作是：</p>
<ul>
<li>在前台记录客户订单和联系方式</li>
<li>拿记录着 <code>订单</code> 的小本子去找制作间，<code>不断检查</code> 订单是否完工，完工的就可以提走并联系客户了。</li>
</ul>
<p>而且，他去看订单完工时，无法在前台记录客户信息，这意味他 <code>阻塞</code> 了，其他工作只能先搁置着。</p>
<p>这个做法，对于制作间而言，和 <code>非阻塞模型</code> 并没有多大区别。还增加了一个店员，但是，用 <code>一个店员</code> 就解决了之前 <code>很多店员</code> 都会跑去 <code>制作间</code> 帮客户问"订单好了没有？" 的问题。</p>
<blockquote>
<p>值得一提的是，为了提高服务质量，这个员工每次去制作间询问一个订单时，都需要记录一些信息：</p>
<ul>
<li>订单完成度询问时，是否被应答；</li>
<li>应答有没有说谎；等</li>
</ul>
<p>有些店对每种不同的考核项均准备了记录册，这和 <code>select</code>模型类似</p>
<p>有些店只用一本记录册，但是册子上可以利用表格记录各种考核项，这和 <code>poll</code> 模型类似</p>
</blockquote>
<p><code>select</code> 模型 和 <code>poll</code> 模型的近似度比较高。</p>
<p>没多久，老板就发现了，这个店员的工作效率有点低下，他每次都要拿着一本订单簿，去把订单都问一遍，倒不是员工不勤快，是这个模式有点问题。</p>
<p>于是老板又进行了改革：</p>
<ul>
<li>在 <code>前台</code> 和 <code>制作间</code> 之间加一个送信管道。</li>
<li>制作间有进度需要汇报了，就送一份信到前台，信上写着订单号。</li>
<li>前台员工直接去问对应的订单。</li>
</ul>
<p>这就变成了 <code>epoll模型</code>解决了 <code>select/poll</code> 模型的遍历效率问题。</p>
<p>这样改革后，前台员工就不再需要按着订单簿从上到下挨个问了。提高了效率，前台员工只要<code>无事发生</code>，就可以优雅的划水了。</p>
<p>我们看一下NativeLooper的构造函数：</p>
<pre><code class="language-cpp">Looper::Looper(bool allowNonCallbacks) :
        mAllowNonCallbacks(allowNonCallbacks), mSendingMessage(false),
        mResponseIndex(0), mNextMessageUptime(LLONG_MAX) {
    int wakeFds[2];
    int result = pipe(wakeFds);
    LOG_ALWAYS_FATAL_IF(result != 0, "Could not create wake pipe.  errno=%d", errno);

    mWakeReadPipeFd = wakeFds[0];
    mWakeWritePipeFd = wakeFds[1];

    result = fcntl(mWakeReadPipeFd, F_SETFL, O_NONBLOCK);
    LOG_ALWAYS_FATAL_IF(result != 0, "Could not make wake read pipe non-blocking.  errno=%d",
            errno);

    result = fcntl(mWakeWritePipeFd, F_SETFL, O_NONBLOCK);
    LOG_ALWAYS_FATAL_IF(result != 0, "Could not make wake write pipe non-blocking.  errno=%d",
            errno);

    // Allocate the epoll instance and register the wake pipe.
    mEpollFd = epoll_create(EPOLL_SIZE_HINT);
    LOG_ALWAYS_FATAL_IF(mEpollFd &lt; 0, "Could not create epoll instance.  errno=%d", errno);

    struct epoll_event eventItem;
    memset(&amp; eventItem, 0, sizeof(epoll_event)); // zero out unused members of data field union
    eventItem.events = EPOLLIN;
    eventItem.data.fd = mWakeReadPipeFd;
    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp; eventItem);
    LOG_ALWAYS_FATAL_IF(result != 0, "Could not add wake read pipe to epoll instance.  errno=%d",
            errno);
}
</code></pre>
<h2 id="总结-3"><a class="header" href="#总结-3">总结</a></h2>
<p>相信看到这里，大家已经自己悟透了各种问题。按照惯例，还是要总结下，因为 <code>这篇是脑暴</code>，所以 <code>思绪</code> 是比较 <code>跳跃</code> 的，内容前后关系不太明显。</p>
<p>我们结合一个问题来点明内容前后关系。</p>
<blockquote>
<p>Java层 Looper和MQ 会什么使用了死循环但是 <code>不会"阻塞"UI线程</code> / <code>没造成ANR</code> / <code>依旧可以响应点击事件</code></p>
</blockquote>
<ul>
<li>Android是基于 <code>事件驱动</code> 的，并建立了 <code>完善的</code> 消息机制</li>
<li>Java层的消息机制只是一个局部，其负责的就是面向消息队列，处理 <code>消息队列管理</code>，<code>消息分发</code>，<code>消息处理</code></li>
<li>Looper的死循环保障了 <code>消息队列</code> 的 <code>消息分发</code> 一直处于有效运行中，不循环就停止了分发。</li>
<li>MessageQueue的 <code>死循环</code> 保障了 <code>Looper可以获取有效的消息</code>，保障了Looper <code>只要有消息，就一直运行</code>，发现有效消息，就跳出了死循环。</li>
<li>而且Java层MessageQueue在 next() 方法中的死循环中，通过JNI调用了 Native层MQ的 <code>pollOnce</code>，驱动了Native层去处理Native层消息</li>
<li>值得一提的是，UI线程处理的事情也都是基于消息的，无论是更新UI还是响应点击事件等。</li>
</ul>
<p>所以，正是Looper 进行loop()之后的死循环，保障了UI线程的各项工作正常执行。</p>
<p>再说的ANR，这是Android 确认<code>主线程</code> 消息机制 <code>正常</code> 且 <code>健康</code> 运转的一种检测机制。</p>
<p>因为主线程Looper需要利用 <code>消息机制</code> 驱动UI渲染和交互事件处理，
如果某个消息的执行，或者其衍生出的业务，在主线程占用了大量的时间，导致主线程长期阻塞，会影响用户体验。</p>
<p>所以ANR检测采用了一种 <code>埋定时炸弹</code> 的机制，必须依靠Looper的高效运转来消除之前装的定时炸弹。而这种定时炸弹比较有意思，<code>被发现了才会炸</code>。</p>
<p>在说到 <code>响应点击事件</code>，类似的事件总是从硬件出发的，在到内核，再进程间通信到用户空间，这些事件以消息的形式存在于Native层，经过处理后，表现出：</p>
<blockquote>
<p>ViewRootImpl收到了InputManager的输入，并进行了事件处理</p>
</blockquote>
<hr />
<p>这里我们借用一张图总结整个消息机制流程：</p>
<p><img src="https://img.jbzj.com/file_images/article/201609/2016922103751644.jpg?2016822103759" alt="" /></p>
<p><em>图片来自 《Android7.0 MessageQueue详解》 作者 Gaugamela</em></p>
<blockquote>
<p>PS:这篇文章写得很长，内容长，耗时也长，大约花费了10天的时间，其中还有不少内容写得未能尽兴。例如：
"Java层在哪些情况下利用JNI调取Native层的唤醒，为什么这么干？"等等。</p>
<p>但是考虑到篇幅，决定不再往下挖了。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>Android中遇到的兼容性工作</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="好玩系列让项目中的相册支持heif格式图片"><a class="header" href="#好玩系列让项目中的相册支持heif格式图片">好玩系列：让项目中的相册支持Heif格式图片</a></h1>
<h2 id="前言-9"><a class="header" href="#前言-9">前言</a></h2>
<p>目前市面上的成熟的APP，其用户体系中均存在 <code>设置头像</code> 的功能，考虑到尺寸规范问题，一般会加入 <code>图片裁剪</code> 功能；
考虑到页面UI统一度问题，甚至会在应用内实现 <code>相册</code>功能。据此推断：各位的项目中，会遇到 <code>Heif格式图片</code> 需要兼容的需求。</p>
<p>笔者目前参与的商业项目，也被市场要求对Heif图片进行适配。这篇文章，记录了我在这件事情上 <code>折腾</code> 的过程。</p>
<blockquote>
<p>好玩系列是我进行 <code>新事物实践</code> 、 <code>尝试创造</code> 的记录，<a href="https://github.com/leobert-lan/Blog/blob/main/info/%E5%85%B3%E4%BA%8E%E5%A5%BD%E7%8E%A9%E7%B3%BB%E5%88%97.md">了解更多</a></p>
</blockquote>
<h2 id="背景"><a class="header" href="#背景">背景</a></h2>
<p>HEIF格式的全名为 High Efficiency Image File Format（高效率图档格式），是由动态图像专家组（MPEG）在2013年推出的新格式，<a href="https://nokiatech.github.io/heif/">了解更多</a></p>
<p><a href="https://github.com/nokiatech/heif">了解Heif整个项目</a></p>
<p><a href="https://github.com/nokiatech/heif_conformance">测试文件</a></p>
<p><em>笔者注：印象中，iOS系统大约在16年就全面支持这一类型的文件了，而Android大约是三年前，在Android P推出的时候，宣布原生支持Heif文件</em></p>
<p>随着市场上的Android机器已经大面积过渡到 <code>Android Q</code>，从这一点看，确实到了该适配的阶段了。</p>
<blockquote>
<p>目标，至少实现Android P及其以上的适配，尝试向更低版本适配</p>
</blockquote>
<h2 id="iso-base-media-file-format"><a class="header" href="#iso-base-media-file-format">ISO Base Media File Format</a></h2>
<blockquote>
<p>HEIF格式是基于 ISO Base Media File Format格式衍生出来的图像封装格式，所以它的文件格式同样符合ISO Base Media File Format (ISO/IEC 14496-12)中的定义（ ISOBMFF）。</p>
<p>文件中所有的数据都存储在称为Box的数据块结构中，每个文件由若干个Box组成，每个Box有自己的类型和长度。在一个Box中还可以包含子Box，最终由一系列的Box组成完整的文件内容，结构如下图所示，图中每个方块即代表一个Box。</p>
<p>我们常见的MP4文件同样是ISOBMFF结构，所以HEIF文件结构和MP4文件结构基本一致，只是用到的Box类型有区别。</p>
<p>HEIF文件如果是单幅的静态图片的话，使用item的形式保存数据，所有item单独解码；如果保存的为图片序列的话，使用track的方式保存。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2926667-337a35837bb3325e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200" alt="" /></p>
<p>作者：金山视频云
链接：https://www.jianshu.com/p/b016d10a087d
来源：简书
著作权归作者所有</p>
</blockquote>
<h2 id="通过contentresolver查询heif格式文件"><a class="header" href="#通过contentresolver查询heif格式文件">通过ContentResolver查询Heif格式文件</a></h2>
<p>系统通过ContentProvider向其他应用暴露图片等内容信息。目前 <code>尚未查询相关文档</code> ，未确定 <code>Android相册向其他应用提供了Heif文件查询支持</code></p>
<p>通过查询我们得到Heif文件的 <code>主要的</code> 扩展名为 <code>heic</code> 、 <code>heif</code>.</p>
<pre><code class="language-java">ContentResolver contentResolver = context.getContentResolver();
String sort = MediaStore.Images.Media.DATE_MODIFIED + " desc ";
String selection = MediaStore.Images.Media.MIME_TYPE + "=?";
String[] selectionArgs = new String[]{"image/heic"};

String[] projection = {MediaStore.Images.Media._ID, MediaStore.Images.ImageColumns.BUCKET_DISPLAY_NAME,
        MediaStore.Images.ImageColumns.DATE_MODIFIED};

Cursor cursor = contentResolver.query(
        MediaStore.Images.Media.EXTERNAL_CONTENT_URI,
        projection,
        selection,
        selectionArgs,
        sort
);
</code></pre>
<p>我们在测试文件中只找到了 <code>heic</code>, 就先只测一种。</p>
<p>我们发现，系统支持的情况下，是可以查询到数据的。<em>PS，导入数据到手机后，最好重启下</em></p>
<h2 id="解码与图片显示"><a class="header" href="#解码与图片显示">解码与图片显示</a></h2>
<p>我们忽略掉Android版本相应的适配问题，假定已经得到了相应文件的 Uri, 项目中Glide-4.12.0版本已经处理了适配。</p>
<p><code>我们去探索一下，是自行添加的解码器，还是依赖于系统API</code></p>
<p><a href="https://github.com/bumptech/glide/blob/9c6eae7dccd4570dd2914fc2be84631f7b3b570e/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ExifInterfaceImageHeaderParser.java">ExifInterfaceImageHeaderParser 提及内容</a></p>
<pre><code>/**
 * Uses {@link ExifInterface} to parse orientation data.
 *
 * &lt;p&gt;ExifInterface supports the HEIF format on OMR1+. Glide's {@link DefaultImageHeaderParser}
 * doesn't currently support HEIF. In the future we should reconcile these two classes, but for now
 * this is a simple way to ensure that HEIF files are oriented correctly on platforms where they're
 * supported.
 */
</code></pre>
<p>文档中提到，系统版本 <code>O_MR1+</code> 中已经支持了 <code>HEIF</code>，但是目前的 <code>DefaultImageHeaderParser</code> 还不支持，未来会综合考虑这两个类（系统Exif相关类和DefaultImageHeaderParser），但目前，这是一个简单的方式，确保HEIF在受支持的平台上被正确处理图片方向。</p>
<p><a href="https://github.com/bumptech/glide/blob/5acc99f8fc7e772aeef8aa959ff2a9c203ab1aa6/library/src/main/java/com/bumptech/glide/Glide.java">Glide 类中提及的内容</a></p>
<pre><code>// Right now we're only using this parser for HEIF images, which are only supported on OMR1+.
// If we need this for other file types, we should consider removing this restriction.
if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O_MR1) {
  registry.register(new ExifInterfaceImageHeaderParser());
}
</code></pre>
<p>目前仅用于解析HEIF文件的头信息。</p>
<p>我们知道，Glide加载是先获取流，解析头信息，利用对应的解码器处理。而加载此类性质的图片时，是先解码为Bitmap，在进行 <code>装饰</code> , 而Bitmap的解码是利用了系统API，见BitmapFactory.</p>
<p>所以，如果项目中使用了Glide（<em>似乎高于4.10.0即具有功能，没有仔细查阅</em>），而手机也支持了HEIF，那么应用就可以支持Heif显示了。</p>
<p>Glide官方对于 <code>自定义解码器</code> 还是持保守态度的。但是我们要试一下，尝试在Glide中接入Heif解码器。</p>
<hr />
<p>至此，我们已经完成了基本目标：</p>
<ul>
<li>借用平台自身兼容性（当然也可以自己根据版本适配查询语句），利用 <code>ContentResolver</code> 获取 Heif格式的图片</li>
<li>借助Glide已有的实现，直接在支持的平台版本上解码、构建Bitmap、构建相应Drawable、呈现。</li>
</ul>
<p>Glide官方提供了支持，是一件值得庆幸的事情。</p>
<p><em>因为项目中仅使用了Glide，笔者没有继续对Fresco展开调研。而Fresco作为一款优秀的图片加载框架，并且有庞大的社区支持，盲目推测其亦实现了内部支持。</em></p>
<p>接下来展开向更低版本适配的尝试。当然，这 <code>仅限于</code> 解码、呈现环节，并不考虑 <code>ContentProvider</code>， <code>ContentResolver</code> 在低版本上对于Heif格式文件的适配。</p>
<hr />
<h2 id="尝试向glide接入heif解码器"><a class="header" href="#尝试向glide接入heif解码器">尝试向Glide接入Heif解码器</a></h2>
<blockquote>
<p>将官方测试数据集导入 <code>支持Heif</code> 的小米、华为部分机型后，我发现部分图片未被系统支持，提示文件损毁或者不受支持。</p>
</blockquote>
<p>另外，冲着好玩，我值得折腾一下。</p>
<p><strong>必须申明</strong>：下面的实践只是从好玩角度出发的，<code>并未考虑</code> 健壮性和全场景覆盖。</p>
<p>我计划将Heif文件放入Assets资源，按照我们对Glide的了解，其解码路径起始点是：<code>android.content.res.AssetManager$AssetInputStream</code></p>
<pre><code class="language-kotlin">@GlideModule
class CustomGlideModule : AppGlideModule() {
    override fun registerComponents(context: Context, glide: Glide, registry: Registry) {
        if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.O_MR1) {
            registry.register(object : ImageHeaderParser {
                override fun getType(`is`: InputStream): ImageHeaderParser.ImageType {
                    return ImageHeaderParser.ImageType.UNKNOWN
                }

                override fun getType(byteBuffer: ByteBuffer): ImageHeaderParser.ImageType {
                    return ImageHeaderParser.ImageType.UNKNOWN
                }

                override fun getOrientation(`is`: InputStream, byteArrayPool: ArrayPool): Int {
                    return ImageHeaderParser.UNKNOWN_ORIENTATION
                }

                override fun getOrientation(byteBuffer: ByteBuffer, byteArrayPool: ArrayPool): Int {
                    return ImageHeaderParser.UNKNOWN_ORIENTATION
                }

            })
        }

        registry.prepend(
                Registry.BUCKET_BITMAP,
                InputStream::class.java, Bitmap::class.java, CustomBitmapDecoder(context, glide.bitmapPool)
        )
    }

}
</code></pre>
<p>这样，我们会得到这样一条解码路径：</p>
<pre><code>DecodePath{ 
	dataClass=class android.content.res.AssetManager$AssetInputStream, 
	decoders=[
		osp.leobert.android.heifdemo.CustomBitmapDecoder@5c4ee9e,
		com.bumptech.glide.load.resource.bitmap.StreamBitmapDecoder@1c1ed7f
	],
	transcoder=com.bumptech.glide.load.resource.transcode.BitmapDrawableTranscoder@529014c
}
</code></pre>
<p>接下来我们需要考虑解码器的接入。</p>
<h3 id="nokia的sdk"><a class="header" href="#nokia的sdk">Nokia的SDK</a></h3>
<p>Nokia的Heif库：<a href="https://github.com/nokiatech/heif">链接</a></p>
<p>草率了，经过一番源码研读，发现只有读写过程封装，相当于只有 <code>最基础</code> 的协议封包、拆包，想要真正在Android上使用，还有很多事情要处理。</p>
<p><img src="Android/Idea/post_14/a1.jpeg" alt="" /></p>
<h3 id="看下android-p"><a class="header" href="#看下android-p">看下Android P</a></h3>
<p>我们知道，Android P原生支持了Heif，查一下资料，其底层支持如下：</p>
<p><img src="https://image-static.segmentfault.com/352/543/3525433938-5bcd76c4a185b_articlex" alt="" /></p>
<hr />
<p>一番思考后，发现 <code>成本过大</code>。</p>
<p>再附上 Glide 适用的Decoder：</p>
<pre><code class="language-kotlin">class CustomBitmapDecoder(val context: Context, val bitmapPool: BitmapPool) : ResourceDecoder&lt;InputStream, Bitmap&gt; {
    override fun handles(source: InputStream, options: Options): Boolean {
        return true
    }

    @Throws(IOException::class)
    fun toByteArray(input: InputStream): ByteArray? {
        val output = ByteArrayOutputStream()
        copy(input, output)
        return output.toByteArray()
    }

    @Throws(IOException::class)
    fun copy(input: InputStream, output: OutputStream): Int {
        val count = copyLarge(input, output)
        return if (count &gt; 2147483647L) {
            -1
        } else count.toInt()
    }

    @Throws(IOException::class)
    fun copyLarge(input: InputStream, output: OutputStream): Long {
        val buffer = ByteArray(4096)
        var count = 0L
        var n = 0
        while (-1 != input.read(buffer).also { n = it }) {
            output.write(buffer, 0, n)
            count += n.toLong()
        }
        return count
    }

    override fun decode(source: InputStream, width: Int, height: Int, options: Options): Resource&lt;Bitmap&gt;? {

        val heif = HEIF()
        try {
            val byteArray = toByteArray(source)
            // Load the file
            heif.load(ByteArrayInputStream(byteArray))

            // Get the primary image
            val primaryImage = heif.primaryImage

            // Check the type, assuming that it's a HEVC image
            if (primaryImage is HEVCImageItem) {
//                val decoderConfig = primaryImage.decoderConfig.config

                val imageData = primaryImage.itemDataAsArray
                // Feed the data to a decoder

                // FIXME: 2021/3/23 find a decoder to generate Bitmap when not upon Android P
                return BitmapResource.obtain(
                        BitmapFactory.decodeByteArray(imageData, 0, imageData.size),
                        bitmapPool
                )
            }
        } // All exceptions thrown by the HEIF library are of the same type
        // Check the error code to see what happened
        catch (e: Exception) {
            e.printStackTrace()
        } finally {
            heif.release()
        }
        return null
    }
}
</code></pre>
<p>如果找到了一个解码器，在Android P以下支持解码或转码，封装为Bitmap，就 <code>可以在低版本上适配</code> 了。当然还需要完成：<code>适配所有可能的解码路径</code>，<code>头信息处理</code> 工作。</p>
<p>这次尝试， <code>以失败告终</code>。</p>
<p>居然翻车了，<img src="Android/Idea/post_14/jljt.gif" alt="" /></p>
<h2 id="遐想"><a class="header" href="#遐想">遐想</a></h2>
<p>力大砖飞？集成ImageMagick之类的库，直接实现图片转码，成本有点过大了，先不折腾。</p>
<p>本次实践，我们实现了基本目标，高级目标因为初步调研不充分以失败告终，但是也增长了知识。</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="glide"><a class="header" href="#glide">Glide</a></h3>
<p>Glide 源码和设计解析</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="三思系列glide-4x全方位认知----模块职责概览--glide一"><a class="header" href="#三思系列glide-4x全方位认知----模块职责概览--glide一">三思系列：Glide 4.X全方位认知 -- 模块职责概览 | Glide（一）</a></h1>
<p>最近在解决一些问题时，进行了一下检索，发现 <code>绝大多数文章</code> 是 <code>基于3.X</code>。Glide从进入4.X也有两三年了，在3.X的基础上，发生了很多变化。 所幸我对 <code>4.X</code>
的源码还比较熟，且Glide的设计也很精彩，索性写一写 <code>对4.X的剖析</code>。</p>
<p>当然，对于多数读者而言，因为有一定的基础知识，这些剖析文章并不是满地金砖了，可以泛读查漏。</p>
<blockquote>
<p>三思系列是我最新的学习、总结形式，着重于:<strong>问题分析</strong>、<strong>技术积累</strong>、<strong>视野拓展</strong>，<a href="https://leobert-lan.github.io/info/about_sansi_series.html">了解更多</a></p>
</blockquote>
<h2 id="本文主旨"><a class="header" href="#本文主旨">本文主旨</a></h2>
<p><strong>Glide是一个 <code>庞大</code> 的项目，这一篇旨在对Glide项目4.X版本进行 <code>全方位的认知</code></strong></p>
<p>具体为：<strong>了解Glide处理哪些问题，哪些模块与之相对应</strong></p>
<p>对早年间 Square公司开源的 <code>Picasso</code> 比较熟悉的读者而言，不难理解：<code>Picasso</code> 是一个 <code>小而雅</code> 的框架，聚焦于图片加载的以下4点主要问题：</p>
<ul>
<li><code>异步过程管理与调度</code></li>
<li><code>资源与显示容器多对多关系</code></li>
<li><code>多级缓存</code></li>
<li><code>图片转换支持ScaleType</code></li>
</ul>
<p>而后起之秀 <code>Glide</code> 已经是一个 <code>博大且细致</code> 的图片异步加载框架。</p>
<p>在Glide 1.X 时期，两者的关注点基本一致，随着官方支持Glide的发展，它的关注点也越来越多，包括但不限于：</p>
<ul>
<li><code>资源的封装</code></li>
<li><code>资源获取方式与过程</code></li>
<li><code>缓存</code></li>
<li><code>decode</code>、<code>encode</code> 的过程</li>
<li><code>Target的抽象</code>，<em>注：媒体资源获取的最终目标，例如存为文件、加载到ImageView中等</em></li>
<li><code>图片转换</code></li>
<li><code>资源与Target多对多关系</code></li>
<li><code>生命周期感知与控制</code></li>
</ul>
<p>仔细思考这些点之后，我们不难发现，Glide已经着眼于解决这样一个问题：</p>
<blockquote>
<p>构建一个系统，对指定的标识媒体资源的实体，<em>其封装形式可以自行扩展</em>，执行资源的获取，并应用内存、磁盘进行缓存，封装图片的解码过程，按指定要求进行
裁切、缩放等图片转换，最终将结果运用到指定的目标。并对整个过程按照Android平台特性进行生命周期管理。</p>
</blockquote>
<p>而这个过程中的绝大多数 <code>节点</code> 或者称之为 <code>切面</code>，均可进行 <code>外部扩展</code></p>
<p>这一点我们可以从项目介绍中得到印证：<em>看重点单词即可</em></p>
<blockquote>
<p>Glide is a fast and efficient open source <code>media management</code> and <code>image loading framework</code> for Android that wraps <code>media decoding</code>, <code>memory and disk caching</code>, and <code>resource pooling</code> into a simple and easy to use interface.</p>
<p>Glide supports <code>fetching</code>, <code>decoding</code>, and <code>displaying</code> video stills, images, and animated GIFs. Glide includes a flexible API
that allows developers to plug in to almost any network stack. By default Glide uses a custom <code>HttpUrlConnection</code> based
stack, but also includes utility libraries plug in to Google's Volley project or Square's OkHttp library instead.</p>
<p>Glide's <code>primary focus</code> is on <code>making scrolling any kind of a list of images</code> as <code>smooth and fast</code> as possible, but Glide is
also effective for <code>almost any case</code> where you need to <code>fetch</code>, <code>resize</code>, and <code>display</code> a remote image.</p>
</blockquote>
<h2 id="模块职责划分从glide的构建过程窥一斑"><a class="header" href="#模块职责划分从glide的构建过程窥一斑">模块职责划分，从Glide的构建过程窥一斑</a></h2>
<p>不难理解：一个庞大的系统需要在符合 <code>SRP</code> 的基础上进行职责划分，这样一来，类就会变得很多，构建过程会变得复杂，利用Builder模式可以很好的解决这一问题。</p>
<pre><code class="language-java">class GlideBuilder {
    public Glide build(@NonNull Context context) {
        if (sourceExecutor == null) {
            sourceExecutor = GlideExecutor.newSourceExecutor();
        }

        if (diskCacheExecutor == null) {
            diskCacheExecutor = GlideExecutor.newDiskCacheExecutor();
        }

        if (animationExecutor == null) {
            animationExecutor = GlideExecutor.newAnimationExecutor();
        }

        if (memorySizeCalculator == null) {
            memorySizeCalculator = new MemorySizeCalculator.Builder(context).build();
        }

        if (connectivityMonitorFactory == null) {
            connectivityMonitorFactory = new DefaultConnectivityMonitorFactory();
        }

        if (bitmapPool == null) {
            int size = memorySizeCalculator.getBitmapPoolSize();
            if (size &gt; 0) {
                bitmapPool = new LruBitmapPool(size);
            } else {
                bitmapPool = new BitmapPoolAdapter();
            }
        }

        if (arrayPool == null) {
            arrayPool = new LruArrayPool(memorySizeCalculator.getArrayPoolSizeInBytes());
        }

        if (memoryCache == null) {
            memoryCache = new LruResourceCache(memorySizeCalculator.getMemoryCacheSize());
        }

        if (diskCacheFactory == null) {
            diskCacheFactory = new InternalCacheDiskCacheFactory(context);
        }

        if (engine == null) {
            engine = new Engine(
                    memoryCache,
                    diskCacheFactory,
                    diskCacheExecutor,
                    sourceExecutor,
                    GlideExecutor.newUnlimitedSourceExecutor(),
                    GlideExecutor.newAnimationExecutor(),
                    isActiveResourceRetentionAllowed);
        }

        RequestManagerRetriever requestManagerRetriever =
                new RequestManagerRetriever(requestManagerFactory);

        return new Glide(
                context,
                engine,
                memoryCache,
                bitmapPool,
                arrayPool,
                requestManagerRetriever,
                connectivityMonitorFactory,
                logLevel,
                defaultRequestOptions.lock(),
                defaultTransitionOptions);
    }
}
</code></pre>
<p>从这里我们可以收集到一下有效信息</p>
<ul>
<li>缓存与池
<ul>
<li>MemorySizeCalculator</li>
<li>LruBitmapPool</li>
<li>BitmapPoolAdapter</li>
<li>LruArrayPool</li>
<li>LruResourceCache</li>
<li>InternalCacheDiskCacheFactory</li>
</ul>
</li>
<li>资源获取
<ul>
<li>RequestManagerRetriever</li>
<li>DefaultConnectivityMonitorFactory</li>
</ul>
</li>
<li>核心流程管理
<ul>
<li>Engine</li>
</ul>
</li>
<li>线程池
<ul>
<li>GlideExecutor</li>
</ul>
</li>
</ul>
<p>再看到构造函数：<em>代码挺长，略去了部分内容</em></p>
<pre><code class="language-java">class Glide {
    Glide(
            @NonNull Context context,
            @NonNull Engine engine,
            @NonNull MemoryCache memoryCache,
            @NonNull BitmapPool bitmapPool,
            @NonNull ArrayPool arrayPool,
            @NonNull RequestManagerRetriever requestManagerRetriever,
            @NonNull ConnectivityMonitorFactory connectivityMonitorFactory,
            int logLevel,
            @NonNull RequestOptions defaultRequestOptions,
            @NonNull Map&lt;Class&lt;?&gt;, TransitionOptions&lt;?, ?&gt;&gt; defaultTransitionOptions) {

        this.engine = engine;
        this.bitmapPool = bitmapPool;
        this.arrayPool = arrayPool;
        this.memoryCache = memoryCache;
        this.requestManagerRetriever = requestManagerRetriever;
        this.connectivityMonitorFactory = connectivityMonitorFactory;

        DecodeFormat decodeFormat = defaultRequestOptions.getOptions().get(Downsampler.DECODE_FORMAT);
        bitmapPreFiller = new BitmapPreFiller(memoryCache, bitmapPool, decodeFormat);

        final Resources resources = context.getResources();

        registry = new Registry();
        registry.register(new DefaultImageHeaderParser());

        Downsampler downsampler = new Downsampler(registry.getImageHeaderParsers(),
                resources.getDisplayMetrics(), bitmapPool, arrayPool);
        ByteBufferGifDecoder byteBufferGifDecoder =
                new ByteBufferGifDecoder(context, registry.getImageHeaderParsers(), bitmapPool, arrayPool);
        ResourceDecoder&lt;ParcelFileDescriptor, Bitmap&gt; parcelFileDescriptorVideoDecoder =
                VideoDecoder.parcel(bitmapPool);
        ByteBufferBitmapDecoder byteBufferBitmapDecoder = new ByteBufferBitmapDecoder(downsampler);
        StreamBitmapDecoder streamBitmapDecoder = new StreamBitmapDecoder(downsampler, arrayPool);
        ResourceDrawableDecoder resourceDrawableDecoder =
                new ResourceDrawableDecoder(context);
        ResourceLoader.StreamFactory resourceLoaderStreamFactory =
                new ResourceLoader.StreamFactory(resources);
        ResourceLoader.UriFactory resourceLoaderUriFactory =
                new ResourceLoader.UriFactory(resources);
        ResourceLoader.FileDescriptorFactory resourceLoaderFileDescriptorFactory =
                new ResourceLoader.FileDescriptorFactory(resources);
        ResourceLoader.AssetFileDescriptorFactory resourceLoaderAssetFileDescriptorFactory =
                new ResourceLoader.AssetFileDescriptorFactory(resources);
        BitmapEncoder bitmapEncoder = new BitmapEncoder(arrayPool);

        BitmapBytesTranscoder bitmapBytesTranscoder = new BitmapBytesTranscoder();
        GifDrawableBytesTranscoder gifDrawableBytesTranscoder = new GifDrawableBytesTranscoder();

        ContentResolver contentResolver = context.getContentResolver();

        registry
                .append(ByteBuffer.class, new ByteBufferEncoder())
                /*略去一段内容，太长了*/
                .register(GifDrawable.class, byte[].class, gifDrawableBytesTranscoder);

        ImageViewTargetFactory imageViewTargetFactory = new ImageViewTargetFactory();
        glideContext =
                new GlideContext(
                        context,
                        arrayPool,
                        registry,
                        imageViewTargetFactory,
                        defaultRequestOptions,
                        defaultTransitionOptions,
                        engine,
                        logLevel);
    }
}
</code></pre>
<p>这一段可以分为即可部分：</p>
<ul>
<li>builder 的 field 对应取值赋值</li>
<li>构建非开放的 <code>BitmapPreFiller</code> 实例</li>
<li>构建 <code>Registry</code> 实例 <code>registry</code></li>
<li>构建 <code>DefaultImageHeaderParser</code> 、 <code>ResourceLoader</code> 、<code>Decoder</code> 、 <code>ResourceTranscoder</code> 并将之注册到 <code>registry</code></li>
<li>构建 <code>GlideContext</code> 实例 <code>glideContext</code></li>
</ul>
<p>按照经验推断，Registry 是一个策略注册表，服务于 <code>策略模式</code>。</p>
<p><em>不难理解：Glide的工作环境非常复杂，例如获取资源，其资源存在位置可能在网络中的某个位置、 可能在应用的Assets中，也可能在其他位置，对于某一个目标，根据场景不同，存在不同的实现策略</em></p>
<p>继续按照经验推断，注册会分为不同的策略组，对应不同的目标,这一点我们稍后再看。</p>
<p>再按照我们常见的使用习惯，追踪一下初始化过程：<em>泛读即可</em></p>
<pre><code class="language-java">class Glide {
    public static Glide get(@NonNull Context context) {
        if (glide == null) {
            synchronized (Glide.class) {
                if (glide == null) {
                    checkAndInitializeGlide(context);
                }
            }
        }

        return glide;
    }

    private static void checkAndInitializeGlide(@NonNull Context context) {
        //...
        initializeGlide(context);
        //...
    }

    //重载略去
    public static RequestManager with(@NonNull Activity activity) {
        return getRetriever(activity).get(activity);
    }

    @NonNull
    private static RequestManagerRetriever getRetriever(@Nullable Context context) {
        // Context could be null for other reasons (ie the user passes in null), but in practice it will
        // only occur due to errors with the Fragment lifecycle.
        Preconditions.checkNotNull(
                context,
                "You cannot start a load on a not yet attached View or a Fragment where getActivity() "
                        + "returns null (which usually occurs when getActivity() is called before the Fragment "
                        + "is attached or after the Fragment is destroyed).");
        return Glide.get(context).getRequestManagerRetriever();
    }
}
</code></pre>
<p>按照使用习惯，一般从 <code>Glide.with(...)</code> 开始得到 <code>RequestManager</code>，当然，也可以以 <code>Glide.get(context).getRequestManagerRetriever()</code>
方式获取。如果Glide没有初始化，则会调用 <code>initializeGlide</code> 进行初始化。</p>
<p>跟进一下代码，<em>泛读即可</em></p>
<pre><code class="language-java">class Glide {
    private static void initializeGlide(@NonNull Context context) {
        initializeGlide(context, new GlideBuilder());
    }

    @SuppressWarnings("deprecation")
    private static void initializeGlide(@NonNull Context context, @NonNull GlideBuilder builder) {
        Context applicationContext = context.getApplicationContext();
        GeneratedAppGlideModule annotationGeneratedModule = getAnnotationGeneratedGlideModules();
        List&lt;com.bumptech.glide.module.GlideModule&gt; manifestModules = Collections.emptyList();
        if (annotationGeneratedModule == null || annotationGeneratedModule.isManifestParsingEnabled()) {
            manifestModules = new ManifestParser(applicationContext).parse();
        }

        if (annotationGeneratedModule != null
                &amp;&amp; !annotationGeneratedModule.getExcludedModuleClasses().isEmpty()) {
            Set&lt;Class&lt;?&gt;&gt; excludedModuleClasses =
                    annotationGeneratedModule.getExcludedModuleClasses();
            Iterator&lt;com.bumptech.glide.module.GlideModule&gt; iterator = manifestModules.iterator();
            while (iterator.hasNext()) {
                com.bumptech.glide.module.GlideModule current = iterator.next();
                if (!excludedModuleClasses.contains(current.getClass())) {
                    continue;
                }
                if (Log.isLoggable(TAG, Log.DEBUG)) {
                    Log.d(TAG, "AppGlideModule excludes manifest GlideModule: " + current);
                }
                iterator.remove();
            }
        }

        if (Log.isLoggable(TAG, Log.DEBUG)) {
            for (com.bumptech.glide.module.GlideModule glideModule : manifestModules) {
                Log.d(TAG, "Discovered GlideModule from manifest: " + glideModule.getClass());
            }
        }

        RequestManagerRetriever.RequestManagerFactory factory =
                annotationGeneratedModule != null
                        ? annotationGeneratedModule.getRequestManagerFactory() : null;
        builder.setRequestManagerFactory(factory);
        for (com.bumptech.glide.module.GlideModule module : manifestModules) {
            module.applyOptions(applicationContext, builder);
        }
        if (annotationGeneratedModule != null) {
            annotationGeneratedModule.applyOptions(applicationContext, builder);
        }
        Glide glide = builder.build(applicationContext);
        for (com.bumptech.glide.module.GlideModule module : manifestModules) {
            module.registerComponents(applicationContext, glide, glide.registry);
        }
        if (annotationGeneratedModule != null) {
            annotationGeneratedModule.registerComponents(applicationContext, glide, glide.registry);
        }
        applicationContext.registerComponentCallbacks(glide);
        Glide.glide = glide;
    }
}
</code></pre>
<p>泛读之后，我们发现主要有 <code>三步</code>：</p>
<ul>
<li>构建GlideBuilder</li>
<li>通过反射，加载 <code>可能存在</code> 的自定义模块，设置到Builder中</li>
<li>构建Glide</li>
</ul>
<blockquote>
<p>思危：如果直接使用GlideBuilder进行构建，则无法直接运用自定义模块的内容，需要自行注入。</p>
</blockquote>
<h2 id="模块职责划分于register挖细节"><a class="header" href="#模块职责划分于register挖细节">模块职责划分，于Register挖细节</a></h2>
<p>上一节中，我们略去了Glide实例化过程的一些细节，其实现内容为：向Register注册了各种模块，可以泛读一下源码：</p>
<pre><code class="language-java"> registry
        .append(ByteBuffer.class,new ByteBufferEncoder())
        .append(InputStream.class,new StreamEncoder(arrayPool))
        /* Bitmaps */
        .append(Registry.BUCKET_BITMAP,ByteBuffer.class,Bitmap.class,byteBufferBitmapDecoder)
        .append(Registry.BUCKET_BITMAP,InputStream.class,Bitmap.class,streamBitmapDecoder)
        .append(
        Registry.BUCKET_BITMAP,
        ParcelFileDescriptor.class,
        Bitmap.class,
        parcelFileDescriptorVideoDecoder)
        .append(
        Registry.BUCKET_BITMAP,
        AssetFileDescriptor.class,
        Bitmap.class,
        VideoDecoder.asset(bitmapPool))
        .append(Bitmap.class,Bitmap.class,UnitModelLoader.Factory.&lt;Bitmap&gt;getInstance())
        .append(
        Registry.BUCKET_BITMAP,Bitmap.class,Bitmap.class,new UnitBitmapDecoder())
        .append(Bitmap.class,bitmapEncoder)
        /* BitmapDrawables */
        .append(
        Registry.BUCKET_BITMAP_DRAWABLE,
        ByteBuffer.class,
        BitmapDrawable.class,
        new BitmapDrawableDecoder&lt;&gt;(resources,byteBufferBitmapDecoder))
        .append(
        Registry.BUCKET_BITMAP_DRAWABLE,
        InputStream.class,
        BitmapDrawable.class,
        new BitmapDrawableDecoder&lt;&gt;(resources,streamBitmapDecoder))
        .append(
        Registry.BUCKET_BITMAP_DRAWABLE,
        ParcelFileDescriptor.class,
        BitmapDrawable.class,
        new BitmapDrawableDecoder&lt;&gt;(resources,parcelFileDescriptorVideoDecoder))
        .append(BitmapDrawable.class,new BitmapDrawableEncoder(bitmapPool,bitmapEncoder))
        /* GIFs */
        .append(
        Registry.BUCKET_GIF,
        InputStream.class,
        GifDrawable.class,
        new StreamGifDecoder(registry.getImageHeaderParsers(),byteBufferGifDecoder,arrayPool))
        .append(Registry.BUCKET_GIF,ByteBuffer.class,GifDrawable.class,byteBufferGifDecoder)
        .append(GifDrawable.class,new GifDrawableEncoder())
        /* GIF Frames */
        // Compilation with Gradle requires the type to be specified for UnitModelLoader here.
        .append(
        GifDecoder.class,GifDecoder.class,UnitModelLoader.Factory.&lt;GifDecoder&gt;getInstance())
        .append(
        Registry.BUCKET_BITMAP,
        GifDecoder.class,
        Bitmap.class,
        new GifFrameResourceDecoder(bitmapPool))
        /* Drawables */
        .append(Uri.class,Drawable.class,resourceDrawableDecoder)
        .append(
        Uri.class,Bitmap.class,new ResourceBitmapDecoder(resourceDrawableDecoder,bitmapPool))
        /* Files */
        .register(new ByteBufferRewinder.Factory())
        .append(File.class,ByteBuffer.class,new ByteBufferFileLoader.Factory())
        .append(File.class,InputStream.class,new FileLoader.StreamFactory())
        .append(File.class,File.class,new FileDecoder())
        .append(File.class,ParcelFileDescriptor.class,new FileLoader.FileDescriptorFactory())
        // Compilation with Gradle requires the type to be specified for UnitModelLoader here.
        .append(File.class,File.class,UnitModelLoader.Factory.&lt;File&gt;getInstance())
        /* Models */
        .register(new InputStreamRewinder.Factory(arrayPool))
        .append(int.class,InputStream.class,resourceLoaderStreamFactory)
        .append(
        int.class,
        ParcelFileDescriptor.class,
        resourceLoaderFileDescriptorFactory)
        .append(Integer.class,InputStream.class,resourceLoaderStreamFactory)
        .append(
        Integer.class,
        ParcelFileDescriptor.class,
        resourceLoaderFileDescriptorFactory)
        .append(Integer.class,Uri.class,resourceLoaderUriFactory)
        .append(
        int.class,
        AssetFileDescriptor.class,
        resourceLoaderAssetFileDescriptorFactory)
        .append(
        Integer.class,
        AssetFileDescriptor.class,
        resourceLoaderAssetFileDescriptorFactory)
        .append(int.class,Uri.class,resourceLoaderUriFactory)
        .append(String.class,InputStream.class,new DataUrlLoader.StreamFactory())
        .append(String.class,InputStream.class,new StringLoader.StreamFactory())
        .append(String.class,ParcelFileDescriptor.class,new StringLoader.FileDescriptorFactory())
        .append(
        String.class,AssetFileDescriptor.class,new StringLoader.AssetFileDescriptorFactory())
        .append(Uri.class,InputStream.class,new HttpUriLoader.Factory())
        .append(Uri.class,InputStream.class,new AssetUriLoader.StreamFactory(context.getAssets()))
        .append(
        Uri.class,
        ParcelFileDescriptor.class,
        new AssetUriLoader.FileDescriptorFactory(context.getAssets()))
        .append(Uri.class,InputStream.class,new MediaStoreImageThumbLoader.Factory(context))
        .append(Uri.class,InputStream.class,new MediaStoreVideoThumbLoader.Factory(context))
        .append(
        Uri.class,
        InputStream.class,
        new UriLoader.StreamFactory(contentResolver))
        .append(
        Uri.class,
        ParcelFileDescriptor.class,
        new UriLoader.FileDescriptorFactory(contentResolver))
        .append(
        Uri.class,
        AssetFileDescriptor.class,
        new UriLoader.AssetFileDescriptorFactory(contentResolver))
        .append(Uri.class,InputStream.class,new UrlUriLoader.StreamFactory())
        .append(URL.class,InputStream.class,new UrlLoader.StreamFactory())
        .append(Uri.class,File.class,new MediaStoreFileLoader.Factory(context))
        .append(GlideUrl.class,InputStream.class,new HttpGlideUrlLoader.Factory())
        .append(byte[].class,ByteBuffer.class,new ByteArrayLoader.ByteBufferFactory())
        .append(byte[].class,InputStream.class,new ByteArrayLoader.StreamFactory())
        .append(Uri.class,Uri.class,UnitModelLoader.Factory.&lt;Uri&gt;getInstance())
        .append(Drawable.class,Drawable.class,UnitModelLoader.Factory.&lt;Drawable&gt;getInstance())
        .append(Drawable.class,Drawable.class,new UnitDrawableDecoder())
        /* Transcoders */
        .register(
        Bitmap.class,
        BitmapDrawable.class,
        new BitmapDrawableTranscoder(resources))
        .register(Bitmap.class,byte[].class,bitmapBytesTranscoder)
        .register(
        Drawable.class,
        byte[].class,
        new DrawableBytesTranscoder(
        bitmapPool,bitmapBytesTranscoder,gifDrawableBytesTranscoder))
        .register(GifDrawable.class,byte[].class,gifDrawableBytesTranscoder);
</code></pre>
<p><code>直接讲解</code> 这段代码是 <code>无意义</code> 的，我们从 <code>Register</code> 类入手，分析注册的内容。</p>
<pre><code class="language-java">public class Registry {
    public static final String BUCKET_GIF = "Gif";
    public static final String BUCKET_BITMAP = "Bitmap";
    public static final String BUCKET_BITMAP_DRAWABLE = "BitmapDrawable";
    private static final String BUCKET_PREPEND_ALL = "legacy_prepend_all";
    private static final String BUCKET_APPEND_ALL = "legacy_append";

    private final ModelLoaderRegistry modelLoaderRegistry;
    private final EncoderRegistry encoderRegistry;
    private final ResourceDecoderRegistry decoderRegistry;
    private final ResourceEncoderRegistry resourceEncoderRegistry;
    private final DataRewinderRegistry dataRewinderRegistry;
    private final TranscoderRegistry transcoderRegistry;
    private final ImageHeaderParserRegistry imageHeaderParserRegistry;

    private final ModelToResourceClassCache modelToResourceClassCache =
            new ModelToResourceClassCache();
    private final LoadPathCache loadPathCache = new LoadPathCache();
    private final Pool&lt;List&lt;Throwable&gt;&gt; throwableListPool = FactoryPools.threadSafeList();

    public Registry() {
        this.modelLoaderRegistry = new ModelLoaderRegistry(throwableListPool);
        this.encoderRegistry = new EncoderRegistry();
        this.decoderRegistry = new ResourceDecoderRegistry();
        this.resourceEncoderRegistry = new ResourceEncoderRegistry();
        this.dataRewinderRegistry = new DataRewinderRegistry();
        this.transcoderRegistry = new TranscoderRegistry();
        this.imageHeaderParserRegistry = new ImageHeaderParserRegistry();
        setResourceDecoderBucketPriorityList(
                Arrays.asList(BUCKET_GIF, BUCKET_BITMAP, BUCKET_BITMAP_DRAWABLE));
    }
    //API略去
}
</code></pre>
<h3 id="资源model加载器"><a class="header" href="#资源model加载器">资源Model加载器</a></h3>
<p><code>modelLoaderRegistry</code> 用于注册 <code>资源Model加载方式</code> 信息。例如，资源的定义Model为 <code>Uri</code> 类，注册一个 <code>ModelLoaderFactory</code> ，生产对应的
<code>ModelLoader</code>，将 <code>Uri</code> 媒体实体，加载为 <code>InputStream</code> 或者其他形式的 <code>内容</code></p>
<p>相关类：</p>
<ul>
<li><code>ModelLoaderFactory</code></li>
<li><code>ModelLoader</code> 等</li>
</ul>
<h3 id="编码器"><a class="header" href="#编码器">编码器</a></h3>
<p><code>encoderRegistry</code> 用于注册 <code>内容encode方式</code> 信息。例如，媒体实体已被加载为 <code>InputStream</code>，注册一个对应处理的 <code>Encoder&lt;InputStream&gt;</code>，
用于处理内容的encode，如写入磁盘过程</p>
<p>相关类：<code>Encoder</code> 接口及其实现类</p>
<p>相应的，<code>resourceEncoderRegistry</code> 用于注册 <code>Resource 的encode方式</code>，这些encoder面向 <code>Resource</code>，相比于 <code>InputStream</code> 等低级形式的编码内容封装，
<code>Resource</code> 实现类进行了更高级别的编码内容封装。</p>
<p>相关类：</p>
<ul>
<li><code>ResourceEncoder</code> 接口及其实现类</li>
<li><code>Resource</code> 接口及其实现类</li>
<li><code>EncodeStrategy</code></li>
</ul>
<p>不难理解：媒体资源的数据封装存在不同 <code>层级</code>：</p>
<ul>
<li>读取数据的InputSteam</li>
<li>Bitmap，BitmapDrawable</li>
</ul>
<p>所以 encode过程 对不同层级的封装类，有不同的处理，当然，encoder可以通过 <code>wrapper</code>，<code>adapter</code>,<code>transfer</code> 等形式，利用其它encoder扩展功能</p>
<h3 id="解码器"><a class="header" href="#解码器">解码器</a></h3>
<p><code>decoderRegistry</code> 用于注册 <code>媒体数据解码为Resource方式</code> 的信息。</p>
<p>前面我们提到 <code>modelLoaderRegistry</code> 注册的信息中，可以得到 <code>ModelLoader</code>， 它们负责将 <code>资源Model</code> 加载为 <code>资源内容</code>，这种 <code>资源内容</code>以 <code>InputStream</code> 等低级形式存在即可。</p>
<p>不难理解，这可以有效的解决 <code>类数量爆炸</code> 问题。</p>
<blockquote>
<p>脑暴：假定 Model 的类数量为m个，解码后输出的形式有n个</p>
<ul>
<li>不采用这种方式处理，一共需要 m*n 个 decoder 类</li>
<li>采用这种方式处理，一共需要 m+n 个 decoder 类</li>
</ul>
<p>当 <code>层级</code> 增加时，差距会更加明显</p>
<p>按照经验推断，Glide在处理decode过程时，采用了 <code>Wrapper/delegate</code> 模式 或者 <code>bridge</code> 模式。</p>
</blockquote>
<blockquote>
<p>思变：项目中是否可以使用类似方式，处理不同层级之间 <code>数据Bean</code> 的 <code>转化</code> 或者 <code>包装</code>？</p>
</blockquote>
<p>相关类：</p>
<ul>
<li><code>ResourceDecoder</code> 及其实现类</li>
<li><code>Resource</code> 及其实现类</li>
</ul>
<h3 id="转换器"><a class="header" href="#转换器">转换器</a></h3>
<p><em>虽然直译为转码器，但是容易概念混淆，按照其功能称为转换器</em></p>
<p><code>transcoderRegistry</code> 用于注册 <code>转化器，及其负责的原始类型和转换类型</code> 信息，转换器将资源从一种形式转换为另一种形式。例如: <code>Bitmap -&gt; byte[]</code></p>
<p>相关类：</p>
<ul>
<li><code>ResourceTranscoder</code> 及其实现类</li>
<li><code>Resource</code> 及其实现类</li>
</ul>
<h3 id="头信息解析器"><a class="header" href="#头信息解析器">头信息解析器</a></h3>
<p><code>imageHeaderParserRegistry</code> 用于注册 <code>头信息解析器</code> 信息</p>
<p><em>注，部分操作系统为了更简便的决定文件的处理方式，利用了文件扩展名。但文件实质内容的编码方式信息，存储在文件头信息中，又称： <code>File Sigs</code>、<code>文件魔数</code> 。</em></p>
<blockquote>
<p>例如 FF D8 代表 Generic JPEG image file，即 JPE, JPEG, JPG</p>
</blockquote>
<p><a href="https://www.garykessler.net/library/file_sigs.html">了解更多关于File Sigs内容</a></p>
<p>相关类：</p>
<ul>
<li><code>ImageHeaderParser</code> 及其实现类</li>
<li><code>ImageType</code></li>
</ul>
<h2 id="模块职责总结"><a class="header" href="#模块职责总结">模块职责总结</a></h2>
<p>通过前文的分析，并查阅Glide源码，我们可以对模块职责进行一次初步总结。</p>
<p>在之后的文章中，我们将对具体模块进行 <code>更细致</code> 的挖掘，此处总结的类信息，就是 <code>突破口</code> 。</p>
<p><em>考虑到目前收集的信息 <code>并不全面</code> ，我不打算绘制一个图，下面的信息也 <code>并非</code> 十分重要，所以将其作为一个 <code>临时的备忘录</code> 即可。
在后续内容中，我会对各个模块单独总结成图</em></p>
<p>下一篇，我们将对 <code>资源Model加载、获取流程</code> 进行 <code>深度挖掘</code>。</p>
<hr />
<h3 id="缓存与池"><a class="header" href="#缓存与池">缓存与池</a></h3>
<ul>
<li>MemorySizeCalculator</li>
<li>LruBitmapPool</li>
<li>BitmapPoolAdapter</li>
<li>LruArrayPool</li>
<li>LruResourceCache</li>
<li>InternalCacheDiskCacheFactory</li>
</ul>
<h3 id="资源获取"><a class="header" href="#资源获取">资源获取</a></h3>
<ul>
<li>RequestManagerRetriever</li>
<li>RequestManager</li>
<li>RequestBuilder</li>
<li>Request</li>
<li>DefaultConnectivityMonitorFactory</li>
</ul>
<h3 id="核心流程"><a class="header" href="#核心流程">核心流程</a></h3>
<ul>
<li>Engine</li>
</ul>
<p>其他信息尚不能确定。主要流程的相关信息如下：</p>
<h4 id="资源model加载器-1"><a class="header" href="#资源model加载器-1">资源Model加载器</a></h4>
<ul>
<li><code>ModelLoaderFactory</code></li>
<li><code>ModelLoader</code> 等</li>
</ul>
<h4 id="编码器-1"><a class="header" href="#编码器-1">编码器</a></h4>
<ul>
<li><code>Encoder</code> 接口及其实现类</li>
<li><code>ResourceEncoder</code> 接口及其实现类</li>
<li><code>Resource</code> 接口及其实现类</li>
<li><code>EncodeStrategy</code></li>
</ul>
<h4 id="解码器-1"><a class="header" href="#解码器-1">解码器</a></h4>
<ul>
<li><code>ResourceDecoder</code> 及其实现类</li>
<li><code>Resource</code> 及其实现类</li>
</ul>
<h4 id="转换器-1"><a class="header" href="#转换器-1">转换器</a></h4>
<ul>
<li><code>ResourceTranscoder</code> 及其实现类</li>
<li><code>Resource</code> 及其实现类</li>
</ul>
<h4 id="头信息解析器-1"><a class="header" href="#头信息解析器-1">头信息解析器</a></h4>
<ul>
<li><code>ImageHeaderParser</code> 及其实现类</li>
<li><code>ImageType</code></li>
</ul>
<h3 id="线程池"><a class="header" href="#线程池">线程池</a></h3>
<ul>
<li>GlideExecutor</li>
</ul>
<h3 id="glide的创建与配置"><a class="header" href="#glide的创建与配置">Glide的创建与配置</a></h3>
<p><code>GlideBuilder</code> 用于创建，<code>com.bumptech.glide.module</code> 包下的内容用于自定义模块，诸如：</p>
<ul>
<li><code>AppGlideModule</code></li>
<li><code>LibraryGlideModule</code></li>
</ul>
<p>以及一些已废弃的内容，不再赘述</p>
<h2 id="思危思退思变"><a class="header" href="#思危思退思变">思危、思退、思变</a></h2>
<p><em>可能有读者习惯性地拉到尾部，前面提到，结尾处的大篇幅内容都是 <code>备忘录</code> 性质,而且之后的系列文章会在这些内容的基础上展开，可读可不读</em></p>
<p>但既然拉到了这里，就思考一下吧，阅读优秀的框架，不仅仅可以深入了解框架内容，也可以锻炼设计能力：</p>
<ul>
<li>思危：使用GlideBuilder构建Glide实例是否有没有注意到的危险？</li>
<li>思危：项目中再次对Glide实现单例是否存在危险？</li>
<li>思变：项目中是否存在可以借鉴Glide的设计思路的地方？</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="三思系列glide-4x加载过程一文掌握--glide二"><a class="header" href="#三思系列glide-4x加载过程一文掌握--glide二">三思系列：Glide 4.X加载过程一文掌握 | Glide（二）</a></h1>
<p>上一篇中，我们通过阅读Glide初始化的主要代码，对Glide中的模块进行了职责梳理。这一篇，我们在前文的基础上，对Glide的 <code>资源加载过程</code> 进行梳理。</p>
<p>当然，通过博文来看 <code>大篇幅</code> 的代码是相当 <code>枯燥乏味</code> 的，为了让阅读体验更佳，本文中会直接用 <code>UML图</code> 代替绝大多数的 <code>代码拷贝</code>。</p>
<p><em>注：本文基于Glide 4.12.0。另：我的UML功底不太牢，文中涉及的UML图未必是最恰当的，如图类型或者标识错用，如果读者对此有所建树，我真诚的希望你可以在留言区留下宝贵的参考意见。</em></p>
<p>再次介绍下三思系列：</p>
<blockquote>
<p>三思系列是我最新的学习、总结形式，着重于:<strong>问题分析</strong>、<strong>技术积累</strong>、<strong>视野拓展</strong>，<a href="https://leobert-lan.github.io/info/about_sansi_series.html">了解更多</a></p>
</blockquote>
<hr />
<h2 id="攻坚突破口"><a class="header" href="#攻坚突破口">攻坚突破口</a></h2>
<p>在第一篇收尾时，我们总结了深度分析时的突破口，和加载过程强关联的内容摘录如下：</p>
<blockquote>
<p>资源获取</p>
<ul>
<li>RequestManagerRetriever</li>
<li>RequestManager</li>
<li>RequestBuilder</li>
<li>Request</li>
<li>DefaultConnectivityMonitorFactory</li>
</ul>
<p>核心流程</p>
<ul>
<li>Engine</li>
</ul>
<p>资源Model加载器</p>
<ul>
<li><code>ModelLoaderFactory</code></li>
<li><code>ModelLoader</code> 等</li>
</ul>
</blockquote>
<p>如果读者在阅读本文时，手边刚好有Glide的源码，可以配合阅读。</p>
<h2 id="request的构建"><a class="header" href="#request的构建">Request的构建</a></h2>
<p>不难理解，Glide在设计时，将 <code>资源加载</code> &amp; <code>资源处理</code> &amp; <code>资源使用</code> 等指令描述封装在了 <code>Request</code> 实现类中。</p>
<p>最简单的使用Sample代码：</p>
<pre><code>// Samples/imgur
// com.bumptech.glide.samples.imgur.MainActivity

ImgurGlide.with(vh.imageView)
      .load(image.link)
      .into(vh.imageView);
</code></pre>
<p>调用 Glide.with 得到 <code>RequestManagerRetriever</code> 实例，并进一步调用 RequestManagerRetriever.get 得到 <code>RequestManager</code> 实例</p>
<p>而接下来的过程，则如下图所示，<em>相比于此图，以文字形式描述的过程略显啰嗦</em></p>
<p><img src="Android/Glide/./uml/FetchResourceSequence1.png" alt="" /></p>
<p>图中的 1、2、3 表示了Request的创建过程。</p>
<p>当创建完成后，需要执行 Request，但需要注意，Glide处理了一个 <code>很重要</code> 的问题：</p>
<blockquote>
<p>Target复用场景下，与Resource并非 <code>一一对应</code></p>
</blockquote>
<p>并且这个问题在 <code>网络环境变化</code>、 <code>生命周期协同</code> 等背景下被放大。</p>
<p>所以在开始执行请求前，还需要进行一层判断：</p>
<blockquote>
<p>对于该Target，<code>本次</code> 请求的Request是否与 <code>前次</code> 请求的Request一致？</p>
</blockquote>
<ul>
<li>一致，执行前次请求</li>
<li>不一致，清空与target绑定的各种关系；设置本次请求；执行请求</li>
</ul>
<pre><code class="language-java">class RequestBuilder {
    private &lt;Y extends Target&lt;TranscodeType&gt;&gt; Y into(
            @NonNull Y target,
            @Nullable RequestListener&lt;TranscodeType&gt; targetListener,
            @NonNull RequestOptions options) {
        //...

        options = options.autoClone();
        Request request = buildRequest(target, targetListener, options);

        Request previous = target.getRequest();
        if (request.isEquivalentTo(previous)
                &amp;&amp; !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) {
            request.recycle();
            if (!Preconditions.checkNotNull(previous).isRunning()) {
                previous.begin();
            }
            return target;
        }

        requestManager.clear(target);
        target.setRequest(request);
        requestManager.track(target, request);

        return target;
    }
}
</code></pre>
<p><em>其他代码忽略</em></p>
<h2 id="request的触发"><a class="header" href="#request的触发">Request的触发</a></h2>
<p>前文中，我们已经阅读到了 <code>新Request</code> 的触发环节，入口代码如下：</p>
<pre><code class="language-java">class RequestManager {
    void track(@NonNull Target&lt;?&gt; target, @NonNull Request request) {
        targetTracker.track(target);
        requestTracker.runRequest(request);
    }
}
</code></pre>
<p>接下来挖掘下Request触发流程细节，依旧先看图：</p>
<p><img src="Android/Glide/./uml/FetchResourceSequence2.png" alt="" /></p>
<p><code>1、2</code> 两步对应了 <code>RequestManager#track(Target&lt;?&gt; target, Request request)</code>, 标签中备注了<code>1</code> 处为 <code>生命周期监测</code></p>
<blockquote>
<p>简要扩展：<code>TargetTracker</code> 是一个 <code>组合模式</code> 实现，实现了 Glide 中的 <code>LifecycleListener</code>，当关联的对象的生命周期产生变化时，这些变化会被感知，并且
<code>TargetTracker</code> 会被回调，实现请求的生命周期协同管理。</p>
</blockquote>
<p>而 <code>2</code> 则开始处理请求：</p>
<ul>
<li>如果当前 RequestTracker 是运行中的，则直接调用 <code>Request#begin()</code> 执行请求； <code>5</code></li>
<li>否则加入等待队列，当 <code>resumeRequests</code> 或 <code>restartRequests</code> 被调用时，进入运行状态，调用 <code>Request#begin()</code> 执行请求； <code>3、4</code></li>
</ul>
<h2 id="request执行细节"><a class="header" href="#request执行细节">Request执行细节</a></h2>
<p>在开始阅读请求细节之前，不妨先了解下Request中的状态机制。</p>
<p>不难理解：Request的整个过程是 <code>复杂的</code>，设计中，将其设计成不同的 <code>切面过程</code> ，处于不同的状态时，处理对应的切面，这样可以降低外部调度时的复杂度。</p>
<h3 id="状态概览"><a class="header" href="#状态概览">状态概览</a></h3>
<p>状态的枚举如下：</p>
<pre><code class="language-java">private enum Status {
    /**
     * Created but not yet running.
     */
    PENDING,
    /**
     * In the process of fetching media.
     */
    RUNNING,
    /**
     * Waiting for a callback given to the Target to be called to 
     * determine target dimensions.
     */
    WAITING_FOR_SIZE,
    /**
     * Finished loading media successfully.
     */
    COMPLETE,
    /**
     * Failed to load media, may be restarted.
     */
    FAILED,
    /**
     * Cancelled by the user, may not be restarted.
     */
    CANCELLED,
    /**
     * Cleared by the user with a placeholder set, may not be restarted.
     */
    CLEARED,
    /**
     * Temporarily paused by the system, may be restarted.
     */
    PAUSED,
  }
</code></pre>
<p>阅读代码后，整理主要的状态变化图如下：<em>在阅读处理细节时，还会提到相应的内容</em></p>
<p><img src="Android/Glide/./uml/state.png" alt="" /></p>
<h3 id="request处理流程一"><a class="header" href="#request处理流程一">Request处理流程一</a></h3>
<p>这一小节，我们将涉及这三个细节：</p>
<ul>
<li>尺寸获取</li>
<li>必要的PlaceHolder设置</li>
<li>向Engine 发起加载请求</li>
</ul>
<p><img src="Android/Glide/./uml/FetchResourceSequence3.png" alt="" /></p>
<p>如前文所提及:</p>
<ul>
<li>当资源无法通过校验，将直接进入 FAILED</li>
<li>当一切都已准备就绪，即 COMPLETE，则进入资源处理流程 <code>onResourceReady</code></li>
</ul>
<p>否则进入 <code>WAITING_FOR_SIZE</code>，并处理尺寸处理</p>
<ul>
<li>如果已经测量过的尺寸是合法的，进入 <code>onSizeReady</code>； <code>2、11</code></li>
<li>否则获取尺寸，并挂Callback； <code>3、5、6、7、8、9、10、11</code></li>
</ul>
<p><em>注意：当onSizeReady后，状态将变为 RUNNING，进入资源获取流程，即<code>11</code>，并且，如果有必要处理PlaceHolder且满足条件，则会在begin时处理PlaceHolder设置，即<code>4</code></em></p>
<p>不难理解：处理请求时，Target的尺寸未必处于可测量状态，Glide内利用了ViewTree的回调机制，以ViewTarget为例，当该Target进入 <code>PreDraw状态</code> 时，
开始测量尺寸，准确的讲是 <code>获取尺寸</code>。</p>
<p>至此，我们即将阅读到了 <code>资源加载</code> 过程。</p>
<h3 id="request处理流程二----资源加载"><a class="header" href="#request处理流程二----资源加载">Request处理流程二 -- 资源加载</a></h3>
<p>这一小节，我们专注于一个流程细节：<code>资源加载</code> 过程</p>
<p>简单想象一下，一个媒体资源，它的真身可能存在于："网络中的某台主机"，"本地的磁盘的用户文件目录下"，"当前应用的核心资源目录下" 等等。</p>
<p>使用这些资源时，<code>均从原始位置获取</code> 的方式是不可取的，除了 <code>最大的获取成本</code> 外，还额外付诸 <code>加载时间、解析算力成本</code>。</p>
<blockquote>
<p>不难理解：在资源有效时限可被信任的前提下，有必要设计缓存机制，<code>牺牲空间换取时间和算力</code> 。</p>
<p>下一篇中，我们将深入Glide的缓存机制，挖掘细节；在本篇中，读者仅需要先记住：</p>
<ul>
<li>Glide 设计了缓存</li>
<li>缓存包含 <code>内存缓存</code>，<code>磁盘缓存</code>；内存缓存中包含两个级别：<code>已加载激活的缓存</code>、<code>LRU缓存以及映射</code>； 磁盘缓存包含两个级别：<code>已解码数据</code>，<code>原始数据</code></li>
<li>不同的缓存使用策略，同时对应了缓存的<code>存储</code>、<code>获取</code></li>
</ul>
</blockquote>
<p>整个加载流程可以分为3个环节：</p>
<ul>
<li>生成key</li>
<li>从内存缓存中获取</li>
<li>使用EngineJob 从磁盘缓存中获取</li>
</ul>
<p>同样先给出图：<em>为了方便阅读，将流程切分成了5张图</em></p>
<p><img src="Android/Glide/./uml/FetchResourceSequence4_1-0.png" alt="" />
<img src="Android/Glide/./uml/FetchResourceSequence4_1-1.png" alt="" />
<img src="Android/Glide/./uml/FetchResourceSequence4_1-2.png" alt="" />
<img src="Android/Glide/./uml/FetchResourceSequence4_2-0.png" alt="" />
<img src="Android/Glide/./uml/FetchResourceSequence4_2-1.png" alt="" /></p>
<hr />
<p>接下来我们逐步分析</p>
<p><img src="Android/Glide/./uml/FetchResourceSequence4_1-0.png" alt="" /></p>
<p><code>1、2</code>是生成key过程，<strong>注意：KEY的生成方式中，隐藏着危险</strong>。</p>
<p>不难理解，对同一个媒体资源，采用不同的处理方式，得到的结果存在差别，缓存时，必须 <code>完整的</code> 考虑到这些处理差别，否则会出现 <code>资源错用</code>。<em>本文先不对此进行展开</em></p>
<hr />
<p><img src="Android/Glide/./uml/FetchResourceSequence4_1-1.png" alt="" /></p>
<p>接下来执行 <code>loadFromActiveResources</code>,即从 <code>已加载激活的缓存</code> 中获取</p>
<p>如果不允许使用内存缓存，则直接返回null进入下一级缓存获取</p>
<p>如果得到了缓存资源，则直接运用；否则进入下一级缓存获取</p>
<hr />
<p>此时，激活缓存未取到目标资源，将进入LRU内存缓存获取</p>
<p><img src="Android/Glide/./uml/FetchResourceSequence4_1-2.png" alt="" /></p>
<p>同样的，如果不允许使用内存缓存，则直接返回null进入下一级缓存获取</p>
<p>如果得到了缓存资源，<em>将从LRU内存缓存中被remove，做LRU标记维护，并被加载到 <code>激活缓存</code> 中激活</em>，则直接运用；否则进入下一级缓存获取。</p>
<hr />
<p>至此，内存缓存无法支持目标资源的获取，需要转向磁盘缓存</p>
<p><em>不难理解：这里的内在细节会很复杂。将在缓存分析篇章中展开</em></p>
<p>同样不难理解：当细节非常复杂时，有必要进行 <code>封装</code> ，<code>隐藏实现细节</code>，对调用者提供语义恰当的 <code>API</code> 即可。</p>
<p>Glide中，将这些细节封装为 EngineJob 和 DecodeJob；</p>
<p>不难理解：这种加载过程是 <code>相对耗时</code> 的，没有必要 <code>阻塞式</code> 等待结果以使用；因此，在加载的过程中，完全可能出现以下场景： <code>同一资源</code> 被 <code>多次要求</code> 加载。
于是，对Job可以进行 <code>复用</code> ，获取到还在加载中的Job时，增加回调即可，如下图所示：</p>
<p><img src="Android/Glide/./uml/FetchResourceSequence4_2-0.png" alt="" /></p>
<p>如果没有可复用的Job，则创建相应的Job，维护Job资源池，设置回调，如下图所示：
<img src="Android/Glide/./uml/FetchResourceSequence4_2-1.png" alt="" /></p>
<h3 id="request处理流程三----资源使用"><a class="header" href="#request处理流程三----资源使用">Request处理流程三 -- 资源使用</a></h3>
<p>在前文的讲解中，我们阅读到当资源加载成功后，会执行到： <code>Request#onResourceReady(Resource&lt;?&gt;, DataSource)</code>，而其实现内容即为资源使用。
当然加载失败，或者资源校验失败会执行 <code>onLoadFailed(GlideException e)</code>。</p>
<pre><code class="language-java">class SingleRequest {
    @Override
    public void onResourceReady(Resource&lt;?&gt; resource, DataSource dataSource) {
        stateVerifier.throwIfRecycled();
        loadStatus = null;
        if (resource == null) {
            GlideException exception = new GlideException("...");
            onLoadFailed(exception);
            return;
        }

        Object received = resource.get();
        if (received == null || !transcodeClass.isAssignableFrom(received.getClass())) {
            releaseResource(resource);
            GlideException exception = new GlideException("...");
            onLoadFailed(exception);
            return;
        }

        if (!canSetResource()) {
            releaseResource(resource);
            // We can't put the status to complete before asking canSetResource().
            status = Status.COMPLETE;
            return;
        }

        onResourceReady((Resource&lt;R&gt;) resource, (R) received, dataSource);
    }
    
    private void onResourceReady(Resource&lt;R&gt; resource, R result, DataSource dataSource) {
        // We must call isFirstReadyResource before setting status.
        boolean isFirstResource = isFirstReadyResource();
        status = Status.COMPLETE;
        this.resource = resource;

        //log

        isCallingCallbacks = true;
        try {
            if ((requestListener == null
                    || !requestListener.onResourceReady(result, model, target, dataSource, isFirstResource))
                    &amp;&amp; (targetListener == null
                    || !targetListener.onResourceReady(result, model, target, dataSource, isFirstResource))) {
                Transition&lt;? super R&gt; animation =
                        animationFactory.build(dataSource, isFirstResource);
                target.onResourceReady(result, animation);
            }
        } finally {
            isCallingCallbacks = false;
        }

        notifyLoadSuccess();
    }
}

</code></pre>
<p><em>注意:RequestListener 以及 TargetListener的处理，在使用监听器 <code>附加</code> 一些功能时，例如 <code>采集埋点</code>、 <code>依赖状态触发</code>，需要注意此处细节。</em></p>
<p>而Target实现类的具体实现，本文略去，感兴趣的读者还请自行阅读源码。</p>
<h2 id="内容总结"><a class="header" href="#内容总结">内容总结</a></h2>
<p>这是一张Glide 3.x时代的架构图，仅供参考</p>
<div style="background-color: white">
<img src="http://sniffer-site.oss-cn-shenzhen.aliyuncs.com/GlideDiagram.png" alt="Glide 3.x架构图供参考" />
</div>
<p><em>图片有区域透明，使用了html加了背景色，如果被转义了，<a href="http://sniffer-site.oss-cn-shenzhen.aliyuncs.com/GlideDiagram.png">请看这里</a></em></p>
<p>图中，<code>蓝色</code> 和 <code>紫色</code> 区域对应了资源加载过程，<code>黄色</code> 区域对应了原始资源获取，<code>品红色</code> 区域对应了内部线程池。</p>
<p><em>虽然这张图已经无法和 <code>Glide 4.x</code> 完全对应，但是处理问题的主要流程还是没有变化的。</em></p>
<p>本文的内容，是在 <code>Glide 4.12.0版本基础上</code> 对 <code>蓝色区域</code> 的 <code>深度挖掘</code> 以及对 <code>紫色区域</code> 的 <code>简要梳理</code> <em>择去了缓存实现细节</em>。</p>
<h2 id="思危思退思变-1"><a class="header" href="#思危思退思变-1">思危、思退、思变</a></h2>
<p>在加载过程分析中，我们已经罗列了部分可能出现错误使用的地方。这些点需要注意并在使用中避开。</p>
<p>本文中没有涉及到具体案例，所以没有 <code>更优做法</code> ， <code>更合适的做法</code> 。</p>
<p>但阅读优秀的源码，可以分析其设计思路，思考这样设计的优劣。</p>
<p>如：</p>
<ul>
<li>Request 根据内在状态枚举处理切面，在异步处理的过程中，隐藏了内在实现，仅提供最简单的控制API，如 <code>begin</code>，<code>pause</code>；又为什么不使用 <code>状态模式</code>？</li>
<li>Engine 作为整个流程的控制核心，这是一种 <code>Facade模式</code> 实践，如果没有它的存在，则使用者需要清晰的了解：
<ul>
<li>缓存的使用细节</li>
<li>EngineJob的调度等 <p>
而增加了 Facade层后，对使用者而言，仅需要知道其功能和API语义即可。</li>
</ul>
</li>
</ul>
<p>当然，这些内容以及更细致的思考，需要建立在 <code>有目的</code> 地源码阅读上，而本文所起到的作用，类似于 <code>引子</code>，<code>参考</code>。</p>
<hr />
<p>假期到了，也希望读者们去踏踏青，锻炼锻炼，拥有健康的身体状态！</p>
<p>最近会降低写原创的频次，<em>先前一周写两到三篇着实也有些累</em>。</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="ksp"><a class="header" href="#ksp">KSP</a></h3>
<p>Kotlin Symbol Processing</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="好玩系列--拥抱kotlin-symbol-processingksp项目实战"><a class="header" href="#好玩系列--拥抱kotlin-symbol-processingksp项目实战">好玩系列 | 拥抱Kotlin Symbol Processing(KSP),项目实战</a></h1>
<h2 id="写在最前"><a class="header" href="#写在最前">写在最前</a></h2>
<p>这一篇，我们抱着拥抱新事物的心态，尝试一些新事物。笔者在这一次历程中，对三项事物进行了尝鲜：</p>
<ul>
<li>手动迁移一个小规模的Gradle项目，由 <code>Groovy Script</code> 转为 <code>Kotlin Script</code></li>
<li>Kotlin Symbol Processing</li>
<li>Kotlin Poet</li>
</ul>
<p>这次的 <code>重点是KSP</code> ，Kotlin Poet学习成本比较低，迁移 <code>Kotlin Script</code> 仅仅是比较繁琐。</p>
<p><strong>既然要实战，那么就需要一个实际的项目来支持</strong>，笔者选取了个人的开源项目<a href="https://github.com/leobert-lan/DaVinCi">DaVinCi</a>,.</p>
<p>关注笔者动态的读者可能注意到：笔者在过年时发布过一篇文章<a href="https://leobert-lan.github.io/Android/Drawable/post_4.html">好玩系列：拥有它，XML文件少一半--更方便的处理View背景</a>,
在这篇文章中，我们提到了一种 <code>取代xml背景资源文件</code> 的方案，并且提到之后会 <code>实现Style机制</code>。本篇文章中，以此为目标，展开 <code>KSP的实战过程</code>。</p>
<p><em>PS:对DaVinCi不了解并不影响本文内容的理解</em></p>
<p><em>如果读者对好玩系列感兴趣，建议点个关注，查看 <a href="https://github.com/leobert-lan/Blog/blob/main/info/%E5%85%B3%E4%BA%8E%E5%A5%BD%E7%8E%A9%E7%B3%BB%E5%88%97.md">关于好玩系列</a>
了解笔者创作该系列的初衷。</em></p>
<h2 id="ksp简介"><a class="header" href="#ksp简介">KSP简介</a></h2>
<p>在正式了解KSP之前，我们需要 <code>复习</code> 之前的知识：</p>
<ul>
<li>编译期处理</li>
<li>APT与KAPT</li>
<li>Transformer</li>
</ul>
<p>因为一些特定的需求，在项目进行编译的过程中，需要增加一定的处理，例如：生成源码文件并参与编译；修改编译的产物。</p>
<p>基于Gradle编译任务链中的 <code>APT机制</code>，可以实现 <code>Annotation Processor</code>，常见于 <code>代码生成</code>， <code>SPI机制实现</code><em>如AutoService</em> ，也可以用来生成文档。</p>
<p>而APT仅支持Java源码，KAPT并没有 <code>专门的注解处理器</code> ，所以kotlin项目使用KAPT时，需要 <code>生成代码桩</code> <em>即Java Stub</em> 再交由APT 进行处理。</p>
<p>基于Gradle编译任务链中的 <code>Transformer机制</code>，可以动态的修改编译结果，例如利用 <code>Javasist</code>，<code>ASM</code> 等字节码操纵框架 增加、修改字节码中的业务逻辑。</p>
<p>这导致Kotlin项目想要针对注解进行处理时，要么用力过猛，采用Transformer机制，要么就使用KAPT并牺牲时间。<em>Transformer机制并无时间优势，若KAPT可以等价处理时，
Transformer机制往往呈现力大砖飞之势</em></p>
<p>那么顺理成章，KSP用于解决纯Kotlin项目下，无专门注解处理器的问题。</p>
<p>在KSP之前，Kotlin的编译存在有 <code>Kotlin Compiler Plugin</code>
<a href="https://kotlinlang.org/docs/all-open-plugin.html#:~:text=The%20all-open%20compiler%20plugin,without%20the%20explicit%20open%20keyword.&amp;text=All-open%20allows%20to%20specify%20such%20annotations."><em>了解更多</em></a>
，下文简称KCP，KCP用于解决Kotlin 的关键词和注解的编译问题，例如 <code>data class</code>，</p>
<p>而KCP的功能太过于强大，以至于需要 <code>很大的学习成本</code> ，而将问题局限于 <code>注解处理</code> 时，这一学习成本是多余的，于是出现了KSP，它基于KCP，但 <code>屏蔽了KCP的细节</code> ，
让我们 <code>专注于注解处理的业务</code></p>
<p><img src="https://img-blog.csdnimg.cn/202011012150146.png" alt="KCP开发的若干过程" /></p>
<p><em>KCP的复杂程度从其架构可见一斑</em></p>
<p><em><a href="https://android-developers.googleblog.com/2021/02/announcing-kotlin-symbol-processing-ksp.html">KSP-Alpha版本已于2月发布</a></em></p>
<h2 id="正式开始之前"><a class="header" href="#正式开始之前">正式开始之前</a></h2>
<p>在正式开始之前，我们再简要的阐明一下实战的目标：DaVinCi中可以定义 Style 和 StyleFactory：</p>
<p><em>推荐使用 StyleRegistry.Style.Factory，而不要直接定义 StyleRegistry.Style</em></p>
<pre><code class="language-kotlin">@DaVinCiStyle(styleName = "btn_style.main")
class DemoStyle : StyleRegistry.Style("btn_style.main") {
    init {
        this.register(
            state = State.STATE_ENABLE_FALSE,
            expression = DaVinCiExpression.shape().rectAngle().solid("#80ff3c08").corner("10dp")
        ).register(
            state = State.STATE_ENABLE_TRUE,
            expression = DaVinCiExpression.shape().rectAngle().corner("10dp")
                .gradient("#ff3c08", "#ff653c", 0)
        )
    }
}

@DaVinCiStyleFactory(styleName = "btn_style.main")
class DemoStyleFactory : StyleRegistry.Style.Factory() {
    override val styleName: String = "btn_style.main"

    override fun apply(style: StyleRegistry.Style) {
        style.register(
            state = State.STATE_ENABLE_FALSE,
            expression = DaVinCiExpression.shape().rectAngle().solid("#80ff3c08").corner("10dp")
        ).register(
            state = State.STATE_ENABLE_TRUE,
            expression = DaVinCiExpression.shape().rectAngle().corner("10dp")
                .gradient("#ff3c08", "#ff653c", 0)
        )
    }
}
</code></pre>
<p>并利用</p>
<pre><code class="language-kotlin">osp.leobert.android.davinci.StyleRegistry#register(style: Style)
osp.leobert.android.davinci.StyleRegistry#registerFactory(factory: Style.Factory)
</code></pre>
<p>进行全局注册</p>
<p>我们并且期望将 <code>StyleName</code> 生成常量，且分别检查Style和StyleFactory是否有重复。</p>
<p>那么我们期望生成以下内容：</p>
<pre><code class="language-kotlin">/**
 * auto-generated by DaVinCi, do not modify
 */
public object AppDaVinCiStyles {
  public const val btn_style_main: String = "btn_style.main"

  /**
   * register all styles and styleFactories
   */
  public fun register(): Unit {
    registerStyles()
    registerStyleFactories()
  }

  private fun registerStyles(): Unit {
    osp.leobert.android.davinci.StyleRegistry.register(com.example.simpletest.factories.DemoStyle())
  }

  private fun registerStyleFactories(): Unit {
    osp.leobert.android.davinci.StyleRegistry.registerFactory(com.example.simpletest.factories.DemoStyleFactory())
  }
}
</code></pre>
<h2 id="正式开始"><a class="header" href="#正式开始">正式开始</a></h2>
<h3 id="定义注解"><a class="header" href="#定义注解">定义注解</a></h3>
<pre><code class="language-kotlin">@Target(AnnotationTarget.CLASS)
public annotation class DaVinCiStyle(val styleName: String)

@Target(AnnotationTarget.CLASS)
public annotation class DaVinCiStyleFactory(val styleName: String)
</code></pre>
<p>显然，需要单独建立Module，这并不复杂。</p>
<h3 id="引入-comgoogledevtoolsksp-插件"><a class="header" href="#引入-comgoogledevtoolsksp-插件">引入 com.google.devtools.ksp 插件</a></h3>
<pre><code class="language-kotlin">//project build.gradle.kts
plugins {
    id("com.google.devtools.ksp") version Dependencies.Kotlin.Ksp.version apply false
    kotlin("jvm") version Dependencies.Kotlin.version apply false
    id("org.jetbrains.dokka") version Dependencies.Kotlin.dokkaVersion  apply false
    id("com.vanniktech.maven.publish") version "0.15.1" apply false
}
</code></pre>
<pre><code class="language-kotlin">//Module build.gradle.kts
plugins {
    id("com.google.devtools.ksp")
    kotlin("jvm")
//  kotlin("kapt")
}

dependencies {
    compileOnly(Dependencies.Kotlin.Ksp.api)

    implementation(Dependencies.AutoService.annotations)
    ksp("dev.zacsweers.autoservice:auto-service-ksp:0.5.2")
    implementation(Dependencies.KotlinPoet.kotlinPoet)
    implementation(Dependencies.guava)
    

//  todo use stable version when release
    implementation(project(":annotation"))
}
</code></pre>
<p>引入必要的依赖，这里我们使用ksp实现的auto-service实现SPI，<strong>具体可参考DaVinCi项目源码，此处不再赘述</strong></p>
<h2 id="实现-symbolprocessorprovider-处理注解"><a class="header" href="#实现-symbolprocessorprovider-处理注解">实现 SymbolProcessorProvider 处理注解</a></h2>
<h3 id="必要的知识"><a class="header" href="#必要的知识">必要的知识</a></h3>
<p>核心非常简要，<code>实现SymbolProcessorProvider接口</code> ，提供一个 <code>SymbolProcessor</code> 接口的实例</p>
<pre><code class="language-kotlin">package com.google.devtools.ksp.processing

/**
 * [SymbolProcessorProvider] is the interface used by plugins to integrate into Kotlin Symbol Processing.
 */
interface SymbolProcessorProvider {
    /**
     * Called by Kotlin Symbol Processing to create the processor.
     */
    fun create(environment: SymbolProcessorEnvironment): SymbolProcessor
}

</code></pre>
<p>处理注解的入口：</p>
<pre><code class="language-kotlin">package com.google.devtools.ksp.processing

import com.google.devtools.ksp.symbol.KSAnnotated

/**
 * [SymbolProcessor] is the interface used by plugins to integrate into Kotlin Symbol Processing.
 * SymbolProcessor supports multiple round execution, a processor may return a list of deferred symbols at the end
 * of every round, which will be passed to proceesors again in the next round, together with the newly generated symbols.
 * Upon Exceptions, KSP will try to distinguish the exceptions from KSP and exceptions from processors.
 * Exceptions will result in a termination of processing immediately and be logged as an error in KSPLogger.
 * Exceptions from KSP should be reported to KSP developers for further investigation.
 * At the end of the round where exceptions or errors happened, all processors will invoke onError() function to do
 * their own error handling.
 */
interface SymbolProcessor {
    /**
     * Called by Kotlin Symbol Processing to run the processing task.
     *
     * @param resolver provides [SymbolProcessor] with access to compiler details such as Symbols.
     * @return A list of deferred symbols that the processor can't process.
     */
    fun process(resolver: Resolver): List&lt;KSAnnotated&gt;

    /**
     * Called by Kotlin Symbol Processing to finalize the processing of a compilation.
     */
    fun finish() {}

    /**
     * Called by Kotlin Symbol Processing to handle errors after a round of processing.
     */
    fun onError() {}
}

</code></pre>
<p>环境可以给到的内容：</p>
<pre><code class="language-kotlin">class SymbolProcessorEnvironment(
    /**
     * passed from command line, Gradle, etc.
     */
    val options: Map&lt;String, String&gt;,
    /**
     * language version of compilation environment.
     */
    val kotlinVersion: KotlinVersion,
    /**
     * creates managed files.
     */
    val codeGenerator: CodeGenerator,
    /**
     * for logging to build output.
     */
    val logger: KSPLogger
)
</code></pre>
<p>这里注意，ksp还无法像APT一样进行debug，所以开发阶段还有一些障碍，仅能 <code>靠日志进行排查</code>。</p>
<p><code>codeGenerator</code> 用于生成kotlin源码文件，注意写入时 <code>必须分离到子线程</code> ，否则KSP会进入无限等待。
<code>options</code> 用于手机、获取配置参数</p>
<h3 id="开始编码"><a class="header" href="#开始编码">开始编码</a></h3>
<p>略去获取配置参数的部分</p>
<p>定义目标注解的信息：</p>
<pre><code class="language-kotlin">val DAVINCI_STYLE_NAME = requireNotNull(DaVinCiStyle::class.qualifiedName)
val DAVINCI_STYLE_FACTORY_NAME = requireNotNull(DaVinCiStyleFactory::class.qualifiedName)
</code></pre>
<p>利用Resolver得到目标注解的KSName，e.g.:</p>
<pre><code class="language-kotlin">resolver.getKSNameFromString(DAVINCI_STYLE_NAME)
</code></pre>
<p>并进一步得到被注解的类</p>
<pre><code class="language-kotlin">resolver.getClassDeclarationByName(
    resolver.getKSNameFromString(DAVINCI_STYLE_NAME)
)
</code></pre>
<p>此刻，代码示例如下：</p>
<pre><code class="language-kotlin">
private class DaVinCiSymbolProcessor(
    environment: SymbolProcessorEnvironment,
) : SymbolProcessor {

    //忽略

    companion object {
        val DAVINCI_STYLE_NAME = requireNotNull(DaVinCiStyle::class.qualifiedName)
        val DAVINCI_STYLE_FACTORY_NAME = requireNotNull(DaVinCiStyleFactory::class.qualifiedName)
    }

    override fun process(resolver: Resolver): List&lt;KSAnnotated&gt; {


        val styleNotated = resolver.getClassDeclarationByName(
            resolver.getKSNameFromString(DAVINCI_STYLE_NAME)
        )?.asType(emptyList())

        val factoryNotated = resolver.getClassDeclarationByName(
            resolver.getKSNameFromString(DAVINCI_STYLE_FACTORY_NAME)
        )?.asType(emptyList())

        //暂未涉及


        return emptyList()
    }
}
</code></pre>
<p>进行必要的检查，如果没有任意的目标注解，按照自己的计划进行抛错或者其他；</p>
<p>此刻我们得到了目标注解的类型，即 <code>KSClassDeclaration实例</code></p>
<h3 id="扫描被注解的目标"><a class="header" href="#扫描被注解的目标">扫描被注解的目标</a></h3>
<p>利用 <code>Resolver</code> 和 <code>目标注解的类型</code> 进行扫描</p>
<p>而我们的既定目标是寻找被注解的类，所以直接过滤被注解的目标为 <code>KSClassDeclaration</code>，直接排除掉 Method 和 Property</p>
<pre><code class="language-kotlin">
factoryNotated?.let {
    handleDaVinCiStyleFactory(resolver = resolver, notationType = it)
}

private fun handleDaVinCiStyleFactory(resolver: Resolver, notationType: KSType) {
    resolver.getSymbolsWithAnnotation(DAVINCI_STYLE_FACTORY_NAME)
            .asSequence()
            .filterIsInstance&lt;KSClassDeclaration&gt;()
            .forEach { style -&gt;
                //解析类上的注解信息、保存以待后续处理
                /*end @forEach*/
            }
}
</code></pre>
<h3 id="解析注解信息"><a class="header" href="#解析注解信息">解析注解信息</a></h3>
<p>这里和APT有一点差异，无法直接将 <code>KSAnnotation</code> 转换为实际注解，但并不影响我们操作，可以判断注解的类型、获取注解中方法的返回值。</p>
<p>前面已经得到了被注解的 <code>KSClassDeclaration实例</code>，可以直接得到对于它的注解，并通过 <code>KSType</code> 比对得到目标注解，并进一步解析其 <code>arguments</code>，
得到注解中的值。</p>
<pre><code class="language-kotlin">val annotation =
        style.annotations.find { it.annotationType.resolve() == notationType }
                ?: run {
                    logE("@DaVinCiStyleFactory annotation not found", style)
                    return@forEach
                }

//structure: DaVinCiStyle(val styleName: String, val parent: String = "")

val styleName = annotation.arguments.find {
    it.name?.getShortName() == "styleName"
}?.value?.toString() ?: kotlin.run {
    logE("missing styleName? version not matched?", style)
    return@forEach
}

//下面是简要的信息处理和保存
val constName = generateConstOfStyleName(styleName)
if (styleFactoryProviders.containsKey(constName)) {
    logE(
            "duplicated style name:${styleName}, original register:${styleFactoryProviders[constName]?.clzNode}",
            style
    )
    return@forEach
}

styleFactoryProviders[constName] = MetaInfo.Factory(
        constName = constName,
        styleName = styleName,
        clzNode = style
)

</code></pre>
<h3 id="基于信息生成kotlin源码"><a class="header" href="#基于信息生成kotlin源码">基于信息生成Kotlin源码</a></h3>
<p>参考 <a href="https://square.github.io/kotlinpoet/">kotlin poet</a> 进行学习</p>
<p>鉴于此部分代码完全与DaVinCi的业务相关，故略去。</p>
<h3 id="生成源码文件"><a class="header" href="#生成源码文件">生成源码文件</a></h3>
<pre><code class="language-kotlin">//daVinCiStylesSpec 为利用Kotlin Poet编写的源码信息
val fileSpec = FileSpec.get(packageName ?: "", daVinCiStylesSpec)

val dependencies = Dependencies(true)
thread(true) {
    codeGenerator.createNewFile(
        dependencies = dependencies,
        packageName = packageName ?: "",
        fileName = "${moduleName ?: ""}DaVinCiStyles",
        extensionName = "kt"
    ).bufferedWriter().use { writer -&gt;
        try {
            fileSpec.writeTo(writer)
        } catch (e: Exception) {
            logE(e.message ?: "", null)
        } finally {
            writer.flush()
            writer.close()
        }
    }
}
</code></pre>
<p>再次注意，<code>需要在子线程中执行</code></p>
<p><em>若对碎片化的代码不太敏感，可以下载DaVinCi的源码进行对照阅读</em></p>
<h2 id="在项目中使用"><a class="header" href="#在项目中使用">在项目中使用</a></h2>
<p>前面我们已经完成了KSP的核心逻辑，现在我们需要配置并使用它</p>
<p>这里注意，<strong>ksp的生成目录不属于默认sourceSets，<code>需要单独配置</code></strong></p>
<pre><code class="language-kotlin">plugins {
    id("com.android.application")
    id("com.google.devtools.ksp") //version Dependencies.Kotlin.Ksp.version
    //略
}

android {
    //略

    buildTypes {
        getByName("release") {
            sourceSets {
                getByName("main") {
                    java.srcDir(File("build/generated/ksp/release/kotlin"))
                }
            }
            //略
        }

        getByName("debug").apply {

            sourceSets {
                getByName("main") {
                    java.srcDir(File("build/generated/ksp/debug/kotlin"))
                }
            }
        }
    }
}

ksp {
    arg("daVinCi.verbose", "true")
    arg("daVinCi.pkg", "com.examole.simpletest")
    arg("daVinCi.module", "App")
}

dependencies {

    implementation(project(":davinci"))
    ksp(project(":anno_ksp"))
    implementation(project(":annotation"))
    //略

}

</code></pre>
<p>运行 <code>kspXXXXKotlin</code> 任务即可</p>
<h2 id="结语"><a class="header" href="#结语">结语</a></h2>
<p>至此，KSP的实战已告一段落，相信读者朋友们一定产生了浓厚的兴趣，并准备尝试一番了，赶紧开始吧！</p>
<hr />
<h3 id="写给对davinci感兴趣的读者朋友们"><a class="header" href="#写给对davinci感兴趣的读者朋友们">写给对DaVinCi感兴趣的读者朋友们</a></h3>
<p>继DaVinCi开源以及相关文章发布后，也引起了部分读者朋友们的讨论和关注，此次结合实战KSP的机会，对DaVinCi的功能进行了升级，这里也简单的交代一下，
DaVinCi目前已经支持：</p>
<ul>
<li><code>GradientDrawable</code> , <code>StateListDrawable</code> 的背景设置 （原有）</li>
<li><code>ColorStateList</code> 文字色设置（新增）</li>
<li>以上两者的Style定义和使用 （新增）</li>
</ul>
<p>开发DaVinCi时，我的初衷是："既然难以管理Style和Shape资源，那索性就用一种更加方便的方式来处理"，但这件本身是违背"优秀代码、优秀项目管理"的。</p>
<p>而本次为DaVinCi添加Style机制，又将这一问题摆上桌面，笔者也将思考并尝试寻找一种 <code>有效、有趣</code> 的方式，来解决这一问题。如果各位读者对此有比较好的点子，非常希望能够分享一二。</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="base"><a class="header" href="#base">Base</a></h3>
<p>基础知识的创作计划尚未确立，有兴致时会挑一些手头遇到的内容写写，作为系统性（例如View系统、消息系统）知识之外的补遗</p>
<ul>
<li><a href="Android/Base/./post_35.html">孔乙己：你可知道页面和弹窗“通信“的方式有四种？</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="孔乙己你可知道页面和弹窗通信的方式有四种"><a class="header" href="#孔乙己你可知道页面和弹窗通信的方式有四种">孔乙己：你可知道页面和弹窗“通信“的方式有四种？</a></h1>
<p><em>演示用源码和内容思维导图于文末</em></p>
<p>这日孔乙己照常走进星巴克，点了份大杯拿铁，还要脱脂奶的， 虽然过上了小康生活，但毛病还是没有改，照例掏出一大把硬币，排出三十二枚。</p>
<p>就在等待时，听到旁边一桌人说道："好兄弟，别摸鱼了，今天我请你喝咖啡，这个弹窗功能可务必要加好，不能出bug啊"。"呵呵，一个弹窗、还能难道我伟大的Android工程师？"
手指孔乙己说道："在他拿到咖啡前，我就能写好，bug不存在的！"</p>
<p>孔乙己看热闹不嫌事大，凑上前去，"哟嚯，小兄弟年纪不大口气不小，你可知道Android中界面使用弹窗，有四种写法？今天就让我孔乙己来和你说道说道"</p>
<p>众人哂笑："这孔乙己还真是孔乙己，茴香豆的茴字你是不是也要说道说道？"</p>
<p>孔乙己大怒道："这可不是茴香豆的茴字！这可是必备的基础知识啊，有些你今天用不着了，但遇上祖传代码呢？"</p>
<p>为了说的清晰些，我们约定："在界面点击按钮触发弹窗、弹窗中可输入文字，确定后将输入的内容显示在按钮上方的文本框中。让场景更加真实些，界面包含Activity界面和Fragment界面两种主流情况"。</p>
<p>孔乙己准备先做点准备工作：封装两种情况获取Context、绑定View、绑定事件</p>
<p><em>诸位可以忽略下面这段模板代码，仅仅是担心后续内容中的代码引起疑惑，可以直接跳跃到 <a href="Android/Base/post_35.html#demo1">最久远的做法: Dialog</a></em></p>
<pre><code class="language-kotlin">sealed class Host {
    abstract val context: Context

    abstract fun &lt;T : View&gt; view(@IdRes id: Int): T
    abstract fun launchFragment(fragment: DialogFragment)
    abstract fun launchFragment2(fragment: DialogFragment, listener: FragmentResultListener)

    class ActivityHost(private val activity: AppCompatActivity) : Host() {
        override val context: Context
            get() = activity

        override fun &lt;T : View&gt; view(id: Int): T {
            return activity.findViewById(id)
        }

        override fun launchFragment(fragment: DialogFragment) {
            //下文展开
        }

        override fun launchFragment2(fragment: DialogFragment, listener: FragmentResultListener) {
            //下文展开
        }
    }

    class FragmentHost(private val fragment: Fragment) : Host() {
        override val context: Context
            get() = fragment.requireContext()

        override fun &lt;T : View&gt; view(id: Int): T {
            return fragment.requireView().findViewById(id)
        }

        override fun launchFragment(fragment: DialogFragment) {
            //下文展开
        }

        override fun launchFragment2(fragment: DialogFragment, listener: FragmentResultListener) {
            //下文展开
        }
    }
}

class Demo(val host: Host) {

    interface OnResultListener {
        fun onResult(text: String?)
    }

    companion object {
        const val BUNDLE_STR_INPUT = "BUNDLE_STR_INPUT"
        const val BUNDLE_BOOL_FROM_FG = "BUNDLE_BOOL_FROM_FG"
        const val KEY_INPUT = "KEY_INPUT"
    }

    fun onStart() {
        val btnDemo1: Button = host.view(R.id.btn1)
        val btnDemo2: Button = host.view(R.id.btn2)
        val btnDemo3: Button = host.view(R.id.btn3)
        val btnDemo4: Button = host.view(R.id.btn4)

        btnDemo1.setOnClickListener { demo1() }
        btnDemo2.setOnClickListener { demo2() }
        btnDemo3.setOnClickListener { demo3() }
        btnDemo4.setOnClickListener { demo4() }
    }

    fun setText(text: String?) {
        host.view&lt;TextView&gt;(R.id.tv_result).text = text
    }

    private fun demo1() {
    }

    private fun demo2() {
    }

    private fun demo3() {
    }

    private fun demo4() {
    }
}
</code></pre>
<p>很轻易的，孔乙己完成了准备工作</p>
<h2 id="最久远的做法-dialog"><a class="header" href="#最久远的做法-dialog"><a id="demo1">最久远的做法: Dialog</a></a></h2>
<p>还能看到这种做法的，那项目一定是历史悠久了。</p>
<h3 id="做法"><a class="header" href="#做法">做法</a></h3>
<p>孔乙己继续说道："这种做法只需要拿到 Context 和 业务回调函数即可"</p>
<pre><code class="language-kotlin">private fun demo1() {
    val view = LayoutInflater.from(host.context).inflate(R.layout.view_input, null)
    val dialog = AlertDialog.Builder(host.context)
        .setView(view)
        .setPositiveButton("OK") { dialog, _ -&gt;
            dialog?.dismiss()
            setText(view.findViewById&lt;EditText&gt;(R.id.et_input)?.text?.toString())
        }
        .setNegativeButton("cancel") { dialog, _ -&gt; dialog?.dismiss() }
        .create()
    dialog.show()
}
</code></pre>
<h3 id="优点"><a class="header" href="#优点">优点</a></h3>
<p>很显然，它的优点很明显：<strong>简单、易于封装</strong>，诸位可以很容易的按照产品和UI的需求、剥离弹窗UI部分，从而保持业务部分 "纯粹"， 既能够 <code>高效复用</code> ，也 <code>避免</code> UI变更时改动业务类。</p>
<h3 id="缺点"><a class="header" href="#缺点">缺点</a></h3>
<p>孔乙己转头问小兄弟："你可知道它的缺点吗？"，小兄弟默默不言， 孔乙己也不去管他，笑道："你把弹窗弹出来、再转一下屏幕看。或者把不保留活动打开，退后台再进。哈哈，是不是弹窗没了？"</p>
<p>再仔细看看，是不是还发生了 <code>WindowLeak</code>？</p>
<p>这个设计需要开发者额外维护生命周期变化所导致的问题。</p>
<h2 id="不操心生命周期变化的方式dialogfragment--settargetfragment"><a class="header" href="#不操心生命周期变化的方式dialogfragment--settargetfragment">不操心生命周期变化的方式：DialogFragment + setTargetFragment</a></h2>
<p>孔乙己继续说道："Google知道这个设计不好，于是再Fragment系统中增加弹窗交互系统，想要利用Fragment在宿主生命周期变化后的恢复特性来解决这一问题"</p>
<h3 id="做法-1"><a class="header" href="#做法-1">做法</a></h3>
<p>孔乙己又做了点准备工作，和前文的Dialog保持了功能一致：</p>
<pre><code class="language-kotlin">sealed class DemoDialogFragment : DialogFragment() {

    override fun onCreateDialog(savedInstanceState: Bundle?): Dialog {
        val view = LayoutInflater.from(requireContext()).inflate(R.layout.view_input, null)
        return AlertDialog.Builder(requireContext())
            .setView(view)
            .setPositiveButton("OK") { _, _ -&gt;
                dismissAllowingStateLoss()
                onPositive(view.findViewById&lt;EditText&gt;(R.id.et_input)?.text?.toString())
            }
            .setNegativeButton("Cancel") { _, _ -&gt; dismissAllowingStateLoss() }
            .create()
    }

    protected abstract fun onPositive(text: String?)
}
</code></pre>
<p>孔乙己又按照两种界面形式区分了结果处理：</p>
<ul>
<li>Fragment来源则重新获得 targetFragment，约定调用onActivityResult进行回调</li>
<li>Activity来源则约定Activity必须实现回调接口，获取宿主Activity后进行转型继而进行回调</li>
</ul>
<pre><code class="language-kotlin">class Demo2 : DemoDialogFragment() {
    private var fromFg = false

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        fromFg = arguments?.getBoolean(BUNDLE_BOOL_FROM_FG) ?: false
    }

    override fun onPositive(text: String?) {
        val intent = Intent()
        intent.putExtras(Bundle().apply {
            putString(BUNDLE_STR_INPUT, text)
        })

        if (fromFg) {
            targetFragment?.onActivityResult(targetRequestCode, Activity.RESULT_OK, intent)
        } else {
            (requireActivity() as OnResultListener).onResult(text)
        }
    }
}
</code></pre>
<p>编写好 "启动" 方式</p>
<pre><code class="language-kotlin"> class ActivityHost(private val activity: AppCompatActivity) : Host() {

    override fun launchFragment(fragment: DialogFragment) {
        val arg = fragment.arguments ?: Bundle()
        arg.putBoolean(BUNDLE_BOOL_FROM_FG, false)
        fragment.arguments = arg
        fragment.show(activity.supportFragmentManager, fragment.javaClass.name)
    }
}

class FragmentHost(private val fragment: Fragment) : Host() {

    override fun launchFragment(fragment: DialogFragment) {
        val arg = fragment.arguments ?: Bundle()
        arg.putBoolean(BUNDLE_BOOL_FROM_FG, true)
        fragment.arguments = arg
        fragment.setTargetFragment(this.fragment, 2)
        //使用 fragment.requireActivity().supportFragmentManager 亦可
        fragment.show(this.fragment.requireFragmentManager(), fragment.javaClass.name)
    }
}
</code></pre>
<p>略去回调处理逻辑，<em>简单的取数据和方法调用</em></p>
<pre><code class="language-kotlin">private fun demo2() {
    host.launchFragment(DemoDialogFragment.Demo2())
}
</code></pre>
<h3 id="优点-1"><a class="header" href="#优点-1">优点</a></h3>
<p>小兄弟拿起demo进行了把玩，不错不错，这个没bug了。</p>
<h3 id="缺点-1"><a class="header" href="#缺点-1">缺点</a></h3>
<p>孔乙己又是邪魅一笑，你不觉得这 <strong>代码太TM多</strong> 了吗？使用很不方便啊，Activity和Fragment还有使用差异。</p>
<p>小兄弟试探的答道："改造下，全部干成回调函数？那不就基本统一了吗？"</p>
<p>孔乙己又是邪魅一笑，不错、这就是第三种做法了，你来试一试。</p>
<h2 id="不靠谱的-dialogfragment--callback"><a class="header" href="#不靠谱的-dialogfragment--callback">不靠谱的 DialogFragment + Callback</a></h2>
<p>孔乙己在一旁看着小兄弟飞快的编码，左手一个Callback，右手一个invoke Callback，三下五除二就改完了</p>
<h3 id="做法-2"><a class="header" href="#做法-2">做法</a></h3>
<pre><code class="language-kotlin">class Demo3 : DemoDialogFragment() {
    var listener: OnResultListener? = null
    override fun onPositive(text: String?) {
        listener?.onResult(text) ?: Log.e("DEMO3", "listener is null!")
    }
}

private fun demo3() {
    host.launchFragment(DemoDialogFragment.Demo3().apply {
        this.listener = object : OnResultListener {
            override fun onResult(text: String?) {
                setText(text)
            }
        }
    })
}
</code></pre>
<h3 id="优点-2"><a class="header" href="#优点-2">优点</a></h3>
<p>小兄弟对孔乙己说："孔兄，你看，它又变得 <strong>很简单、很容易封装</strong> 了，他们再改UI我也不担心改业务代码了，你看生命周期变化的时候它也不消失了！"</p>
<h3 id="缺点-2"><a class="header" href="#缺点-2">缺点</a></h3>
<p>孔乙己邪魅一笑，"小兄弟别高兴的太早，转完了屏幕测一下功能还正常不？"</p>
<p>小兄弟闻言一试，大呼："回调函数怎么没了！可有解救之法？"</p>
<p>孔乙己说道："自然是有的，先想想为什么会这样？重新出现的弹窗是系统在处理宿主生命周期变化时为你恢复的，但并不保证所有的引用都恢复"</p>
<p>破解自然是有办法的，让Callback被恢复，或者让Callback不需要被恢复也能得到正确的对象即可，但需要注意不能带来宿主的内存泄漏问题。</p>
<p>改造自然是需要花费很多精力的，但是现在有福了。</p>
<h2 id="拥抱新变化fragmentresultlistener"><a class="header" href="#拥抱新变化fragmentresultlistener">拥抱新变化：FragmentResultListener</a></h2>
<p>孔乙己说道："Google自然是知道方法二中的诸多问题，终于是提供了大一统解决方案"</p>
<p>先把AndroidX-Appcompat升级到 1.3.0</p>
<pre><code class="language-kotlin">implementation 'androidx.appcompat:appcompat:1.3.0'
</code></pre>
<p>我们将会拥有新API：</p>
<pre><code class="language-kotlin">FragmentManager#setFragmentResultListener(key:String, lifecycleOwner:LifecycleOwner, listener:FragmentResultListener)

FragmentManager#setFragmentResult(key:String, bundle:Bundle)
</code></pre>
<h3 id="做法-3"><a class="header" href="#做法-3">做法</a></h3>
<p>孔乙己使用新API进行了修改</p>
<pre><code class="language-kotlin">class ActivityHost(private val activity: AppCompatActivity) : Host() {
    //...

    override fun launchFragment2(fragment: DialogFragment, listener: FragmentResultListener) {
        activity.supportFragmentManager.setFragmentResultListener(Demo.KEY_INPUT, activity, listener)
        fragment.show(activity.supportFragmentManager, fragment.javaClass.name)
    }
}

class FragmentHost(private val fragment: Fragment) : Host() {
    //...

    override fun launchFragment2(fragment: DialogFragment, listener: FragmentResultListener) {
        this.fragment.parentFragmentManager.setFragmentResultListener(Demo.KEY_INPUT, this.fragment, listener)
        fragment.show(this.fragment.parentFragmentManager, fragment.javaClass.name)
    }
}
</code></pre>
<p>重新呼出弹窗后</p>
<pre><code class="language-kotlin">private fun demo4() {
    host.launchFragment2(fragment = DemoDialogFragment.Demo4()) { requestKey, result -&gt;
        if (requestKey != KEY_INPUT) return@launchFragment2
        setText(result.getString(BUNDLE_STR_INPUT))
    }
}
</code></pre>
<p>非常完美。此时店员的声音飘来："孔乙己先生，您的大杯脱脂奶拿铁好了"。</p>
<p>孔乙己对众人说道："我的咖啡好了，要走了，有这种官方方案，第三种方法便不再优化了，至于此方案是否有缺点，诸位还请阅读源码，江湖再见"。</p>
<h2 id="附"><a class="header" href="#附">附</a></h2>
<p><a href="https://github.com/leobert-lan/BlogWorkShop">演示代码</a></p>
<p>内容导图</p>
<p><img src="Android/Base/./post_35/post_35.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="sysapp"><a class="header" href="#sysapp">SysApp</a></h3>
<p>Android系统应用部分，基础部分。</p>
<p>系统应用一般通过ContentProvider对外提供服务，当然也包含Intent方式（一般在设计上会保持信息一致）。</p>
<p>本章节并不打算完全罗列所有的系统应用，只会挑选相对不常用、但产品方案中可能需要的部分。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用日历丰富产品的用户体验"><a class="header" href="#使用日历丰富产品的用户体验">使用日历丰富产品的用户体验</a></h1>
<h2 id="前言-10"><a class="header" href="#前言-10">前言</a></h2>
<p>经过一段时间的梳理和遴选，我挑选出了Android知识图谱中重要的部分，制作了一张脑图。读者朋友们可按照脑图查漏补缺了， <a href="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4eb015559c364ca09a216c92c7b1c5de~tplv-k3u1fbpfcp-watermark.image?">图片尺寸较大，仅附链接</a> 。</p>
<p><em>当然，这是我按照自己的判断、结合参考其他博主的观点进行的挑选，不同的细分领域要求的重点有所不同，不可一以概之，且未曾遴选内容并非没必要掌握。图中的4-5层没有展示，以后文章见。</em></p>
<p>本篇属于 part2-系统应用部分。</p>
<img width="600" alt="desc" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8763beabd548467daea5a634c790c797~tplv-k3u1fbpfcp-watermark.image?"/>
<p>在一些助手类的APP中，在使用应用的过程中会产生 "日程" 数据。作为用户理所当然的希望在事情发生前收到提醒。</p>
<p>而我们知道，通过 <code>推送进行提醒</code> 存在一定的不可靠性。那么 <code>在用户手机日历中自动插入事件</code> 则是一个重要的补充手段。</p>
<p>本篇中，我们将用 5-10分钟的时间，回顾操作日历的知识点。</p>
<p><em>注：开发者官网具有更详尽地说明，只是有点啰嗦，<a href="https://developer.android.google.cn/guide/topics/providers/calendar-provider?hl=en">英文版</a>  <a href="https://developer.android.google.cn/guide/topics/providers/calendar-provider?hl=zh_cn">中文版</a></em></p>
<h2 id="重点先行"><a class="header" href="#重点先行">重点先行</a></h2>
<p>值得关注的重点：</p>
<ul>
<li>权限</li>
<li>ContentResolver 进行 查询、插入、修改、删除 操作</li>
<li>CalendarContract 中 各"表"含义和字段作用 （文中不会详细列举，看API doc即可，足够详细）</li>
<li>同步适配器以及何时需要使用同步适配器</li>
<li>EntityIterator简化模板代码</li>
<li>RFC 5545 简要规则</li>
<li>使用逻辑删除与物理删除</li>
<li>从日历日程跳转回APP</li>
</ul>
<p>如果您已经掌握了这些内容，可忽略下文，下文面向初学者。</p>
<h2 id="权限"><a class="header" href="#权限">权限</a></h2>
<p>小于23时，不需要获取动态权限，Manifest声明日历读写权限即可。</p>
<p><em>API 14 即 Android 4.0以下不支持，庆幸没那么古老的手机了</em></p>
<pre><code class="language-xml">
&lt;manifest&gt;
    &lt;uses-permission android:name="android.permission.READ_CALENDAR"/&gt;
    &lt;uses-permission android:name="android.permission.WRITE_CALENDAR"/&gt;
    ...
&lt;/manifest&gt;
</code></pre>
<p>大于等于23时，用你喜欢的方式处理动态权限获取即可。</p>
<h2 id="查询创建本地日历"><a class="header" href="#查询创建本地日历">查询、创建本地日历</a></h2>
<p>实际上，从这里开始的所有内容均和 <code>ContentResolver</code> 有关，相应的，日历应用通过 <code>ContentProvider</code>提供了这些服务，以及通过 <code>Intent</code> 做功能补充。</p>
<p>日历账户信息属于 <code>CalendarContract.Calendars</code> 范畴，可将其看做一张数据库表理解查询与插入</p>
<h3 id="查询"><a class="header" href="#查询">查询</a></h3>
<p>定义关心的列，可理解为 SQL 语句中 Select片段的Column，当然使用null传参可获取所有列，这将增加I/O成本和内存开销。</p>
<pre><code class="language-kotlin"> // dynamic lookups improves performance.
private val EVENT_PROJECTION: Array&lt;String&gt; = arrayOf(
    CalendarContract.Calendars._ID,                     // 0
    CalendarContract.Calendars.ACCOUNT_NAME,            // 1
    CalendarContract.Calendars.CALENDAR_DISPLAY_NAME,   // 2
    CalendarContract.Calendars.OWNER_ACCOUNT            // 3
)

// The indices for the projection array above.
private const val PROJECTION_ID_INDEX: Int = 0
private const val PROJECTION_ACCOUNT_NAME_INDEX: Int = 1
private const val PROJECTION_DISPLAY_NAME_INDEX: Int = 2
private const val PROJECTION_OWNER_ACCOUNT_INDEX: Int = 3
</code></pre>
<p>uri则类似SQL中的 FROM片段，代表了表名</p>
<pre><code class="language-kotlin">val uri: Uri = CalendarContract.Calendars.CONTENT_URI
</code></pre>
<p>拼接条件模板，条件模板+参数 则类似SQL中的 Where片段。代码中演示了查询条件为 <strong>账户名为"张三" 且 账户类型为本地账户 且 账户拥有者为"张三"</strong></p>
<pre><code class="language-kotlin">val selection: String = "((${CalendarContract.Calendars.ACCOUNT_NAME} = ?) AND (" +
        "${CalendarContract.Calendars.ACCOUNT_TYPE} = ?) AND (" +
        "${CalendarContract.Calendars.OWNER_ACCOUNT} = ?))"
val selectionArgs: Array&lt;String&gt; = arrayOf("张三", CalendarContract.ACCOUNT_TYPE_LOCAL, "张三")
</code></pre>
<pre><code class="language-kotlin">val cur: Cursor? = contentResolver.query(uri, EVENT_PROJECTION, selection, selectionArgs, null)
</code></pre>
<p>执行查询，<strong>注意此类操作均回避主线程，养成好习惯</strong></p>
<p>遍历cursor，略</p>
<p>_
注：可能您在使用Sqlite数据库时，因为表结构是自行定义的，已经习惯了编码操作cursor、或者依赖ORM框架。而在ContentResolver相关的模块中，您可以尝试使用 <code>android.content.EntityIterator</code>
进而遍历 <code>Entity</code>，可直接获得 <code>ContentValue</code>，减少很多模板代码_</p>
<h3 id="插入"><a class="header" href="#插入">插入</a></h3>
<p>可以选择插入 <code>本地账户</code> 或 <code>在线同步账户</code>，区别就是是否通过服务器同步数据。</p>
<p><em>一般Exchange协议的邮件服务器适用性更强，但本地账户已经足够满足需求。</em></p>
<p>我们需要注意：这张表的数据列来自4处定义：</p>
<pre><code class="language-java">public static final class Calendars
        implements BaseColumns, SyncColumns, CalendarColumns {

}
</code></pre>
<p>牵涉到 <code>SyncColumns</code> 中定义的字段时，其写操作必须以 <code>同步适配器</code> 方式进行。</p>
<p><em>作者按：不需要死记，有十几个列，记住规则即可，开发时注意</em></p>
<p>需对uri做一定处理，包括：</p>
<ul>
<li><code>CALLER_IS_SYNCADAPTER</code> 设置为 true</li>
<li>提供 <code>ACCOUNT_NAME</code> 和 <code>ACCOUNT_TYPE</code>，作为 URI 中的查询参数，插入时据实填写即可，修改时注意数据有效性。</li>
</ul>
<p>代码固定如下：</p>
<pre><code class="language-kotlin">private fun Uri.asSyncAdapter(accountName: String, accountType: String): Uri {
    return this.buildUpon()
        .appendQueryParameter(CalendarContract.CALLER_IS_SYNCADAPTER, "true")
        .appendQueryParameter(CalendarContract.Calendars.ACCOUNT_NAME, accountName)
        .appendQueryParameter(CalendarContract.Calendars.ACCOUNT_TYPE, accountType).build()
}

//例如：
CalendarContract.Calendars.CONTENT_URI.asSyncAdapter("张三", CalendarContract.ACCOUNT_TYPE_LOCAL)
</code></pre>
<p>以下代码演示插入的关键代码，您可以按照需求增加列参数，例如是否显示、时区、地区等</p>
<pre><code class="language-kotlin">//构造行数据
val values = ContentValues().apply {
    // The new display name for the calendar
    put(CalendarContract.Calendars.CALENDAR_DISPLAY_NAME, "${username}的日历")
    put(CalendarContract.Calendars.ACCOUNT_NAME, username)
    put(CalendarContract.Calendars.OWNER_ACCOUNT, username)
    put(CalendarContract.Calendars.ACCOUNT_TYPE, CalendarContract.ACCOUNT_TYPE_LOCAL)
}

//插入
val resultUri = contentResolver.insert(
    CalendarContract.Calendars.CONTENT_URI.asSyncAdapter(username, CalendarContract.ACCOUNT_TYPE_LOCAL),
    values
)

//解析id
resultUri?.let {
    calendarId = ContentUris.parseId(it)
}
</code></pre>
<h2 id="插入日程和提醒"><a class="header" href="#插入日程和提醒">插入日程和提醒</a></h2>
<p><em>注：源码中体现为Event、文档中直译为事件，文中采用日程，更符合用语习惯，并非新事物</em></p>
<p>日程数据隶属于日历，因此我们需要事先获取操作的日历的日历id，<em>参见上一节</em>。</p>
<h3 id="插入日程"><a class="header" href="#插入日程">插入日程</a></h3>
<p>日程对应 <code>CalendarContract.Events</code> "表" ：</p>
<pre><code class="language-java">public static final class Events implements BaseColumns,
        SyncColumns, EventsColumns, CalendarColumns {
}
</code></pre>
<p>同理，写 <code>SyncColumns</code> 中的字段时，需要使用同步适配器，不再赘述。</p>
<p>业务相关字段主要定义于：<code>EventsColumns</code>，包含以下类别：</p>
<ul>
<li>所属日历id</li>
<li>日程的名称、描述</li>
<li>颜色等样式相关</li>
<li>时间和规则描述，如起止时间、是否全天时间、如何重复</li>
<li>访客控制权限</li>
<li>等</li>
</ul>
<p>如果是非重复日程，则必须提供起止时间，如下代码构建ContentValue：</p>
<pre><code class="language-kotlin">val event = ContentValues().let {
    //UTC 毫秒级时间戳
    it.put(CalendarContract.Events.DTSTART, startMillis)
    it.put(CalendarContract.Events.DTEND, endMillis)

    //非全天
    it.put(CalendarContract.Events.ALL_DAY, 0)
    //标题和描述
    it.put(CalendarContract.Events.TITLE, title)
    it.put(CalendarContract.Events.DESCRIPTION, desc)

    //所属日历的id
    it.put(CalendarContract.Events.CALENDAR_ID, calendarId)
    //时区
    it.put(CalendarContract.Events.EVENT_TIMEZONE, SimpleTimeZone.getDefault().displayName)

    //API &gt;=16
    // 来源APP的应用包名
    it.put(CalendarContract.Events.CUSTOM_APP_PACKAGE, pkg)
    // 为日程自定义uri，在支持的设备上，打开来源APP时可获取该uri值
    it.put(CalendarContract.Events.CUSTOM_APP_URI, uri)

    it
}
</code></pre>
<p>其他字段参考API文档选择使用。</p>
<p>如果是重复事件，<strong>则无需传递结束时间戳，而需要提供规则信息</strong></p>
<pre><code class="language-kotlin">//单次持续时间，而非从第一次起到最后一次截至的时间
it.put(CalendarContract.Events.DURATION, duration)
//日程的重复发生规则
it.put(CalendarContract.Events.RRULE, rRule)
//日程的日期重复规则
it.put(CalendarContract.Events.RDATE, rDate)
</code></pre>
<p>这三个参数的值，均遵循 <a href="https://www.rfc-editor.org/rfc/rfc5545">RFC 5545</a></p>
<ul>
<li>DURATION: ”P600S” 标识持续600s即10分钟, “PT1H” 表示持续1小时， “P2W” 表示持续 2周。</li>
<li>RRULE: ”FREQ=DAILY;WKST=SU;UNTIL=20230225T070000Z” 表示每日重复直至2023年2月25号7点；</li>
<li>RDATE: 配合RRULE生成更加复杂的规则，如有必要，请研究 RFC 5545</li>
</ul>
<p><strong>插入日程并获取日程id</strong>：</p>
<pre><code class="language-kotlin">val uri: Uri? = contentResolver.insert(CalendarContract.Events.CONTENT_URI, event)

// get the event ID that is the last element in the Uri
val eventID: Long = uri?.lastPathSegment?.toLong() ?: -1
</code></pre>
<h4 id="从日程详情回到来源app"><a class="header" href="#从日程详情回到来源app">从日程详情回到来源APP</a></h4>
<p>插入日程时，我们使用了如下字段，标识了日程的来源APP和日程的自定义Uri。</p>
<pre><code class="language-kotlin">//API &gt;=16
// 来源APP的应用包名
it.put(CalendarContract.Events.CUSTOM_APP_PACKAGE, pkg)
// 为日程自定义uri，在支持的设备上，打开来源APP时可获取该uri值
it.put(CalendarContract.Events.CUSTOM_APP_URI, uri)
</code></pre>
<p>在大多数ROM的内置日历中，均支持在日程详情中跳转到来源应用。<em>注意，存在一些例外。鸿蒙系统内置日历也并未完全支持该特性</em></p>
<p>您可以通过注册IntentFilter配合实现该功能：</p>
<pre><code class="language-xml">&lt;!--注意：exported需设置为true，进行适配--&gt;
&lt;activity android:name="XXXActivity"&gt;
    &lt;intent-filter&gt;
        &lt;action android:name="android.provider.calendar.action.HANDLE_CUSTOM_EVENT"/&gt;
        &lt;category android:name="android.intent.category.DEFAULT"/&gt;
        &lt;data android:mimeType="vnd.android.cursor.item/event"/&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;
</code></pre>
<p>并从Intent中获取日程的自定义Uri：</p>
<pre><code class="language-java">getIntent().getStringExtra(CalendarContract.EXTRA_CUSTOM_APP_URI)
</code></pre>
<h3 id="为日程插入提醒"><a class="header" href="#为日程插入提醒">为日程插入提醒</a></h3>
<p>首先，要获取日程的id，可以在插入日程时从返回uri中解析得出，也可以通过查询日程解析得出</p>
<p>此时，操作的是提醒表，<code>CalendarContract.Reminders</code>:</p>
<pre><code class="language-java">public static final class Reminders implements BaseColumns,
        RemindersColumns, EventsColumns {

}
</code></pre>
<p>一般设置提前时间、 提醒方式、日程id即可</p>
<pre><code class="language-kotlin">val values = ContentValues().apply {
    put(CalendarContract.Reminders.MINUTES, 1)
    put(CalendarContract.Reminders.EVENT_ID, eventID)
    put(CalendarContract.Reminders.METHOD, CalendarContract.Reminders.METHOD_ALERT)
}

contentResolver.insert(CalendarContract.Reminders.CONTENT_URI, values)
</code></pre>
<h2 id="读取日程"><a class="header" href="#读取日程">读取日程</a></h2>
<p>掌握了插入之后，您已经掌握了表和字段含义，读取日程则更加简单</p>
<p>按实际需求拼接查询条件后，执行查询。</p>
<pre><code class="language-kotlin">val selection = "((${CalendarContract.Events.CALENDAR_ID} = ?))"
val selectionArgs: Array&lt;String&gt; = arrayOf(calendarId.toString())
val cur: Cursor? = contentResolver.query(CalendarContract.Events.CONTENT_URI, null, selection, selectionArgs, null)

</code></pre>
<p>解析：</p>
<pre><code class="language-kotlin">cur?.let {
    val events = CalendarContract.EventsEntity.newEntityIterator(cur, contentResolver)
        .asSequence()
        .map { entity -&gt; entity.entityValues }
        .map {
            //解析转换实体对象
        }
        .toCollection(arrayListOf())
}
</code></pre>
<h2 id="更改日程"><a class="header" href="#更改日程">更改日程</a></h2>
<p>通过向URI追加ID的方式，可以限定至修改的条目（类似数据库ORM框架中按主键更新），而不必使用限定条件。</p>
<pre><code class="language-kotlin">val values = ContentValues().apply {
    // The new title for the event
    put(CalendarContract.Events.TITLE, "Kickboxing")
}
val updateUri: Uri = ContentUris.withAppendedId(CalendarContract.Events.CONTENT_URI, eventID)
//影响的行数
val rows: Int = contentResolver.update(updateUri, values, null, null)
</code></pre>
<p>而使用限定条件可以更加灵活</p>
<h2 id="删除日程"><a class="header" href="#删除日程">删除日程</a></h2>
<p>同样的，删除也可以使用追加ID方式，或者使用限定条件方式。</p>
<p>删除可分为两种：应用删除（逻辑删除）、同步适配器删除（物理删除）</p>
<p>应用删除将 deleted 列的值设置为 1，即逻辑删除。此标记告知同步适配器该行已删除，并且应将此删除传播至服务器。</p>
<p>同步适配器删除将会从数据库中移除事件及其所有关联数据。</p>
<p>以下为逻辑删：</p>
<pre><code class="language-kotlin">val deleteUri: Uri = ContentUris.withAppendedId(
    CalendarContract.Events.CONTENT_URI, 日程id
)
return contentResolver.delete(deleteUri, null, null)
</code></pre>
<p>物理删除则需通过URI构造同步适配器，参见上文。</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="di"><a class="header" href="#di">DI</a></h3>
<p>Android 知识体系 - part4 - 依赖注入</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/488677faa02244ddbe171a873d4ae62b~tplv-k3u1fbpfcp-watermark.image?" alt="Part 4.png" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hilt进阶--一文吃透hilt自定义与跨壁垒"><a class="header" href="#hilt进阶--一文吃透hilt自定义与跨壁垒">Hilt进阶--一文吃透Hilt自定义与跨壁垒</a></h1>
<h2 id="前言-11"><a class="header" href="#前言-11">前言</a></h2>
<p>本文隶属于我归纳整理的Android知识体系的第四部分，属于DI中Hilt的进阶内容</p>
<img width="360" alt="desc" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/488677faa02244ddbe171a873d4ae62b~tplv-k3u1fbpfcp-watermark.image?"/>
<p>如果您需要学习Hilt的基础内容，可以通过Android开发者官方提供的
<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzk0NDIwMTExNw==&amp;action=getalbum&amp;album_id=1797733109421948930&amp;token=1293285389&amp;lang=zh_CN#wechat_redirect">MAD Skills</a>
12-15篇 和 <a href="https://dagger.dev/hilt/">官方使用教程</a></p>
<p>文章按照以下内容展开：</p>
<img width="800" alt="desc" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b2331bffb3e04976bea27c41fc54e42b~tplv-k3u1fbpfcp-watermark.image?"/>
<p>文中涉及的代码和案例，均可以于 <a href="https://github.com/leobert-lan/HiltWorkshop">workshop</a> 中获得。</p>
<blockquote>
<p><strong>非常重要</strong>：经过反复思考，我删除了原先编写的关于Hilt工作原理和生成代码的部分。或许加上这部分，会让部分读者获得更深刻地理解，<strong>但我担心会让更多的读者陷入困境</strong> 而不敢使用。</p>
<p>正如同Google要创建Hilt一样，他们希望开发者以更简单的方式接入Dagger2，本篇文章也希望读者朋友能够先掌握如何使用，并结合场景选用最佳实践方案。在此基础上再行理解背后的设计原理。</p>
</blockquote>
<h2 id="跨越-ioc容器的壁垒"><a class="header" href="#跨越-ioc容器的壁垒">跨越 IOC容器的壁垒</a></h2>
<p>使用依赖注入（DI）时，我们需要它对 <code>实例</code> 、<code>依赖关系</code> 、 <code>生命周期</code> 进行管理，因此DI框架会构建一个容器，用于实现这些功能。这个容器我们惯称为IOC容器。</p>
<p>在容器中，会按照我们制定的规则：</p>
<ul>
<li>创建实例</li>
<li>访问实例</li>
<li>注入依赖</li>
<li>管理生命周期</li>
</ul>
<p>但容器外也有访问容器内部的需求，显然这里存在一道虚拟的 <code>边界、壁垒</code>。这种需求分为两类：</p>
<ul>
<li>依赖注入客观需要的入口</li>
<li>系统中存在合理出现的、非DI框架管理的实例，但它不希望破坏其他实例对象的 <code>生命周期</code> 、<code>作用域唯一性</code>，即它的依赖希望交由DI框架管理</li>
</ul>
<p><strong>但请注意</strong>，IOC容器内部也存在着 <code>边界、壁垒</code>，这和它管理实例的机制有关，在Hilt（包括Dagger）中，最大颗粒度的内部壁垒是 <code>Component</code>。</p>
<p><strong>即便从外部突破IOC容器的壁垒，也只能进入某个特定的Component</strong></p>
<h3 id="使用entrypoint跨越ioc容器壁垒"><a class="header" href="#使用entrypoint跨越ioc容器壁垒">使用EntryPoint跨越IOC容器壁垒</a></h3>
<p>在Hilt中，我们可以很方便地</p>
<ul>
<li>使用接口定义 进入点（EntryPoint），并使用 <code>@EntryPoint</code> 注解使其生效；</li>
<li>用 <code>@InstallIn</code> 注解指明访问的Component；</li>
<li>并利用 <code>EntryPoints</code> 完成访问，突破容器壁垒</li>
</ul>
<p>下面的代码展示了如何定义：</p>
<p><em>UserComponent是自定义的Component，在下文中会详细展开</em></p>
<pre><code class="language-kotlin">@EntryPoint
@InstallIn(UserComponent::class)
interface UserEntryPoint {
    fun provideUserVO(): UserVO
}
</code></pre>
<p>下面的代码展示了如何获取进入点，注意，您需要先获得对应的Component实例。</p>
<p><em>对于Hilt内建的Component，均有其获取方法，而自定义的Component，需从外界发起生命周期控制，同样会预留实例访问路径</em></p>
<pre><code class="language-kotlin">fun manualGet(): UserEntryPoint {
    return EntryPoints.get(
        UserComponentManager.instance.generatedComponent(),
        UserEntryPoint::class.java
    )
}
</code></pre>
<p>当获取进入点后，即可使用预定义的API，访问容器内的对象实例。</p>
<h2 id="自定义scopecomponent"><a class="header" href="#自定义scopecomponent">自定义Scope、Component</a></h2>
<p>部分业务场景中，Hilt内建的Scope和Component并不能完美支持，此时我们需要进行自定义。</p>
<p><em>为了下文能够更顺利的展开，我们再花一定的笔墨对 <code>Scope</code>、<code>Component</code>、<code>Module</code> 的含义进行澄清。</em></p>
<h3 id="scopecomponentmodule的真实含义"><a class="header" href="#scopecomponentmodule的真实含义">Scope、Component、Module的真实含义</a></h3>
<p>前文提到两点:</p>
<ul>
<li>DI框架需要 <code>创建实例</code>、<code>访问实例</code>、<code>注入依赖</code>、<code>管理生命周期</code></li>
<li>IOC容器内部也存在着 <code>边界、壁垒</code>，这和它管理实例的机制有关，在Hilt（包括Dagger）中，最大颗粒度的内部壁垒是 <code>Component</code>。</li>
</ul>
<p>不难理解：</p>
<ul>
<li>实例之间，也会存在依赖关系；</li>
<li>DI框架需要管理内部实例的生命周期；</li>
<li>需要进行依赖注入的客户，本身也存在生命周期，<strong>它的依赖对象，应该结合实际需求被合理控制生命周期，避免生命周期泄漏</strong>；</li>
</ul>
<p>因此，出现了 <code>范围、作用域</code> 即 <code>Scope</code> 的概念，它包含两个维度：实例的生命周期范围；实例之间的访问界限。</p>
<p>并且DI框架通过Component控制内部对象的生命周期。</p>
<p>举一个例子描述，以Activity为例，Activity需要进行依赖注入，并且我们不希望Activity自身需要的依赖出现生命周期泄漏，于是按照Activity的生命周期特点定义了：</p>
<ul>
<li><code>ActivityRetainedScoped</code> <code>ActivityRetainedComponent</code>，不受reCreate 影响</li>
<li><code>ActivityScoped</code>、 <code>ActivityComponent</code>，横竖屏切换等配置变化引起reCreate 开始新生命周期</li>
</ul>
<p>并据此对 <code>依赖对象实例</code> 实施 <code>生命周期</code> 和 <code>访问范围</code> 控制</p>
<p>可以记住以下三点结论：</p>
<ul>
<li>Activity实例按照 <code>预定Scope对应的生命周期范围</code> 创建、管理Component，访问Component中的实例；</li>
<li>Component内的实例可以互相访问，实例的生命周期和Component一致；</li>
<li>Activity实例（需要依赖注入的客户）和 Component中的实例 可以访问 <code>父Component</code>中的实例，<em>父Component的生命周期完全包含子Component的生命周期</em></li>
</ul>
<p>内建的Scope、Component关系参考：</p>
<img style="background-color:white" width="400" alt="desc" src="https://dagger.dev/hilt/component-hierarchy.svg"/>
<p><strong>而Module指导DI框架 <code>创建实例</code>、<code>选用实例进行注入</code></strong></p>
<p>值得注意的是，Hilt（以及Dagger）可以通过 <code>@Inject</code> 注解类构造函数指导 <code>创建实例</code>，此方式创建的实例的生命周期跟随宿主，与 <code>通过Module方式</code> 进行对比，存在生命周期管理粒度上的差异。</p>
<h3 id="自定义"><a class="header" href="#自定义">自定义</a></h3>
<p>至此，已不难理解：因为有实际的生命周期范围管理需求，才会自定义。</p>
<p>为了方便行文以及编写演示代码，我们举一个常见的例子：用户登录的生命周期。</p>
<blockquote>
<p>一般的APP在设计中，用户登录后会持久化TOKEN，下次APP启动后验证TOKEN真实性和时效性，通过验证后用户仍保持登录状态，直到TOKEN超时、登出。当APP退出时，可以等效认为用户登录生命周期结束。</p>
</blockquote>
<p>显然，用户登录的生命周期完全涵盖在APP生命周期（Singleton Scope）中，但略小于APP生命周期；和Activity生命周期无明显关联。</p>
<h4 id="定义scope"><a class="header" href="#定义scope">定义Scope</a></h4>
<pre><code class="language-kotlin">import javax.inject.Scope

@Scope
annotation class UserScope
</code></pre>
<p>就是这么简单。</p>
<h4 id="定义component"><a class="header" href="#定义component">定义Component</a></h4>
<p>定义Component时，需要指明父Component和对应的Scope：</p>
<pre><code class="language-kotlin">import dagger.hilt.DefineComponent

@DefineComponent(parent = SingletonComponent::class)
@UserScope
interface UserComponent {
}
</code></pre>
<p>Hilt需要以Builder构建Component，不仅如此，一般构建Component时存在初始信息，例如：ActivityComponent需要提供Activity实例。</p>
<p>通常设计中，用户Component存在 <code>用户基本信息、TOKEN</code> 等初始信息</p>
<pre><code class="language-kotlin">data class User(val name: String, val token: String) {
}
</code></pre>
<p>此时，我们可以在Builder中完成初始信息的注入：</p>
<pre><code class="language-kotlin">import dagger.BindsInstance
import dagger.hilt.DefineComponent

@DefineComponent.Builder
interface Builder {
    fun feedUser(@BindsInstance user: User?): Builder

    fun build(): UserComponent
}
</code></pre>
<p>我们以 <code>@BindsInstance</code> 注解标识需要注入的初始信息，<em>注意合理控制其可空性，在后续的使用中，可空性需保持一致</em></p>
<p><em>注意：方法名并不重要，采用习惯性命名即可，我习惯于将向容器喂入参数的API添加feed前缀</em></p>
<p>当我们通过Hilt获得Builder实例时，即可控制Component的创建（即生命周期开始）</p>
<h4 id="使用manager管理component"><a class="header" href="#使用manager管理component">使用Manager管理Component</a></h4>
<p>不难想象，Component的管理基本为模板代码，Hilt中提供了模板和接口类：</p>
<p><em>如果您想避免模板代码编写，可以定义扩展模块，使用APT、KCP、KSP生成</em></p>
<p>此处展示非线程安全的简单使用Demo</p>
<pre><code class="language-kotlin">@Singleton
class UserComponentManager @Inject constructor(
    private val builder: UserComponent.Builder
) : GeneratedComponentManager&lt;UserComponent&gt; {

    companion object {
        lateinit var instance: UserComponentManager
    }

    private var userComponent = builder
        .feedUser(null)
        .build()

    fun onLogin(user: User) {
        userComponent = builder.feedUser(user).build()
    }

    fun onLogout() {
        userComponent = builder.feedUser(null).build()
    }

    override fun generatedComponent(): UserComponent {
        return userComponent
    }

}
</code></pre>
<p>您也可以定义如下的线程安全的Manager，并使用 <code>ComponentSupplier</code> 提供实例</p>
<pre><code class="language-kotlin">class CustomComponentManager(
    private val componentCreator: ComponentSupplier
) : GeneratedComponentManager&lt;Any&gt; {

    @Volatile
    private var component: Any? = null

    private val componentLock = Any()

    override fun generatedComponent(): Any {
        if (component == null) {
            synchronized(componentLock) {
                if (component == null) {
                    component = componentCreator.get()
                }
            }
        }

        return component!!
    }
}
</code></pre>
<p>您可以根据实际需求选择最适宜的方法进行管理，不再赘述。</p>
<h4 id="在生命周期范围更小的component中使用"><a class="header" href="#在生命周期范围更小的component中使用">在生命周期范围更小的Component中使用</a></h4>
<p>至此，我们已经完成了自定义Scope、Component的主要工作，通过Manager即可控制生命周期。</p>
<p>如果想在生命周期范围更小的Component中访问 UserComponent中的对象实例，您需要谨记前文提到的三条结论。</p>
<p><em>该需求很合理，但下面的例子并不足够典型</em></p>
<p>此时，您需要通过一个合理的Component实现访问，例如在Activity中需要注入相关实例时。
因为 <code>ActivityRetainedComponent</code> 和 <code>UserComponent</code> 不存在父子关系，Scope没有交集，所以 <strong>需要找到共同的父Component进行帮助，并通过EntryPoint突破壁垒</strong> ：</p>
<p>前文中，我们将 <code>UserComponentManager</code> 划入 <code>SingletonComponent</code>, 他是两种的共同父Component，此时可以这样处理：</p>
<pre><code class="language-kotlin">@Module
@InstallIn(ActivityRetainedComponent::class)
object AppModule {

    @Provides
    fun provideUserVO(manager: UserComponentManager):UserVO {
        return UserEntryPoint.manualGet(manager.generatedComponent()).provideUserVO()
    }
}
</code></pre>
<h2 id="解决独立library的依赖初始化问题"><a class="header" href="#解决独立library的依赖初始化问题">解决独立library的依赖初始化问题</a></h2>
<p>此问题属于常见案例，通过研究它的解决方案，我们可以更深刻地理解前文内容，做到吃透。</p>
<p>当处理主工程时，没有代码隔离，我们可以很轻易的修改Application的代码，因此很多问题难以暴露。</p>
<blockquote>
<p>例如，我们可以在Application中通过注解标明依赖 <em>（满足Singleton Scope前提）</em> ，DI框架会帮助我们进行注入，在注入后可以编写逻辑代码，将对象赋值给全局变量，便可以 "方便" 的使用。</p>
<p><em>为方便下文表述，我们称之 "方案1"</em></p>
</blockquote>
<p><strong>显然，这是有异味的代码，虽然它有效且方便。</strong></p>
<blockquote>
<p>因此，我们选取一些场景来说明该做法的弊端：</p>
<ul>
<li>场景1：创建独立Library，其中使用Hilt作为DI框架，Library中存在自定义Component，需要初始化管理入口</li>
<li>场景2：项目采用了组件化，该Library按照渠道包需求，渠道包A集成、渠道包B不集成</li>
<li>场景3：项目采用了Uni-App、React-Native等技术，该Library中存在实例由反射方式创建、不受Hilt管理，无法借助Hilt自动注入依赖</li>
</ul>
<p>以上场景并不相互孤立</p>
</blockquote>
<p>在场景1中，我们仍然可以通过 <code>方案1</code> 完成需求，但在场景2中便不再可行。</p>
<p>常规的组件化、插件化，都会完成代码隔离&amp;使用抽象，因此无法在主工程的Application中使用目标类。通过定制字节码工具曲线救国，则属实是大炮打蚊子、屎盆子镶金边</p>
<h3 id="使用hilt的聚合能力解决问题"><a class="header" href="#使用hilt的聚合能力解决问题">使用hilt的聚合能力解决问题</a></h3>
<p>在 MAD Skills 系列文章的最后一篇中，简单提及了Hilt的聚合能力，它至少包含以下两个层面：</p>
<ul>
<li>即便一个已经编译为aar的库，在被集成后，Hilt依旧能够扫描该库中Hilt相关的内容，进行依赖图聚合</li>
<li>Hilt生成的代码，依旧存在着注解，这些注解可以被注解处理器、字节码工具识别、并进一步处理。可以是Hilt内建的处理器或您自定义的扩展处理器</li>
</ul>
<p>依据第一个层面，我们可以制定一个约定：</p>
<blockquote>
<p>子Library按照抽象接口提供Library初始化实例，主工程的Application通过DI框架获取后进行初始化</p>
<p><em>我们将其称为方案2</em></p>
</blockquote>
<p>例如，在Library中定义如下初始化类：</p>
<pre><code class="language-kotlin">class LibInitializer @Inject constructor(
    private val userComponentManager: UserComponentManager
) : Function1&lt;Application, Any&gt; {

    override fun invoke(app: Application): Any {
        UserComponentManager.instance = userComponentManager
        return Unit
    }
}
</code></pre>
<p>不难发现，他是方案1的变种，将依赖获取从Application中挪到了LibInitializer中</p>
<p>并约定绑定实例&amp;集合注入， <em>依旧在Library中编码</em> ：</p>
<pre><code class="language-kotlin">@InstallIn(SingletonComponent::class)
@Module
abstract class AppModuleBinds {
    @Binds
    @IntoSet
    abstract fun provideLibInitializer(bind: LibInitializer): Function1&lt;Application, Any&gt;
}
</code></pre>
<p>在主工程的Application中：</p>
<pre><code class="language-kotlin">@HiltAndroidApp
class App : Application() {
    @Inject
    lateinit var initializers: Set&lt;@JvmSuppressWildcards Function1&lt;Application, Any&gt;&gt;

    override fun onCreate() {
        super.onCreate()
        initializers.forEach {
            it(this)
        }
    }
}
</code></pre>
<p>如此即可满足场景1、场景2的需求。</p>
<p>但仔细思考一下，这种做法太 <strong>"强硬"</strong> 了，不仅要求主工程的Application进行配合，而且需要小心的处理初始化代码的分配。</p>
<p>在场景3中，这些技术均有相适应的插件初始化入口；组件化插件化项目中，也具有类似的设计。随集成方式的不同，很可能造成 <strong>初始化逻辑遗漏或者重复</strong> 。</p>
<p>注意：重复初始化可能造成潜在的Scope泄漏，滋生bug。</p>
<h3 id="聚合能力entrypoint"><a class="header" href="#聚合能力entrypoint">聚合能力+EntryPoint</a></h3>
<p>前文中，我们已经讨论了使用EntryPoint突破IOC容器的壁垒，也体验了Hilt的聚合能力。而 <code>SingletonComponent</code> 作为内建Component，同样可以使用EntryPoint突破容器壁垒。</p>
<p>如果您对Hilt的源码或其设计有一定程度的了解，应当清楚：</p>
<blockquote>
<p>内建Component均有对应的ComponentHolder，而SingletonComponent对应的Holder即为Application。</p>
</blockquote>
<p>通过 Holder实例和 <code>EntryPointAccessors</code> 可以获得定义的 <code>EntryPoint接口</code></p>
<p>为 <code>SingletonComponent</code> 自定义EntryPoint后，即可摆脱Hilt自定注入的传递链而通过逻辑编码获取实例。</p>
<pre><code class="language-kotlin">@EntryPoint
@InstallIn(SingletonComponent::class)
interface UserComponentEntryPoint {
    companion object {
        fun manualGet(context: Context): UserComponentEntryPoint {
            return EntryPointAccessors.fromApplication(
                context, UserComponentEntryPoint::class.java
            )
        }
    }

    fun provideBuilder(): UserComponent.Builder

    fun provideManager():UserComponentManager
}
</code></pre>
<p>通过这一方式，我们只需要获得Context即可突破壁垒访问容器内部实例，Hilt不再约束Library的初始化方式。</p>
<p>至此，您可以在原先的Library初始化模块中，按需自由的添加逻辑！</p>
<p><em>注意：Builder由Hilt生成实现，无法干预其生命周期，故每次调用时生成新的实例，从一般的编码需求，获取Manager实例即可。您可以在WorkShop项目中获得验证</em></p>
<h3 id="问题衍生"><a class="header" href="#问题衍生">问题衍生</a></h3>
<p>在场景3中，我们继续进行衍生：</p>
<blockquote>
<p>Library作为动态插件，并不直接集成，而是通过插件化技术，动态集成启用功能。又该如何处理呢？</p>
</blockquote>
<p>在MAD Skills系列文章的第四篇中，简单提及了Hilt的扩展能力。考虑到篇幅以及AAB（Dynamic Feature）、插件化的背景，我们将在下一篇文章中对该问题展开解决方案的讨论。</p>
<h2 id="末"><a class="header" href="#末">末</a></h2>
<p>先做到正确使用，再逐步理解原理。我会在后续系列文章中，同读者酣畅淋漓的讨论Hilt的工作原理和实现原理。</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="jetpack-compose"><a class="header" href="#jetpack-compose">Jetpack Compose</a></h3>
<p>本系列将开始 <code>Jetpack Compose</code> 的学习之旅。</p>
<blockquote>
<p><em>如无特殊说明，代码均基于 1.0.1版本</em></p>
<p><em>如无特殊说明，文中的 <code>Compose</code> 均指代 <code>Jetpack compose</code></em></p>
<p>文中代码均可在 <a href="https://github.com/leobert-lan/ComposeWorkShop">WorkShop</a> 中获取</p>
</blockquote>
<p>第一阶段：学习控件的特性、并掌握使用</p>
<ul>
<li><a href="Compose/./post_21.html">Jetpack Compose | 一文理解神奇的Modifier</a></li>
<li><a href="Compose/./post_26.html">Jetpack Compose | 控件篇（一） -- Text、TextField、Button</a></li>
<li><a href="Compose/./post_27.html">Jetpack Compose | 控件篇（二） -- Icon，Image</a></li>
<li><a href="Compose/./post_28.html">Jetpack Compose | 控件篇（三） -- Switch、CheckBox、RadioButton</a></li>
<li><a href="Compose/./post_29.html">Jetpack Compose | 控件篇（四）-- Box、Row、Column</a></li>
<li><a href="Compose/./post_30.html">Jetpack Compose | 控件篇（五）-- Spacer、LazyRow、LazyColumn &amp; 让Column可滑动</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jetpack-compose--一文理解神奇的modifier"><a class="header" href="#jetpack-compose--一文理解神奇的modifier">Jetpack Compose | 一文理解神奇的Modifier</a></h1>
<h2 id="写在最前-1"><a class="header" href="#写在最前-1">写在最前</a></h2>
<p>Jetpack Compose的预览版出来已经有很长时间了，相信很多读者都进行了一番尝试。<em>注意：下文如无特殊说明，Compose均指代Jetpack Compose</em></p>
<p>可以说，Compose在声明布局时，其风格和React的JSX、Flutter 等非常的相似。</p>
<p>而且有一个高频出现的内容： <code>Modifier</code>，即 <code>修饰器</code>，顾名思义，它是对某些内容进行修饰的， 在Compose的设计中，和UI相关的内容都涉及到它，例如：<code>尺寸</code>，<code>形状</code> 等</p>
<p>这一篇文章，我们一起学习两部分内容：</p>
<ul>
<li>Modifier的源码和设计</li>
<li>SDK中既有的Modifier实现概览</li>
</ul>
<p>当然，最全面的学习文档当属：<a href="https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/Modifier">官方API文档</a> ，
<em>后续查询API的含义和设计细节等都会用到，建议收藏</em></p>
<p><em>文中的代码均基于 1.0.1 版本</em></p>
<h2 id="先放大招modifier的45行代码"><a class="header" href="#先放大招modifier的45行代码">先放大招，Modifier的45行代码</a></h2>
<p>其实有效代码行大约20行。</p>
<p>先举个使用示例：</p>
<pre><code class="language-kotlin">Modifier.height(320.dp).fillMaxWidth()
</code></pre>
<p>这里的 <code>Modifier</code> 是接口 <code>androidx.compose.ui.Modifier</code> 的匿名实现，这也是一个很有意思的实用技巧。</p>
<p>我们先简单的概览下源码，再进行解读：</p>
<pre><code class="language-kotlin">interface Modifier {
    // ...
    companion object : Modifier {
        override fun &lt;R&gt; foldIn(initial: R, operation: (R, Element) -&gt; R): R = initial
        override fun &lt;R&gt; foldOut(initial: R, operation: (Element, R) -&gt; R): R = initial
        override fun any(predicate: (Element) -&gt; Boolean): Boolean = false
        override fun all(predicate: (Element) -&gt; Boolean): Boolean = true
        override infix fun then(other: Modifier): Modifier = other
        override fun toString() = "Modifier"
    }
}
</code></pre>
<p>而本身的接口则为：</p>
<pre><code class="language-kotlin">package androidx.compose.ui

import androidx.compose.runtime.Stable

interface Modifier {

    fun &lt;R&gt; foldIn(initial: R, operation: (R, Element) -&gt; R): R

    fun &lt;R&gt; foldOut(initial: R, operation: (Element, R) -&gt; R): R

    fun any(predicate: (Element) -&gt; Boolean): Boolean

    fun all(predicate: (Element) -&gt; Boolean): Boolean

    infix fun then(other: Modifier): Modifier =
        if (other === Modifier) this else CombinedModifier(this, other)
}
</code></pre>
<h3 id="modifier接口默认实现赏析"><a class="header" href="#modifier接口默认实现赏析">Modifier接口默认实现赏析</a></h3>
<p>先看Modifier接口，和Java8类似，Kotlin的接口可以提供默认实现，
显然， <code>foldIn</code> 和 <code>foldOut</code> 在这里是看不出门道的，<code>具体做什么</code> 需结合 operation来看，<code>如何做</code> 则需看其实现，先略过。</p>
<p><code>any</code> 和 <code>all</code> 也是看不出啥的，<em>毕竟我把注释删了</em>。</p>
<p>而 <code>then</code> 方法则有点意思，接收一个 <code>Modifier</code> 接口实例，
如果该实例是Modifier的内部默认实现，则认为是无效操作，依旧返回自身，否则则返回一个 <code>CombinedModifier实例</code> 将自身和 <code>other</code> 结合在一起。</p>
<p><strong>从这里，我们可以读出一点 <code>味道</code> ： 设计者一定会将一系列的Modifier设计成一个类似链表的结构，并且希望我们从Modifier的 companion实现开始进行构建链表。</strong></p>
<p><em>如果结合注释，我们可以获知：Modifier会通过 <code>then</code> 组成一个链表，并且 <code>any</code> 和 <code>all</code> 是对链表的元素运行判断表达式，<code>foldIn</code>，<code>foldOut</code> 则会对链表的元素执行operation。</em></p>
<h3 id="modifier-companion实现赏析"><a class="header" href="#modifier-companion实现赏析">Modifier companion实现赏析</a></h3>
<p>再回过头来看 <code>companion实现</code>。<code>then</code>、<code>foldIn</code>，<code>foldOut</code> 都是给啥返回啥，
再结合先前的接口默认实现，我们可以推断： <strong>正常使用的话，最终的链表中不包含 companion实现</strong> ，这从它的 <code>any</code> 和 <code>all</code> 的实现也可见一斑。</p>
<p><em>很显然这是一个有意思的技巧，这里不做过多解析，但既然我这样描述，一定可以让它进入链表中的</em>。</p>
<h3 id="combinedmodifier-实现"><a class="header" href="#combinedmodifier-实现">CombinedModifier 实现</a></h3>
<pre><code class="language-kotlin">package androidx.compose.ui

import androidx.compose.runtime.Stable

class CombinedModifier(
    private val outer: Modifier,
    private val inner: Modifier
) : Modifier {
    override fun &lt;R&gt; foldIn(initial: R, operation: (R, Modifier.Element) -&gt; R): R =
        inner.foldIn(outer.foldIn(initial, operation), operation)

    override fun &lt;R&gt; foldOut(initial: R, operation: (Modifier.Element, R) -&gt; R): R =
        outer.foldOut(inner.foldOut(initial, operation), operation)

    override fun any(predicate: (Modifier.Element) -&gt; Boolean): Boolean =
        outer.any(predicate) || inner.any(predicate)

    override fun all(predicate: (Modifier.Element) -&gt; Boolean): Boolean =
        outer.all(predicate) &amp;&amp; inner.all(predicate)

    override fun equals(other: Any?): Boolean =
        other is CombinedModifier &amp;&amp; outer == other.outer &amp;&amp; inner == other.inner

    override fun hashCode(): Int = outer.hashCode() + 31 * inner.hashCode()

    override fun toString() = "[" + foldIn("") { acc, element -&gt;
        if (acc.isEmpty()) element.toString() else "$acc, $element"
    } + "]"
}

</code></pre>
<p>目前可以读出 <code>foldIn</code> 和 <code>foldOut</code> 的执行的次序，另外可以看出 <code>any</code> 和 <code>all</code> 没啥幺蛾子。</p>
<p>看完 Modifier.Element 之后我们赏析下 foldIn 和 foldOut的递归</p>
<h3 id="modifierelement"><a class="header" href="#modifierelement">Modifier.Element</a></h3>
<p>不出意外，SDK内部的各种修饰效果都将实现这一接口，同样没啥幺蛾子。</p>
<pre><code class="language-kotlin">package androidx.compose.ui

interface Modifier {
    //...

    interface Element : Modifier {
        override fun &lt;R&gt; foldIn(initial: R, operation: (R, Element) -&gt; R): R =
            operation(initial, this)

        override fun &lt;R&gt; foldOut(initial: R, operation: (Element, R) -&gt; R): R =
            operation(this, initial)

        override fun any(predicate: (Element) -&gt; Boolean): Boolean = predicate(this)

        override fun all(predicate: (Element) -&gt; Boolean): Boolean = predicate(this)
    }
}

</code></pre>
<h2 id="foldin-和-foldout-赏析"><a class="header" href="#foldin-和-foldout-赏析">foldIn 和 foldOut 赏析</a></h2>
<p>这里举一个栗子来看 foldIn 和 foldOut 的递归：</p>
<pre><code class="language-kotlin">class A : Modifier.Element
class B : Modifier.Element
class C : Modifier.Element

fun Modifier.a() = this.then(A())
fun Modifier.b() = this.then(B())
fun Modifier.c() = this.then(C())
</code></pre>
<p>那么 <code>Modifier.a().b().c()</code> 的到的是什么呢？为了看起来直观点，我们 <code>以 CM 代指 CombinedModifier</code></p>
<pre><code class="language-kotlin">CM (
    outer = CM (
        outer = A(),
        inner = B()
    ),
    inner = C()
)
</code></pre>
<p>结合前面阅读源码获得的知识，我们再假设一个operation：</p>
<pre><code class="language-kotlin">val initial = StringBuilder()
val operation: (StringBuilder, Element) -&gt; StringBuilder = { builder, e -&gt;
    builder.append(e.toString()).append(";")
    builder
} 

</code></pre>
<p>显然：</p>
<pre><code class="language-kotlin">Modifier.a().b().c().foldIn(initial, operation)
</code></pre>
<p>所得到的执行过程为：</p>
<pre><code class="language-kotlin">val ra = operation.invoke(initial,A())
val rb = operation.invoke(ra,B())
return operation.invoke(rb,C())
</code></pre>
<p>从链表的头部执行到链表的尾部。</p>
<p>而foldOut 则相反，从链表的尾部执行到链表的头部。</p>
<p><em>当然，真正使用时，我们不一定会一直返回 initial</em>。 但这和Modifier没啥关系，只影响到对哪个对象使用Modifier。</p>
<blockquote>
<p>注意：Modifier 会构成一个链表，那么就有次序之说，次序不一致，最终得到的结果会有所不同，这一点需要牢记。</p>
</blockquote>
<h2 id="sdk中既有的modifier实现概览"><a class="header" href="#sdk中既有的modifier实现概览">SDK中既有的Modifier实现概览</a></h2>
<p>上文中，我们在 <code>Modifier的源码和设计细节</code> 上花费了很长的篇幅，相信各位读者也已经彻底理解，下面我们看点轻松的。</p>
<p>很显然，下面这部分内容 <code>混个脸熟</code> 即可，就像在Android中的原生布局，一时间遗忘了布局属性的具体拼写也无伤大雅，借助SDK文档可以很快的查询到，
但是 <strong>不知道有这些属性</strong> 就会影响到开发了。</p>
<h3 id="三个重要的包"><a class="header" href="#三个重要的包">三个重要的包</a></h3>
<ul>
<li>androidx.compose.foundation.layout： Modifier和布局相关的扩展</li>
<li>androidx.compose.ui.draw： Modifier和绘制相关的扩展</li>
<li>androidx.compose.foundation：Modifier的基础包，其中扩展部分主要为点击事件、背景、滑动等</li>
</ul>
<p>API文档的内容是很枯燥的，如果读者仅仅是打算先混个脸熟，可以<strong>泛读下文内容</strong>，如果已经准备开始结合API文档进行编码实践，可以Fork
<a href="https://github.com/leobert-lan/ComposeWorkShop">我的WorkShop项目</a> ，将源码和效果对照起来</p>
<h3 id="foundation-layout库----androidxcomposefoundationlayout"><a class="header" href="#foundation-layout库----androidxcomposefoundationlayout">foundation-layout库 -- androidx.compose.foundation.layout</a></h3>
<p>具体的API列表和描述见 <a href="https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/layout/package-summary">Api文档</a></p>
<p>这个包中，和布局相关，诸如：尺寸、边距、盒模型等，很显然，其中的内容非常的多。关于Modifier的内容，我们不罗列API。</p>
<blockquote>
<p>正如同 DSL 的设计初衷，对于Compose而言，了解Android原生开发的同学，或者对前端领域有一丁点了解的同学，70%的DSL-API可以一眼看出其含义，
并推断出效果，而剩下来的部分，多半需要实际测试下效果。</p>
</blockquote>
<h3 id="ui库----androidxcomposeuidraw"><a class="header" href="#ui库----androidxcomposeuidraw">ui库 -- androidx.compose.ui.draw</a></h3>
<p>这部分大多和绘制相关，所幸这部分API不太多，我们花费一屏来罗列下，混个脸熟。</p>
<p>具体的API列表和描述见 <a href="https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/draw/package-summary">Api文档</a></p>
<ul>
<li>透明度</li>
</ul>
<blockquote>
<p>Modifier.alpha(alpha: Float)</p>
</blockquote>
<ul>
<li>按形状裁切</li>
</ul>
<blockquote>
<p>Modifier.clip(shape: Shape)</p>
</blockquote>
<ul>
<li>按照指定的边界裁切内容, 类似Android中的子View内容不超过父View</li>
</ul>
<blockquote>
<p>Modifier.clipToBounds()</p>
<p>Clip the content to the bounds of a layer defined at this modifier.</p>
</blockquote>
<ul>
<li>在此之后进行一次指定的绘制</li>
</ul>
<blockquote>
<p>Modifier.drawBehind(onDraw: DrawScope.() -&gt; Unit)</p>
<p>Draw into a Canvas behind the modified content.</p>
</blockquote>
<ul>
<li>基于缓存绘制, 用于尺寸未发生变化，状态未发生变化时</li>
</ul>
<blockquote>
<p>Modifier.drawWithCache(onBuildDrawCache: CacheDrawScope.() -&gt; DrawResult)</p>
</blockquote>
<ul>
<li>人为控制在布局之前或者之后进行指定的绘制</li>
</ul>
<blockquote>
<p>Modifier.drawWithContent(onDraw: ContentDrawScope.() -&gt; Unit)</p>
</blockquote>
<ul>
<li>利用Painter 进行绘制</li>
</ul>
<blockquote>
<p>Modifier.paint(painter: Painter, sizeToIntrinsics: Boolean, alignment: Alignment, contentScale: ContentScale, alpha: Float, colorFilter: ColorFilter?)</p>
</blockquote>
<ul>
<li>围绕中心进行旋转</li>
</ul>
<blockquote>
<p>Modifier.rotate(degrees: Float)</p>
</blockquote>
<ul>
<li>缩放</li>
</ul>
<blockquote>
<p>Modifier.scale(scaleX: Float, scaleY: Float)</p>
</blockquote>
<ul>
<li>等比缩放</li>
</ul>
<blockquote>
<p>Modifier.scale(scale: Float)</p>
</blockquote>
<ul>
<li>绘制阴影</li>
</ul>
<blockquote>
<p>Modifier.shadow(elevation: Dp, shape: Shape, clip: Boolean)</p>
</blockquote>
<h3 id="foundation库----androidxcomposefoundation"><a class="header" href="#foundation库----androidxcomposefoundation">foundation库 -- androidx.compose.foundation</a></h3>
<p>所幸这部分也不太多，罗列下</p>
<ul>
<li>设置背景</li>
</ul>
<blockquote>
<p>Modifier.background(color: Color, shape: Shape = RectangleShape)</p>
<p>Modifier.background(brush: Brush, shape: Shape = RectangleShape, alpha: Float = 1.0f)</p>
<p>Brush 是渐变的，Color是纯色的</p>
</blockquote>
<ul>
<li>设置边界，即描边效果</li>
</ul>
<blockquote>
<p>Modifier.border(border: BorderStroke, shape: Shape = RectangleShape)</p>
<p>Modifier.border(width: Dp, color: Color, shape: Shape = RectangleShape)</p>
<p>Modifier.border(width: Dp, brush: Brush, shape: Shape)</p>
</blockquote>
<ul>
<li>点击效果</li>
</ul>
<blockquote>
<p>Modifier.clickable(enabled: Boolean = true, onClickLabel: String? = null, role: Role? = null, onLongClickLabel: String? = null, onLongClick: () -&gt; Unit = null, onDoubleClick: () -&gt; Unit = null, onClick: () -&gt; Unit)</p>
<p>Modifier.clickable(enabled: Boolean = true, interactionState: InteractionState, indication: Indication?, onClickLabel: String? = null, role: Role? = null, onLongClickLabel: String? = null, onLongClick: () -&gt; Unit = null, onDoubleClick: () -&gt; Unit = null, onClick: () -&gt; Unit)</p>
</blockquote>
<p>长按、单击、双击均包含在内</p>
<ul>
<li>可滑动</li>
</ul>
<blockquote>
<p>Modifier.horizontalScroll(state: ScrollState, enabled: Boolean = true, reverseScrolling: Boolean = false)</p>
<p>Modifier.verticalScroll(state: ScrollState, enabled: Boolean = true, reverseScrolling: Boolean = false)</p>
</blockquote>
<h2 id="结语-1"><a class="header" href="#结语-1">结语</a></h2>
<p>这一篇，我们学习了Modifier的源码，和Modifier的 <code>各种效果</code> 混了下脸熟。但是还有一个问题没有去探索：</p>
<blockquote>
<p>Modifier 到底是如何产生作用的？</p>
</blockquote>
<p>显然，要解答这个问题，需要探索 <code>Compose如何渲染视图</code> ，这件事情不适合在本篇就安排，会在后续的学习中展开。</p>
<p>对比Android原生技术栈，这是一个全新的内容，要真正的全面掌握还需要积累很多的知识，就如同最开始入门Android开发那样，<strong>各类控件的使用都需要学习和记忆</strong></p>
<p>但它也仅局限于：<code>一种新的声明式、响应式UI构建框架</code>，并不用过于畏惧，虽然有较高的上手成本，按部就班的学习积累就可以掌握使用方式。
它还没有颠覆整个Android客户端的开发方式，不用心急和焦虑。</p>
<p><em>另：WorkShop中的演示代码会跟随整个Compose系列的问题，我是兴致来了就更新一部分，这意味着可能会出现：有些效果在博客中提到了，但WorkShop中没有写进去</em></p>
<div style="break-before: page; page-break-before: always;"></div><p>#Jetpack Compose | 控件篇（一） -- Text、TextField、Button</p>
<p>这一篇，我们一起学习 Jetpack Compose 中的部分控件 -- <code>Text、TextField、Button</code>，掌握其使用方式和特性。</p>
<p><em>文中代码均基于 1.0.1版本</em></p>
<p><em>如无特殊说明，下文中的 <code>Compose</code> 均指代 <code>Jetpack compose</code></em></p>
<h2 id="小互动"><a class="header" href="#小互动">小互动</a></h2>
<p>上一篇文章：<a href="https://juejin.cn/post/6994359593375629326">Compose | 一文理解神奇的Modifier </a> 在郭婶的号上有读者评论到不知道Compose从何学起，
无从下手，这里简单的谈一谈我的看法：</p>
<ul>
<li>Compose 以及 Jetpack Compose 对于Android从业人员而言确实是一门 <code>全新的技术</code></li>
<li>目前才兴起，还没有达到一个辉煌的阶段</li>
</ul>
<p>在此背景下，开始学习研究Compose 都可以算的上 <code>先行者</code>，而且这门技术还做不到诸如："一年内全面替代老技术"、"不掌握就找不到工作" 这种程度。</p>
<p>那么按部就班的学习它就行了，没有时间上的紧迫感。而学习一样东西，有这样几个阶段：</p>
<ul>
<li>掌握如何使用</li>
<li>掌握实现细节，逐渐理解其本质</li>
<li>从其本质出发，利用对程序的理解，优化使用方式甚至优化这门技术</li>
</ul>
<p>显然，我们现在要做的就是：</p>
<ul>
<li>先结合官方资料以及源码，先掌握如何使用：<code>它解决哪些问题，怎么使用它解决问题</code></li>
<li>鉴于部分读者已经有一定的基础，对类似技术有了一定的理解，在此过程中就可以提前阅读该技术的实现细节，尝试理解其本质。或者再掌握了使用方式后再开始。</li>
<li>再之后的道路就很清晰了</li>
</ul>
<p>下面我们进入今天的正文。</p>
<h2 id="text"><a class="header" href="#text">Text</a></h2>
<p>在Android中，有 <code>TextView</code> 这一控件，用于展示文本，Compose中对应的是 <code>Text</code>。</p>
<p>先看源码：</p>
<pre><code class="language-kotlin">fun Text(
    text: String,
    modifier: Modifier = Modifier,
    color: Color = Color.Unspecified,
    fontSize: TextUnit = TextUnit.Unspecified,
    fontStyle: FontStyle? = null,
    fontWeight: FontWeight? = null,
    fontFamily: FontFamily? = null,
    letterSpacing: TextUnit = TextUnit.Unspecified,
    textDecoration: TextDecoration? = null,
    textAlign: TextAlign? = null,
    lineHeight: TextUnit = TextUnit.Unspecified,
    overflow: TextOverflow = TextOverflow.Clip,
    softWrap: Boolean = true,
    maxLines: Int = Int.MAX_VALUE,
    onTextLayout: (TextLayoutResult) -&gt; Unit = {},
    style: TextStyle = LocalTextStyle.current
)
</code></pre>
<pre><code class="language-kotlin">fun Text(
    text: AnnotatedString,
    modifier: Modifier = Modifier,
    color: Color = Color.Unspecified,
    fontSize: TextUnit = TextUnit.Unspecified,
    fontStyle: FontStyle? = null,
    fontWeight: FontWeight? = null,
    fontFamily: FontFamily? = null,
    letterSpacing: TextUnit = TextUnit.Unspecified,
    textDecoration: TextDecoration? = null,
    textAlign: TextAlign? = null,
    lineHeight: TextUnit = TextUnit.Unspecified,
    overflow: TextOverflow = TextOverflow.Clip,
    softWrap: Boolean = true,
    maxLines: Int = Int.MAX_VALUE,
    inlineContent: Map&lt;String, InlineTextContent&gt; = mapOf(),
    onTextLayout: (TextLayoutResult) -&gt; Unit = {},
    style: TextStyle = LocalTextStyle.current
)
</code></pre>
<p>这两个方法原型的唯一差别就是形参 <code>text</code> 的类型，AnnotatedString 类似于Android中的 SpannableString, 可以标记各类效果。</p>
<p><strong>其实阅读源码后可以发现，Text 基于 BasicText 实现，应用了样式</strong>。</p>
<pre><code class="language-kotlin">val textColor = color.takeOrElse {
    style.color.takeOrElse {
        LocalContentColor.current.copy(alpha = LocalContentAlpha.current)
    }
}
val mergedStyle = style.merge(
    TextStyle(
        color = textColor,
        fontSize = fontSize,
        fontWeight = fontWeight,
        textAlign = textAlign,
        lineHeight = lineHeight,
        fontFamily = fontFamily,
        textDecoration = textDecoration,
        fontStyle = fontStyle,
        letterSpacing = letterSpacing
    )
)
BasicText(
    text,
    modifier,
    mergedStyle,
    onTextLayout,
    overflow,
    softWrap,
    maxLines,
    inlineContent
)
</code></pre>
<p>参数含义：（翻译自API文档）</p>
<ul>
<li>text - 要显示的内容</li>
<li>modifier - 需要应用的修饰器.</li>
<li>color - 文字色. 如果是 <code>Color.Unspecified</code>, 同时 style 没有配饰颜色, 将会使用 <code>LocalContentColor</code>.</li>
<li>fontSize - 字号. See TextStyle.fontSize.</li>
<li>fontStyle - 文字样式，例如斜体，See TextStyle.fontStyle.</li>
<li>fontWeight - 字重，例如加粗.</li>
<li>fontFamily - 字体系列. See TextStyle.fontFamily.</li>
<li>letterSpacing - 字间距. See TextStyle.letterSpacing.</li>
<li>textDecoration - 文字装饰效果，例如下划线. See TextStyle.textDecoration.</li>
<li>textAlign - 文字段落对齐方式. See TextStyle.textAlign.</li>
<li>lineHeight - 行高. See TextStyle.lineHeight.</li>
<li>overflow - 溢出时的处理方案，所谓溢出即文本框显示不下这么多文字.</li>
<li>softWrap - 是否应用换行符. 如果不应用，则一行写完，<code>overflow</code> 、<code>TextAlign</code> 无效.</li>
<li>maxLines - 最大行数，必须大于0.</li>
<li>inlineContent - 占位的替代信息匹配</li>
<li>onTextLayout - 绘制文字计算布局时的回调</li>
<li>style - 样式，例如： color, font, line height 等.</li>
</ul>
<p><em><a href="https://github.com/leobert-lan/ComposeWorkShop">WorkShop</a> 中按照这些参数编写了一些样例代码，效果如下，因过度图片压缩导致有锯齿感，非Compose问题</em></p>
<p><img src="Compose/./post_26/text_demo.webp" alt="text_demo" /></p>
<p><em>考虑到阅读体验，代码请移步WorkShop</em></p>
<h2 id="textfield"><a class="header" href="#textfield">TextField</a></h2>
<p>Android中有 <code>EditText</code> 控件，用于接收 <code>用户的文本输入</code>，Compose中为 <code>TextField</code></p>
<p>和 <code>TextField</code> 类似的还有 <code>OutlinedTextField</code>，使用上和 <code>TextField</code> 一致，多一个描边外框效果</p>
<p>方法原型：</p>
<pre><code class="language-kotlin">fun TextField(
    value: String,
    onValueChange: (String) -&gt; Unit,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    readOnly: Boolean = false,
    textStyle: TextStyle = LocalTextStyle.current,
    label: @Composable (() -&gt; Unit)? = null,
    placeholder: @Composable (() -&gt; Unit)? = null,
    leadingIcon: @Composable (() -&gt; Unit)? = null,
    trailingIcon: @Composable (() -&gt; Unit)? = null,
    isError: Boolean = false,
    visualTransformation: VisualTransformation = VisualTransformation.None,
    keyboardOptions: KeyboardOptions = KeyboardOptions.Default,
    keyboardActions: KeyboardActions = KeyboardActions(),
    singleLine: Boolean = false,
    maxLines: Int = Int.MAX_VALUE,
    interactionSource: MutableInteractionSource = remember { MutableInteractionSource() },
    shape: Shape =
        MaterialTheme.shapes.small.copy(bottomEnd = ZeroCornerSize, bottomStart = ZeroCornerSize),
    colors: TextFieldColors = TextFieldDefaults.textFieldColors()
)
</code></pre>
<pre><code class="language-kotlin">fun TextField(
    value: TextFieldValue,
    onValueChange: (TextFieldValue) -&gt; Unit,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    readOnly: Boolean = false,
    textStyle: TextStyle = LocalTextStyle.current,
    label: @Composable (() -&gt; Unit)? = null,
    placeholder: @Composable (() -&gt; Unit)? = null,
    leadingIcon: @Composable (() -&gt; Unit)? = null,
    trailingIcon: @Composable (() -&gt; Unit)? = null,
    isError: Boolean = false,
    visualTransformation: VisualTransformation = VisualTransformation.None,
    keyboardOptions: KeyboardOptions = KeyboardOptions.Default,
    keyboardActions: KeyboardActions = KeyboardActions(),
    singleLine: Boolean = false,
    maxLines: Int = Int.MAX_VALUE,
    interactionSource: MutableInteractionSource = remember { MutableInteractionSource() },
    shape: Shape =
        MaterialTheme.shapes.small.copy(bottomEnd = ZeroCornerSize, bottomStart = ZeroCornerSize),
    colors: TextFieldColors = TextFieldDefaults.textFieldColors()
)
</code></pre>
<p>很巧，和Text类似，除了value 和 onValueChange 的类型不一致，其他均一致。</p>
<p>简单追溯代码后可以发现：</p>
<ul>
<li>和Android不一致，它并没有依赖Text的实现，而Android中 Edittext 继承自 TextView</li>
<li>TextField 同样是结合 <code>较为通用的设计</code> 组合而成的一个控件，并不仅仅只有文字相关部分</li>
</ul>
<p><em>本篇注重于学习如何使用，故而略去源码部分</em></p>
<p>参数含义：</p>
<p>value: TextFieldValue
输入框中要显示的文本，包含了输入框编辑状态的信息，这个功能很强大，可以用来更新文本，光标等，然后还可以从其他位置直接观察到这些值的变化。也就是相当于双向绑定的意思；</p>
<ul>
<li>value: 显示的文本</li>
<li>onValueChange: 更新后的回调</li>
<li>modifier:修饰器</li>
<li>enabled:是否可用，如果为false，将不可选中，不可输入，呈现出禁用状态</li>
<li>readOnly:是否只读，如果是true，则不可编辑，但是可以选中，可以触发复制</li>
<li>textStyle: 文字样式，<em>前文中Text的诸多参数亦用于构建TextStyle</em></li>
<li>label: 显示在文本字段内的可选标签，未获得焦点时呈现</li>
<li>placeholder: 获得焦点时的默认呈现 <em>类似Tint的效果</em></li>
<li>leadingIcon: 输入框前部的图标；</li>
<li>trailingIcon: 输入框后部的图标；</li>
<li>isError: 输入内容是否错误，如果为true，则label，Icon等会相应的展示错误的显示状态；</li>
<li>visualTransformation: 内容显示转变，例如输入密码时可以变成特定效果</li>
<li>keyboardOptions: 软件键盘选项</li>
<li>keyboardActions: ImeAction</li>
<li>singleLine: 是否单行输入</li>
<li>maxLines:最大行数，需要≥1。如果将singleLine设置为true，则将忽略此参数，</li>
<li>interactionSource: <em>目前的知识体系暂不深入</em></li>
<li>shape: 输入框的形状</li>
<li>colors: 各种状态下的颜色 <em>类似Android的ColorStateList</em></li>
</ul>
<h3 id="效果演示"><a class="header" href="#效果演示">效果演示</a></h3>
<pre><code class="language-kotlin">TextField(
    value = "文字",
    onValueChange = {
        
    }
)
</code></pre>
<p>如果我们测试这样一段代码，会发现无论输入什么，显示内容都不会改变。Compose 需要我们在外部维护状态</p>
<p>一个有效的输入框代码示例：</p>
<pre><code class="language-kotlin">var text by rememberSaveable { mutableStateOf("文字") }
TextField(
    value = text,
    onValueChange = {
        text = it
    }
)
</code></pre>
<p><em>如果读者仔细的观察一下，会发现这里的value 依旧对应 String 类型！这里充分利用了Delegate的特性！！</em></p>
<p>接下来，我们尝试一下几个有趣的属性。</p>
<blockquote>
<p>而下述的一些简单属性，相信读者已经心中有数，就不在WorkShop中演示了：</p>
<ul>
<li>modifier</li>
<li>enabled</li>
<li>readOnly</li>
<li>textStyle</li>
<li>visualTransformation</li>
<li>singleLine</li>
<li>maxLines</li>
<li>shape</li>
<li>colors</li>
</ul>
</blockquote>
<h3 id="label--placeholder"><a class="header" href="#label--placeholder">label &amp; placeholder</a></h3>
<pre><code class="language-kotlin">var text by rememberSaveable { mutableStateOf("") }
TextField(
    value = text,
    onValueChange = { text = it },
    label = { Text("Label") },
    placeholder = { Text("PlaceHolder") }
)
</code></pre>
<p>未获得焦点时，显示label：<em>这里输入的是啥</em>，获取焦点后，label缩小，如果没有初始值，则显示PlaceHolder，否则初始文字
PlaceHolder：<em>输入示例</em></p>
<p><em>效果在章节末呈现</em></p>
<h3 id="leadingicontrailingicon"><a class="header" href="#leadingicontrailingicon">leadingIcon&amp;trailingIcon</a></h3>
<pre><code class="language-kotlin">var text by rememberSaveable { mutableStateOf("") }

TextField(
    value = text,
    onValueChange = { text = it },
    placeholder = { Text("PlaceHolder") },
    leadingIcon = { Icon(Icons.Filled.Favorite, contentDescription = "Favorite") },
    trailingIcon = { Icon(Icons.Filled.Clear, contentDescription = "Clear",modifier = Modifier.clickable {
        text = ""
    }) }
)
</code></pre>
<blockquote>
<p>如果在Android原生SDK下，做法可以是：</p>
<ul>
<li>完全自定义View -- 完全通过继承</li>
<li>继承ViewGroup或者特定ViewGroup，内部通过组合控件方式 <em>反射xml布局或者代码构建</em> 实现逻辑 -- 继承 + 组合</li>
<li>定义类，内部通过组合控件方式 <em>反射xml布局或者代码构建</em> 实现逻辑 -- 组合</li>
</ul>
<p>每种做法都有自身的优势和劣势，<strong>但代码量都会很多</strong></p>
<p>这个例子下我们还无法去讨论 <code>组合与继承的优劣对比</code> ，但代码量的感性对比非常明显</p>
</blockquote>
<h3 id="iserror--keyboardactions--输入校验"><a class="header" href="#iserror--keyboardactions--输入校验">isError &amp; keyboardActions &amp; 输入校验</a></h3>
<pre><code class="language-kotlin">var text by rememberSaveable { mutableStateOf("") }
var isError by rememberSaveable { mutableStateOf(false) }

fun validate(text: String) {
    isError = text.count() &lt; 5
}

TextField(
    value = text,
    onValueChange = {
        text = it
        isError = false
    },
    singleLine = true,
    label = { Text(if (isError) "Email*" else "Email") },
    isError = isError,
    keyboardActions = KeyboardActions { validate(text) },
    modifier = Modifier.semantics {
        // Provide localized description of the error
        if (isError) {
            Toast.makeText(this@P26TextFieldSample,"输入错误",Toast.LENGTH_SHORT).show()
        }
    }
)
</code></pre>
<p>代码含义清晰明了</p>
<h3 id="上述例子的效果"><a class="header" href="#上述例子的效果">上述例子的效果</a></h3>
<p><img src="Compose/./post_26/text_field_demo.webp" alt="text_field_demo" /></p>
<p>读者可以clone项目后自行体验</p>
<blockquote>
<p>相信有读者已经在思考Compose是如何实现 <code>双向绑定</code> 的了，按照我们的学习计划，这将在后续的文章中展开。</p>
</blockquote>
<h2 id="button"><a class="header" href="#button">Button</a></h2>
<p>相信看到这里，有读者已经在思考一个问题了：</p>
<blockquote>
<p>Modifier 中有点击相关的内容，为什么还需要有Button呢？它真的是一个视图控件吗？还是一个特定的、带有点击效果的样式组合？</p>
</blockquote>
<p>其实 <code>Button</code> 在人机交互中，是一个类似 <code>隐喻</code> 的存在，指代点击可触发特定行为的交互区，在设计发展中，
逐渐形成了一些约定：</p>
<ul>
<li><strong>可触发和不可触发的状态要可识别</strong></li>
<li><strong>从其所在环境中可以被轻易地识别出来</strong></li>
<li><strong>点击或者按压要有视觉反馈效果</strong></li>
</ul>
<p>所以样式上是一个不可忽略的侧重点。但是也要客观的承认一点：<code>中式UI和欧美UI确实不是一个风格</code>，所以多数情况下我们会修改掉默认效果。</p>
<p>看一下方法原型：</p>
<pre><code class="language-kotlin">fun Button(
    onClick: () -&gt; Unit,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    interactionSource: MutableInteractionSource = remember { MutableInteractionSource() },
    elevation: ButtonElevation? = ButtonDefaults.elevation(),
    shape: Shape = MaterialTheme.shapes.small,
    border: BorderStroke? = null,
    colors: ButtonColors = ButtonDefaults.buttonColors(),
    contentPadding: PaddingValues = ButtonDefaults.ContentPadding,
    content: RowScope.() -&gt; Unit
): @Composable Unit
</code></pre>
<ul>
<li>onClick: 点击事件回调</li>
<li>modifier: 修饰器</li>
<li>enabled:是否可点击触发</li>
<li>interactionSource:</li>
<li>elevation: z轴投影效果</li>
<li>shape: button和投影的形状</li>
<li>border: 描边</li>
<li>colors: 背景色、内容色、各个状态配色</li>
<li>contentPadding: 容器和内容的间距</li>
<li>content: 内容</li>
</ul>
<h3 id="代码示例"><a class="header" href="#代码示例">代码示例</a></h3>
<p>一个最简单的文字按钮：</p>
<pre><code class="language-kotlin">Button(
    onClick = {
        toast("onClick")
    },
    modifier = Modifier.clickable {
        toast("Modifier.onClick")
    }
) {
    Text(
        text = "Button",
    )
}
</code></pre>
<p>显然，点击生效的是 <code>onClick</code> 的回调函数。</p>
<p><em>在 <strong>后面的效果图</strong> 或者 <strong>运行WorkShop后</strong> 可发现，这个文字Button已经运用了许多样式</em></p>
<p><em>Button的样式部分，读者可自行编码探索实践一二，可以很轻易的和Android原生内容对应上，不再展开。</em></p>
<p>前文的方法原型中，<code>content: RowScope.() -&gt; Unit</code> 显然可以包含更多的东西。<em>Row 的布局特性会在后续文章展开</em></p>
<p>例如：</p>
<pre><code class="language-kotlin">Button(
    onClick = {
        toast("onClick")
    }
) {
    Icon(
        Icons.Filled.Favorite,
        contentDescription = "Favorite"
    )
    Text(
        text = "Button",
    )
}
</code></pre>
<p>可以在文字左边放置一个 <code>Favorite</code> 图标</p>
<h3 id="结合样式的衍生物"><a class="header" href="#结合样式的衍生物">结合样式的衍生物</a></h3>
<p>而Compose中，还有一些内容，代表着Button的操作含义，但有更特殊的样式含义，例如：</p>
<ul>
<li>OutlinedButton：有边线的Button, 但非实质的，<em>借用Android原生的内容比喻：有Stroke效果，无Solid效果</em></li>
<li>IconButton：显示一个Icon的button <em>但编码上未强制约束</em></li>
<li>IconToggleButton：两个状态图标的icon，相互切换，<em>例如：收藏、取消收藏</em>，表现含义上有别于 <code>Switch</code>，表现类似无文字的 <code>CheckBox</code></li>
</ul>
<h4 id="outlinedbutton"><a class="header" href="#outlinedbutton">OutlinedButton</a></h4>
<pre><code class="language-kotlin">fun OutlinedButton(
    onClick: () -&gt; Unit,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    interactionSource: MutableInteractionSource = remember { MutableInteractionSource() },
    elevation: ButtonElevation? = null,
    shape: Shape = MaterialTheme.shapes.small,
    border: BorderStroke? = ButtonDefaults.outlinedBorder,
    colors: ButtonColors = ButtonDefaults.outlinedButtonColors(),
    contentPadding: PaddingValues = ButtonDefaults.ContentPadding,
    content: @Composable RowScope.() -&gt; Unit
)
</code></pre>
<p>和Button参数含义一致</p>
<h4 id="iconbutton"><a class="header" href="#iconbutton">IconButton</a></h4>
<pre><code class="language-kotlin">fun IconButton(
    onClick: () -&gt; Unit,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    interactionSource: MutableInteractionSource = remember { MutableInteractionSource() },
    content: @Composable () -&gt; Unit
)
</code></pre>
<p><em>参数含义参考Button</em></p>
<p>适用场景如返回键、关闭按钮等</p>
<p>示例：</p>
<pre><code class="language-kotlin">IconButton(
    onClick = {
        toast("onClick")
    },
) {
    Icon(
        imageVector = Icons.Filled.Favorite,
        contentDescription = "Favorite"
    )
}
</code></pre>
<h4 id="icontogglebutton"><a class="header" href="#icontogglebutton">IconToggleButton</a></h4>
<pre><code class="language-kotlin">fun IconToggleButton(
    checked: Boolean,
    onCheckedChange: (Boolean) -&gt; Unit,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    interactionSource: MutableInteractionSource = remember { MutableInteractionSource() },
    content: @Composable () -&gt; Unit
) 
</code></pre>
<ul>
<li>checked：默认状态</li>
<li>onCheckedChange：状态变化后的回调</li>
</ul>
<p>适用场景如：收藏、取消收藏等</p>
<p>示例：</p>
<pre><code class="language-kotlin">val checkedState = remember { mutableStateOf(true) }

IconToggleButton(
    checked = checkedState.value,
    onCheckedChange = {
        checkedState.value = it
    },
) {
    Icon(
        imageVector = Icons.Filled.Favorite,
        contentDescription = "Favorite",
        tint = if (checkedState.value) {
            Color.Red
        } else {
            Color.Gray
        }
    )
}
</code></pre>
<p>上述所有内容的效果：
<img src="Compose/./post_26/button_demo.webp" alt="button_demo" /></p>
<h2 id="结语-2"><a class="header" href="#结语-2">结语</a></h2>
<p>在本篇文章中，我们一起学习了Compose的部分基础内容，这些内容学起来也比较枯燥，但适应了Compose之后，学习这些基础内容就会越来越快。</p>
<p>读者可以结合 <a href="https://github.com/leobert-lan/ComposeWorkShop">WorkShop</a> 实践一波，加深印象！</p>
<p>我们下一篇见。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jetpack-compose--控件篇二----iconimage"><a class="header" href="#jetpack-compose--控件篇二----iconimage">Jetpack Compose | 控件篇（二） -- Icon，Image</a></h1>
<h2 id="写在最前-2"><a class="header" href="#写在最前-2">写在最前</a></h2>
<p>在上一篇，我们学习了Compose 中的 <code>Text</code> 、<code>TextField</code> 、<code>Button</code>，并在WorkShop中进行了一系列尝试。
除了对他们的效果有了直观的认识外，也感受了Compose的编码乐趣。</p>
<p>本篇我们将继续学习Icon和Image，从命名上我们可以看出他们和 <code>图形、图片</code> 有关，也是 <code>内容呈现</code> 中非常重要的一种载体和方式。</p>
<blockquote>
<p><em>文中代码均基于 1.0.1版本</em></p>
<p><em>如无特殊说明，文中的 <code>Compose</code> 均指代 <code>Jetpack compose</code></em></p>
<p>文中代码均可在 <a href="https://github.com/leobert-lan/ComposeWorkShop">WorkShop</a> 中获取，本篇代码集中于 post27 包下</p>
</blockquote>
<h2 id="icon"><a class="header" href="#icon">Icon</a></h2>
<h3 id="使用方法"><a class="header" href="#使用方法">使用方法</a></h3>
<p>翻阅源码，我们可以获知有三个函数用于构建Icon组件。</p>
<p>分别是：</p>
<pre><code class="language-kotlin">fun Icon(
    imageVector: ImageVector,
    contentDescription: String?,
    modifier: Modifier = Modifier,
    tint: Color = LocalContentColor.current.copy(alpha = LocalContentAlpha.current)
)
</code></pre>
<pre><code class="language-kotlin">fun Icon(
    bitmap: ImageBitmap,
    contentDescription: String?,
    modifier: Modifier = Modifier,
    tint: Color = LocalContentColor.current.copy(alpha = LocalContentAlpha.current)
)
</code></pre>
<pre><code class="language-kotlin">fun Icon(
    painter: Painter,
    contentDescription: String?,
    modifier: Modifier = Modifier,
    tint: Color = LocalContentColor.current.copy(alpha = LocalContentAlpha.current)
)
</code></pre>
<p>不难发现，仅第一个形参类型不一致，但均是Icon的实际内容。</p>
<p>而其他三个参数，含义分别为：</p>
<ul>
<li>contentDescription: 内容含义描述，用于 <code>无障碍服务</code> ，如果这个Icon可以被触发，就需要解释它的含义，如果仅仅是装饰性质，可以忽略掉</li>
<li>modifier: 修饰器</li>
<li>tint: 着色器，可以直接修改Icon实质内容的颜色。<em>从事Android行业的读者并不陌生</em></li>
</ul>
<p>而实质内容可以以三种方式进行描述：</p>
<ul>
<li>ImageVector 矢量图</li>
<li>ImageBitmap 位图</li>
<li>Painter 可被绘制的内容，这是一个抽象的类，类似于Android中的 <code>Drawable</code></li>
</ul>
<h3 id="效果"><a class="header" href="#效果">效果</a></h3>
<p>Compose中已经存在一些矢量图资源，例如：</p>
<pre><code class="language-kotlin">public val Icons.Filled.Favorite: ImageVector
    get() {
        if (_favorite != null) {
            return _favorite!!
        }
        _favorite = materialIcon(name = "Filled.Favorite") {
            materialPath {
                moveTo(12.0f, 21.35f)
                lineToRelative(-1.45f, -1.32f)
                curveTo(5.4f, 15.36f, 2.0f, 12.28f, 2.0f, 8.5f)
                curveTo(2.0f, 5.42f, 4.42f, 3.0f, 7.5f, 3.0f)
                curveToRelative(1.74f, 0.0f, 3.41f, 0.81f, 4.5f, 2.09f)
                curveTo(13.09f, 3.81f, 14.76f, 3.0f, 16.5f, 3.0f)
                curveTo(19.58f, 3.0f, 22.0f, 5.42f, 22.0f, 8.5f)
                curveToRelative(0.0f, 3.78f, -3.4f, 6.86f, -8.55f, 11.54f)
                lineTo(12.0f, 21.35f)
                close()
            }
        }
        return _favorite!!
    }
</code></pre>
<p>当然，按照 <code>MaterialDesign</code>, 存在一系列的风格:</p>
<ul>
<li>Filled 默认，图形是内容填充风格</li>
<li>Outlined 只有描边，不做填充</li>
<li>Rounded 圆形，例如圆形启动图标</li>
<li>TwoTone 双调，<em>不确定doc是否写错，和Sharp完全一致，可以看情况搭讪下设计MM，顺带提升下审美</em></li>
<li>Sharp 例如直角图标</li>
</ul>
<p><a href="https://fonts.google.com/icons?selected=Material+Icons">均可以在Google Fonts进行定制与体验</a></p>
<pre><code class="language-kotlin">Icon(
    Icons.Filled.Call,
    contentDescription = "Call"
)
Icon(
    Icons.Outlined.Call,
    contentDescription = "Call"
)
Icon(
    Icons.Rounded.Call,
    contentDescription = "Call"
)
Icon(
    Icons.TwoTone.Call,
    contentDescription = "Call"
)
Icon(
    Icons.Sharp.Call,
    contentDescription = "Call"
)
</code></pre>
<p>选取了部分内置图标进行直观感受。</p>
<p>三种资源使用方式以及Tint：</p>
<pre><code class="language-kotlin">Icon(
    ImageBitmap.imageResource(id = R.drawable.baseline_fingerprint_black_24dp),
    contentDescription = "Check fingerprint",
    tint = Color.Green
)
</code></pre>
<p><img src="Compose/./post_27/icon_demo.webp" alt="icon_demo.webp" /></p>
<h2 id="image"><a class="header" href="#image">Image</a></h2>
<h3 id="使用方式"><a class="header" href="#使用方式">使用方式</a></h3>
<p>和Icon的使用类似，同样有三个函数：</p>
<pre><code class="language-kotlin">fun Image(
    bitmap: ImageBitmap,
    contentDescription: String?,
    modifier: Modifier = Modifier,
    alignment: Alignment = Alignment.Center,
    contentScale: ContentScale = ContentScale.Fit,
    alpha: Float = DefaultAlpha,
    colorFilter: ColorFilter? = null
)
</code></pre>
<pre><code class="language-kotlin">fun Image(
    imageVector: ImageVector,
    contentDescription: String?,
    modifier: Modifier = Modifier,
    alignment: Alignment = Alignment.Center,
    contentScale: ContentScale = ContentScale.Fit,
    alpha: Float = DefaultAlpha,
    colorFilter: ColorFilter? = null
)
</code></pre>
<pre><code class="language-kotlin">fun Image(
    painter: Painter,
    contentDescription: String?,
    modifier: Modifier = Modifier,
    alignment: Alignment = Alignment.Center,
    contentScale: ContentScale = ContentScale.Fit,
    alpha: Float = DefaultAlpha,
    colorFilter: ColorFilter? = null
)
</code></pre>
<p>和Icon对比，如下参数不同：</p>
<ul>
<li>alignment: 内容对齐方式</li>
<li>contentScale: 缩放，<em>类似Android ScaleType</em></li>
<li>alpha: 内容的Alpha通道</li>
<li>colorFilter: 色彩过滤器，<em>可以实现tint、滤镜矩阵等，非Compose特有，不再展开</em></li>
</ul>
<blockquote>
<p>值得一提的是, 图片因其信息量大的特性，实际应用过程中，对于远程资源，总是需要考虑：</p>
<ul>
<li>加载耗时</li>
<li>清晰度分级</li>
<li>缓存</li>
</ul>
<p>等内容，本篇我们仅学习静态资源的加载, 而和Compose相关的 <code>资源</code> 加载函数，在Icon中已经有代码示例，本节不再赘述。</p>
</blockquote>
<h2 id="结语-3"><a class="header" href="#结语-3">结语</a></h2>
<p>又很愉快地学完了一些新知识，当然，在Icon和Image中，依旧存在很多我们没有挖掘的内容，但不用着急，在起始阶段，我们仅需要掌握控件的特性和使用方式。</p>
<p>当我们掌握了UI布局相关的内容后，我们会回过头来，再学习他的原理部分。</p>
<p><em>打个招呼：其实起始阶段的内容都非常简单，但因为我最近比较懒，而且正在处理一件有挑战的事情，占用了很多精力，所以更新有点拖沓</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jetpack-compose--控件篇三----switchcheckboxradiobutton"><a class="header" href="#jetpack-compose--控件篇三----switchcheckboxradiobutton">Jetpack Compose | 控件篇（三） -- Switch、CheckBox、RadioButton</a></h1>
<h2 id="写在最前-3"><a class="header" href="#写在最前-3">写在最前</a></h2>
<p>在之前的文章中，我们学习过Compose 中的 <code>ImageButton</code>。</p>
<p>本篇我们将继续学习 <code>Switch</code> 、 <code>CheckBox</code> 、<code>RadioButton</code> , 这三个控件在 <code>人机交互界面</code> 中也是由来已久。</p>
<blockquote>
<p><em>文中代码均基于 1.0.1版本</em></p>
<p><em>如无特殊说明，文中的 <code>Compose</code> 均指代 <code>Jetpack compose</code></em></p>
<p>文中代码均可在 <a href="https://github.com/leobert-lan/ComposeWorkShop">WorkShop</a> 中获取，本篇代码集中于 post28 包下</p>
<p>完整系列目录: <a href="https://leobert-lan.github.io/Compose/">Github Pages</a> | <a href="https://juejin.cn/column/6999815370697605156">掘金</a> | <a href="https://blog.csdn.net/a774057695/category_11298077.html">csdn</a></p>
</blockquote>
<h2 id="switch"><a class="header" href="#switch">Switch</a></h2>
<p>当功能含义如同 <code>开关</code> 一般时，我们可以使用该控件，例如："深色模式"、"飞行模式"</p>
<h3 id="使用方式-1"><a class="header" href="#使用方式-1">使用方式</a></h3>
<pre><code class="language-kotlin">fun Switch(
    checked: Boolean,
    onCheckedChange: ((Boolean) -&gt; Unit)?,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    interactionSource: MutableInteractionSource = remember { MutableInteractionSource() },
    colors: SwitchColors = SwitchDefaults.colors()
)
</code></pre>
<p>经过前面的学习，这些参数的含义应该不陌生了。</p>
<p>修改配色可以通过如下API构建 <code>SwitchColors</code> 对象实例</p>
<pre><code class="language-kotlin">object SwitchDefaults {
    fun colors(
        checkedThumbColor: Color = MaterialTheme.colors.secondaryVariant,
        checkedTrackColor: Color = checkedThumbColor,
        checkedTrackAlpha: Float = 0.54f,
        uncheckedThumbColor: Color = MaterialTheme.colors.surface,
        uncheckedTrackColor: Color = MaterialTheme.colors.onSurface,
        uncheckedTrackAlpha: Float = 0.38f,
        disabledCheckedThumbColor: Color = checkedThumbColor
            .copy(alpha = ContentAlpha.disabled)
            .compositeOver(MaterialTheme.colors.surface),
        disabledCheckedTrackColor: Color = checkedTrackColor
            .copy(alpha = ContentAlpha.disabled)
            .compositeOver(MaterialTheme.colors.surface),
        disabledUncheckedThumbColor: Color = uncheckedThumbColor
            .copy(alpha = ContentAlpha.disabled)
            .compositeOver(MaterialTheme.colors.surface),
        disabledUncheckedTrackColor: Color = uncheckedTrackColor
            .copy(alpha = ContentAlpha.disabled)
            .compositeOver(MaterialTheme.colors.surface)
    ): SwitchColors
}
</code></pre>
<p>结合前文学习的知识，我们不难推测，下述的代码并不能真正起到 <code>开关</code> 的功能：</p>
<pre><code class="language-kotlin">Switch(checked = false, onCheckedChange = {
    Log.d("tag", "onCheckChanged:$it")
})
</code></pre>
<p><em>实际效果可体验WorkShop</em></p>
<p>我们需要构建一个 <code>"被观测"</code> 的数据源  <em>[注意：这个说法虽然比较形象但并不准确]</em> ，它被 <code>Compose构建的树的节点</code> 所观测，即 <code>该Switch</code>，当其内容发生变化
后，可反映到UI上。</p>
<p>例如：</p>
<pre><code class="language-kotlin">var checked by rememberSaveable { mutableStateOf(false) }

Switch(checked = checked, onCheckedChange = {
    checked = it
    Log.d("tag", "onCheckChanged:$it")
})
</code></pre>
<p>或者：</p>
<pre><code class="language-kotlin">val checked = remember { mutableStateOf(false) }

Switch(checked = checked.value, onCheckedChange = {
    checked.value = it
    Log.d("tag", "onCheckChanged:$it")
})
</code></pre>
<p><em>当然，按照Compose的用法，这些函数必须要同时存在于 <code>@Compose</code> 的函数块中，这样才能被目标节点所 <code>"观测"</code></em></p>
<p><em>效果将在文末给出</em></p>
<h2 id="checkbox"><a class="header" href="#checkbox">CheckBox</a></h2>
<p>当形式为：<code>选中/不选中</code> 时，可以使用该控件。</p>
<h3 id="使用方式-2"><a class="header" href="#使用方式-2">使用方式</a></h3>
<pre><code class="language-kotlin">fun Checkbox(
    checked: Boolean,
    onCheckedChange: ((Boolean) -&gt; Unit)?,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    interactionSource: MutableInteractionSource = remember { MutableInteractionSource() },
    colors: CheckboxColors = CheckboxDefaults.colors()
)
</code></pre>
<p>和 <code>Switch</code> 非常相似，同样的，我们可以修改配色：</p>
<pre><code class="language-kotlin">object CheckboxDefaults {
   
    @Composable
    fun colors(
        checkedColor: Color = MaterialTheme.colors.secondary,
        uncheckedColor: Color = MaterialTheme.colors.onSurface.copy(alpha = 0.6f),
        checkmarkColor: Color = MaterialTheme.colors.surface,
        disabledColor: Color = MaterialTheme.colors.onSurface.copy(alpha = ContentAlpha.disabled),
        disabledIndeterminateColor: Color = checkedColor.copy(alpha = ContentAlpha.disabled)
    ): CheckboxColors
}
</code></pre>
<p><strong>至此，我们意识到，<code>Compose</code> 固定了 <code>Switch</code> , <code>Checkbox</code> 的样式风格，如果定制图标，可以使用 <code>ImageButton</code> 。</strong></p>
<p>如下代码将得到一个最简单可用的 <code>CheckBox</code></p>
<pre><code class="language-kotlin">var checked by rememberSaveable { mutableStateOf(false) }

Checkbox(checked = checked, onCheckedChange = {
    checked = it
    Log.d("tag", "onCheckChanged:$it")
})
</code></pre>
<blockquote>
<p>不同于Android原生控件，<code>Compose</code> 中的 <code>Checkbox</code> 无法添加文字 -- 这很 <strong>Compose!</strong>.</p>
<p>Compose 贯穿始终的一个原则就是 <code>组合</code> ， 显然：文字部分应该使用 Text。</p>
</blockquote>
<h2 id="radiobutton"><a class="header" href="#radiobutton">RadioButton</a></h2>
<p><code>Compose</code> 中并没有 <code>RadioButtonGroup</code> 的内容。 <em>也有可能是我没有找到</em>。</p>
<p>但是，这并不重要！<code>Compose</code> 并不推崇在控件内部维护状态，否则会违背 <code>纯函数</code> 的理念。而且，我们可以很轻易地利用 <code>组合</code> 方式外挂一段逻辑，实现单选。</p>
<p><em>注意：按照一般性的UI设计语言，多选应该利用Checkbox，实现思路有类似之处</em></p>
<h3 id="如何使用"><a class="header" href="#如何使用">如何使用</a></h3>
<pre><code class="language-kotlin">@Composable
fun RadioButton(
    selected: Boolean,
    onClick: (() -&gt; Unit)?,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    interactionSource: MutableInteractionSource = remember { MutableInteractionSource() },
    colors: RadioButtonColors = RadioButtonDefaults.colors()
)
</code></pre>
<p>和前两者不同，<code>RadioButton</code> 的回调函数是 <code>点击回调</code> 含义。</p>
<p><em>遵照UI设计语言，被点击则意味着 <code>选中</code>，而在单选中，通过逻辑保持该组仅目标项被选中。</em></p>
<p>通过以下API可以修改配色</p>
<pre><code class="language-kotlin">object RadioButtonDefaults {
    
    @Composable
    fun colors(
        selectedColor: Color = MaterialTheme.colors.secondary,
        unselectedColor: Color = MaterialTheme.colors.onSurface.copy(alpha = 0.6f),
        disabledColor: Color = MaterialTheme.colors.onSurface.copy(alpha = ContentAlpha.disabled)
    ): RadioButtonColors
}
</code></pre>
<p>构建一个单选组：</p>
<pre><code class="language-kotlin">val tags = arrayListOf("A", "B", "C", "D")
val selectedTag = remember { mutableStateOf("") }

Row {
    tags.forEach {
        Row {
            RadioButton(
                selected = it == selectedTag.value,
                onClick = {
                    selectedTag.value = it
                }
            )

            Text(text = it)
        }

        Spacer(modifier = Modifier.width(20.dp))
    }
}
</code></pre>
<p>同样，读者可以按照喜好利用代理的方式创建 <code>可观测数据源</code></p>
<pre><code class="language-kotlin">val tags = arrayListOf("A", "B", "C", "D")
var selectedTag by rememberSaveable { mutableStateOf("") }


Row {
    tags.forEach {
        Row {
            RadioButton(
                selected = selectedTag == it,
                onClick = {
                    selectedTag = it
                }
            )

            Text(text = it,modifier = Modifier.clickable {
                selectedTag = it
            })
        }

        Spacer(modifier = Modifier.width(20.dp))
    }
}
</code></pre>
<p>而且，按照UX的设计风格，可以灵活的为文字部分添加触发。</p>
<blockquote>
<p>思考：如下代码可以实现多选吗？</p>
</blockquote>
<pre><code class="language-kotlin">val tags = arrayListOf("A", "B", "C", "D")
var selectedItems by rememberSaveable { mutableStateOf(linkedSetOf&lt;String&gt;()) }

Row {
    tags.forEach {
        Row {
            Checkbox(checked = selectedItems.contains(it), onCheckedChange = {selected-&gt;
                if (selected) {
                    selectedItems.add(it)
                } else {
                    selectedItems.remove(it)
                }
                Log.d("tag", "onCheckChanged:$it,$selected")
            })

            Text(text = it)
        }

        Spacer(modifier = Modifier.width(20.dp))
    }
}
</code></pre>
<p>当然不可以！Set 集合内容的变化并无法被观测！那么怎么处理呢？</p>
<p>以目前我们掌握的知识，可以：</p>
<ul>
<li>利用位运算</li>
<li>添加一个观测源、组合判断，但这会被lint校验警告</li>
</ul>
<pre><code class="language-kotlin">//组合判断 会被警告的做法
val tags = arrayListOf("A", "B", "C", "D")
val selectedItems by rememberSaveable { mutableStateOf(linkedSetOf&lt;String&gt;()) }
var version by rememberSaveable { mutableStateOf(0) }

Row {
    tags.forEach {
        Row {
            Checkbox(
                checked = version != null &amp;&amp; selectedItems.contains(it),
                onCheckedChange = { selected -&gt;
                    if (selected) {
                        selectedItems.add(it)
                    } else {
                        selectedItems.remove(it)
                    }
                    version++
                    Log.d("tag", "onCheckChanged:$it,$selected")
                })

            Text(text = it)
        }

        Spacer(modifier = Modifier.width(20.dp))
    }
}
</code></pre>
<blockquote>
<p>是否还有更加优雅的解法呢？我们先保留这一疑惑，使得我们的探索过程更加的 <code>平稳</code> 、 <code>有趣</code> ， 而不必在开始阶段花费过多的精力。</p>
</blockquote>
<h2 id="效果-1"><a class="header" href="#效果-1">效果</a></h2>
<p><img src="Compose/./post_28/p28_demo.webp" alt="效果" /></p>
<h2 id="结语-4"><a class="header" href="#结语-4">结语</a></h2>
<p>很快又到了这一阶段，这意味着我们又掌握了新的知识，同时也产生了更多的疑惑，不过不用心急，所有的谜题最终都会解开。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jetpack-compose--控件篇四---boxrowcolumn"><a class="header" href="#jetpack-compose--控件篇四---boxrowcolumn">Jetpack Compose | 控件篇（四）-- Box、Row、Column</a></h1>
<p>在上一篇中，我们完成了 <code>Switch、CheckBox、RadioButton</code> 相关内容的学习，至此，最基本的简单控件我们已经学完，接下来我们将学习 <code>基本的布局</code>。</p>
<blockquote>
<p>以Android 为例，我们已经完成了：<code>TextView、Edittext、Button、ImageView、CheckBox、SwitchButton、RadioButton</code> 等内容的学习。</p>
<p>接下来将开始学习布局规则，例如：<code>FrameLayout、LinearLayout、RelativeLayout、ConstraintLayout</code> 等</p>
</blockquote>
<blockquote>
<p><em>文中代码均基于 1.0.1版本</em></p>
<p><em>如无特殊说明，文中的 <code>Compose</code> 均指代 <code>Jetpack compose</code></em></p>
<p>文中代码均可在 <a href="https://github.com/leobert-lan/ComposeWorkShop">WorkShop</a> 中获取，本篇代码集中于 post29 包下</p>
<p>完整系列目录: <a href="https://leobert-lan.github.io/Compose/">Github Pages</a> | <a href="https://juejin.cn/column/6999815370697605156">掘金</a> | <a href="https://blog.csdn.net/a774057695/category_11298077.html">csdn</a></p>
</blockquote>
<h2 id="box"><a class="header" href="#box">Box</a></h2>
<p>类似Android中的 <code>FrameLayout</code>。</p>
<p>在UI设计中，不可避免的会将一些UI元素组合在一起，从外观上进行整体改变，将他们从环境中 "独立" 开来。很自然地诞生了这一方式：以一个节点包裹这些UI元素，
将整体外观设计运用于这一节点上。</p>
<p><em>注意：这个节点可以根据排布元素的需求灵活的选择布局</em> -- 在Compose中，这个节点可以是Box，但不一定必须是Box！</p>
<h3 id="使用方式-3"><a class="header" href="#使用方式-3">使用方式</a></h3>
<pre><code class="language-kotlin">@Composable
inline fun Box(
    modifier: Modifier = Modifier,
    contentAlignment: Alignment = Alignment.TopStart,
    propagateMinConstraints: Boolean = false,
    content: @Composable BoxScope.() -&gt; Unit
)
</code></pre>
<p><em>很显然，这是一个内联函数，意味着它类似Facade模式的运用，其底层实现较为复杂，这里针对需求场景做了封装，隐匿了大量细节</em></p>
<p>在当前的学习阶段，我们克制住好奇心，先不探索细节。</p>
<p>参数含义：</p>
<ul>
<li>modifier: 修饰器</li>
<li>contentAlignment：内容对齐方式 <em>注意：这和FrameLayout有区别</em></li>
<li>propagateMinConstraints：是否运用最小尺寸到内容，如果为TRUE，内容的最小尺寸将按照modifier中的信息进行设定，否则仅作用于Box</li>
<li>content：内容 <em>Android中子View的概念</em></li>
</ul>
<p>在WorkShop中，我们沿用了 <a href="https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/layout/package-summary?hl=en#Box(androidx.compose.ui.Modifier)">Google的一个demo</a></p>
<pre><code class="language-kotlin">Box {
    Box(Modifier.fillMaxSize().background(Color.Cyan))
    Box(
            Modifier.matchParentSize().padding(top = 20.dp, bottom = 20.dp).background(Color.Yellow)
    )
    Box(
            Modifier.matchParentSize().padding(40.dp).background(Color.Magenta)
    )
    Box(
            Modifier.align(Alignment.Center).size(300.dp, 300.dp).background(Color.Green)
    )
    Box(
            Modifier.align(Alignment.TopStart).size(150.dp, 150.dp).background(Color.Red)
    )
    Box(
            Modifier.align(Alignment.BottomEnd).size(150.dp, 150.dp).background(Color.Blue)
    )
}
</code></pre>
<p>在这个Demo中，我们可以看到：</p>
<ul>
<li>对齐方式、padding 对 Box的 位置和大小所产生的影响</li>
<li>内容按照声明的次序先后进行排布</li>
</ul>
<p><img src="Compose/./post_29/p29_demo1.webp" alt="" /></p>
<h4 id="根据box的布局限制调整内容"><a class="header" href="#根据box的布局限制调整内容">根据Box的布局限制调整内容</a></h4>
<p><em>这是不同屏幕尺寸下的一种适配手段</em></p>
<p>这将使用到：<code>BoxWithConstraints</code></p>
<pre><code class="language-kotlin">@Composable
fun BoxWithConstraints(
    modifier: Modifier = Modifier,
    contentAlignment: Alignment = Alignment.TopStart,
    propagateMinConstraints: Boolean = false,
    content: @Composable BoxWithConstraintsScope.() -&gt; Unit
)
</code></pre>
<p>和Box的区别在于 content，lambda中的上下文是 <code>BoxWithConstraintsScope</code> 实例，而不再是 <code>BoxScope</code> 实例，据此，我们可以在布局时获知Box的尺寸限制：</p>
<pre><code class="language-kotlin">@Stable
interface BoxWithConstraintsScope : BoxScope {
    /**
     * The constraints given by the parent layout in pixels.
     * Use [minWidth], [maxWidth], [minHeight] or [maxHeight] if you need value in [Dp].
     */
    val constraints: Constraints
    /**
     * The minimum width in [Dp].
     */
    val minWidth: Dp
    /**
     * The maximum width in [Dp].
     */
    val maxWidth: Dp
    /**
     * The minimum height in [Dp].
     */
    val minHeight: Dp
    /**
     * The maximum height in [Dp].
     */
    val maxHeight: Dp
}
</code></pre>
<p>下面展示一个例子：</p>
<p>当Box最大高度小于100dp时，放置一个50*50dp的Box，否则纵向放置两个；初始高度为80dp，通过点击按钮在100dp和80dp间来回切换：</p>
<pre><code class="language-kotlin">var height by rememberSaveable { mutableStateOf(80) }
BoxWithConstraints(
    modifier = Modifier.height(height.dp)
) {
    val rectangleHeight = 50.dp
    if (maxHeight &lt; rectangleHeight * 2) {
        Box(Modifier
            .size(50.dp, rectangleHeight)
            .background(Color.Blue))
    } else {
        Column {
            Box(Modifier
                .size(50.dp, rectangleHeight)
                .background(Color.Blue))
            Box(Modifier
                .size(50.dp, rectangleHeight)
                .background(Color.Gray))
        }
    }
}

Button(onClick = {
    height = if (height &lt; 100) 100 else 80
}) {
    Text(text = "点击切换高度")
}
</code></pre>
<h3 id="效果-2"><a class="header" href="#效果-2">效果</a></h3>
<p>高度为80dp时，仅显示一个蓝色色块：</p>
<p><img src="Compose/./post_29/p29_demo3.webp" alt="" /></p>
<p>高度为100dp时，显示两个色块：</p>
<p><img src="Compose/./post_29/p29_demo2.webp" alt="" /></p>
<h2 id="row"><a class="header" href="#row">Row</a></h2>
<p>在Android中，也有Row的概念 <code>TableRow</code> ，它被用在TableLayout中，作为表格的行:</p>
<pre><code class="language-java">public class TableRow extends LinearLayout {
    //...
}
</code></pre>
<p>和Android的 <code>TableRow</code> 类似，Compose中的Row效果等同于 <strong>横向的 LinearLayout</strong></p>
<h3 id="使用方式-4"><a class="header" href="#使用方式-4">使用方式：</a></h3>
<pre><code class="language-kotlin">@Composable
inline fun Row(
    modifier: Modifier = Modifier,
    horizontalArrangement: Arrangement.Horizontal = Arrangement.Start,
    verticalAlignment: Alignment.Vertical = Alignment.Top,
    content: @Composable RowScope.() -&gt; Unit
)
</code></pre>
<p>参数含义：</p>
<ul>
<li>modifier: 修饰器</li>
<li>horizontalArrangement: 纵向上的范围</li>
<li>verticalAlignment: 横向的对齐方式</li>
<li>content：内容声明</li>
</ul>
<p>借用 <a href="https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/layout/package-summary?hl=en#Row(androidx.compose.ui.Modifier,androidx.compose.foundation.layout.Arrangement.Horizontal,androidx.compose.ui.Alignment.Vertical,kotlin.Function1)">Google的Demo</a></p>
<pre><code class="language-kotlin">Row {
    // The child with no weight will have the specified size.
    Box(Modifier.size(40.dp, 80.dp).background(Color.Magenta))
    // Has weight, the child will occupy half of the remaining width.
    Box(Modifier.height(40.dp).weight(1f).background(Color.Yellow))
    // Has weight and does not fill, the child will occupy at most half of the remaining width.
    // Therefore it will occupy 80.dp (its preferred width) if the assigned width is larger.
    Box(
        Modifier.size(80.dp, 40.dp)
            .weight(1f, fill = false)
            .background(Color.Green)
    )
}
</code></pre>
<p>在一行中，先用掉 40*80dp的空间，剩下来的空间 <em>（横向）</em> ，利用Weight进行均分，如果不使用fill策略，将使用给定的宽度。</p>
<p>在WorkShop中，提供了更多的场景Demo，可以发现，使用Weight时，总是：<strong>先计算给定尺寸的元素，并对剩余空间使用Weight进行分配</strong>。</p>
<p><em>这一点和Android的LinearLayout相比要更加灵活、好用</em></p>
<h4 id="纵向对齐方式"><a class="header" href="#纵向对齐方式">纵向对齐方式</a></h4>
<p>通过 verticalAlignment 可以指定纵向的对齐方式，例如纵向居中对齐：</p>
<pre><code class="language-kotlin">Row(verticalAlignment = Alignment.CenterVertically) {
    //...
}
</code></pre>
<p>可以使用：</p>
<ul>
<li>Top 顶部对齐，默认</li>
<li>CenterVertically 居中对齐</li>
<li>Bottom 底部对齐</li>
</ul>
<h4 id="横向范围"><a class="header" href="#横向范围">横向范围</a></h4>
<p>当Row的尺寸大于内容的尺寸时，可以调整内容的位置：</p>
<p>例如横向的居中</p>
<pre><code class="language-kotlin"> Row(
    modifier = Modifier.fillMaxWidth(),
    horizontalArrangement = Arrangement.Center) {
    // The child with no weight will have the specified size.
    Box(Modifier
        .size(40.dp, 80.dp)
        .background(Color.Magenta))
}
</code></pre>
<h3 id="效果-3"><a class="header" href="#效果-3">效果</a></h3>
<p><img src="Compose/./post_29/p29_demo4.webp" alt="" /></p>
<h2 id="column"><a class="header" href="#column">Column</a></h2>
<p>和 Row类似，但排布方向为纵向</p>
<p><em>读者可以自行编码以尝试效果，不再赘述</em></p>
<h3 id="使用方式-5"><a class="header" href="#使用方式-5">使用方式</a></h3>
<pre><code class="language-kotlin">inline fun Column(
    modifier: Modifier = Modifier,
    verticalArrangement: Arrangement.Vertical = Arrangement.Top,
    horizontalAlignment: Alignment.Horizontal = Alignment.Start,
    content: @Composable ColumnScope.() -&gt; Unit
) 
</code></pre>
<p><em>参考Row的使用方式</em></p>
<h2 id="结语-5"><a class="header" href="#结语-5">结语</a></h2>
<p>很快又到了说结束的时候，本篇中，我们一同学习了Compose中最基本的布局方式，当然，还有一些问题没有继续往下探索：如果内容超过容器的大小该如何处理呢？</p>
<p>我们将在后续的篇章中继续探索。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jetpack-compose--控件篇五---spacerlazyrowlazycolumn--让column可滑动"><a class="header" href="#jetpack-compose--控件篇五---spacerlazyrowlazycolumn--让column可滑动">Jetpack Compose | 控件篇（五）-- Spacer、LazyRow、LazyColumn &amp; 让Column可滑动</a></h1>
<p>在上一篇中，我们完成了 <code>Box、Row、Column</code> 相关内容的学习，并且留下了一个疑问：<strong>"如果容器大小不足以承载内容，怎么处理呢？"</strong>，这一篇我们一起学习这部分内容。</p>
<blockquote>
<p><em>文中代码均基于 1.0.1版本</em></p>
<p><em>如无特殊说明，文中的 <code>Compose</code> 均指代 <code>Jetpack compose</code></em></p>
<p>文中代码均可在 <a href="https://github.com/leobert-lan/ComposeWorkShop">WorkShop</a> 中获取，本篇代码集中于 post29 &amp; post30 包下</p>
<p>完整系列目录: <a href="https://leobert-lan.github.io/Compose/">Github Pages</a> | <a href="https://juejin.cn/column/6999815370697605156">掘金</a> | <a href="https://blog.csdn.net/a774057695/category_11298077.html">csdn</a></p>
</blockquote>
<h2 id="和android进行简单对比"><a class="header" href="#和android进行简单对比">和Android进行简单对比</a></h2>
<p>在Android中，SDK提供了诸如： <code>ScrollView</code> <code>NestedScrollView</code> <code>ListView</code> <code>GridView</code> <code>RecyclerView</code>，等针对各类场景下适用的控件，
基于滑动手势调整内容展示区域，以达到显示更多内容的目的。</p>
<p>进一步探索可以发现：View本身就包含了Scroll机制的 <code>半成品实现</code>，当然，本文我们不去深究Android的内容，借助我们已经掌握的Android知识，引出一点：</p>
<blockquote>
<p>基于Scroll机制，用小容器展现大内容的本质：在视图测量的基础上，结合滑动手势处理，调整内容布局，绘制后展现。</p>
</blockquote>
<p>在早期的一些文章中，有博主提到：Compose中对应的内容为 <code>ScrollRow，ScrollColumn</code> / <code>LazyRow、LazyColumn</code>。</p>
<p><em>在早期的预览版中，短暂的存在过 ScrollRow，ScrollColumn等内容，似乎已经被移除</em></p>
<p><strong>Compose中也是按照这样的思路设计的</strong>，我们将在后续的文章中再细致地展开研究，本篇中仅学习如何使用它们。</p>
<p>在真正开始这部分内容之前，先补充一个简单的控件 Spacer，可以简单的创建占位间距，<em>后续的文章中已经没有他的位置了</em>。</p>
<h2 id="spacer"><a class="header" href="#spacer">Spacer</a></h2>
<p>在之前的文章中，我们学习过Modifier，其中包含一些和布局相关的API，例如：<code>padding</code>、<code>offset</code>，但并无 <code>margin</code> 等内容，<em>按照业内惯例，
如果已经存在一个广为接受的名词，一般不会使用新词，至少词根是一致的</em>
，在Compose中，使用了Spacer，取缔了Margin的一些使用场景。</p>
<p><em>注：计算总是有损耗的，不要滥用Spacer,并且很多场景下有特定的方式处理间距，后续会逐渐学习到</em></p>
<h3 id="如何使用-1"><a class="header" href="#如何使用-1">如何使用</a></h3>
<pre><code class="language-kotlin">@Composable
fun Spacer(modifier: Modifier)
</code></pre>
<p>一般只需要指定他的宽高尺寸即可，例如：</p>
<pre><code class="language-kotlin">Spacer(modifier = Modifier.size(3.dp))
</code></pre>
<h2 id="lazycolumn"><a class="header" href="#lazycolumn">LazyColumn</a></h2>
<p><em>在上一篇文章中，我们已经学习过 Row和Column，它们仅仅是在方向上不一致，在实现上非常类似。同样的，LazyRow和LazyColumn也是如此。</em></p>
<p>Doc中提到：</p>
<blockquote>
<p>The vertically scrolling list that only composes and lays out the currently visible items.
The content block defines a DSL which allows you to emit items of different types.
For example you can use LazyListScope.item to add a single item and LazyListScope.items to add a list of items.</p>
</blockquote>
<p>仅 组合计算 以及 布局 当前可见元素的纵向可滑动列表。内容块定义了一个DSL，允许创建不同类型的元素。</p>
<p>例如：使用 <code>LazyListScope.item</code> 添加单个元素， <code>LazyListScope.items</code> 添加元素列表。</p>
<p><em>注："内容块定义了一个DSL，允许创建不同类型的元素"，这并不同于Android中概念： <code>RecyclerView#Adapter</code> 具有将数据映射为同类型 <code>ViewHolder</code> 或 不同类型 <code>ViewHolder</code>
的能力。而是指 "添加元素时可以是 <code>单个元素</code>，或者是 <code>元素的列表</code>，这是不同的类型。
<strong>字面翻译在中文语境下容易造成误解。</strong></em></p>
<p>很显然，它类似于Android中的 <code>ListView</code>,<code>RecyclerView</code>, <strong>着重点在于 <code>Lazy</code></strong>，<strong>不会将元素一股脑的全计算、布局出来</strong>。</p>
<p>所以，它并不对标ScrollView，在它的使用场景下，可滑动需求非常普遍，便默认实现了！</p>
<blockquote>
<p>我们前面提到：</p>
<p>在早期的一些文章中，有博主提到：Compose中对应的内容为 ScrollRow，ScrollColumn / LazyRow、LazyColumn</p>
<p>这本没有啥错误，但绝不是被曲解的： "Row和Column 无法提供滑动能力，而是需要使用 LazyRow、LazyColumn"</p>
</blockquote>
<p><strong>但气氛已经烘托到这里了</strong>，那我们先将其学完，再学习 Row和Column 如何提供滑动能力。</p>
<h3 id="如何使用-2"><a class="header" href="#如何使用-2">如何使用</a></h3>
<pre><code class="language-kotlin">@Composable
fun LazyColumn(
    modifier: Modifier = Modifier,
    state: LazyListState = rememberLazyListState(),
    contentPadding: PaddingValues = PaddingValues(0.dp),
    reverseLayout: Boolean = false,
    verticalArrangement: Arrangement.Vertical =
        if (!reverseLayout) Arrangement.Top else Arrangement.Bottom,
    horizontalAlignment: Alignment.Horizontal = Alignment.Start,
    flingBehavior: FlingBehavior = ScrollableDefaults.flingBehavior(),
    content: LazyListScope.() -&gt; Unit
)
</code></pre>
<p>各个参数含义：</p>
<ul>
<li>modifier：修饰器</li>
<li>state：用于控制或者观测列表状态</li>
<li>contentPadding：整体内容周围的一个Padding，<em>注：内容四周的留白，以纵向列表为例，尾部没有展示时看不到尾部的留白</em> 这通过Modifier无法实现，
<em>注：Modifier只能实现列表容器固定的留白间距</em> 。可以使用它在第一个元素前和最后一个元素后留白。 如果需要在元素间留出间距，可以使用 verticalArrangement</li>
<li>reverseLayout：是否反转列表</li>
<li>verticalArrangement：子控件纵向的范围。<em>可用于添加子控件之间的间距，以及内容不足以填满列表最小尺寸时，如何排布</em></li>
<li>horizontalAlignment：子控件横向对齐方式</li>
<li>flingBehavior：fling行为的处理逻辑</li>
<li>content：声明了如何提供子控件的DSL，有两种方式</li>
</ul>
<pre><code class="language-kotlin">@LazyScopeMarker
interface LazyListScope {

    fun item(key: Any? = null, content: @Composable LazyItemScope.() -&gt; Unit)

    fun items(
        count: Int,
        key: ((index: Int) -&gt; Any)? = null,
        itemContent: @Composable LazyItemScope.(index: Int) -&gt; Unit
    )

    @ExperimentalFoundationApi
    fun stickyHeader(key: Any? = null, content: @Composable LazyItemScope.() -&gt; Unit)
}
</code></pre>
<p><em>顺带一提：笔者参与的上一个项目中，高频使用RecycleView用作内容呈现，为了便捷的处理 "item之间的间距"、"首尾留白"、"特定item间不应用间距"， 在项目中写了一套部件，后续可以拆出来同大家分享下。</em></p>
<h3 id="基于lazylistscopeitem-方法"><a class="header" href="#基于lazylistscopeitem-方法">基于LazyListScope.item 方法</a></h3>
<p>在上一篇文章对应的WorkShop内容中，已经出现了这一用法 <em>post29包下</em>。</p>
<p>例如：</p>
<pre><code class="language-kotlin">private fun LazyListScope.rowDemo() {
    item {
        CodeSample(code = "row sample 1:")
        Row {
            // ignore
        }
    }

    item {
        CodeSample(code = "row sample 2:纵向居中对齐")
        // ignore
    }

    // ignore
}
</code></pre>
<h3 id="基于lazylistscopeitems-方法"><a class="header" href="#基于lazylistscopeitems-方法">基于LazyListScope.items 方法</a></h3>
<p>除了直接使用API，SDK中同样提供了部分内联函数，消除处理数据结构的代码冗余：</p>
<pre><code class="language-kotlin">inline fun &lt;T&gt; LazyListScope.items(
    items: List&lt;T&gt;,
    noinline key: ((item: T) -&gt; Any)? = null,
    crossinline itemContent: @Composable LazyItemScope.(item: T) -&gt; Unit
)

inline fun &lt;T&gt; LazyListScope.itemsIndexed(
    items: List&lt;T&gt;,
    noinline key: ((index: Int, item: T) -&gt; Any)? = null,
    crossinline itemContent: @Composable LazyItemScope.(index: Int, item: T) -&gt; Unit
)

inline fun &lt;T&gt; LazyListScope.items(
    items: Array&lt;T&gt;,
    noinline key: ((item: T) -&gt; Any)? = null,
    crossinline itemContent: @Composable LazyItemScope.(item: T) -&gt; Unit
)

inline fun &lt;T&gt; LazyListScope.itemsIndexed(
    items: Array&lt;T&gt;,
    noinline key: ((index: Int, item: T) -&gt; Any)? = null,
    crossinline itemContent: @Composable LazyItemScope.(index: Int, item: T) -&gt; Unit
)
</code></pre>
<p>按照以往Android中的开发经验，我们很容易写出如下的代码：</p>
<pre><code class="language-kotlin">// WorkShop 中的入口页面，枚举了各个例子对应的Activity
@Composable
fun TestList(activity: Activity, cases: List&lt;Pair&lt;String, Class&lt;out Activity&gt;&gt;&gt;) {
    LazyColumn(contentPadding = PaddingValues(horizontal = 16.dp, vertical = 8.dp)) {
        itemsIndexed(items = cases) { _, item -&gt;
            Column(
                horizontalAlignment = Alignment.CenterHorizontally,
            ) {
                Spacer(modifier = Modifier.size(3.dp))
                Box(
                    modifier = Modifier
                        .height(48.dp)
                        .fillMaxWidth()
                        .background(
                            color = Color.LightGray,
                            shape = RoundedCornerShape(CornerSize(6.dp))
                        )
                        .clickable {
                            activity.startActivity(Intent(activity, item.second))
                        },
                    contentAlignment = Alignment.Center
                ) {
                    Text(text = item.first, color = MainTxt, textAlign = TextAlign.Center)
                }
                Spacer(modifier = Modifier.size(3.dp))
            }
        }
    }
}

TestList(
    activity = this@MainActivity, cases = arrayListOf(
        "Layout samples" to P21LayoutSample::class.java,
        "Draw samples" to P21DrawSample::class.java,
        "Text samples" to P26TextSample::class.java,
        "TextField samples" to P26TextFieldSample::class.java,
        "Button samples" to P26ButtonSample::class.java,
        "Icon samples" to P27IconSample::class.java,
        "Image samples" to P27ImageSample::class.java,
        "Switch,Checkbox,RadioButton samples" to P28SwitchRbCbSample::class.java,
        "Box,Row,Column samples" to P29BoxRowColumnSample::class.java,
    )
)
</code></pre>
<p>如果从Android的视角出发，这段代码相当于创建 ViewHolder的ItemView 以及 onBindViewHolder 的实现</p>
<pre><code class="language-kotlin">Column(
    horizontalAlignment = Alignment.CenterHorizontally,
) {
    Spacer(modifier = Modifier.size(3.dp))
    Box(
        modifier = Modifier
            .height(48.dp)
            .fillMaxWidth()
            .background(
                color = Color.LightGray,
                shape = RoundedCornerShape(CornerSize(6.dp))
            )
            .clickable {
                activity.startActivity(Intent(activity, item.second))
            },
        contentAlignment = Alignment.Center
    ) {
        Text(text = item.first, color = MainTxt, textAlign = TextAlign.Center)
    }
    Spacer(modifier = Modifier.size(3.dp))
}
</code></pre>
<p>也就是说，我们利用了ItemView固有的 "留白" 处理了Item之间的间距，显然这不是最佳实践方案！</p>
<h3 id="更加优雅地处理间距和对齐"><a class="header" href="#更加优雅地处理间距和对齐">更加优雅地处理间距和对齐</a></h3>
<p>上文中已经提及：</p>
<ul>
<li>contentPadding</li>
<li>verticalArrangement</li>
<li>horizontalAlignment</li>
</ul>
<p>基于此我们对代码进行改造，以减少没用的嵌套</p>
<pre><code class="language-kotlin">@Composable
fun TestList(activity: Activity, cases: List&lt;Pair&lt;String, Class&lt;out Activity&gt;&gt;&gt;) {
    LazyColumn(
        contentPadding = PaddingValues(horizontal = 16.dp, vertical = 8.dp),
        verticalArrangement = spacedBy(6.dp, Alignment.Top),
        horizontalAlignment = Alignment.CenterHorizontally,
    ) {
        itemsIndexed(items = cases) { _, item -&gt;
            Box(
                modifier = Modifier
                    .height(48.dp)
                    .fillMaxWidth()
                    .background(
                        color = Color.LightGray,
                        shape = RoundedCornerShape(CornerSize(6.dp))
                    )
                    .clickable {
                        activity.startActivity(Intent(activity, item.second))
                    },
                contentAlignment = Alignment.Center
            ) {
                Text(
                    text = item.first,
                    color = MainTxt,
                    textAlign = TextAlign.Center
                )
            }
        }
    }
}
</code></pre>
<p>可以得到一致的效果：</p>
<p><img src="Compose/./post_30/p30_demo1.webp" alt="" /></p>
<h2 id="让column可滑动"><a class="header" href="#让column可滑动">让Column可滑动</a></h2>
<p><em>参考可以实现Row的可滑动</em></p>
<p>最开始在和Modifier混脸熟的过程中，我们提及了 <code>androidx.compose.foundation</code> 包，并且含有子包：
<code>androidx.compose.foundation.gestures</code>，顾名思义，后者和手势处理有关。</p>
<ul>
<li>androidx.compose.foundation.gestures.ScrollableKt#scrollable</li>
<li>androidx.compose.foundation.ScrollKt#verticalScroll</li>
<li>androidx.compose.foundation.ScrollKt#horizontalScroll</li>
</ul>
<p>经过这一阶段的学习，我们可以做出一个结论：</p>
<blockquote>
<p>Compose 中包含一部分基本的函数，以及结合实际使用场景，在基本函数上 "装饰" 出高级函数</p>
</blockquote>
<p>从命名上，我们很容易得知 <code>scrollable</code> 是比较基本的函数，<code>verticalScroll</code>，<code>horizontalScroll</code> 是基于 <code>scrollable</code> 装饰出的高级函数。</p>
<p>阅读源码后也确实验证了我们的推测。</p>
<p><em>以 verticalScroll 为例，horizontalScroll暂不展开</em></p>
<p>Doc内容如下：</p>
<blockquote>
<p>Modify element to allow to scroll vertically when height of the content is bigger than max
constraints allow. In order to use this modifier, you need to create and own [ScrollState]
@see [rememberScrollState]</p>
</blockquote>
<p>修饰布局元素，当其内容高度超过最大允许的限制时，允许在纵向进行滚动。</p>
<p><em>注：内容最大高度地限制需要考虑容器的高度、padding、offset等内容</em></p>
<p>为了使用它，你需要创建并持有 <code>ScrollState</code> 实例，参见 <code>rememberScrollState</code></p>
<p><strong>方法原型</strong>：</p>
<pre><code class="language-kotlin">fun Modifier.verticalScroll(
    state: ScrollState,
    enabled: Boolean = true,
    flingBehavior: FlingBehavior? = null,
    reverseScrolling: Boolean = false
)
</code></pre>
<ul>
<li>state：滚动状态，ScrollState实例</li>
<li>enabled：当触摸事件发生时，是否允许滑动</li>
<li>flingBehavior：fling处理逻辑</li>
<li>reverseScrolling：是否反向滑动</li>
</ul>
<h3 id="demo"><a class="header" href="#demo">Demo</a></h3>
<pre><code class="language-kotlin">Column(
    modifier = Modifier
        .fillMaxWidth()
        .height(600.dp)
        .verticalScroll(
            state = rememberScrollState()
        )

) {
    Box(
        Modifier
            .fillMaxWidth()
            .height(400.dp)
            .background(Color.Green)
    )

    Spacer(modifier = Modifier.height(50.dp))

    Box(
        Modifier
            .fillMaxWidth()
            .height(400.dp)
            .background(Color.Blue)
    )

}
</code></pre>
<p>很显然，内容高度已经超过了最大限制！</p>
<h3 id="效果-4"><a class="header" href="#效果-4">效果</a></h3>
<p><img src="Compose/./post_30/p30_demo2.gif" alt="" /></p>
<h2 id="结语-6"><a class="header" href="#结语-6">结语</a></h2>
<p>至此，Compose中的列表我们已经学习完成，经过简单探索Modifier中滑动的相关内容，掌握了让Column在内容超出展示限制时可以响应滑动的方案。
较为遗憾的是，目前我们所掌握的知识还不足以支撑我们继续探索下去。</p>
<p>当然，在后续的文章中，我们会继续学习相关的基础知识，最终一起探索Compose中深层次的内容</p>
<p><em>另：最近祖传代码改的有点精神分裂，文章更新效率还是没上的来。读者朋友们，如果觉得我的分享对你有一些帮助，还请点个赞让我知道，给予我支持下去的动力；如果内容写的不好，也烦请留个言把想看的内容告知我，可以在后续的文章中一起交流！</em></p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="multithreading"><a class="header" href="#multithreading">MultiThreading</a></h3>
<p>Java多线程系列</p>
<ul>
<li><a href="MultiThreading/./post_33.html">总纲</a></li>
<li><a href="MultiThreading/./README.html">Java多线程系列--基础知识手册</a></li>
<li><a href="MultiThreading/./post_37.html">Java基础--图解JVM内存模型和JVM线程模型</a></li>
<li><a href="MultiThreading/./post_38.html">Java多线程系列--掌控面试，一文吃透Synchronized锁</a></li>
<li><a href="MultiThreading/./README.html">Java多线程系列--一文吃透AQS</a></li>
<li><a href="MultiThreading/./README.html">Java多线程系列--一文吃透Lock锁</a></li>
<li><a href="MultiThreading/./post_39.html">Java多线程基础--线程生命周期与线程协作详解</a></li>
<li><a href="MultiThreading/./post_42.html">Java多线程基础--线程的创建与线程池管理</a></li>
<li><a href="MultiThreading/./post_46.html">Java多线程系列--掌握Future，轻松获取异步任务结果</a></li>
<li><a href="MultiThreading/./post_50.html">Java多线程系列--Fork&amp;Join框架，分治的艺术</a></li>
<li><a href="MultiThreading/./post_54.html">Java多线程系列--掌握CompletableFuture，驾驭异步编程</a></li>
<li><a href="MultiThreading/./README.html">Java多线程系列--并发工具JUC</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java多线程系列总纲"><a class="header" href="#java多线程系列总纲">Java多线程系列总纲</a></h1>
<p>终于，开始着手写Java多线程系列了。 <strong>Java多线程系列</strong> 写起来不会很容易，一来：照本宣科是没有必要的，二来，完全脱离书本性知识又是 "空中楼阁"。</p>
<p>在我的计划中，每一篇文章：</p>
<ul>
<li>都从 <code>基础知识</code> 开始入手，整理 <code>必知必会</code> 的内容，这些内容也是面试的常客；</li>
<li>在此基础上，结合自身多年的工作经验，<code>挑选、设计案例进行一定地展开</code>，对于基础还不够牢的读者而言，可以在练手中理解书本内容；对于我以及诸位老司机，可以借机反思一下；</li>
<li>整理新收获，或者在某些点上深挖一下，<code>尝试突破</code>。</li>
</ul>
<h2 id="总纲"><a class="header" href="#总纲">总纲</a></h2>
<p>本篇作为系列的总纲，将发散性的谈一谈Java多线程的内容要点，系列文章将依次展开。</p>
<p>谈到多线程，绕不开的基本概念：操作系统中的 <code>进程</code> 和 <code>线程</code> 以及 JVM线程和操作系统线程的关系。在这个过程中，将涉及到：<code>JVM内存模型</code> 和 <code>JVM方法执行过程</code> 的知识；</p>
<p>*作者按：此处将产生一篇文章：<a href="MultiThreading/./post_37.html">Java基础--图解JVM内存模型和JVM线程模型</a> *</p>
<p>继而，我们又需要理解 <code>临界资源</code> 和 <code>临界区</code> 的概念，并且接触到 <code>锁</code> 、 <code>内存屏障</code> 、 <code>CAS</code> 、 <code>AQS</code> 的知识；</p>
<p><em>作者按：这部分基础知识，我将专门汇总一篇 <a href="MultiThreading/">Java多线程系列--基础知识手册</a>，其内容未必能完全详尽，每一块的内容将会在对应篇章中进行展开。锁的知识十分重要，将独立一篇文章：<a href="MultiThreading/./post_38.html">Java多线程系列--掌控面试，一文吃透锁</a></em></p>
<p><em>作者按：一文吃透锁太难了，拆分二至三篇文章 "一文吃透Synchronized锁" 、 "一文吃透AQS"，"一文吃透Lock锁"，2022-03-19</em></p>
<p>谈及一个事物，绕不开其生命周期、管理、作用关系；对于线程也是如此。</p>
<p><em>作者按：此处将产生两篇文章：<a href="MultiThreading/./post_39.html">Java多线程基础--线程生命周期与线程协作详解</a> ; <a href="MultiThreading/./post_42.html">Java多线程基础--线程的创建与线程池管理</a></em></p>
<p>至此，我们发现，在多线程协作中，获取在异步的基础上获取结果非常的麻烦，庆幸的是，我们拥有Future这一利器；</p>
<p><em>作者按：此处将产生一篇文章 <a href="MultiThreading/./post_46.html">Java多线程系列--掌握Future，轻松获取异步任务结果</a></em></p>
<p>人总是贪心的，当我们想到可以异步去利用机器性能时，自然会考虑利用并发去充分利用机器性能，但 "左右互搏之术" 很难驾驭，一不小心就会走火入魔，写出bug。
如果一个大型任务可以很方便的被拆分成各种小任务并最终合并得到结果，参考阿姆达尔定律 (Amdahl's Law)，则可以充分利用计算资源。</p>
<p><em>作者按：此处将产生一篇文章 <a href="MultiThreading/./post_50.html">Java多线程系列--Fork&amp;Join框架，分治的艺术</a></em></p>
<p>岁月静好，但Future也有缺陷，我们需要优雅、优雅、优雅地实现异步，驾驭异步。</p>
<p><em>作者按：此处将产生一篇文章 <a href="MultiThreading/./post_54.html">Java多线程系列--掌握CompletableFuture，驾驭异步编程</a></em></p>
<p>至此，武功已经练成，但工欲善其事必先利其器，我们需要还有各类工具帮助我们写好多线程代码。</p>
<p><em>作者按：此处将产生一篇文章 <a href="MultiThreading/">Java多线程系列--并发工具JUC</a></em></p>
<p>至此，我们将至少产生9篇文章，但多线程的知识远不止这么多，创作过程中可能会进行增加，完成情况可以参考下面，喜欢在其他平台阅读的可跳转到掘金或CSDN</p>
<p>完成情况：</p>
<ul>
<li>-[ ] <a href="MultiThreading/">Java多线程系列--基础知识手册</a></li>
<li>-[x] <a href="MultiThreading/./post_37.html">Java基础--图解JVM内存模型和JVM线程模型</a>, 其他平台：<a href="https://juejin.cn/post/7068941257074016263/">掘金</a>, <a href="https://blog.csdn.net/a774057695/article/details/123152488">CSDN</a></li>
<li>-[x] <a href="MultiThreading/./post_38.html">Java多线程系列--掌控面试，一文吃透Synchronized锁</a> <em><del>Java多线程系列--掌控面试，一文吃透锁</del> 更名为：Java多线程系列--掌控面试，一文吃透Synchronized锁</em> <a href="https://juejin.cn/post/7076820950020259848/">掘金</a> <a href="https://blog.csdn.net/a774057695/article/details/123604669">CSDN</a></li>
<li>-[x] <a href="MultiThreading/./post_39.html">Java多线程基础--线程生命周期与线程协作详解</a>，其他平台：<a href="https://juejin.cn/post/7080088772754292744/">掘金</a>, <a href="https://blog.csdn.net/a774057695/article/details/123801729">CSDN</a></li>
<li>-[x] <a href="MultiThreading/./post_42.html">Java多线程基础--线程的创建与线程池管理</a>,其他平台: <a href="https://juejin.cn/post/7098235227490746375/">掘金</a> , <a href="https://blog.csdn.net/a774057695/article/details/124800874">CSDN</a></li>
<li>-[x] <a href="MultiThreading/./post_46.html">Java多线程系列--掌握Future，轻松获取异步任务结果</a>,其他平台：<a href="https://juejin.cn/post/7147552484213719076">掘金</a> , <a href="https://blog.csdn.net/a774057695/article/details/127051722">CSDN</a></li>
<li>-[x] <a href="MultiThreading/./post_50.html">Java多线程系列--Fork&amp;Join框架，分治的艺术</a> ，<a href="https://juejin.cn/post/7204782377348726840/">掘金</a> ， <a href="https://blog.csdn.net/a774057695/article/details/129250701">CSDN</a></li>
<li>-[x] <a href="MultiThreading/./post_54.html">Java多线程系列--掌握CompletableFuture，驾驭异步编程</a>，<a href="https://juejin.cn/post/7219943233799159864/">掘金</a> , <em>CSDN停止更新</em></li>
<li>-[ ] <a href="MultiThreading/">Java多线程系列--并发工具JUC</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java基础--图解jvm内存模型和jvm线程模型"><a class="header" href="#java基础--图解jvm内存模型和jvm线程模型">Java基础--图解JVM内存模型和JVM线程模型</a></h1>
<h2 id="前言-12"><a class="header" href="#前言-12">前言</a></h2>
<p>各位亲爱的读者朋友，我正在创作 <code>Java多线程系列</code> 文章，严格的说，<strong>JVM内存模型的知识并不隶属于Java多线程范畴</strong>，但在讨论多线程的过程中，会涉及到相关概念，考虑到它作为 <code>面经常客</code>，故单独成篇进行知识梳理。</p>
<p><em>在有意无意渲染之下，环境中充斥着焦虑，虽然我并不认为正经面试真的有必要考察这些，毕竟没有几个岗位是开发JVM的。本篇文章将尽最大努力做到容易记忆，帮助各位克服焦虑！</em></p>
<p>在本篇中，将JVM内存模型以及JVM线程模型的关键知识，形成凝练的图、辅以文字，同读者一起回顾并掌握这些知识。</p>
<p><em>作者按：本篇按照自己有限的知识进行整理，如有谬误，还请读者在评论区不吝指出</em></p>
<blockquote>
<p>了解系列以及总纲：<a href="https://leobert-lan.github.io/MultiThreading/post_33.html">Java多线程系列</a></p>
</blockquote>
<p>先来看一张 <strong>较为完整</strong> 的图：</p>
<p><img src="MultiThreading/./post_37/jvm_memory_structure.png" alt="" /></p>
<p><em>作者按：图片源自亿图图示的模板</em></p>
<p>再右侧再补充GC部分后，就比较完整了。今天的文章中，类加载部分略去，GC部分略去。</p>
<p><em>作者按：读者朋友们还是应当将这两部分吃透的，如果面试遇到，可以顺着图展开作答</em></p>
<p><strong>图中的 <code>Java栈</code> 又称为 <code>Java虚拟机栈</code> 、 <code>虚拟机栈</code> 、 <code>JVM栈</code> 等； <code>本地栈</code> 即 <code>本地方法栈</code></strong></p>
<h2 id="jvm内存模型"><a class="header" href="#jvm内存模型">JVM内存模型</a></h2>
<p>从上图中，我们将运行时数据区剥出来，形成下图，即JVM内存模型 <em>(内存区域)</em>：</p>
<p><img src="MultiThreading/./post_37/jvm_memory.png" alt="" /></p>
<p><strong>在JVM1.8中，图中的 <code>方法区</code> 为 <code>元数据区</code></strong></p>
<blockquote>
<p>在多线程背景下，我们应个景：</p>
<ul>
<li>堆和方法区是 <strong>线程共享</strong> 的</li>
<li>虚拟机栈、本地方法栈、程序计数器是 <strong>线程隔离</strong> 的</li>
</ul>
</blockquote>
<p>下面展开谈一谈这五个区域的作用。</p>
<p><em>以Java虚拟机规范为界，不讨论具体实现</em></p>
<h3 id="方法区jvm18为元数据区"><a class="header" href="#方法区jvm18为元数据区">方法区（JVM1.8为元数据区）</a></h3>
<p>方法区的作用为：存放虚拟机加载的：类型信息，域（Field）信息，方法（Method）信息，常量，静态变量，即时编译器编译后的代码缓存</p>
<p>值得注意的是，无法申请到内存时，将抛出 <code>OutOfMemoryError</code></p>
<p>方法区中存在运行时常量池，字面量、符号引用等存放入其中。</p>
<p>在Hotspot的演变过程中：</p>
<ul>
<li>Java6及之前：方法区存在永久代，保存有静态变量</li>
<li>Java7：进行去永久代工作，虽然还保留着，但静态常量池，如字符串常量池，已经移动到堆中</li>
<li>Java8：移除永久代，类型信息、域（Field）信息、方法（Method）信息存放在元数据区；字符串常量池、静态变量存放在堆区</li>
</ul>
<p><em>作者按：不同的虚拟机实现细节我也没有研究过，感兴趣的读者可以自行研究，如有靠谱文章希望分享下</em></p>
<h3 id="虚拟机栈"><a class="header" href="#虚拟机栈">虚拟机栈</a></h3>
<p>虚拟机栈中保存了 <strong>每一次</strong> <code>方法调用</code> 的信息。</p>
<p>每个Java线程创建时，都会创建对应的 <code>虚拟机栈</code> ，每一次方法调用，都会往栈中压入一个 <code>栈帧</code>。如下图：</p>
<p><img src="MultiThreading/./post_37/stack_frame.png" alt="" /></p>
<p>而栈帧中，包含：</p>
<ul>
<li>局部变量表：保存函数 <em>（即方法）</em> 的局部变量</li>
<li>操作数栈：保存计算过程中的结果，即临时变量</li>
<li>动态链接：指向方法区的运行时常量池。字节码中的 <code>方法调用指令</code> 以常量池中指向方法的 <code>符号引用</code> 为参数。</li>
<li>方法的返回地址</li>
</ul>
<h3 id="本地方法栈"><a class="header" href="#本地方法栈">本地方法栈</a></h3>
<p>和虚拟机栈功能上类似，它管理了native方法的一些执行细节，而虚拟机栈管理的是Java方法的执行细节。</p>
<h3 id="程序计数器"><a class="header" href="#程序计数器">程序计数器</a></h3>
<p>程序计数器记录线程执行的字节码行号，<em>如果当前线程正在运行native方法则为空</em>。也有称之为 <code>PC寄存器</code></p>
<p>字节码解释器在工作时，通过改变计数器的值来选取下一跳需要执行的字节码指令，<code>分支</code> 、 <code>循环</code> 、
<code>跳转</code> 、 <code>异常处理</code> 、<code>线程恢复</code> 等基本功能都需要依赖计数器来完成。</p>
<blockquote>
<p>Java虚拟机的多线程实现方式：通过 <strong>轮流切换并分配处理器执行时间</strong> 实现</p>
</blockquote>
<p>所以，在任意确定的时间点，一个处理器只会处理一个线程中的指令。为了正确地处理 <strong>线程切换后的任务恢复</strong> ，每一个线程都具有自身的程序计数器</p>
<h3 id="堆"><a class="header" href="#堆">堆</a></h3>
<p>堆提供了类实例和数组的内存，可以按如下方式划分：</p>
<ul>
<li>新生代 <em>亦可称之年轻代、New Generation</em>
<ul>
<li>Eden区</li>
<li>Survivor 区 <em>S0和S1中存在互相移动，一些文章中的from、to是指移动上的逻辑关系</em>
<ul>
<li>S0</li>
<li>S1</li>
</ul>
</li>
</ul>
</li>
<li>老年代 <em>Old Generation</em></li>
</ul>
<p>如下图所示：</p>
<p><img src="MultiThreading/./post_37/jvm_heap.png" alt="" /></p>
<p>划分和对象创建与GC有关，</p>
<ul>
<li>新生成的对象在Eden区</li>
<li>触发 Minor GC后，还 "幸存" 的对象移动到S0</li>
<li>再次触发Minor GC后，S0和Eden 中存活的对象被移动到S1中，S0清空</li>
<li>每次移动时，自动递增计数器，超过默认值时 <em>（印象中是16）</em>，移动到老年代，如果Eden中没有足够内存分配，也将直接在老年代中分配内存</li>
<li>老年代中依靠Major GC</li>
</ul>
<h3 id="小总结"><a class="header" href="#小总结">小总结</a></h3>
<p>将上文的知识点进行汇总后，我们可以得到一张新图：</p>
<p><img src="MultiThreading/./post_37/JVM_1_8.jpg" alt="" /></p>
<p><em>图片来自亿图图示模板，再次不用画图了😂</em></p>
<h2 id="jvm线程模型"><a class="header" href="#jvm线程模型">JVM线程模型</a></h2>
<p>一个Java线程的实现方式可以有三种：</p>
<ul>
<li>使用内核线程实现</li>
<li>使用用户线程实现</li>
<li>使用用户线程加轻量级进程混合实现</li>
</ul>
<p>印象中JVM没有规定线程实现的规范，具体研究需要结合具体的JVM实现，下面我们简单探索一下</p>
<h3 id="内核线程模型"><a class="header" href="#内核线程模型">内核线程模型</a></h3>
<p>内核线程模型: 完全依赖操作系统内核提供的内核线程（Kernel-Level Thread ，KLT）来实现多线程。这种方式下：<code>线程的切换调度</code> 由 <code>系统内核</code> 完成。</p>
<p>一般而言，程序不会直接使用内核线程，而是使用一种 <strong>高级接口</strong> 即 <code>轻量级进程</code>（Light Weight Process,LWP）。</p>
<p><img src="MultiThreading/./post_37/jvm_thread_model1.png" alt="" /></p>
<p><em>图片来自网络</em></p>
<p>用户进程中，通过 <code>LWP</code> 使用系统的 <code>内核线程</code> 。由于其一对一的关系，又称为 <code>一对一模型</code></p>
<p>由于 <code>用户线程</code> 与 <code>LWP</code> 一一对应，<code>LWP</code> 是独立的调度单元，因此某个LWP在 <strong>用户进程调用过程中</strong> 发生阻塞，以及在 <strong>系统调用中</strong> 发生了阻塞，都不会影响整个进程的执行。</p>
<p>但是LWP依托内核线程，所以 <strong>线程操作</strong> 需要 <strong>依赖系统调用</strong> ，代价是较高的，需要在 <code>用户态（User Mode）</code> 和 <code>内核态（Kernel Mode）</code> 中来回切换；
而且每个 <code>LWP</code> 都需要一个 <code>内核线程</code> 进行支持，因此 <code>LWP</code> 要消耗一定的内核资源，因此一个系统仅可支持 <strong>少量有限</strong> 的 <code>LWP</code>。</p>
<h3 id="用户线程模型"><a class="header" href="#用户线程模型">用户线程模型</a></h3>
<p>排除掉 <code>内核线程</code> ，JVM平台也可以实现 <code>用户线程 User Thread</code> 下文简称 <code>UT</code> ，完全自行实现创建、调度、销毁。</p>
<p>区别于内核线程模型，此时线程的调度不再依赖内核，极少占据内核资源，基本限定在用户态内，所以可以突破量的限制，并且减少线程切换时的损耗。</p>
<p>这样看起来似乎很美好，但难以利用多核CPU的优势，并且一旦产生系统调用发生中断，其他线程也将被中断。</p>
<p>这种 <code>多对一模型</code> 的实用性较低。</p>
<p><img src="MultiThreading/./post_37/jvm_thread_model2.png" alt="" /></p>
<h3 id="混合模型"><a class="header" href="#混合模型">混合模型</a></h3>
<p>又称 <code>多对多模型</code> ，这种方式充分利用了上面两种方式的优点。</p>
<p><img src="MultiThreading/./post_37/jvm_thread_model3.png" alt="" /></p>
<p>这种模型中，既存在UT，也存在LWP。</p>
<p>创建、切换线程(UT)依旧是廉价的，并且可以拥有大量的线程；同时利用 LWP作为UT到KLT（内核线程）的桥梁，
享受了系统内核的线程调度、CPU映射，免去了自行实现系统调用的部分，进行系统调用时，阻塞整个进程的概率也低于 <code>用户线程模型</code> 。</p>
<h2 id="后记"><a class="header" href="#后记">后记</a></h2>
<p>又水了一篇文章，相信各位读者朋友已经基本记住了这些内容，可以愉快的侃大山了。希望疫情早日结束。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java多线程系列--掌控面试一文吃透synchronized锁"><a class="header" href="#java多线程系列--掌控面试一文吃透synchronized锁">Java多线程系列--掌控面试，一文吃透Synchronized锁</a></h1>
<h2 id="前言-13"><a class="header" href="#前言-13">前言</a></h2>
<p>各位亲爱的读者朋友，我正在创作 <code>Java多线程系列</code> 文章，本篇我们将分析重点内容：<code>锁</code></p>
<p>锁是 <strong>面试中的常客</strong> ，也是多线程编码中 <strong>必不可少</strong> 的内容，无论是为了 <strong>"面试胜利"</strong> ，还是 <strong>"写出高质量的代码"</strong> ，我们都需要掌握它。</p>
<p><em>作者按：本篇按照自己有限的知识进行整理，如有谬误，还请读者在评论区不吝指出</em></p>
<blockquote>
<p>了解系列以及总纲：<a href="https://leobert-lan.github.io/MultiThreading/post_33.html">Java多线程系列</a></p>
</blockquote>
<p>本文篇幅较长，内容较为跳跃，可参考导图阅读：</p>
<p><img src="MultiThreading/./post_38/guide.png" alt="" /></p>
<h2 id="前文拾遗----java对象结构"><a class="header" href="#前文拾遗----java对象结构">前文拾遗 -- JAVA对象结构</a></h2>
<p>先前已经发布过一篇系列文章：<a href="https://juejin.cn/post/7068941257074016263">克服焦虑--图解JVM内存模型和JVM线程模型</a></p>
<p>其中还有一处关键知识没有展开："Java对象包含哪些内容"，这部分内容和锁的实现有关，本篇将由此继续展开。</p>
<p>单刀直入，在HotSpot虚拟机中，一个对象实例可以被划分出三块信息：</p>
<ul>
<li>对象头 Header</li>
<li>实例数据 Instance Data，亦有称之对象体</li>
<li>对齐填充 Padding</li>
</ul>
<p>其中对齐填充可能存在，实例数据是供给 <code>应用程序逻辑</code> 使用的，存储了实例的字段信息。接下来重点探讨对象头。</p>
<h3 id="java对象头"><a class="header" href="#java对象头">Java对象头</a></h3>
<p>对象头部分的信息主要面向JVM，包含：</p>
<ul>
<li>Mark Word</li>
<li>kclass, 对象对应的类的元数据指针</li>
<li>array length ，仅数组对象才拥有</li>
</ul>
<p>整体划分如图所示：</p>
<p><img src="MultiThreading/./post_38/jvm_header.jpeg" alt="" /></p>
<p><em>图片来自网络搜索，水印为Java帮帮</em></p>
<h4 id="mark-word"><a class="header" href="#mark-word">Mark Word</a></h4>
<p>Mark Word 用于存储对象运行时数据： <code>哈希</code>、<code>GC分代年龄</code>、<code>锁状态标志</code>、<code>线程持有的锁</code>、<code>偏向线程ID</code>、<code>偏向时间戳</code> 等。</p>
<p>查找 HotSpot中markOop的doc如下：</p>
<pre><code class="language-java">// The markOop describes the header of an object.
// Note that the mark is not a real oop but just a word.
// It is placed in the oop hierarchy for historical reasons.
//
// Bit-format of an object header (most significant first, big endian layout below):
//
//  32 bits:
//  --------
//  hash:25 ------------&gt;| age:4    biased_lock:1 lock:2 (normal object)
//  JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)
//  size:32 ------------------------------------------&gt;| (CMS free block)
//  PromotedObject*:29 ----------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)
//
//  64 bits:
//  --------
//  unused:25 hash:31 --&gt;| unused:1   age:4    biased_lock:1 lock:2 (normal object)
//  JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)
//  PromotedObject*:61 ---------------------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)
//  size:64 -----------------------------------------------------&gt;| (CMS free block)
//
//  unused:25 hash:31 --&gt;| cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; normal object)
//  JavaThread*:54 epoch:2 cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; biased object)
//  narrowOop:32 unused:24 cms_free:1 unused:4 promo_bits:3 -----&gt;| (COOPs &amp;&amp; CMS promoted object)
//  unused:21 size:35 --&gt;| cms_free:1 unused:7 ------------------&gt;| (COOPs &amp;&amp; CMS free block)
</code></pre>
<p><em>32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit，开启压缩后为32bit</em></p>
<p>梳理64位虚拟机五种状态下的对象头：</p>
<pre><code class="language-commandline">|------------------------------------------------------------------------------------------------------------------|
|                                     Object Header(128bits)                                                       |
|---------------------|--------------------------------------------------------------------------------------------|
|       State         |                                   Mark Word(64bits)               |  Klass Word(64bits)    |
|---------------------|--------------------------------------------------------------------------------------------|
|       Nomal         | unused:25|identity_hashcode:31|unused:1|age:4|biase_lock:1|lock:2 | OOP to metadata object |
|---------------------|--------------------------------------------------------------------------------------------|
|       Biased        | thread:54|      epoch:2       |unused:1|age:4|biase_lock:1|lock:2 | OOP to metadata object |
|---------------------|--------------------------------------------------------------------------------------------|
|  Lightweight Locked |                     ptr_to_lock_record:62                 |lock:2 | OOP to metadata object |
|---------------------|--------------------------------------------------------------------------------------------|
|  Heavyweight Locked |                    ptr_to_heavyweight_monitor:62          |lock:2 | OOP to metadata object |
|---------------------|--------------------------------------------------------------------------------------------|
|     Marked for GC   |                                                           |lock:2 | OOP to metadata object |
|---------------------|--------------------------------------------------------------------------------------------|
</code></pre>
<p><em>排版不方便的话看下图：</em></p>
<p><img src="MultiThreading/./post_38/jvm_header_64.png" alt="" /></p>
<p>如果运行在 HotSpot openJdk VM 上，可以借助："org.openjdk.jol:jol-core:0.9" 打印对象头进行对照。</p>
<p><a href="https://blog.csdn.net/qdh186/article/details/96162413">五种状态下分析对象头的一份参考博客</a></p>
<p><em>作者按：此处的知识我们留一个印象即可，Android同学可能只能拿来吹牛</em></p>
<p>归纳后知识概要如图：</p>
<p><img src="MultiThreading/./post_38/jvm_obj_structure.png" alt="" /></p>
<p><em>注：32位</em></p>
<h2 id="锁的常见概念分类"><a class="header" href="#锁的常见概念分类">锁的常见概念、分类</a></h2>
<p>我们平时会听到关于锁的各种概念名词，前文的表中，我们也看到了 <code>偏向锁</code> <code>轻量级锁</code> <code>重量级锁</code> 的身影，接下来简单聊一聊分类以及常见概念。</p>
<h3 id="乐观锁--悲观锁"><a class="header" href="#乐观锁--悲观锁">乐观锁 / 悲观锁</a></h3>
<p>乐观锁和悲观锁是一种相对的 <strong>态度</strong> 。在并发的背景下，访问临界区时 <strong>可能会</strong> 发生 "冲突"，不同的态度演变出不同的策略。</p>
<p><strong>悲观</strong> 地看，可以 <strong>认为冲突一定会发生</strong> ：访问临界区时，自身线程的写入行为一定会影响其他线程，自身线程的读取行为一定会受到其他线程的写入影响！ 所以 <strong>必须要进行锁保护</strong> ，通过 "独占"，"排他" 等特性，保障无冲突。
即：<strong>悲观地认为，不加锁的并发操作一定会出现冲突，必须加锁</strong></p>
<p><strong>乐观</strong> 地看，可以 <strong>认为发生冲突是场景限定的事件</strong> ：读不会有冲突，但写入存在冲突可能。所以 <strong>只有在写操作时，进行冲突检测，检测到冲突时操作就会失败，返回错误信息</strong></p>
<p>在Java中，悲观锁即各种实际的锁实现，而乐观锁即无锁编程，转为使用CAS算法。</p>
<h3 id="独享锁--共享锁"><a class="header" href="#独享锁--共享锁">独享锁 / 共享锁</a></h3>
<p>锁可以被访问者独享或者共享，直白地讲：独享锁在某一时间点，只能被一个线程获取，其它线程必须等待锁被持有者释放之后，才可能获取到锁，而共享锁可以被多个线程获取。</p>
<p>独享锁又称独占锁、排它锁。</p>
<p>显然，共享锁认为持有它的线程们在并发操作时并不会发生冲突。</p>
<h3 id="可重入锁--非可重入锁"><a class="header" href="#可重入锁--非可重入锁">可重入锁 / 非可重入锁</a></h3>
<p>从概念上看：一个线程在持有一个锁的时候，它内部能否再次（多次）申请该锁，如果可以则为可重入锁，否则为不可重入锁。</p>
<p>显然易见：<code>不可重入</code> 将大大增加 <code>死锁</code> 的机率。</p>
<p><em>作者按：但在线程的基础上实现类似协程的机制时，非可重入将具有重要意义。</em></p>
<h3 id="公平锁--非公平锁"><a class="header" href="#公平锁--非公平锁">公平锁 / 非公平锁</a></h3>
<p>锁需要通过竞争获取，公平 / 非公平指的是 是否按照"先来后到"获取锁。</p>
<p>如果按照申请顺序分配锁，则为公平锁，否则为非公平锁。</p>
<p>我们常用的Synchronized即非公平锁，Java的可重入锁（ReentrantLock）默认为非公平锁，但可以实例化为公平锁。</p>
<p>非公平锁的优点在于吞吐量比公平锁大。</p>
<h3 id="互斥锁读写锁"><a class="header" href="#互斥锁读写锁">互斥锁、读写锁</a></h3>
<p>独享锁、共享锁的具体实现，读写锁作为读模式时是共享锁。</p>
<p>Java中的 <code>ReentrantLock</code> 是互斥锁，<code>ReadWriteLock</code> 是读写锁实现。</p>
<h3 id="分段锁"><a class="header" href="#分段锁">分段锁</a></h3>
<p>分段锁并非是一种锁，而是一种提高效率的设计思路，将临界区进行划分，当某一块区域的写入并不影响其他区域的读取时，就可以采用分段的思路， 对写入区域加锁，读取其他区域则无需竞争锁从而提高效率，例如 <code>ConcurrentHashMap</code>
就采用了这一设计</p>
<h3 id="偏向锁--轻量级锁--重量级锁"><a class="header" href="#偏向锁--轻量级锁--重量级锁">偏向锁 / 轻量级锁 / 重量级锁</a></h3>
<p>专指 <code>synchronized</code> 的三种锁状态，并且关系到后文中的 <code>锁升级</code> 部分。</p>
<p>在前文中，我们花了很多篇幅梳理 <code>对象头</code> 中的 <code>Mark Word</code>，其中有三种状态：Biased，Lightweight Locked，Heavyweight Locked 于此对应。</p>
<ul>
<li>偏向锁状态：同步代码一直被同一线程访问时，该线程会自动获取锁，降低获取锁的代价。</li>
<li>轻量级锁状态：在偏向锁状态时，一旦另一线程竞争该锁，则升级为轻量级锁，竞争的线程通过 <code>有限的自旋</code> 尝试获取锁，如果锁的持有者在此过程中 <strong>释放了锁</strong> ， 并被该线程成功获取锁，则可以避免阻塞，减少线程切换，*
挂起和恢复线程是较为昂贵的*。</li>
<li>重量级锁状态：当线程完成了有限的自旋后依旧未能获得锁，将不得不进行阻塞以免空耗CPU，此时锁升级为重量级锁</li>
</ul>
<p>不难理解，按照Java的线程模型，<strong>仅多核CPU情况下，采用轻量级锁并利用自旋才有意义</strong>。如果是单核CPU，并不存在真正的时间意义上的线程并发，自旋时，持有锁的线程是挂起的，并无释放锁的可能</p>
<p><em>作者按：Java的线程模型可参见拙作：<a href="https://juejin.cn/post/7068941257074016263">克服焦虑--图解JVM内存模型和JVM线程模型</a></em></p>
<h3 id="自旋锁"><a class="header" href="#自旋锁">自旋锁</a></h3>
<p>基于CAS利用自旋去竞争锁实现同步的一种方式，如前文所言，发生竞争而产生自旋时，当前线程不会阻塞，所以不会直接导致系统调用，减少上下文切换的开销，
但如果一直竞争不到锁，将造成CPU空转，所谓的busy-waiting。对于计算密集型程序而言，可能会带来负面效果。</p>
<p>我们可以利用Atomic实现一个简单的 <code>可重入自旋锁</code></p>
<pre><code class="language-java">public class ReentrantSpinLock {
    private AtomicReference&lt;Thread&gt; cas = new AtomicReference&lt;Thread&gt;();
    private int count;

    public void lock() {
        Thread current = Thread.currentThread();
        if (current == cas.get()) {
            count++;
            return;
        }
        while (!cas.compareAndSet(null, current)) {
            // Do nothing
        }
    }

    public void unlock() {
        Thread cur = Thread.currentThread();
        if (cur == cas.get()) {
            if (count &gt; 0) {
                count--;
            } else {
                cas.compareAndSet(cur, null);
            }
        }
    }
}
</code></pre>
<p>很显然，这也是一个非公平锁、独享锁</p>
<h2 id="synchronized锁"><a class="header" href="#synchronized锁">Synchronized锁</a></h2>
<p><code>synchronized</code> 作为Java关键字，提供同步能力，其核心依赖于Java对象的对象头，当一个类对象被作为synchronized锁对象时，其即为 <code>Monitor</code>，JVM通过
<strong>进入、退出Monitor</strong> 来实现同步</p>
<pre><code class="language-java">class Foo {

    synchronized static foo() {
    }

    synchronized void bar() {
    }

    void baz() {
        synchronized (Foo.class) {
            //同步块
        }
    }
}
</code></pre>
<p>如上代码中展示了三种同步的方式：</p>
<ul>
<li><code>foo()</code> 中锁对应的Monitor为 <code>Foo.class</code></li>
<li><code>bar()</code> 中锁对应的Monitor为 Foo 的对象实例</li>
<li><code>baz()</code> 中的同步块可以用任意的对象作为Monitor，演示部分使用了 <code>Foo.class</code> 作为Monitor</li>
</ul>
<p>注意，Monitor的选取务必慎重，不仅仅要从 <code>同步</code> 的需求角度出发，避免性能损耗，也要注意锁无法正常生效的问题。例如：</p>
<p>我们模拟5个线程同时竞争一个数（初始值为6）并做 <code>--</code> 运算，读者是否认为它会按照 <code>5、4、3、2、1</code> 的顺序输出？</p>
<pre><code class="language-java">class Foo {

  Integer integer = 6;

  void minus() {
    synchronized (integer) {
      if (integer &gt; 0) {
        integer--;
      }
      System.out.println(Thread.currentThread().getId() + " -&gt; i:" + integer);
    }
  }

  static class MThread extends Thread {
    final Foo foo;
    final CountDownLatch latch;

    MThread(Foo foo, CountDownLatch latch) {
      this.foo = foo;
      this.latch = latch;
    }

    @Override
    public void run() {
      super.run();
      try {
        latch.await();
        foo.minus();
      } catch (InterruptedException e) {
        e.printStackTrace();
      }

    }
  }

  public static void main(String[] args) {
    Foo foo = new Foo();
    CountDownLatch latch = new CountDownLatch(1);

    for (int i = 0; i &lt; 5; i++) {
      new MThread(foo,latch).start();
    }
    latch.countDown();
    try {
      Thread.sleep(1000);
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
  }
}
</code></pre>
<p>多执行几次就会发现 <code>可能</code> 会像下面的结果，它并非是一个同步情况的结果，<em>如果想要更顺利的模拟问题的出现，增大线程数即可</em></p>
<pre><code class="language-java">&gt; Task :Foo.main()
13 -&gt; i:3
15 -&gt; i:4
12 -&gt; i:3
14 -&gt; i:1
11 -&gt; i:2
</code></pre>
<p>如果读者注意了lint，会注意到提示：Synchronization on a non-final field 'integer'</p>
<p>很显然，上面的代码并未采用正确的Monitor，在 <code>integer--</code> 的过程中，integer实例已经发生变化：</p>
<pre><code class="language-java">System.out.println(Thread.currentThread().getId() + 
        " -&gt; i:" + integer+","+System.identityHashCode(integer));
</code></pre>
<p>我们增加identityHashCode，并增大并发数量到10，输出如下：</p>
<pre><code class="language-java">13 -&gt; i:0,482590393
15 -&gt; i:1,1722967101
11 -&gt; i:3,1130778910
16 -&gt; i:0,482590393
17 -&gt; i:0,482590393
20 -&gt; i:0,482590393
12 -&gt; i:4,685260083
14 -&gt; i:2,1983109557
19 -&gt; i:0,482590393
18 -&gt; i:0,482590393
</code></pre>
<p>显然，<strong>锁了个寂寞</strong> 。<em>当然，该问题深入研究下去，读者可以一直挖到动态常量池，不再展开</em>。</p>
<p>所以，编码中一定要保持好习惯：<code>Monitor对象不可变</code>，无形中就避开了bug。</p>
<h3 id="锁升级"><a class="header" href="#锁升级">锁升级</a></h3>
<p>前文已经提到了锁的升级：</p>
<blockquote>
<p>偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁 , 锁的升级是单向的</p>
</blockquote>
<p>这其实是 <code>synchronized</code> 内部实现上对锁方式的优化</p>
<h4 id="转换原因"><a class="header" href="#转换原因">转换原因</a></h4>
<p>很显然，这一过程充分考虑各种锁的优点和缺点，在相应场景下以期获得最好的性能。</p>
<ul>
<li>偏向锁：没有自旋、没有系统调用，所以 <strong>消耗少性能高</strong> ，并且具有可重入特性，在 <code>同一线程执行同步代码</code> 场景下是最优选择，但它具有 <strong>撤销锁消耗高</strong> 的缺点。</li>
<li>轻量级锁：前面已经提到，用CAS取代了阻塞，在 <code>锁持有时间短</code> 的场景下是最优选择，可追求 <code>快速响应</code> ，但缺点是短时间内无法获取锁时，自旋消耗CPU资源。</li>
<li>重量级锁：具备 <code>大吞吐量</code> ，未竞争到锁的线程不会自旋消耗资源，适合 <code>锁占用时间长，吞吐量需求大</code> 的场景</li>
</ul>
<p>而从 <strong>偏向锁到轻量级锁</strong>，意味着多线程竞争，假定锁的持有时间不会太长，有限的自旋可以等到持有者释放锁，而当 <strong>轻量级锁升级到重量级锁</strong> ，意味着这一 <strong>假设不成立</strong> ，自旋只是在白白消耗，通过挂起和等待唤醒以提升吞吐量</p>
<h4 id="转换过程"><a class="header" href="#转换过程">转换过程</a></h4>
<p><img src="MultiThreading/./post_38/Synchronization.gif" alt="" /></p>
<p>从OpenJdk的 <a href="MultiThreading/%5Bhttps://wiki.openjdk.java.net/display/HotSpot/Synchronization">WIKI -- Synchronization</a> 可以得到这张图。</p>
<p>为广泛流传的下图的原版
<img src="MultiThreading/./post_38/synchronized2.png" alt="" /></p>
<p>一图胜千言，图中表现的非常明确，读者可以结合WIKI内容自行理解，不再多做赘述。</p>
<p>经常在课程广告中出现的一张图如下,收藏不等于学会：</p>
<p><img src="MultiThreading/./post_38/java_sync.jpg" alt="" /></p>
<p><em>图片水印Blog.Dreamtobe.cn</em></p>
<h2 id="一段很长的后记"><a class="header" href="#一段很长的后记">一段很长的后记</a></h2>
<p>在拟定系列大纲时，本篇的原名为：<code>Java多线程系列--掌控面试，一文吃透锁</code>，然而写至 <code>JDK中的Lock接口</code> 时，
后知后觉的意识到将 <strong>不得不深入源码</strong> 并且涉及到 <code>AQS</code>，AQS的内容在大纲中已有单篇计划，展开则篇幅过长不利于阅读，不展开则实在无内容可写。</p>
<p>原章节内容权且作为 <strong>开端</strong> 、 <strong>引子</strong> 留于文末：</p>
<h3 id="jdk中的lock接口"><a class="header" href="#jdk中的lock接口">JDK中的Lock接口</a></h3>
<p>在Jdk1.5之后，存在Lock接口：</p>
<pre><code class="language-java">public interface Lock {
    //获取锁
    void lock();

    //获取锁，如果线程阻塞状态（未获取到而进入阻塞）被中断则抛出异常
    void lockInterruptibly() throws InterruptedException;

    //尝试获取锁
    boolean tryLock();

    //在给定时间内尝试获取锁，
    boolean tryLock(long var1, TimeUnit var3) throws InterruptedException;

    void unlock();

    Condition newCondition();
}
</code></pre>
<p>前四个API均为获取锁的API，<code>unlock</code> 释放锁，通过Condition提供线程通信能力. <em>Condition将在以后的文章中展开</em></p>
<p>有别于语言关键字 <code>synchronized</code> , 在使用角度上，Lock将需要使用者自行获取锁、释放锁。在内部实现上，区别于 <code>Monitor模式</code> ，增加了更丰富的功能：</p>
<ul>
<li>支持 <code>锁的公平性</code></li>
<li>获取 <code>当前线程调用lock的次数</code></li>
<li>获取 <code>等待锁的线程数</code></li>
<li>查询 <code>是否存在线程等待获取该锁</code></li>
<li>查询 <code>指定的线程是否在等待获取该锁</code></li>
<li>查询 <code>当前线程是否持有该锁</code></li>
<li>判断 <code>锁是否已被持有</code></li>
<li>加锁时如果中断则不加锁，抛出异常</li>
<li><code>尝试获取锁</code> 的机制，如果锁未被其他线程持有则成功，否则返回失败，不会直接进入阻塞</li>
</ul>
<p>很显然，<strong>限于目标和篇幅，这篇文章不会再和诸位读者一同探索源码</strong>，写至此处，我意识到真的无法做到标题中说的："一篇文章吃透锁"。
JDK中还有锁实现，例如常用的：</p>
<ul>
<li>ReentrantLock</li>
<li>ReadWriteLock，一般使用实现类 <code>ReentrantReadWriteLock</code></li>
</ul>
<p><em>作者按：一旦开始深入，将势必谈及AQS，按照计划，这将于后续文章中展开，故本篇不再展开。望读者见谅</em></p>
<h3 id="真正的后记"><a class="header" href="#真正的后记">真正的后记</a></h3>
<p>这一篇又断断续续写了超过一周，期间我也一度怀疑，这个系列要不要继续下去，对于读者而言，买本书钻研可能是比看本系列更加实在的行为，<code>勘校后的知识准确性</code> 、 <code>文字的准确性</code> 、
<code>表达的结构性</code> 都更胜一筹，博客仅能靠碎片化特性占点便宜。</p>
<p>但一件事情坚定了我将它写下去的信念，我翻看了往年的博客，清晰的意识到：</p>
<ul>
<li>将脑海中的知识，整理后再做 <code>结构化的输出</code> ，可以牢靠地掌握这些知识，并且在任意时刻都可以完成流畅的表达</li>
<li>通过对比，清晰的看到自己的成长</li>
<li>文字功力可以通过锻炼得到长足提升</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java多线程基础--线程生命周期与线程协作详解"><a class="header" href="#java多线程基础--线程生命周期与线程协作详解">Java多线程基础--线程生命周期与线程协作详解</a></h1>
<h2 id="前言-14"><a class="header" href="#前言-14">前言</a></h2>
<p>各位亲爱的读者朋友，我正在创作 <code>Java多线程系列</code> 文章，本篇我们将梳理基础内容：<code>线程生命周期与线程协作</code></p>
<p>这是非常基础的内容，本篇仅从 <strong>知识完整性</strong> 角度出发，做一次梳理。</p>
<p><em>作者按：本篇按照自己有限的知识进行整理，如有谬误，还请读者在评论区不吝指出</em></p>
<blockquote>
<p>了解系列以及总纲：<a href="https://leobert-lan.github.io/MultiThreading/post_33.html">Java多线程系列</a></p>
</blockquote>
<h2 id="线程生命周期"><a class="header" href="#线程生命周期">线程生命周期</a></h2>
<p>面向对象设计中，广义上对象均具备生命周期，在狭义上，<code>Thread</code> 类实例的 <code>状态</code> 状态的转变即为线程生命周期。</p>
<p>依据JDK 1.5 开始的代码，Thread实例的State存在6种：</p>
<ul>
<li>NEW</li>
<li>RUNNABLE</li>
<li>BLOCKED</li>
<li>WAITING</li>
<li>TIMED_WAITING</li>
<li>TERMINATED</li>
</ul>
<p>并且有如下生命周期图：</p>
<p><img src="MultiThreading/./post_39/thread_lifecycle1.jpeg" alt="" /></p>
<h3 id="new-新建"><a class="header" href="#new-新建">NEW 新建</a></h3>
<p>尚未 <code>start</code> 的线程的状态，从代码上看：</p>
<pre><code class="language-java">Thread thread=new Thread();
        thread.start();
</code></pre>
<p>在调用start前，即为 <code>NEW</code> 状态。</p>
<h3 id="runnable-可运行"><a class="header" href="#runnable-可运行">RUNNABLE 可运行</a></h3>
<p>当start方法被调用后，即进入 <code>RUNNABLE</code> 状态，注意：</p>
<ul>
<li>start方法多次调用将返回 <code>IllegalThreadStateException</code> 异常</li>
<li>RUNNABLE 存在两种细分：ready（就绪）和 running（运行），调用start时，如果native方法 <code>start0</code> 调用成功则线程就绪，调用失败则从 <code>ThreadGroup</code> 中移除。
就绪状态的线程被处理器调度获得CPU时间片，则变为 <code>running</code></li>
</ul>
<p><img src="MultiThreading/./post_39/thread_runnable.jpeg" alt="" /></p>
<h3 id="blocked-阻塞"><a class="header" href="#blocked-阻塞">BLOCKED 阻塞</a></h3>
<p>注意，JVM中线程的阻塞状态不同于操作系统的I/O阻塞，仅仅是在等待获取监视器锁，在JVM中，发生在进入（或者 调用过 <code>Object#wait()</code> 之后重新进入）synchronized 块/方法</p>
<h3 id="waiting-等待"><a class="header" href="#waiting-等待">WAITING 等待</a></h3>
<p>线程进入这种状态意味着：<strong>"等待其他线程执行特定操作"</strong>，笼统的从意图上看，它在等待其他线程的执行结果，当对方完成后唤醒它继续工作。</p>
<ul>
<li><code>Object#wait()</code> with no timeout</li>
<li><code>Thread#join()</code> with no timeout</li>
<li><code>LockSupport#park()</code></li>
</ul>
<p>如上三种方式可以让线程进入 <code>WAITING</code> 状态，只能等待其他线程进行唤醒</p>
<h3 id="timed_waiting-计时等待"><a class="header" href="#timed_waiting-计时等待">TIMED_WAITING 计时等待</a></h3>
<p>类似于 <code>WAITING</code> 只不过这种等待是有时限的，</p>
<ul>
<li>当前线程 <code>Thread#sleep</code> 调用</li>
<li>调用<code>Object#wait()</code> with timeout</li>
<li>对其他线程调用 <code>Thread#join(long)</code> with timeout</li>
<li><code>LockSupport#parkNanos</code></li>
<li><code>LockSupport#parkUntil</code></li>
</ul>
<p>会进入这种状态</p>
<h3 id="terminated-终止"><a class="header" href="#terminated-终止">TERMINATED 终止</a></h3>
<p>线程中的所有任务执行完毕后进入这种状态，运行时异常或者Error也会导致线程进入终止状态。</p>
<h3 id="小结"><a class="header" href="#小结">小结</a></h3>
<p>务必注意，以上6种状态是从jdk1.5开始引入的。</p>
<p>在一些博客、操作系统相关的书籍中，会看到类似下图的内容：</p>
<p><img src="MultiThreading/./post_39/os_thread_lifecycle.png" alt="" /></p>
<p>注意，这是操作系统层面进程、或者早期的单线程进程时期的进程生命周期，<strong>不能简单的和Java线程生命周期混为一谈</strong>。</p>
<p>可以和Java的线程状态进行如下的映射关联：</p>
<p><img src="MultiThreading/./post_39/thread_lifecycle.png" alt="" /></p>
<p>操作系统是从 <code>CPU使用</code> 的角度谈论线程的状态，而JVM是从自身 <code>管理、调度</code> 的角度谈论线程的状态，更贴切地讲是 <code>服务于监测</code> ，它受限于JVM显式引入的机制。不难理解：</p>
<ul>
<li>OS中的线程：ready、running均对应了 java线程的 <code>RUNNABLE</code> 状态；</li>
<li>而OS中的线程因为 <code>I/O</code> 或者 <code>Event wait</code> 让出CPU使用权进入 <code>waiting</code>，并且 <code>I/O、Event</code> 尚未完成时，并不会进入到可使用CPU的 <code>ready</code> 状态。 在JVM层面：
<ul>
<li>线程可能处在等待监视器锁的 <code>BLOCKED</code> 状态，</li>
<li>也可能是通过操作进入了 <code>WAITING、TIMED_WAITING</code> 状态，</li>
<li>也可能处于 <code>RUNNABLE</code> 状态 ，<em>例如I/O发生时</em></li>
</ul>
</li>
</ul>
<h2 id="线程api与线程协作"><a class="header" href="#线程api与线程协作">线程API与线程协作</a></h2>
<p>除却 <code>Thread</code> 中的API，<code>Object</code>中还有和监视器锁有关的API</p>
<h3 id="object相关api"><a class="header" href="#object相关api">Object相关API</a></h3>
<p>必须在同步代码中调用（准确的讲：获取了对应的锁方可调用），否则抛出 <code>IllegalMonitorStateException</code></p>
<pre><code class="language-java">Object#wait()
</code></pre>
<p>使当前线程 立刻 <strong>释放锁对象</strong> 、进入 <code>WAITING</code> 状态，直到被其他线程唤醒，进入等锁池。</p>
<pre><code class="language-java">Object#wait(long /*timeout*/)
</code></pre>
<p>和</p>
<pre><code class="language-java">Object#wait(long /*timeout*/,int /*nanos*/)
//jdk 1.8 源码附于下
</code></pre>
<p>使当前线程 立刻 <strong>释放锁对象</strong> 、进入 <code>TIMED_WAITING</code> 状态，直到被其他线程唤醒或者达到时间自动唤醒，进入等锁池。</p>
<pre><code class="language-java">//附 jdk 1.8
class Object {

    public final void wait(long timeout, int nanos) throws InterruptedException {
        if (timeout &lt; 0) {
            throw new IllegalArgumentException("timeout value is negative");
        }

        if (nanos &lt; 0 || nanos &gt; 999999) {
            throw new IllegalArgumentException("nanosecond timeout value out of range");
        }

        if (nanos &gt; 0) {
            timeout++;
        }

        wait(timeout);
    }
}
</code></pre>
<pre><code class="language-java">Object#notify()
</code></pre>
<p>在 <strong>同一个等待阻塞池中</strong> 随机唤醒一个处于等待中的线程</p>
<pre><code class="language-java">Object#notifyAll()
</code></pre>
<p>在 <strong>同一个等待阻塞池中</strong> 唤醒所有等待中的线程</p>
<h3 id="thread中相关的api"><a class="header" href="#thread中相关的api">Thread中相关的API</a></h3>
<pre><code class="language-java">static Thread#interrupted()
</code></pre>
<p>检测当前线程是否已经中断,调用后将该线程的中断标志位设置为false</p>
<pre><code class="language-java">static Thread#sleep(long /*millis*/)
</code></pre>
<p>使当前线程睡眠，<strong>不释放锁对象</strong>，让其他线程具有被执行机会</p>
<pre><code class="language-java">static Thread#yield()
</code></pre>
<p>使当前线程放弃cpu的执行权。</p>
<p><em>但选择执行的线程依赖于线程的优先级，有可能又被重新选中</em></p>
<pre><code class="language-java">Thread#interrupt()
</code></pre>
<p>中断该线程，<em>实际只是将中断标志设置为true</em></p>
<p>如果目标线程处在sleep(),join(),wait()中时，目标会收到抛出的 <code>InterruptedException</code> 异常</p>
<pre><code class="language-java">Thread#join()
</code></pre>
<p>阻塞当前线程，等待目标线程执行完毕后唤醒</p>
<pre><code class="language-java">Thread#join(long /*millis*/)
</code></pre>
<p>阻塞当前线程，等待目标线程执行完毕后、或者等待了设定的时间后唤醒</p>
<p>其他API略</p>
<h3 id="线程之间的协作"><a class="header" href="#线程之间的协作">线程之间的协作</a></h3>
<p>不难理解，程序往往被设计为通过多个线程之间的协作完成一项复杂的任务，而每个线程所承担的职责也被简化。</p>
<p>但这种设计方式有利亦有弊，所面向的问题过于具化，模型难以复用。</p>
<p><em>作者按：当然，本文中所指的线程协作，仅局限于线程之间通过监视器锁、线程API让线程执行的顺序有序可控，在此基础上完成整体任务</em></p>
<hr />
<p>本篇文章篇幅较短，内容也较为基础、浅显，但部分内容依旧值得深挖，例如JVM如何实现线程管理，可能短期内不会得到明显的提升但可以加深对JVM、OS、程序微观运行过程的理解。</p>
<p>另外，我删除了线程之间协作的WorkShop内容，内容过于干巴巴，如果有机会，我更希望以 <a href="https://leobert-lan.github.io/info/about_sansi_series.html">三思系列</a> 的形式结合具体实例展开讨论。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java多线程基础--线程的创建与线程池管理"><a class="header" href="#java多线程基础--线程的创建与线程池管理">Java多线程基础--线程的创建与线程池管理</a></h1>
<h2 id="前言-15"><a class="header" href="#前言-15">前言</a></h2>
<p>各位亲爱的读者朋友，我正在创作 <code>Java多线程系列</code> 文章，如果您觉得内容还不错，还请点赞支持一下。</p>
<p>在<a href="https://juejin.cn/post/7080088772754292744">上一篇文章</a> 中，我们回顾了线程生命周期、线程之间相互协作的知识，本篇我们继续挖掘，增强对线程的理解。</p>
<p><em>作者按：本篇按照自己有限的知识进行整理，如有谬误，还请读者在评论区不吝指出</em></p>
<blockquote>
<p>了解系列以及总纲：<a href="https://leobert-lan.github.io/MultiThreading/post_33.html">Java多线程系列</a></p>
</blockquote>
<blockquote>
<p><strong>重要声明</strong>：</p>
<p>出于 <strong>方便叙述</strong> 或 <strong>帮助基础尚且薄弱的读者理解文章内容</strong> 的目的，文中举了一些例子，但这些例子并 <strong>不能</strong> 百分百准确的对应Java中的概念，甚至有些幼稚。</p>
<p>读者朋友们应当注意到这一点，并且清晰的意识到自己的目标是理解Java中的概念与设计，而不必纠结于例子是否有失偏颇。</p>
</blockquote>
<p>本篇博客的内容较为散碎，以下是内容大纲，您可以结合它挑选感兴趣的内容片段阅读、重新梳理知识</p>
<p><img src="MultiThreading/./post_42/guideline.png" alt="" /></p>
<h2 id="线程的创建与启动"><a class="header" href="#线程的创建与启动">线程的创建与启动</a></h2>
<p>在上一篇文章中，我们提到，调用 <code>Thread#start()</code> 即可启动该线程，而并未挖掘虚拟机 <strong>真正启动</strong> 一个线程的 <strong>具体过程</strong>。</p>
<p>可能会让您失望，这一篇依旧不会挖掘这一细节，因为它对设计、编写优质的多线程应用毫无帮助。</p>
<p>如果您对此感兴趣，以下文章可能会有帮助：</p>
<ul>
<li><a href="https://www.yht7.com/news/168270">面试官问如何启动Java 线程</a> <em>未查询到源头作者信息</em></li>
<li><a href="https://www.jianshu.com/p/3ce1b5e5a55e">从Java到C++,以JVM的角度看Java线程的创建与运行</a> <em>作者Van96</em></li>
</ul>
<p>先回归到概念：</p>
<blockquote>
<p>操作系统中的Thread：是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位</p>
<p>JVM中的Thread：A thread is a thread of execution in a program. The Java Virtual Machine allows an application to have
multiple threads of execution running concurrently. -- 似乎解释了，又似乎没有</p>
</blockquote>
<p>"编写应用程序时，不会为了展现自己已经掌握了启动线程的知识而去启动线程"，即线程是手段，这一点并不难理解。应用程序使用线程的目的在于 <strong>完成既定任务</strong> ，
并且基于多线程并发能力提高程序的运行效率、或者基于线程的特性界定职责边界使程序有序运行。</p>
<p>举个例子，工厂接了一批订单，需要在能力一致的一批工人中选择一批完成订单的生产，不难理解：工厂老板在意的是订单的完成，而不是工人的名字、星座、爱好。</p>
<p><strong>那么如何定义线程需要完成的任务呢？</strong></p>
<p>在最初的JDK中，存在两种方式：</p>
<ul>
<li>继承Thread类、覆写 <code>run()</code> 方法定义任务</li>
</ul>
<pre><code class="language-java">class PrimeThread extends Thread {
    long minPrime;

    PrimeThread(long minPrime) {
        this.minPrime = minPrime;
    }

    public void run() {
        // compute primes larger than minPrime
    }
}
</code></pre>
<ul>
<li>组合优于继承的典型例子：实现Runnable接口，作为Thread的任务</li>
</ul>
<pre><code class="language-java">class Foo {
    class PrimeRun implements Runnable {
        long minPrime;

        PrimeRun(long minPrime) {
            this.minPrime = minPrime;
        }

        public void run() {
            // compute primes larger than minPrime
        }
    }

    foo() {
        PrimeRun p = new PrimeRun(143);
        new Thread(p).start();
    }
}
</code></pre>
<p><em>随着JDK的发展，也有更多的方式定义任务，我们将在后续的系列文章中展开。</em></p>
<p>至此，您应该已经意会了 JDK doc 中所说的 <code>a Thread is a thread of execution in a program</code></p>
<h2 id="线程池-1"><a class="header" href="#线程池-1">线程池</a></h2>
<p>回到前文举得例子，工厂经过长时间的运转，积累了足够的经验，老板突然顿悟：只要工人能够胜任工作，自己完全没有必要了解工人，只需要:</p>
<ul>
<li>评估生产任务量</li>
<li>制定好生产计划</li>
<li>把任务和计划交给产线即可</li>
</ul>
<p>完全不用在意是张三做还是李四做。</p>
<p>工人形如线程，产线便形如线程池。结合工厂的实际情况与任务的特性，可以凝练出 <strong>几种产线管理方式</strong> 。</p>
<p>在Java中，直接或者间接的依靠配置 <code>ThreadPoolExecutor</code> 获得线程池。</p>
<blockquote>
<p>作者按：<em>通过简单的搜索，可以发现大量的探讨线程池的博客，可能受面经影响，部分博客均围绕几个常见地面试问题展开。</em> 但务必注意，线程池的知识内容远不止面试题题干所表现的那些内容！相比之下，<strong>理解线程池的设计更为重要</strong>。</p>
<p>而我的文字功力有限，无法像教科书那样，顺着严谨的大纲递进式展开，还让文字显得 <strong>深刻且有趣</strong>，只能尽可能推测读者的兴趣点，展开以下内容</p>
</blockquote>
<p>接下来，让我们结合生活经验，以工厂产线为例子，反思推导线程池的设计，了解 <code>ThreadPoolExecutor</code> 最基本的知识。</p>
<h3 id="threadpoolexecutor-核心设计"><a class="header" href="#threadpoolexecutor-核心设计">ThreadPoolExecutor 核心设计</a></h3>
<p>上文中，我们以 <strong>产线</strong> 类比 <strong>线程池</strong> ，<strong>"工厂对工人的管理方式"</strong> 来类比 <strong>"线程池的管理设计"</strong> ，并且您一定注意到两处重点：<strong>任务</strong> 、 <strong>工人</strong></p>
<p>在线程池中， <strong>上岗工作的线程</strong> 可以类比为 <strong>工人</strong> ，完成产线收到的任务。</p>
<p><em>注意，该类比并不完全准确</em></p>
<p>不难推测，线程池存在两个核心内容：</p>
<ul>
<li>任务队列 <code>BlockingQueue&lt;Runnable&gt; workQueue</code></li>
<li>工作者集合 <code>HashSet&lt;Worker&gt; workers</code></li>
</ul>
<p>任务队列用于存储任务，您应该已经注意到，它使用的是juc下的 <code>BlockingQueue</code> 接口。它的本质还是队列，附加了两种特殊的操作：</p>
<ul>
<li>取 时满足 (或等待至满足) 队列非空</li>
<li>存 时满足 (或等待至满足) 队列有空余空间</li>
</ul>
<p>既然是接口，自然可以有不同的实现，您可以使用不同的实现作为线程池的任务队列。</p>
<p>在线程池设计中，通过依赖抽象 <em>即BlockingQueue</em> 进行了解耦，只关心存取的时机。您可以自行决定队列的特性，诸如大小、存储方式、优先级排序等</p>
<p><em>在先前的系列文章中还未涉及 <code>BlockingQueue</code> ，计划将于后续系列文章中展开，故本文也不会围绕它展开内容</em></p>
<p>接下来，让我们看一看 <strong>一个人上岗成为产线工人的全过程</strong> ，即 <code>Thread</code> 成为线程池 <code>Worker</code> 的过程</p>
<h4 id="成为线程池中的工作者"><a class="header" href="#成为线程池中的工作者">成为线程池中的工作者</a></h4>
<p>产线确定了一个岗位，管理者把岗位信息给到人力资源部门，并申请配给人力：<code>getThreadFactory().newThread(this)</code></p>
<p>人力资源部门派遣了一个 <code>Thread</code> 小T 给到产线，小T已经接受了技能培训，并且知道上岗后从产线的 <code>任务队列</code> 中取任务、出卖体力完成它即可， <code>void runWorker(Worker w)</code>。</p>
<p>小T 就成为了一个 <code>Worker</code>。</p>
<p>您可能意识到，线程池只关心线程的管理，并不关心线程的创建细节，所以再次依赖抽象，对线程创建细节进行了解耦：</p>
<pre><code class="language-java">public interface ThreadFactory {
    Thread newThread(Runnable r);
}
</code></pre>
<p>关于Worker的定义、职责，泛读以下源码即可了然于心：</p>
<pre><code class="language-java">public class ThreadPoolExecutor extends AbstractExecutorService {
    private final class Worker extends AbstractQueuedSynchronizer implements Runnable {

        /** Thread this worker is running in.  Null if factory fails. */
        final Thread thread;
        /** Initial task to run.  Possibly null. */
        Runnable firstTask;
        /** Per-thread task counter */
        volatile long completedTasks;

        /**
         * Creates with given first task and thread from ThreadFactory.
         * @param firstTask the first task (null if none)
         */
        Worker(Runnable firstTask) {
            setState(-1); // inhibit interrupts until runWorker
            this.firstTask = firstTask;
            this.thread = getThreadFactory().newThread(this);
        }

        /** Delegates main run loop to outer runWorker. */
        public void run() {
            runWorker(this);
        }

        //其他略
    }

    public ThreadFactory getThreadFactory() {
        return threadFactory;
    }

    final void runWorker(Worker w) {
        Thread wt = Thread.currentThread();
        Runnable task = w.firstTask;
        w.firstTask = null;
        w.unlock(); // allow interrupts
        boolean completedAbruptly = true;
        try {
            while (task != null || (task = getTask()) != null) {
                //锁处理和判断略
                try {
                    beforeExecute(wt, task);
                    Throwable thrown = null;
                    try {
                        task.run();
                    }
                    //异常略
                    finally {
                        afterExecute(task, thrown);
                    }
                } finally {
                    task = null;
                    w.completedTasks++;
                    w.unlock();
                }
            }
            completedAbruptly = false;
        } finally {
            processWorkerExit(w, completedAbruptly);
        }
    }
}
</code></pre>
<p>您可能留意到，近年来的一些社会不良事件中总会出现一个词：<code>临时工</code>。当然，我并没有任何在此讨论社会问题的意愿， 一条生产线有固定的岗位，也会有按需产生的临时工岗位，甚至完全是临时工岗位，这并不难理解。而线程池也有这样的设计。</p>
<pre><code class="language-java">public class ThreadPoolExecutor extends AbstractExecutorService {
    /**
     * Core pool size is the minimum number of workers to keep alive
     * (and not allow to time out etc) unless allowCoreThreadTimeOut
     * is set, in which case the minimum is zero.
     */
    private volatile int corePoolSize;

    /**
     * Maximum pool size. Note that the actual maximum is internally
     * bounded by CAPACITY.
     */
    private volatile int maximumPoolSize;
}
</code></pre>
<p>注意，线程池在管理时，对线程是一视同仁的，只关心核心线程数量、最大线程数量，并不会依据线程的特征将其分化为 核心/非核心。</p>
<h4 id="产线如何确定一个岗位"><a class="header" href="#产线如何确定一个岗位">产线如何确定一个岗位</a></h4>
<blockquote>
<p>上一节我们提到，产线确定了一个岗位后，向人力资源部门要人并安排成为产线工人。</p>
</blockquote>
<p>那么产线是如何确定一个岗位的呢？即 <strong>线程池如何确定需要增加一个Worker</strong>？</p>
<p>产线不会无缘无故的安排工人上岗工作，必然是收到了生产任务，否则就成了合理摸鱼。</p>
<p>顺理成章的，线程池收到一个任务时，在相应的Size限制没有达到时，优先考虑安排线程进行处理，而不是丢到任务队列中等待。</p>
<p>在先前的系列文章中，我们已经了解到，启动线程是较为昂贵了，虽然线程池规划了 <code>核心线程的数量</code> 和 <code>最大线程数量</code> ，但也不会一开始就全员上岗，而是在任务抵达时逐步的安排线程上岗。</p>
<p>尝试 <strong>安排线程上岗</strong> 时，</p>
<ol>
<li>需先判断线程池工作状态，<strong>如果线程池已经关闭，自然不会再增加线程</strong>，返回失败。比如产线准备停产了，已经接的任务会安排处理，但肯定不会再招工。</li>
<li>如果线程池正常工作，则检查线程数量是否可以继续增加</li>
<li>如果可以继续增加，则尝试更新线程总数，如果失败，则说明在其他线程中也触发了addWorker逻辑，那么线程池的工作状态也可能发生了改变，如果没有改变，则重复步骤2，否则回到步骤1继续检测</li>
<li><em>上一节中的内容</em>，得到Thread实例并让其成为Worker，开始干活</li>
</ol>
<p>整个过程中有CAS操作，鉴于有系列文章的撰写计划，文中不再展开，相应代码可参考gist：</p>
<p><a href="https://gitee.com/leobert_253/codes/7fvi0sl8p9n6jtr2kqxwb74">参考Gist</a></p>
<h4 id="向产线线程池下达任务"><a class="header" href="#向产线线程池下达任务">向产线（线程池）下达任务</a></h4>
<p>联想一下，市场部门小王拿到了一笔单子，来到产线找到负责人老张，让老张安排干掉</p>
<ol>
<li>老张拿起了职工工作排期表，发现 <strong>还有固定岗位空着</strong> ，则直接向人力资源要人上岗干活；
<ol>
<li>注意，招人上岗 <strong>可能失败</strong> ，比如老张手上的信息不及时，现在已经满额了，也有可能厂长决定产线要停掉，通知人力资源不要再派人了</li>
</ol>
</li>
<li>假如固定岗位招不来人，老张继续核实： <strong>产线未停产</strong> 且 <strong>可纳入计划</strong>，在未停产且可纳入计划的情况下，把任务排进了计划
<ol>
<li>老张还是很严谨的，又再次核实产线生产状态，如果产线已经停产并且该任务没有被领取，则把任务拒掉</li>
<li>否则检查工人是否在岗，如没有工人在岗，则向人力资源部门要一个 <strong>临时工</strong> 处理 <strong>任务队列中的任务</strong>， <em>如果要不来人，任务也放着</em></li>
</ol>
</li>
<li>如果产线停产了或者排不进计划了，老张精通人情世故，表示看看能不能拉个临时工来，能拿到人就直接处理，否则就只能拒绝了，
<ol>
<li>如果是产线停了或者达到了最大人数，则要不来人 -- 参考上个小节</li>
<li>否则临时工会处理该任务</li>
</ol>
</li>
</ol>
<p>而线程池中与此过程也非常类似，代码比较简短：</p>
<pre><code class="language-java">public class ThreadPoolExecutor extends AbstractExecutorService {
    public void execute(Runnable command) {
        if (command == null) // 小王在忽悠人
            throw new NullPointerException();

        int c = ctl.get();

        //1.
        if (workerCountOf(c) &lt; corePoolSize) {
            //1.i
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }
        //2.
        if (isRunning(c) &amp;&amp; workQueue.offer(command)) {
            int recheck = ctl.get();
            if (!isRunning(recheck) &amp;&amp; remove(command)) // 2.i
                reject(command);
            else if (workerCountOf(recheck) == 0) // 2.ii
                addWorker(null, false);
        } else if (!addWorker(command, false)) // 3
            reject(command); // 3.i
    }
}
</code></pre>
<h4 id="当你拒绝任务"><a class="header" href="#当你拒绝任务">当你拒绝任务</a></h4>
<p>虽然打工人和老板都想任务及时可靠的被完成，但总有不如意的时候，某些情况下，线程池将不得不拒绝任务。</p>
<p>上文中已经提到：线程池已经关闭、任务队列已经排满。</p>
<p>当线程池拒绝任务时，事情总得有个说法，JDK设计了接口：</p>
<pre><code class="language-java">public interface RejectedExecutionHandler {
    void rejectedExecution(Runnable r, ThreadPoolExecutor executor);
}
</code></pre>
<p>在线程池实例化时，需要指明拒绝策略。</p>
<p>JDK中提供了4个策略：</p>
<ul>
<li>CallerRunsPolicy -- 在线程池未关闭情况下，访问者线程直接负责处理</li>
<li>AbortPolicy -- 抛出 <code>RejectedExecutionException</code> 异常，这是运行时异常， <strong>默认策略</strong></li>
<li>DiscardPolicy -- 这个任务就此罢休</li>
<li>DiscardOldestPolicy -- 只要线程池没关闭，这件事情就非得干，把排在最前的任务踢掉，重走任务下达流程</li>
</ul>
<h4 id="蓦然回首回看构造函数"><a class="header" href="#蓦然回首回看构造函数">蓦然回首，回看构造函数</a></h4>
<p>ThreadPoolExecutor 提供了一系列重载构造函数用于获取特定实例</p>
<p><img src="MultiThreading/post_42/img.png" alt="img.png" /></p>
<pre><code class="language-java">public class ThreadPoolExecutor extends AbstractExecutorService {
    public ThreadPoolExecutor(
            int corePoolSize,
            int maximumPoolSize,
            long keepAliveTime,
            TimeUnit unit,
            BlockingQueue&lt;Runnable&gt; workQueue,
            ThreadFactory threadFactory,
            RejectedExecutionHandler handler
    ) {
        //ignore 参见gist https://gitee.com/leobert_253/codes/wh495q63tvlipum2snca131
    }
}
</code></pre>
<p>以此为例</p>
<ul>
<li>int corePoolSize, 核心线程数量</li>
<li>int maximumPoolSize, 最大线程数量</li>
<li>long keepAliveTime, 配合 unit 表示的时间，作为IDLE 线程等待任务的超时时间，核心线程如果不允许采用超时机制将一直等待任务（默认）</li>
<li>TimeUnit unit, 配合 keepAliveTime</li>
<li>BlockingQueue<Runnable> workQueue 任务队列</li>
<li>ThreadFactory threadFactory 线程创建工厂</li>
<li>RejectedExecutionHandler handler 拒绝任务时的策略</li>
</ul>
<p>当然，这些参数存在一些限制和校验，可参考 <a href="https://gitee.com/leobert_253/codes/wh495q63tvlipum2snca131">gist</a> 进一步阅读，摘自JDK1.8。</p>
<h4 id="线程池的状态标识-ctl的设计"><a class="header" href="#线程池的状态标识-ctl的设计">线程池的状态标识-ctl的设计</a></h4>
<p>前面的内容中已经提到了线程池Shutdown的状态，线程池具有5个状态，先看一眼代码： 相应的二进制补码已标识</p>
<blockquote>
<p>注意，计算机中以补码表示数，如果是有符号数，最高位表示符号，1为负、0为非负，非负数其原码和补码一致，负数的补码：
取原码，符号位不变（保持1），其他位取反，然后加1 得到补码</p>
</blockquote>
<pre><code class="language-java">public class ThreadPoolExecutor extends AbstractExecutorService {
    private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));

    /**
     * 即29
     * */
    private static final int COUNT_BITS = Integer.SIZE - 3;

    /**
     * 0010 0000 00000000 00000000 00000000 -1 =&gt; 
     * 0001 1111 11111111 11111111 11111111
     *
     * wc = ctl &amp; CAPACITY 低29位存储wc
     * state = ctl &amp; ~CAPACITY 高三位存储状态
     * */
    private static final int CAPACITY = (1 &lt;&lt; COUNT_BITS) - 1;

    // runState is stored in the high-order bits
    //补码 111 29个0
    private static final int RUNNING = -1 &lt;&lt; COUNT_BITS;
    //补码 000 29个0
    private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS;
    //补码 001 29个0
    private static final int STOP = 1 &lt;&lt; COUNT_BITS;
    //补码 010 29个0
    private static final int TIDYING = 2 &lt;&lt; COUNT_BITS;
    //补码 011 29个0
    private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS;

    private static int ctlOf(int rs, int wc) {
        return rs | wc;
    }
}
</code></pre>
<p>很显然，<code>ThreadPoolExecutor</code> 将32位的int分为不同的区域标识信息，<em>在多线程背景下，使用AtomicInteger，但本质还是int</em>。</p>
<p>将 32位中的 高三位用于存储状态信息，低29位存储 worker-count（即wc），信息存储于ctl中，非常传统的位运算设计。</p>
<p><em>考虑到篇幅和阅读体验，其他相关的位运算API已经剥离到 <a href="https://gitee.com/leobert_253/codes/buh87kgrlz61m0fawd4pi25">gist</a> , 通过位运算解出状态、wc，判断状态大小等</em></p>
<ul>
<li>Running 运行状态（实例化后的默认状态）</li>
<li>Shutdown 不接收新任务，处理任务队列中的任务</li>
<li>Stop 不接收新任务，不处理任务队列中的任务，并且中断正在处理的任务</li>
<li>Tidying 所有的任务已终止时的一个暂态，随后将执行terminate()，成功后进入Terminated状态</li>
<li>Terminated 彻底终止</li>
</ul>
<p>生命周期变化如下：</p>
<p><img src="MultiThreading/post_42/state.png" alt="img.png" /></p>
<h3 id="线程池目的"><a class="header" href="#线程池目的">线程池目的</a></h3>
<p>此时，请您想一想，创建线程池机制的目的是什么？</p>
<p>前文提到，线程池是对线程进行管理，显然还不是根源。</p>
<ul>
<li>降低资源消耗。 重复利用已创建的线程，可降低线程创建和销毁造成的消耗。</li>
<li>提高响应速度。 线程池中有线程值守，当任务到达时，不需要每次都等待线程创建。<em>注意，并不排除任务排队、必要的线程启动情况</em></li>
<li>提高线程的可管理性，对系统运行状态进行调优。 线程是稀缺资源，不能无限制的创建，使用线程池可以进行统一的分配、监控、调优。</li>
</ul>
<h3 id="面经常客jdk中提供的线程池"><a class="header" href="#面经常客jdk中提供的线程池">面经常客，JDK中提供的线程池</a></h3>
<p>您一定阅读过一些面经，其中包含线程池的题目。作者可能在引导您向着 "JDK中特定的API所提供的线程池特征" 方面展开作答，或者题目看起来就是这样，<em>也许就是一个面试陷阱</em></p>
<p><em>作者按，不要单纯的为了应付面试和放弃了学习的初心。结合问题 <strong>讲清楚线程池的设计</strong> 要比 <strong>单纯的、枯燥的罗列通过调用Executors中的API得到的线程池对应的特征</strong> 有意义</em></p>
<p>在JDK1.5中，Java凝练了4种配置方式，可获得特定管理方式的线程池：</p>
<p><em>Java依据其特征作为Executors中的方法命名，借用它们作为这4类线程池的别名</em></p>
<ul>
<li>FixedThreadPool 数量固定、线程可重用</li>
<li>SingleThreadExecutor 仅单个线程</li>
<li>CachedThreadPool 会根据需要创建新线程的线程池</li>
<li>ScheduledThreadPool 可定期或周期执行任务的线程池</li>
</ul>
<p>前文已经提到，它们直接或者间接的使用了 ThreadPoolExecutor，而不是4个继承类！按照其API命名给了它们别名，但并不是类名！</p>
<h4 id="fixedthreadpool"><a class="header" href="#fixedthreadpool">FixedThreadPool</a></h4>
<p>JDK中提供的包装方法如下：</p>
<pre><code class="language-java">public class Executors {

    public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                0L, TimeUnit.MILLISECONDS,
                new LinkedBlockingQueue&lt;Runnable&gt;());
    }
}
</code></pre>
<p>很显然，<code>FixedThreadPool</code> 是一个定额的池，<code>nThreads</code> 即为核心线程数量，亦为最大线程数量，注意值必须大于0。</p>
<p>这条产线的工人就很惨，活多了也不会加派人手，任务排队等待线程空闲；不来活也要在岗位上待着，不会释放线程。</p>
<p>以 <code>LinkedBlockingQueue</code> 作为任务队列，先到的任务先被处理，并且它是无界的。</p>
<h4 id="singlethreadexecutor"><a class="header" href="#singlethreadexecutor">SingleThreadExecutor</a></h4>
<p>顾名思义，我们会得到一个单一线程的线程池。</p>
<pre><code class="language-java">public class Executors {
    public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {
        return new FinalizableDelegatedExecutorService
                (new ThreadPoolExecutor(1, 1,
                        0L, TimeUnit.MILLISECONDS,
                        new LinkedBlockingQueue&lt;Runnable&gt;(),
                        threadFactory));
    }
}
</code></pre>
<p>可能您会疑惑，</p>
<pre><code>new ThreadPoolExecutor(
    1, 1,
    0L, TimeUnit.MILLISECONDS,
    new LinkedBlockingQueue&lt;Runnable&gt;(),
    threadFactory
)
</code></pre>
<p>已经得到了一个 核心线程数、最大线程数均为1的线程池，为啥要增加 <code>FinalizableDelegatedExecutorService</code> 的参与？</p>
<p>前文未提及但您可能知道，ThreadPoolExecutor是可以重新配置的！例如重新设置核心线程数量：</p>
<pre><code class="language-java">public class ThreadPoolExecutor {
    public void setCorePoolSize(int corePoolSize) {
        if (corePoolSize &lt; 0)
            throw new IllegalArgumentException();
        int delta = corePoolSize - this.corePoolSize;
        this.corePoolSize = corePoolSize;
        if (workerCountOf(ctl.get()) &gt; corePoolSize)
            interruptIdleWorkers();
        else if (delta &gt; 0) {
            int k = Math.min(delta, workQueue.size());
            while (k-- &gt; 0 &amp;&amp; addWorker(null, true)) {
                if (workQueue.isEmpty())
                    break;
            }
        }
    }

}
</code></pre>
<p>而 <code>FinalizableDelegatedExecutorService</code> 继承自 <code>DelegatedExecutorService</code>，扩展了在 <code>finalize()</code> 时关闭线程池。
而后者是一个Wrapper，仅暴露 <code>ExecutorService</code> 接口的功能，通过委托的方式封闭了重新配置线程池的能力。</p>
<h4 id="cachedthreadpool"><a class="header" href="#cachedthreadpool">CachedThreadPool</a></h4>
<p>该池将使用 "线程对象" 缓存方案，核心线程数量为0，全部为临时工，并且基于上文的知识：</p>
<ol>
<li>如果池中没有Worker，则会新增Worker处理，否则任务放入任务队列等待。</li>
<li>非核心线程可以运用获取任务超时时间，当获取任务超时时，则 <code>processWorkerExit</code> 下岗</li>
</ol>
<pre><code class="language-java">public class Executors {
    public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                60L, TimeUnit.SECONDS,
                new SynchronousQueue&lt;Runnable&gt;());
    }
}
</code></pre>
<h4 id="scheduledthreadpool"><a class="header" href="#scheduledthreadpool">ScheduledThreadPool</a></h4>
<pre><code class="language-java">public class Executors {
    public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
        return new ScheduledThreadPoolExecutor(corePoolSize);
    }
}
</code></pre>
<p>不同于前三者，此时得到的线程池可 <strong>定时</strong> 处理任务。</p>
<p>为了实现这一点，ScheduledThreadPoolExecutor</p>
<ul>
<li>使用 <code>DelayedWorkQueue</code> 改变了获取任务的具体实现</li>
<li>使用装饰模式包装原始任务，使得任务在满足 <code>周期性</code> 的条件时，能够重新进入任务队列</li>
</ul>
<p><em>作者按：JDK中的源码实现非常精彩，值得深读。<a href="https://gitee.com/leobert_253/codes/lx59ba0hrgjd3soec16pu80">gist</a></em></p>
<hr />
<p>相信您已经对线程池的设计有了一定的理解，JDK1.8之后也在线程池中增加了Future相关的内容，本文不再继续展开。通过Executors中API的源码，应当已经掌握得到的线程池的特征。</p>
<h2 id="意犹未尽之处"><a class="header" href="#意犹未尽之处">意犹未尽之处</a></h2>
<p>行文至此，内容已经非常冗长，但也不得不告一段落。 文中的部分内容，例如Future、AtomicInteger、CAS等内容，计划在本系列的其他文章中具体展开，文中亦颇多回避。
而DelayedQueue、线程池生命周期变化时的具体细节、线程池的调优等内容，均需要结合代码、场景具体分析，限于文章主题未能尽兴，读者闲暇之余若能将源码再阅读一二，定能有更大的收获。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java多线程系列--掌握future轻松获取异步任务结果"><a class="header" href="#java多线程系列--掌握future轻松获取异步任务结果">Java多线程系列--掌握Future，轻松获取异步任务结果</a></h1>
<h2 id="前言-16"><a class="header" href="#前言-16">前言</a></h2>
<p>最近因为一些个人原因，未能抽出太多精力更新Java多线程系列，一搁置就是好几个月，先向读者诸君致歉。</p>
<p>在本系列的其他文章中，已经提到过线程之间的相互协作， 通过分工，将程序系统的不同任务进行线程分离，充分利用机器性能、提升特定线程的利用率和程序的体验感。</p>
<p><em>详见拙作：<a href="https://juejin.cn/post/7080088772754292744">Java多线程基础--线程生命周期与线程协作详解</a></em>.</p>
<p>并在线程池相关文章中提到：作为程序构建者，我们更关心线程（组）的特性和它们所执行的任务，并不愿意分心去做线程操作。</p>
<p>详见拙作：<a href="https://juejin.cn/post/7098235227490746375">Java多线程基础--线程的创建与线程池管理</a></p>
<p>然而实际开发中，我们同样关心一个任务对程序系统产生的影响，<em>习惯上称之为任务的的执行结果</em>。</p>
<h2 id="runnable的局限性"><a class="header" href="#runnable的局限性">Runnable的局限性</a></h2>
<p>在前文中我们谈到，通过编码实现Runnable接口，将获得具有边界性的 "任务"，在指定的线程（或者线程池）中运行。</p>
<p>重新观察该接口，不难发现它并没有方法返回值：</p>
<pre><code class="language-java">public interface Runnable {
    void run();
}
</code></pre>
<p>在JDK1.5之前，想利用任务的执行结果，需要小心的操作线程访问临界区资源。使用 <code>回调</code> 进行解耦是非常不错的选择。</p>
<h3 id="练手小demo----回顾既往文章知识"><a class="header" href="#练手小demo----回顾既往文章知识">练手小Demo -- 回顾既往文章知识</a></h3>
<p><em>注意，为了减少篇幅使用了lambda，但jdk1.5之前并不支持lambda</em></p>
<blockquote>
<p>将计算任务分离到其他线程执行，再回到主线程消费结果</p>
</blockquote>
<p>我们将计算、IO等耗时任务丢到其他线程，让主线程专注于自身业务，<em>假想它在接受用户输入以及处理反馈,但我们略去这一部分</em></p>
<p>我们可以设计出类似下面的代码：</p>
<p><em>虽然它还有很多不合理之处值得优化，但也足以用于演示</em></p>
<pre><code class="language-java">class Demo {
    static final Object queueLock = new Object();
    static List&lt;Runnable&gt; mainQueue = new ArrayList&lt;&gt;();
    static boolean running = true;

    static final Runnable FINISH = () -&gt; running = false;

    public static void main(String[] args) {
        synchronized (queueLock) {
            mainQueue.add(Demo::onStart);
        }
        while (running) {
            Runnable runnable = null;
            synchronized (queueLock) {
                if (!mainQueue.isEmpty())
                    runnable = mainQueue.remove(0);
            }
            if (runnable != null) {
                runnable.run();
            }
            Thread.yield();
        }
    }

    public static void onStart() {
        //...
    }

    public static void finish() {
        synchronized (queueLock) {
            mainQueue.clear();
            mainQueue.add(FINISH);
        }
    }
}
</code></pre>
<p>再模拟一个计算的线程和任务回调：</p>
<pre><code class="language-java">interface Callback {
    void onResultCalculated(int result);
}

class CalcThread extends Thread {

    private final Callback callback;

    private final int a;

    private final int b;

    public CalcThread(Callback callback, int a, int b) {
        this.callback = callback;
        this.a = a;
        this.b = b;
    }

    @Override
    public void run() {
        super.run();
        try {
            Thread.sleep(10);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        final int result = a + b;
        System.out.println("threadId" + Thread.currentThread().getId() + ",calc result:" + result + ";" + System.currentTimeMillis());

        synchronized (queueLock) {
            mainQueue.add(() -&gt; callback.onResultCalculated(result));
        }
    }
}
</code></pre>
<p>填充一下onStart业务：</p>
<pre><code class="language-java">class Demo {
    public static void onStart() {
        System.out.println("threadId" + Thread.currentThread().getId() + ",onStart," + System.currentTimeMillis());

        new CalcThread(result -&gt; {
            System.out.println("threadId" + Thread.currentThread().getId() + ",onResultCalculated:" + result + ";" + System.currentTimeMillis());
            finish();
        }, 200, 300).start();

    }
}
</code></pre>
<h4 id="复习优化为使用runnable"><a class="header" href="#复习优化为使用runnable">复习：优化为使用Runnable</a></h4>
<p>在前文我们提到，如果业务仅关注任务的执行，并不过于关心线程本身，则可以利用Runnable：</p>
<pre><code class="language-java">class Demo {
    static class CalcRunnable implements Runnable {

        private final Callback callback;

        private final int a;

        private final int b;

        public CalcRunnable(Callback callback, int a, int b) {
            this.callback = callback;
            this.a = a;
            this.b = b;
        }

        @Override
        public void run() {
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            final int result = a + b;
            System.out.println("threadId" + Thread.currentThread().getId() + ",calc result:" + result + ";" + System.currentTimeMillis());

            synchronized (queueLock) {
                mainQueue.add(() -&gt; callback.onResultCalculated(result));
            }
        }
    }

    public static void onStart() {
        System.out.println("threadId" + Thread.currentThread().getId() + ",onStart," + System.currentTimeMillis());

        new Thread(new CalcRunnable(result -&gt; {
            System.out.println("threadId" + Thread.currentThread().getId() + ",onResultCalculated:" + result + ";" + System.currentTimeMillis());
            finish();
        }, 200, 300)).start();

    }
}
</code></pre>
<blockquote>
<p>不难想象出：我们非常需要</p>
<ul>
<li>让特定线程、特定类型的线程方便地接收任务，<em>回顾本系列文章中的 <a href="https://juejin.cn/post/7098235227490746375">线程池篇</a> ，线程池是应运而生</em></li>
<li>拥有比Synchronize更轻量的机制</li>
<li>拥有更方便的数据结构</li>
</ul>
</blockquote>
<p>至此，我们可以体会到：JDK1.5之前，因为JDK的功能不足，Java程序对于线程的使用 <strong>较为粗糙</strong>。</p>
<h2 id="为异步而生的future"><a class="header" href="#为异步而生的future">为异步而生的Future</a></h2>
<p>终于在JDK1.5中，迎来了新特性： <code>Future</code> 以及先前文章中提到的线程池, <em>时光荏苒，一晃将近20年了</em>。</p>
<pre><code class="language-java">/**
 * 略
 * @since 1.5
 * @author Doug Lea
 * @param &lt;V&gt; The result type returned by this Future's {@code get} method
 */
public interface Future&lt;V&gt; {

    boolean cancel(boolean mayInterruptIfRunning);

    boolean isCancelled();

    boolean isDone();

    V get() throws InterruptedException, ExecutionException;

    V get(long timeout, TimeUnit unit)
            throws InterruptedException, ExecutionException, TimeoutException;
}
</code></pre>
<p>尽管已经移除了API注释，但仍然能够理解每个API的含义，不多做赘述。</p>
<p>显而易见，为了增加返回值，<strong>没有必要用如此复杂的</strong> 接口来替代 <code>Runnable</code>。简单思考后可以对返回值的情况进行归纳：</p>
<ul>
<li>返回Runnable中业务的结果，例如计算、读取资源等</li>
<li>单纯的在Runnable执行完毕后返回一个结果</li>
</ul>
<p>从业务层上看，仅需要如下接口即可，它增加了返回值、并可以更友好地让使用者处理异常：</p>
<p><em>作者按：抛开底层实现，仅看业务方编码需要</em></p>
<pre><code class="language-java">public interface Callable&lt;V&gt; {
    /**
     * Computes a result, or throws an exception if unable to do so.
     *
     * @return computed result
     * @throws Exception if unable to compute a result
     * 防盗戳 leobert-lan https://juejin.cn/user/2066737589654327
     */
    V call() throws Exception;
}
</code></pre>
<p>显然，JDK需要提供后向兼容能力：</p>
<ul>
<li>Runnable 不能够丢弃，也不应当丢弃</li>
<li>不能要求使用者完全的重构代码</li>
</ul>
<p>所以一并提供了适配器，让使用者进行简单的局部重构即可用上新特性</p>
<pre><code class="language-java">static final class RunnableAdapter&lt;T&gt; implements Callable&lt;T&gt; {
    final Runnable task;
    final T result;

    RunnableAdapter(Runnable task, T result) {
        this.task = task;
        this.result = result;
    }

    public T call() {
        task.run();
        return result;
    }
}
</code></pre>
<p>而Future恰如其名，它代表了在 "未来" 的一个结果和状态，为了更方便地处理异步而生。</p>
<p>并且内置了 <code>FutureTask</code>，在 <a href="MultiThreading/post_46.html#anchor1">FutureTask详解</a> 章节中再行展开。</p>
<h3 id="类图"><a class="header" href="#类图">类图</a></h3>
<p>在JDK1.8的基础上，看一下精简的类图结构：</p>
<p><img src="MultiThreading/./post_46/FutureDiagram.png" alt="" /></p>
<h2 id="futuretask详解"><a class="header" href="#futuretask详解"><a id="anchor1">FutureTask详解</a></a></h2>
<h3 id="构造函数"><a class="header" href="#构造函数">构造函数</a></h3>
<pre><code class="language-java">public class FutureTask {
    public FutureTask(Callable&lt;V&gt; callable) {
        if (callable == null)
            throw new NullPointerException();
        this.callable = callable;
        this.state = NEW;       // ensure visibility of callable
    }

    public FutureTask(Runnable runnable, V result) {
        this.callable = Executors.callable(runnable, result);
        this.state = NEW;       // ensure visibility of callable
    }
}
</code></pre>
<h3 id="生命周期"><a class="header" href="#生命周期">生命周期</a></h3>
<pre><code class="language-java">public class FutureTask {
    //新建
    private static final int NEW = 0;

    //处理中
    private static final int COMPLETING = 1;

    //正常
    private static final int NORMAL = 2;

    //异常
    private static final int EXCEPTIONAL = 3;

    //已取消
    private static final int CANCELLED = 4;

    //中断中
    private static final int INTERRUPTING = 5;

    //已中断
    private static final int INTERRUPTED = 6;
}
</code></pre>
<p>可能的生命周期转换如下：</p>
<ul>
<li>NEW -&gt; COMPLETING -&gt; NORMAL</li>
<li>NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</li>
<li>NEW -&gt; CANCELLED</li>
<li>NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</li>
</ul>
<p>JDK中原汁原味的解释如下：</p>
<blockquote>
<p>The run state of this task, initially NEW. The run state
transitions to a terminal state only in methods set,
setException, and cancel. During completion, state may take on
transient values of COMPLETING (while outcome is being set) or
INTERRUPTING (only while interrupting the runner to satisfy a
cancel(true)). Transitions from these intermediate to final
states use cheaper ordered/lazy writes because values are unique
and cannot be further modified.</p>
</blockquote>
<h3 id="核心方法"><a class="header" href="#核心方法">核心方法</a></h3>
<p>本节从以下三块入手阅读源码</p>
<ul>
<li>状态判断</li>
<li>取消</li>
<li>获取结果</li>
</ul>
<p>状态判断API的实现非常简单</p>
<pre><code class="language-java">public class FutureTask {
    public boolean isCancelled() {
        return state &gt;= CANCELLED;
    }

    public boolean isDone() {
        return state != NEW;
    }
}
</code></pre>
<p>取消：</p>
<ol>
<li>当前状态为 <code>NEW</code> 且 CAS修改 state 成功，否则返回取消失败</li>
<li>如果 <code>mayInterruptIfRunning</code> 则中断在执行的线程并CAS修改state为INTERRUPTED</li>
<li>调用 finishCompletion
<ol>
<li>删除并通知所有等待的线程</li>
<li>调用done()</li>
<li>设置callable为null</li>
</ol>
</li>
</ol>
<pre><code class="language-java">public class FutureTask {
    public boolean cancel(boolean mayInterruptIfRunning) {
        if (!(state == NEW &amp;&amp;
                UNSAFE.compareAndSwapInt(this, stateOffset, NEW,
                        mayInterruptIfRunning ? INTERRUPTING : CANCELLED))) {

            return false;
        }

        try {    // in case call to interrupt throws exception
            if (mayInterruptIfRunning) {
                try {
                    Thread t = runner;
                    if (t != null)
                        t.interrupt();
                } finally { // final state
                    UNSAFE.putOrderedInt(this, stateOffset, INTERRUPTED);
                }
            }
        } finally {
            finishCompletion();
        }
        return true;
    }

    private void finishCompletion() {
        // assert state &gt; COMPLETING;
        for (WaitNode q; (q = waiters) != null; ) {
            if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) {
                for (; ; ) {
                    Thread t = q.thread;
                    if (t != null) {
                        q.thread = null;
                        LockSupport.unpark(t);
                    }
                    WaitNode next = q.next;
                    if (next == null)
                        break;
                    q.next = null; // unlink to help gc
                    q = next;
                }
                break;
            }
        }

        done();

        callable = null;        // to reduce footprint
    }
}
</code></pre>
<p>获取结果： 先判断状态，如果未进入到 <code>COMPLETING</code>（即为NEW状态），则阻塞等待状态改变，返回结果或抛出异常</p>
<pre><code class="language-java">public class FutureTask {
    public V get() throws InterruptedException, ExecutionException {
        int s = state;
        if (s &lt;= COMPLETING)
            s = awaitDone(false, 0L);
        return report(s);
    }

    public V get(long timeout, TimeUnit unit)
            throws InterruptedException, ExecutionException, TimeoutException {
        if (unit == null)
            throw new NullPointerException();
        int s = state;
        if (s &lt;= COMPLETING &amp;&amp;
                (s = awaitDone(true, unit.toNanos(timeout))) &lt;= COMPLETING)
            throw new TimeoutException();
        return report(s);
    }

    private V report(int s) throws ExecutionException {
        Object x = outcome;
        if (s == NORMAL)
            return (V) x;
        if (s &gt;= CANCELLED)
            throw new CancellationException();
        throw new ExecutionException((Throwable) x);
    }
}
</code></pre>
<h2 id="如何使用-3"><a class="header" href="#如何使用-3">如何使用</a></h2>
<p>而使用则非常简单，也非常的朴素。</p>
<p>我们以文中的的例子进行改造:</p>
<ol>
<li>沿用原Runnable逻辑</li>
<li>移除回调，增加 <code>CalcResult</code></li>
<li>将 <code>CalcResult</code> 对象作为既定返回结果，Runnable中设置其属性</li>
</ol>
<pre><code class="language-java">class Demo {
   static class CalcResult {
      public int result;
   }
   public static void onStart() {
      System.out.println("threadId" + Thread.currentThread().getId() + ",onStart," + System.currentTimeMillis());

      final CalcResult calcResult = new CalcResult();
      Future&lt;CalcResult&gt; resultFuture = Executors.newSingleThreadExecutor().submit(() -&gt; {
         try {
            Thread.sleep(10);
         } catch (InterruptedException e) {
            e.printStackTrace();
         }
         final int result = 200 + 300;
         System.out.println("threadId" + Thread.currentThread().getId() + ",calc result:" + result + ";" + System.currentTimeMillis());
         calcResult.result = result;
      }, calcResult);

      System.out.println("threadId" + Thread.currentThread().getId() + "反正干点什么," + System.currentTimeMillis());
      if (resultFuture.isDone()) {
         try {
            final int ret = resultFuture.get().result;
            System.out.println("threadId" + Thread.currentThread().getId() + ",get result:" + ret + ";" + System.currentTimeMillis());
         } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
         }
      }
      finish();
   }
}
</code></pre>
<p>如果直接使用新特性Callback，则如下：</p>
<p><em>直接返回结果，当然也可以直接返回Integer，不再包裹一层</em></p>
<pre><code class="language-java">class Demo {
   public static void onStart() {
      System.out.println("threadId" + Thread.currentThread().getId() + ",onStart," + System.currentTimeMillis());

      ExecutorService executor = Executors.newSingleThreadExecutor();
      Future&lt;CalcResult&gt; resultFuture = executor.submit(() -&gt; {
         try {
            Thread.sleep(10);
         } catch (InterruptedException e) {
            e.printStackTrace();
         }
         final int result = 200 + 300;
         System.out.println("threadId" + Thread.currentThread().getId() + ",calc result:" + result + ";" + System.currentTimeMillis());
         final CalcResult calcResult = new CalcResult();
         calcResult.result = result;
         return calcResult;
      });

      System.out.println("threadId" + Thread.currentThread().getId() + "反正干点什么," + System.currentTimeMillis());
      if (resultFuture.isDone()) {
         try {
            final int ret = resultFuture.get().result;
            System.out.println("threadId" + Thread.currentThread().getId() + ",get result:" + ret + ";" + System.currentTimeMillis());
         } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
         }
      }
      executor.shutdown();
      finish();
   }
}
</code></pre>
<p>相信读者诸君会有这样的疑惑：</p>
<blockquote>
<p>为何使用Future比原先的回调看起来粗糙？</p>
</blockquote>
<p>首先要明确一点：文中前段的回调Demo，虽然达成了既定目标，但效率并不高！！在当时计算很昂贵的背景下，并不会如此莽撞地使用！</p>
<p>而在JDK1.5开始，提供了大量内容支持多线程开发。考虑到篇幅，会在系列文章中逐步展开。</p>
<p>另外，FutureTask中的CAS与Happens-Before本篇中亦不做展开。</p>
<p>接下来，再做一些引申，简单看一看多线程业务模式。</p>
<h2 id="引申多线程业务模式"><a class="header" href="#引申多线程业务模式">引申，多线程业务模式</a></h2>
<p>常用的多线程设计模式包括：</p>
<ul>
<li>Future模式</li>
<li>Master-Worker模式</li>
<li>Guarded Suspension模式</li>
<li>不变模式</li>
<li>生产者-消费</li>
</ul>
<h3 id="future模式"><a class="header" href="#future模式">Future模式</a></h3>
<p>文中对于Future的使用方式遵循了Future模式。</p>
<p>业务方在使用时，已经明确了任务被分离到其他线程执行时有等待期，在此期间，可以干点别的事情，不必浪费系统资源。</p>
<h3 id="master-worker模式"><a class="header" href="#master-worker模式">Master-Worker模式</a></h3>
<blockquote>
<p>在程序系统中设计两类线程，并相互协作：</p>
<ul>
<li>Master线程（单个）</li>
<li>Worker线程</li>
</ul>
<p>Master线程负责接受任务、分配任务、接收（必要时进一步组合）结果并返回；</p>
<p>Worker线程负责处理子任务，当子任务处理完成后，向Master线程返回结果；</p>
</blockquote>
<p><em>作者按：此时可再次回想一下文章开头的Demo</em></p>
<h3 id="guarded-suspension模式"><a class="header" href="#guarded-suspension模式">Guarded Suspension模式</a></h3>
<ol>
<li>使用缓存队列，使得 服务线程/服务进程 在未就绪、忙碌时能够延迟处理请求。</li>
<li>使用等待-通知机制，将消费 <code>服务的返回结果</code> 的方式规范化</li>
</ol>
<h3 id="不变模式"><a class="header" href="#不变模式">不变模式</a></h3>
<p>在并行开发过程中，为确保数据的一致性和正确性，有必要对对象进行同步，而同步操作会对程序系统的性能产生相当的损耗。</p>
<p>因此，使用状态不可改变的对象，依靠其不变性来确保 <strong>并行操作</strong> 在 <strong>没有同步机制</strong> 的情况下，保持一致性和正确性。</p>
<ol>
<li>对象创建后，其内部状态和数据不再发生改变</li>
<li>对象被共享、被多个线程访问</li>
</ol>
<h3 id="生产者-消费"><a class="header" href="#生产者-消费">生产者-消费</a></h3>
<p>设计两类线程：若干个生产者线程和若干个消费者线程。</p>
<p>生产者线程负责提交用户请求，消费者线程负责处理用户请求。生产者和消费者之间通过共享内存缓冲区进行通信。</p>
<p>内存缓冲区的意义：</p>
<ul>
<li>解决是数据在多线程间的共享问题</li>
<li>缓解生产者和消费者之间的性能差</li>
</ul>
<p>这几种模式从不同角度出发解决特定问题，但亦有一定的相似之处，不再展开。</p>
<h2 id="后记-1"><a class="header" href="#后记-1">后记</a></h2>
<p>至此，我们已经进入尾声，JDK1.5中，对多线程的支持迎来一波井喷。本文以及系列文章中关于线程池的内容也仅仅是基础中的基础，仍旧有大量的内容值得深入，本篇不再往下挖掘。</p>
<p>在后续的系列文章中，我们将展开AQS、HAPPENS-BEFORE等内容，以及和本文高度关联的CompleteFutureTask，JUC工具等。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java多线程系列---forkjoin框架分治的艺术"><a class="header" href="#java多线程系列---forkjoin框架分治的艺术">Java多线程系列-- Fork&amp;Join框架，分治的艺术</a></h1>
<h2 id="前言-17"><a class="header" href="#前言-17">前言</a></h2>
<p>本篇是多线程系列中的一篇，我们在先前的一篇文章中回顾了线程池的主要知识</p>
<p><em><a href="https://juejin.cn/post/7098235227490746375">Java多线程基础--线程的创建与线程池管理</a></em></p>
<p>过去了很长时间，我们简单提要一下：</p>
<ul>
<li>设计目的：简化线程的使用，管理与复用，避免直接操作线程</li>
<li>如何使用线程池</li>
<li>设计实现与源码细节</li>
</ul>
<p>本篇我们延续下去，回顾 Fork&amp;Join。主要内容如下：</p>
<ul>
<li>使用场景和注意事项</li>
<li>设计原理</li>
<li>示例代码演示使用方式以及和线程池简单对比</li>
</ul>
<h2 id="全文总结"><a class="header" href="#全文总结">全文总结</a></h2>
<p><em>内容为基础部分，简单拾遗的读者扫一眼总结即可，若均已掌握，没必要浪费时间阅读细节</em></p>
<ul>
<li>ForkJoinPool是线程池的补充，并不是替代。线程池一般用于处理 <strong>独立的</strong> 请求、任务</li>
<li>适合实现 "分治" 类算法，尤其是分治后递归调用的函数</li>
<li>适用于计算密集型，如果是I/O密集型，或者线程间同步等造成长时间阻塞时，可配合ManagedBlocker使用</li>
<li>Work Stealing（工作窃取）机制 和 双端队列，已经了解设计细节便不需要再看下去了</li>
</ul>
<h2 id="如何使用-4"><a class="header" href="#如何使用-4">如何使用</a></h2>
<p><em>本章非常的基础，已经掌握如何使用，但没有思考过Fork&amp;Join设计思路的读者，可以跳跃到 <a href="MultiThreading/post_50.html#anchor1">原理</a></em></p>
<p>我们挑选一道简单题 <a href="https://leetcode.cn/problems/fibonacci-number/">计算斐波那契数</a> ,并使用递归算法求解。</p>
<blockquote>
<p>斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：</p>
<p>F(0) = 0，F(1) = 1</p>
<p>F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1</p>
<p>给定 n ，请计算 F(n) 。</p>
<p>来源：<a href="https://leetcode.cn/problems/fibonacci-number/">力扣（LeetCode）</a></p>
</blockquote>
<h3 id="forkjoin-实现"><a class="header" href="#forkjoin-实现">Fork&amp;Join 实现</a></h3>
<p>如题，我们需要定义计算任务，这将通过继承 <code>ForkJoinTask 实现</code>，当计算任务不可分（或者没有必要分解）时，自行处理结果返回，否则分解任务。</p>
<pre><code class="language-java">static class Fibonacci extends RecursiveTask&lt;Long&gt; {
    final int n;

    public Fibonacci(int n) {
        this.n = n;
    }

    @Override
    protected Long compute() {
        System.out.println("compute fib(" + n + "), in thread:" + Thread.currentThread().getName());
        if (n &lt;= 1) {
            return (long) n;
        }
        Fibonacci f1 = new Fibonacci(n - 1);
        f1.fork();

        Fibonacci f2 = new Fibonacci(n - 2);
        f2.fork();

        return f2.join() + f1.join();
    }
}
</code></pre>
<p>我们通过 <code>fork()</code> 将子任务丢入任务队列，并通过 <code>join()</code> 得到计算后的结果。</p>
<p>接下来看一看使用ForkJoinPool执行任务：</p>
<p>我们定义一个最大工作线程数为4的ForkJoinPool，并计算 Fib(5) 的结果。<em>可按照CPU核心数取最大工作线程数</em></p>
<p><em>注意，因为没有针对计算过程做任何优化，并且使用了输出，不要计算过大的值折腾电脑</em></p>
<pre><code class="language-java">class Demo {

    public static void main(String[] args) {
        ForkJoinPool forkJoinPool = new ForkJoinPool(4);
        Fibonacci fib = new Fibonacci(5);
        Long result = forkJoinPool.invoke(fib);
        System.out.println(result);
    }
}
</code></pre>
<p>通过 <code>invoke(ForkJoinTask&lt;T&gt; task)</code> 可以在当前线程阻塞式获取计算结果。</p>
<p>通过 <code>execute(ForkJoinTask&lt;?&gt; task)</code> 可以进行异步处理，因为 <code>class ForkJoinTask&lt;V&gt; implements Future&lt;V&gt;</code>，
使用方式和Future一致，<a href="https://juejin.cn/post/7147552484213719076">复习链接</a></p>
<p><em>可以看到，递归过程中有很多的重复,但这源于算法本身</em>，</p>
<p>当递归算法本身会使得子任务产生重复计算或者重复任务时，应当考虑处理中间结果缓存，减少不必要的任务，可以减少重复计算和GC压力。</p>
<p>如果移除控制台输出，一般可以尝试下计算第40个，不建议再计算你更靠后的值。</p>
<pre><code>compute fib(5), in thread:ForkJoinPool-1-worker-1
compute fib(3), in thread:ForkJoinPool-1-worker-1
compute fib(1), in thread:ForkJoinPool-1-worker-1
compute fib(2), in thread:ForkJoinPool-1-worker-3
compute fib(0), in thread:ForkJoinPool-1-worker-3
compute fib(1), in thread:ForkJoinPool-1-worker-0
compute fib(4), in thread:ForkJoinPool-1-worker-2
compute fib(2), in thread:ForkJoinPool-1-worker-2
compute fib(0), in thread:ForkJoinPool-1-worker-2
compute fib(1), in thread:ForkJoinPool-1-worker-2
compute fib(3), in thread:ForkJoinPool-1-worker-2
compute fib(1), in thread:ForkJoinPool-1-worker-2
compute fib(2), in thread:ForkJoinPool-1-worker-0
compute fib(0), in thread:ForkJoinPool-1-worker-0
compute fib(1), in thread:ForkJoinPool-1-worker-3
5
</code></pre>
<h2 id="原理"><a class="header" href="#原理"><a id="anchor1">原理</a></a></h2>
<p>实际上，关于Java ForkJoin设计原理的分析，均源自其开发者 Doug Lea 的论文 <a href="https://gee.cs.oswego.edu/dl/papers/fj.pdf">A Java Fork/Join Framework</a>
以及结合源码展开讨论。</p>
<p>时间充裕的读者可以看一看论文原文，接下来我们节选论文重要内容进行理解。</p>
<h3 id="分治算法的核心思路"><a class="header" href="#分治算法的核心思路">分治算法的核心思路</a></h3>
<p>以伪代码描述分治的思想如下，当问题足够小（无需再拆分）时，直接处理，否则拆分问题，处理并汇总结果</p>
<pre><code>Result solve(Problem problem){
    if(problem is small){
        directly solve problem
    }else{
        split problem into independent parts
        fork new subtasks to solve each part
        join all subtasks
        compose result from subresults
    }
}
</code></pre>
<h3 id="分治并行的核心要求"><a class="header" href="#分治并行的核心要求">分治+并行的核心要求</a></h3>
<p>核心要求:框架能够让构建的子任务并行执行，并且拥有一种等待子任务运行结束的机制。</p>
<p>不难理解这一要求。</p>
<blockquote>
<p>让我们思考一下，线程池+Future是不是满足这一要求？</p>
</blockquote>
<p>很显然，线程池满足这个要求，但线程池的部分策略，甚至Thread的很多核心设计，对于 Fork/Join思路 而言是多余（过剩）的。</p>
<h3 id="哪些是过剩的"><a class="header" href="#哪些是过剩的">哪些是过剩的</a></h3>
<p>包含这几个方面的过剩：</p>
<ul>
<li>Thread本身跟踪记录阻塞的手段</li>
<li>线程池对线程的管理</li>
<li>线程池对任务的管理</li>
</ul>
<p>首先， 在同步和管理方面，Fork/Join任务只有简单的和常规的需求。<em>例如，Fork/Join任务除了等待子任务执行结果，其他情况下不需要阻塞。</em>
因此传统的用于跟踪记录阻塞线程的代价，是一种过剩。</p>
<p><strong>但这种过剩不会为了Fork/Join而推翻重建</strong></p>
<p>其次，对于合理的基础任务粒度而言，构建和管理一个线程的代价，可能比执行任务花费的代价更大。线程池对线程的多种管理手段，大多是不必要的。</p>
<p>再者，Fork&amp;Join 是处理同一个任务的子任务，它更像是一组 "事务"，只在意最终结果，否则就全部取消并丢弃。 而线程池是面向独立的任务，并且采用了BlockingQueue暂存任务，以保障并发时高效且准确。这些对于Fork&amp;Join
而言，都是没有必要的。</p>
<h3 id="fjtask框架思路图示"><a class="header" href="#fjtask框架思路图示">FJTask框架思路图示</a></h3>
<p><em>注:论文从开始就以 "FJTask框架" 指代了Java中将要实现的Fork&amp;Join框架，以 "FJTask" 指代一个可由分治解决的任务</em></p>
<img width="400" alt="desc" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13fbd2e5b60d43cba042b38031bf8e12~tplv-k3u1fbpfcp-watermark.image?"/>
<p>很朴素的思路，让任务得到拆分，并被指派到合适的工作线程中执行，汇总出结果。</p>
<h3 id="work-stealing"><a class="header" href="#work-stealing">work-stealing</a></h3>
<p>上文中我们已经提及，线程池对于任务的管理机制对于 FJTask框架 而言是过剩的。除此之外，Fork&amp;Join倾向于 "大任务优先" 去窃取任务。</p>
<p>这也是Java API文档中提到的，ForkJoinPool和线程池最大的不同（<em>毕竟核心线程数和最大线程数一致的线程池，管理线程是类似的</em>）</p>
<blockquote>
<p>all threads in the pool attempt to find and execute tasks submitted to the pool and/or
created by other active tasks (eventually blocking waiting for work if none exist).</p>
<p>This enables efficient processing when most tasks spawn other subtasks (as do most ForkJoinTasks),
as well as when many small tasks are submitted to the pool from external clients.</p>
<p>Especially when setting asyncMode to true in constructors, ForkJoinPools may also be appropriate
for use with event-style tasks that are never joined.</p>
</blockquote>
<p>按照该设计思路，先让每一个工作线程拥有自己的任务队列，这样在管理方式上才有减负的空间。</p>
<p>参考CILK的设计，给FJTask框架制定如下的任务管理策略</p>
<ul>
<li>每一个工作线程维护自身调度队列中的可运行任务</li>
<li>队列以双端队列的形式被维护，<em>支持后进先出:LIFO的push和pop操作; 和先进先出:FIFO的take操作</em></li>
<li>工作线程将任务所产生的子任务，放入到工作线程自身的双端队列中</li>
<li>处理队列中的任务时，工作线程使用后进先出（LIFO）的策略，<em>递归</em></li>
<li>当一个工作线程，没有本地任务可运行时，它将尝试窃取其他工作线程的任务。此时按照先进先出(FIFO)的策略，即大任务优先。</li>
<li>当一个工作线程触及了join操作，它将尝试处理其他任务，直到目标任务被告知已经结束（通过isDone方法）。所有的任务都会无阻塞的完成。</li>
<li></li>
</ul>
<p>当一个工作线程，没有本地任务可运行，且无法从其他线程中获取任务时，它就会退出（通过yield、sleep和/或者优先级调整）并经过一段时间之后再度尝试直到所有的工作线程都被告知他们都处于空闲的状态。在这种情况下，他们都会阻塞直到其他的任务再度被上层调用。</p>
<p>其中的1-5条，均在下图中得到体现。</p>
<p><em>椭圆代表了工作线程，它内部维护一个双端队列，通过Pushing 放入任务，通过Popping弹出任务执行，并可能被其他工作者从另一端窃取任务</em></p>
<img width="400" alt="work-stealing" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/736cbb1d75284b509ea46f666b87b2e0~tplv-k3u1fbpfcp-watermark.image?"/>
<hr />
<p><em>作者按：源码部分本篇不展开，建议没有读过源码的读者，花点时间泛读一二</em></p>
<h2 id="managedblocker"><a class="header" href="#managedblocker">ManagedBlocker</a></h2>
<p>这是 ForkJoinPool中采用的，为任务提供扩展管理并行数的接口。</p>
<p>在FJTask中，我们希望充分的发挥多核CPU的计算性能，它被设计的擅长计算，但遇到会阻塞的任务时，CPU则会被浪费。</p>
<p>往往在可能会阻塞的任务中，我们期望能增加线程来处理任务，而不是单纯的阻塞等待。</p>
<pre><code class="language-java">public static interface ManagedBlocker {

    boolean block() throws InterruptedException;
    
    boolean isReleasable();
}
</code></pre>
<p>实现并调用：<code>ForkJoinPool#managedBlock</code>。</p>
<p><code>isReleasable()</code>: 如果不需要阻塞，则返回 true;</p>
<p><code>block()</code>: 可能阻塞当前线程，例如等待锁定或条件, 如果没有额外的阻塞必要，返回true。</p>
<p>关于创建补偿线程的细节，不再展开。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java多线程系列--掌握completablefuture驾驭异步编程"><a class="header" href="#java多线程系列--掌握completablefuture驾驭异步编程">Java多线程系列--掌握CompletableFuture，驾驭异步编程</a></h1>
<h2 id="前言-18"><a class="header" href="#前言-18">前言</a></h2>
<p>本文隶属于我归纳整理的Android知识体系的第四部分，属于 <code>异步</code> 部分的多线程内容</p>
<p>您可以通过访问 <a href="https://leobert-lan.github.io/MultiThreading/post_33.html">总纲</a> 阅读系列内的其他文章。</p>
<img width="600" alt="desc" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d229ce6c3a5d4e52985f24fd489f4943~tplv-k3u1fbpfcp-watermark.image?"/>
<p><em>作者按：草稿进行了几次大改，移除了Demo部分、源码解析部分、设计原理部分。结合实际工作经验，"掌握API能熟练使用、能无障碍阅读相关框架源码" 已基本够用。</em></p>
<p>读者可结合下面的导图进行快速的知识自查</p>
<img width="800" alt="desc" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d39c0a5a14540a787f6cc95706d62ce~tplv-k3u1fbpfcp-watermark.image?"/>
<h2 id="一个美好的期望"><a class="header" href="#一个美好的期望">一个美好的期望</a></h2>
<p>通常情况下，我们希望代码的执行顺序和代码的组织顺序一致，即代码表述了同步执行的程序，这样可以减少很多思考。</p>
<p>而 <strong>阅读异步的程序代码，需要在脑海中建立事件流</strong>，当程序业务复杂时，将挑战人的记忆力和空间想象力，<strong>并非所有人都擅长在脑海中构建并分析异步事件流模型</strong>。</p>
<blockquote>
<p>所以，我们期望拥有一个非常友好的框架，能够让我们方便地进行异步编程，并且在框架内部设计有线程同步、异常处理机制。</p>
<p>并且，基于该框架编写的代码具有很高的可读、可理解性。</p>
</blockquote>
<p>而Future基本无法满足这一期望。</p>
<h2 id="future的不足与completablefuture的来源"><a class="header" href="#future的不足与completablefuture的来源">Future的不足与CompletableFuture的来源</a></h2>
<h3 id="future的不足"><a class="header" href="#future的不足">Future的不足</a></h3>
<blockquote>
<p>在先前的系列文章中，我们已经回顾了Future类的设计，在绝大多数场景下，我们选择使用多线程，是为了 <strong>充分利用机器性能</strong> 以及 <strong>避免用户交互线程出现长时间阻塞</strong> 以致影响体验。</p>
<p>所以我们将耗时的、会引起长时间阻塞的任务分离到其他线程执行，并在 <strong>合适时机</strong> 进行线程同步，于主线程（一般负责用户交互处理、界面渲染）中处理结果。</p>
</blockquote>
<p><em>详见拙作 <a href="https://leobert-lan.github.io/MultiThreading/post_46.html">掌握Future，轻松获取异步任务结果</a>
、<a href="https://juejin.cn/post/7147552484213719076">掘金链接</a></em></p>
<p><code>Future</code> 于 Java 1.5版本引入，它类似于 <code>异步处理的结果占位符</code> ， 提供了两个方法获取结果：</p>
<ul>
<li><code>get()</code>, 调用线程进入阻塞直至得到结果或者异常。</li>
<li><code>get(long timeout, TimeUnit unit)</code>, 调用线程将仅在指定时间 timeout 内等待结果或者异常，如果超时未获得结果就会抛出 TimeoutException 异常。</li>
</ul>
<p><code>Future</code> 可以实现 <code>Runnable</code> 或 <code>Callable</code> 接口来定义任务，一定程度上满足 <code>使用框架进行异步编程</code> 的期望，但通过整体源码可知它存在如下 <strong>3个问题</strong> ：</p>
<ul>
<li>调用 <code>get()</code> 方法会一直阻塞直到获取结果、异常，无法在任务完成时获得 "通知" ，无法附加回调函数</li>
<li>不具备链式调用和结果聚合处理能力，当我们想链接多个 <code>Future</code> 共同完成一件任务时，<strong>没有框架级的处理，只能编写业务级逻辑</strong>，合并结果，并小心的处理同步</li>
<li>需要单独编写异常处理代码</li>
</ul>
<p><em>使用 <code>get(long timeout, TimeUnit unit)</code> 和 <code>isDone()</code> 判断，确实可以缓解问题1，但这需要结合业务单独设计（调优），存在大量的不确定性。不再展开</em></p>
<p>Java 8中引入 <code>CompletableFuture</code> 来解决 <code>Future</code> 的不足。</p>
<h3 id="completablefuture来源"><a class="header" href="#completablefuture来源">CompletableFuture来源</a></h3>
<p><code>CompletableFuture</code> 的设计灵感来自于 <code>Google Guava</code> 库的 <code>ListenableFuture</code> 类，它实现了 <code>Future接口</code> 和 <code>CompletionStage接口</code> ，
并且新增一系列API，支持Java 8的 <code>lambda特性</code>，通过回调利用非阻塞方法，提升了异步编程模型。</p>
<img width="600" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0affb25beff4ac7bff9d5a28576ff12~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?"/>
<p>它解决了Future的不足，允许我们在非主线程中运行任务，并向启动线程 <em>(一般是主线程)</em> 通知 <code>任务完成</code> 或 <code>任务失败</code>，编写异步的、非阻塞的程序。</p>
<h2 id="使用completablefuture"><a class="header" href="#使用completablefuture">使用CompletableFuture</a></h2>
<h3 id="最简方式获取实例"><a class="header" href="#最简方式获取实例">最简方式获取实例</a></h3>
<p>使用 <code>CompletableFuture.completedFuture(U value)</code> 可以获取一个 <code>执行状态已经完成</code> 的 <code>CompletableFuture</code> 对象。</p>
<p><em>这可以用于快速改造旧程序，并进行逐步过渡</em></p>
<pre><code class="language-java">class Demo {
    @Test
    public void testSimpleCompletableFuture() {
        CompletableFuture&lt;String&gt; completableFuture =
                CompletableFuture.completedFuture("testSimpleCompletableFuture");

        assertTrue(completableFuture.isDone());
        try {
            assertEquals("testSimpleCompletableFuture", completableFuture.get());
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<h3 id="改造线程同步部分"><a class="header" href="#改造线程同步部分">改造线程同步部分</a></h3>
<p><em>部分老旧程序已经建立了多线程业务模型，我们可以使用 <code>CompletableFuture</code> 改造其中的线程同步部分，但暂不改造数据传递。</em></p>
<p>使用 <code>runAsync()</code> 方法，该方法接收一个 <code>Runnable</code> 类型的参数返回 <code>CompletableFuture&lt;Void&gt;</code>:</p>
<pre><code class="language-java">//并不改变原项目中数据传递的部分、或者不关心结果数据，仅进行同步
class Demo {
    @Test
    public void testCompletableFutureRunAsync() {
        AtomicInteger variable = new AtomicInteger(0);
        CompletableFuture&lt;Void&gt; runAsync = CompletableFuture.runAsync(() -&gt; process(variable));
        runAsync.join();
        assertEquals(1, variable.get());
    }

    public void process(AtomicInteger variable) {
        System.out.println(Thread.currentThread() + " Process...");
        variable.set(1);
    }
}
</code></pre>
<h3 id="进一步改造结果数据传递"><a class="header" href="#进一步改造结果数据传递">进一步改造结果数据传递</a></h3>
<p>当我们关心异步任务的结果数据、或者改造原 <strong>多线程业务模型</strong> 的 <strong>数据传递方式</strong> 时，可以使用 <code>supplyAsync()</code> 方法，该方法接收一个 <code>Supplier&lt;T&gt;</code>
接口类型的参数，它实现了任务的逻辑，方法返回 <code>CompletableFuture&lt;T&gt;</code> 实例。</p>
<pre><code class="language-java">class Demo {
    @Test
    public void testCompletableFutureSupplyAsync() {
        CompletableFuture&lt;String&gt; supplyAsync =
                CompletableFuture.supplyAsync(this::process);
        try {
            // Blocking 
            assertEquals("testCompletableFutureSupplyAsync", supplyAsync.get());
        } catch (ExecutionException | InterruptedException e) {
            e.printStackTrace();
        }
    }

    public String process() {
        return "testCompletableFutureSupplyAsync";
    }
}
</code></pre>
<h3 id="指定执行线程池"><a class="header" href="#指定执行线程池">指定执行线程池</a></h3>
<p>"获取用于执行任务的线程" 类似 Java 8 中的 <code>parallelStream</code>， <code>CompletableFuture</code> 默认从全局
<code>ForkJoinPool.commonPool()</code> 获取线程，用于执行任务。同时也提供了指定线程池的方式用于获取线程执行任务，您可以使用API中具有 <code>Executor</code> 参数的重载方法。</p>
<pre><code class="language-java">class Demo {
    @Test
    public void testCompletableFutureSupplyAsyncWithExecutor() {
        ExecutorService newFixedThreadPool =
                Executors.newFixedThreadPool(2);
        CompletableFuture&lt;String&gt; supplyAsync = CompletableFuture.supplyAsync(this::process,
                newFixedThreadPool);
        try {
            // Blocking 
            assertEquals("testCompletableFutureSupplyAsyncWithExecutor", supplyAsync.get());
        } catch (ExecutionException | InterruptedException e) {
            e.printStackTrace();
        }
    }

    public String process() {
        return "testCompletableFutureSupplyAsyncWithExecutor";
    }
}
</code></pre>
<p><code>CompletableFuture</code> 中有众多API，方法命名中含有 <code>Async</code> 的API可使用线程池。</p>
<p><em>截至此处，以上使用方式均与 <code>Future</code> 类似，接下来演示 <code>CompletableFuture</code> 的不同</em></p>
<h3 id="回调链式调用"><a class="header" href="#回调链式调用">回调&amp;链式调用</a></h3>
<p><code>CompletableFuture</code> 的 <code>get()</code>API是阻塞式获取结果，<code>CompletableFuture</code> 提供了</p>
<ul>
<li><code>thenApply</code></li>
<li><code>thenAccept</code></li>
<li><code>thenRun</code></li>
</ul>
<p>等API来避免阻塞式获取，并且可添加 <code>任务完成</code> 后的回调。这几个方法的使用场景如下：</p>
<ul>
<li><code>&lt;U&gt; CompletableFuture&lt;U&gt; thenApply(Function&lt;? super T,? extends U&gt; fn)</code> 收到结果后，可以进行转化</li>
<li><code>CompletableFuture&lt;Void&gt; thenAccept(Consumer&lt;? super T&gt; action)</code> 收到结果后，对其进行消费</li>
<li><code>CompletableFuture&lt;Void&gt; thenRun(Runnable action)</code> 收到结果后，执行回调，无法消费结果只能消费 <strong>这一事件</strong></li>
</ul>
<p><em>API较为简单，不再代码演示</em></p>
<p>显然，通过链式调用可以组装多个执行过程。</p>
<blockquote>
<p>有读者可能会疑惑：<code>Function</code> 和 <code>Consumer</code> 也可以进行链式组装，是否存在冗余呢？</p>
</blockquote>
<p>两种的链式调用特性确实存在重叠，您可以自行选择用法，但 <code>thenRun</code> 只能采用 <code>CompletableFuture</code>的链式调用。</p>
<p>另外，前面提到，我们可以指定线程池执行任务，对于这三组API，同样有相同的特性，通过 <code>thenXXXXAsync</code> 指定线程池，这是 <code>Function</code> 和 <code>Consumer</code> 的链式组装所无法完成的。</p>
<pre><code class="language-java">class Demo {
    @Test
    public void testCompletableFutureApplyAsync() {
        ExecutorService newFixedThreadPool = Executors.newFixedThreadPool(2);
        ScheduledExecutorService newSingleThreadScheduledExecutor = Executors.newSingleThreadScheduledExecutor();
        // 从线程池 newFixedThreadPool 获取线程执行任务 
        CompletableFuture&lt;Double&gt; completableFuture =
                CompletableFuture.supplyAsync(() -&gt; 1D, newFixedThreadPool)
                        .thenApplyAsync(d -&gt; d + 1D, newSingleThreadScheduledExecutor)
                        .thenApplyAsync(d -&gt; d + 2D);
        Double result = completableFuture.join();
        assertEquals(4D, result);
    }

}
</code></pre>
<h3 id="聚合多个completablefuture"><a class="header" href="#聚合多个completablefuture">聚合多个CompletableFuture</a></h3>
<p>通过 <code>聚合</code> 多个 <code>CompletableFuture</code>，可以组成更 <code>复杂</code> 的业务流，可以达到精细地控制粒度、聚焦单个节点的业务。</p>
<p><em>注意：操作符并不能完全的控制 <code>CompletableFuture</code> 任务执行的时机，您需要谨慎的选择 <code>CompletableFuture</code> 的创建时机</em></p>
<h4 id="thencomposethencomposeasync"><a class="header" href="#thencomposethencomposeasync">thenCompose、thenComposeAsync</a></h4>
<p><code>compose</code> 原意为 <code>组成</code>， 通过多个 <code>CompletableFuture</code> 构建异步流。</p>
<p>在操作的 <code>CompletableFuture</code> 获得结果时，将另一个 <code>CompletableFuture</code> <code>compose</code> 到异步流中，compose的过程中，可以根据操作的 <code>CompletableFuture</code> 的结果编写逻辑。</p>
<p>与 <code>thenApply</code> 相比，<code>thenCompose</code> 返回逻辑中提供的 <code>CompletableFuture</code> 而 <code>thenApply</code> 返回框架内处理的新实例。</p>
<p><em>注意，这一特性在使用 <code>FP编程范式</code>进行编码时，会显得非常灵活，一定程度上提升了函数的复用性</em></p>
<p><em>API含义直观，不再进行代码演示</em></p>
<h4 id="thencombinethencombineasync"><a class="header" href="#thencombinethencombineasync">thenCombine、thenCombineAsync</a></h4>
<p><code>thenCombine</code> 可以用于合并多个 <strong>独立任务</strong> 的处理结果。</p>
<blockquote>
<p><em>注意： <code>thenCompose</code> 进行聚合时，下游可以使用上游的结果，在业务需求上一般表现为依赖上一步结果，而非两者相互独立。</em></p>
</blockquote>
<p>例如，产品希望在博客详情页同时展示 "博客的详情" 和 "作者主要信息" ，以避免内容区抖动或割裂的骨架占位。这两者 <strong>可以独立获取时</strong> ，则可以使用 <code>thenCombine</code> 系列API，分别获取，并合并结果。</p>
<p><code>combine</code> 的特点是 被合并的两个 <code>CompletableFuture</code> 可以并发，等两者都获得结果后进行合并。</p>
<p>但它依旧存在使用上的不便捷，合并超过2个 <code>CompletableFuture</code> 时，显得不够灵活。可以使用
<code>static CompletableFuture&lt;Void&gt; allOf(CompletableFuture&lt;?&gt;... cfs)</code> API。</p>
<p><code>allOf</code> 创建了 <code>CompletableFuture&lt;Void&gt;</code>，并不会帮助我们合并结果，所以需要自行编写业务代码合并，故存在 <code>Side Effects</code>。</p>
<h4 id="runafterbothrunafterbothasyncrunaftereitherrunaftereitherasync"><a class="header" href="#runafterbothrunafterbothasyncrunaftereitherrunaftereitherasync">runAfterBoth、runAfterBothAsync;runAfterEither、runAfterEitherAsync</a></h4>
<ul>
<li><code>runAfterBoth</code> 系列API在两个 <code>CompletableFuture</code> 都获得结果后执行回调</li>
<li><code>runAfterEither</code> 系列API在两个 <code>CompletableFuture</code> 任意一个获得结果后执行回调</li>
</ul>
<p>通过API，不难理解它们需要使用者自行处理结果</p>
<ul>
<li><code>CompletableFuture&lt;Void&gt; runAfterBoth(CompletionStage&lt;?&gt; other, Runnable action)</code>;</li>
<li><code>CompletableFuture&lt;Void&gt; runAfterEither(CompletionStage&lt;?&gt; other, Runnable action)</code></li>
</ul>
<p>同样可以增加编码灵活性，不再赘述。</p>
<h4 id="applytoeitherapplytoeitherasyncaccepteitheraccepteitherasyncthenacceptboththenacceptbothasync"><a class="header" href="#applytoeitherapplytoeitherasyncaccepteitheraccepteitherasyncthenacceptboththenacceptbothasync">applyToEither、applyToEitherAsync；acceptEither、acceptEitherAsync;thenAcceptBoth、thenAcceptBothAsync</a></h4>
<ul>
<li><code>applyToEither</code> 系列API表现如 <code>thenApply</code> 和 <code>Either</code> 的组合，两个同类型的 <code>CompletableFuture</code> 任意一个获得结果后，可消费该结果并进行改变，类似 thenApply</li>
<li><code>acceptEither</code> 系列API表现如 <code>thenAccept</code> 和 <code>Either</code> 的组合，两个同类型的 <code>CompletableFuture</code> 任意一个获得结果后，可消费该结果，类似 thenAccept</li>
<li><code>thenAcceptBoth</code> 系列API表现如 <code>thenCombine</code>，但返回 <code>CompletableFuture&lt;Void&gt;</code></li>
</ul>
<p>同样可以增加编码灵活性，不再赘述</p>
<h3 id="结果处理"><a class="header" href="#结果处理">结果处理</a></h3>
<p>使用回调处理结果有两种API，注意，除了正常获得结果外还可能获得异常，而这两组API簇差异体现在对 <code>异常</code> 的处理中。</p>
<p><code>&lt;U&gt; CompletableFuture&lt;U&gt; handle(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn)</code>
<code>CompletableFuture&lt;T&gt; whenComplete(BiConsumer&lt;? super T, ? super Throwable&gt; action)</code></p>
<p><code>handle</code> 使用 <code>BiFunction</code>，无论是正常结果还是异常情况，均视作可被逻辑接受，消费后转化</p>
<p>而 <code>whenComplete</code> 使用 <code>BiConsumer</code>，仅可消费但不能转化，异常情况被视作不可被逻辑接受，仍会抛出。</p>
<p>举个例子，进行网络编程时会遇到 <code>Exception</code>, 如果业务设计中使用的模型实体包含了 <code>正常结果</code>、<code>异常</code> 两种情况：</p>
<pre><code class="language-kotlin">open class Result&lt;T&gt;(val t: T?) {
    open val isThr: Boolean = false
}

class FailResult&lt;T&gt;(val tr: Throwable) : Result&lt;T&gt;(null) {
    override val isThr: Boolean = true
}
</code></pre>
<p>则适合使用 <code>handle</code> API在底层处理。否则需要额外的异常处理，<em>可依据项目的设计选择处理方式，一般在依据FP范式设计的程序中，倾向于使用handle，避免增加side effect。</em></p>
<h3 id="异常处理"><a class="header" href="#异常处理">异常处理</a></h3>
<p>在多线程背景下，异常处理并不容易。它不仅仅是使用 <code>try-catch</code> 捕获异常，还包含程序异步流中，节点出现异常时流的业务走向。</p>
<p>在 <code>CompletableFuture</code> 中，节点出现异常将跳过后续节点，进入异常处理。</p>
<p>_如果您不希望某个节点抛出异常导致后续流程中断，则可在节点的处理中捕获并包装为结果、或者对子 CompletableFuture 节点采用 <code>handle</code>、<code>exceptionally</code> API转换异常 _</p>
<p>除前文提到的 <code>handle</code> <code>whenComplete</code>，<code>CompletableFuture</code> 中还提供了 <code>exceptionally</code> API用于处理异常</p>
<p><code>CompletableFuture&lt;T&gt; exceptionally(Function&lt;Throwable, ? extends T&gt; fn)</code></p>
<p>从表现结果看，它类似于 <code>handle</code> API中对异常的处理，将异常转换为目标结果的一种特定情形。</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="io"><a class="header" href="#io">IO</a></h3>
<p>IO系列</p>
<ul>
<li><a href="IO/./post_55.html">Java IO 系列总纲</a></li>
<li><a href="IO/./post_56.html">Java IO系列 | 经典 IO</a></li>
<li><a href="IO/./post_57.html">Java IO 系列 | NIO-1.0一文速览</a></li>
<li><a href="IO/./post_58.html">Java IO系列 | NIO-1.0拾遗、NIO-2.0 &amp; 零拷贝必吹的牛皮</a></li>
<li><a href="IO/./post_59.html">IO系列 | 一文掌握OKHTTP中的OKIO为什么这么OK</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java-io-系列总纲"><a class="header" href="#java-io-系列总纲">Java IO 系列总纲</a></h1>
<p>在Android开发中，不可避免的会接触到IO，抛开系统部分的IO，在应用开发领域，仍然会接触到IO，诸如：</p>
<ul>
<li>文件读写</li>
<li>网络通信</li>
</ul>
<p>或许您在开发中不再直接使用JDK中的API完成IO部分的功能，但仍有必要了解相关知识。</p>
<p>JAVA的IO，通过虚拟机建立在操作系统的IO之上，在梳理JAVA的IO时，可适当了解操作系统部分IO的相关知识，但本系列不会深究。</p>
<h3 id="大纲"><a class="header" href="#大纲">大纲</a></h3>
<p>本系列中，计划包含以下内容：</p>
<ul>
<li>JAVA 经典IO 一篇</li>
<li>JAVA NIO 1-3篇</li>
<li>OK-IO 1篇</li>
<li>Linux系统中的IO（如有必要）</li>
<li>IO模型概览 <em>本文顺带</em></li>
</ul>
<hr />
<p>下图表现了一个冯诺依曼机的结构：</p>
<img width="500" alt="desc" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52fed46757174695b60c342ed90c0596~tplv-k3u1fbpfcp-watermark.image"/>
<p>在操作系统中，IO操作会涉及到 <code>用户空间、内核空间的切换</code> ，以及 <code>内核空间、用户空间之间的数据拷贝</code> ，接下来就常见的IO模型，简单了解下概念和设计理念。</p>
<p><em>注：不同操作系统在实现时会存在一定差异，不做深究</em></p>
<h2 id="io模型"><a class="header" href="#io模型">IO模型</a></h2>
<ul>
<li>阻塞I/O(blocking I/O)</li>
<li>非阻塞I/O(non-blocking I/O)</li>
<li>I/O复用(I/O multiplexing)</li>
<li>信号驱动式I/O(signal-driven I/O)</li>
<li>异步I/O(asynchronous I/O)</li>
</ul>
<h3 id="阻塞ioblocking-io"><a class="header" href="#阻塞ioblocking-io">阻塞I/O(blocking I/O)</a></h3>
<blockquote>
<p>阻塞IO、BIO、Blocking IO</p>
<p>在 <code>内核IO操作</code> 彻底完成后，才返回 <code>用户空间</code> 执行应用的操作。</p>
<p>此过程中，用户空间程序的执行状态是阻塞的，程序需等到IO操作彻底完成。</p>
</blockquote>
<p>以读为例，示意图如下</p>
<img width="500" alt="desc" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b64a8bb2f6cb49c382790cc817a1c933~tplv-k3u1fbpfcp-watermark.image"/>
<h3 id="非阻塞ionon-blocking-io"><a class="header" href="#非阻塞ionon-blocking-io">非阻塞I/O(non-blocking I/O)</a></h3>
<p><em>注意，此处不要与 <code>JAVA的nio包</code> 内容混淆</em></p>
<blockquote>
<p>非阻塞IO</p>
<p>相比于BIO，NIO中 <code>数据等待阶段</code> 是非阻塞的，操作系统不会挂起应用。</p>
<p>类似于JAVA中使用Future进行非阻塞多线程编程，以读为例，应用 <code>轮询</code> 内核，数据是否完成，数据准备就绪后，发起系统调用获取数据，系统调用的过程中，应用阻塞。</p>
</blockquote>
<blockquote>
<p>轮询： 应用进程对非阻塞描述符循环发送系统调用，以查看某个操作是否就绪</p>
</blockquote>
<p>以读为例，示意图如下</p>
<img width="500" alt="desc" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba20f635d8954f349fa91f149a67b0f8~tplv-k3u1fbpfcp-watermark.image"/>
<h3 id="io复用io-multiplexing"><a class="header" href="#io复用io-multiplexing">I/O复用(I/O multiplexing)</a></h3>
<blockquote>
<p>I/O复用</p>
<p>经典的Reactor设计。进程通过将一个或者多个操作阻塞在 <code>select</code> 阶段，select可以帮我们检测 <code>fd（文件操作符）</code> 是否处于就绪状态。</p>
<p>如果有数据准备好，就返回可操作的信息，再进行进一步地读写操作</p>
</blockquote>
<p>当需要观测的fd很多时，数据准备的占比可能变高，轮询的收益会降低，而多路复用会得到更高的收益。</p>
<p>以读为例，示意图如下</p>
<img width="500" alt="desc" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/072845f506cf49e2a887ff59dec607f2~tplv-k3u1fbpfcp-watermark.image"/>
<h3 id="信号驱动式iosignal-driven-io"><a class="header" href="#信号驱动式iosignal-driven-io">信号驱动式I/O(signal-driven I/O)</a></h3>
<blockquote>
<p>信号驱动式I/O</p>
<p>在数据准备阶段，不再阻塞等待，内核准备好数据后，通过信号通知用户空间，用户空间的应用发起系统调用，阻塞获取数据</p>
</blockquote>
<p>以读为例，示意图如下</p>
<img width="500" alt="desc" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8a09e9bc7b74e449c1d07fd470380d7~tplv-k3u1fbpfcp-watermark.image"/>
<h3 id="异步ioasynchronous-io"><a class="header" href="#异步ioasynchronous-io">异步I/O(asynchronous I/O)</a></h3>
<blockquote>
<p>异步I/O</p>
<p>不同于信号驱动式I/O，在数据等待完成后，进行内核到用户空间的数据拷贝，完成后信号通知应用程序处理数据</p>
</blockquote>
<img width="500" alt="desc" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73a8f4e05bf5483da29e79cb6d012256~tplv-k3u1fbpfcp-watermark.image"/>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java-io系列--经典-io"><a class="header" href="#java-io系列--经典-io">Java IO系列 | 经典 IO</a></h1>
<h2 id="前言-19"><a class="header" href="#前言-19">前言</a></h2>
<p>Android 开发中不可避免会接触到IO，本篇作为系列中的第一篇，将和大家一同花费5分钟的时间，梳理 经典IO 的知识。</p>
<p>重点内容脑图如下，文章亦按照此结构展开，如已熟练掌握，可跳过</p>
<img width="600" alt="desc" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e30f7a31900446f0ad56e53124d564e8~tplv-k3u1fbpfcp-watermark.image"/>
<p><em>作者按：在一些文章、资料中，将JDK1.4前的IO内容，称为 <code>经典IO</code>、 <code>BIO</code> 、 <code>标准IO</code> 、 <code>Blocking IO</code> 、<code>传统IO</code> 、 <code>Java IO</code>。 都有一定的道理，但注意 <code>BIO</code>
、<code>Blocking IO</code> 此类称谓可能引起混淆。本系列中以 <code>经典IO</code> 指代JDK1.4 前的IO</em></p>
<h2 id="java-经典io-概述"><a class="header" href="#java-经典io-概述">JAVA 经典IO 概述</a></h2>
<h3 id="流模型与分类"><a class="header" href="#流模型与分类">流模型与分类</a></h3>
<img width="600" alt="desc" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b37be911d88b4b97a3fa12dc1cc0cb8c~tplv-k3u1fbpfcp-watermark.image"/>
<p>在经典IO中，流(stream)是对数据传输的总称。流代表数据的流动。</p>
<ul>
<li>按 <code>操作单位</code> ，可以分为
<ul>
<li><code>字节流</code> ，操作对象为字节</li>
<li><code>字符流</code> ，操作对象为字符，涉及到编码</li>
</ul>
</li>
<li>按 <code>数据流方向</code> ， 可以分为：
<ul>
<li><code>输入流</code> ， 输入流代表从某个地方(硬盘、内存、网络等)读入内存</li>
<li><code>输出流</code> ， 输出流代表从内存写出到某个地方</li>
</ul>
</li>
<li>按 <code>功能类型</code> ， 可以分为：
<ul>
<li><code>节点流</code> ， 节点流代表数据的源头和终点，常见的有文件流、数组流和管道流等</li>
<li><code>处理流</code> ， 处理流是连接在节点流之上，为节点流提供某种额外的功能,如缓冲、转换等</li>
</ul>
</li>
</ul>
<h3 id="优点-3"><a class="header" href="#优点-3">优点</a></h3>
<p>不难想象，IO的 <code>场景</code> 和 <code>处理过程</code> 是多而繁杂的，因此需要 <code>加以抽象</code> 、并 <code>建立类簇</code>，以满足程序设计的通用性和扩展性，而 <code>流</code> 的抽象非常贴切，包含了最基础的操作API。
<strong>对于调用方而言非常友好</strong>。</p>
<h3 id="局限性"><a class="header" href="#局限性">局限性</a></h3>
<p>经典IO 设计中采用 <code>同步阻塞机制</code> 。以读为例，调用 <code>read()</code> 方法时，如果数据尚未就绪，线程会阻塞。这会降低程序的运行效率，在网络IO中更加明显。</p>
<p>对于IO负荷较小的客户端程序，尚可接受，但对于 <code>高负载</code> 、<code>高并发</code> 的服务器环境，经典IO存在明显的瓶颈，并不能充分发挥硬件性能和带宽。</p>
<h2 id="字节流"><a class="header" href="#字节流">字节流</a></h2>
<p>按照数据流方向，JDK中设计有两个基类：</p>
<ul>
<li><code>InputStream</code> 读取字节数据的抽象父类</li>
<li><code>OutputStream</code> 写出字节数据的抽象父类</li>
</ul>
<h3 id="uml"><a class="header" href="#uml">UML</a></h3>
<p>JDK中主要的类UML图如下：</p>
<p><em>作者按：每个子类的具体作用不再展开，如您尚不清楚部分类的作用，可直接阅读JDK中的注释</em></p>
<img width="600" alt="desc" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12158bd37e164a2ea047778527bd4c98~tplv-k3u1fbpfcp-watermark.image"/>
<img width="600" alt="desc" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d0d8f5a1bf840e5954fb1348ba7eaa6~tplv-k3u1fbpfcp-watermark.image"/>
<ul>
<li><code>FileInputStream</code> 和 <code>FileOutputStream</code>:用于读写文件</li>
<li><code>BufferedInputStream</code> 和 <code>BufferedOutputStream</code>:带缓冲的文件流,可以提高读写效率</li>
<li><code>DataInputStream</code> 和 <code>DataOutputStream</code>:用于读写基本数据类型</li>
<li><code>ByteArrayInputStream</code> 和 <code>ByteArrayOutputStream</code>:操作内存中的字节数组</li>
<li><code>ObjectInputStream</code> 和 <code>ObjectOutputStream</code>:用于读写可序列化的对象</li>
</ul>
<p><em>当下，应用中 <code>ObjectInputStream</code>、<code>ObjectOutputStream</code> 使用相对较少，一般会将其序列化为JSON、XML存储或映射到数据库。</em></p>
<p>对象类必须满足以下条件：</p>
<ul>
<li>实现 <code>java.io.Serializable</code> 接口。</li>
<li>该类 <code>除transient关键字修饰</code> 的所有属性必须是可序列化的。</li>
</ul>
<pre><code class="language-java">class Demo {
    public static void main(String[] args) throws Exception{
        // 写对象
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("object.txt"));
        oos.writeObject(new Person("张三", 25));
        oos.close();

        // 读对象
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream("object.txt"));
        Person p = (Person) ois.readObject();
        ois.close();

        System.out.println(p.getName() + ", " + p.getAge());
        // 张三, 25
    }
}
</code></pre>
<h2 id="字符流"><a class="header" href="#字符流">字符流</a></h2>
<p>按照数据流的方向，JDK中设计有两大基类：</p>
<ul>
<li><code>Reader</code> :读取字符数据的抽象父类。</li>
<li><code>Writer</code> :写出字符数据的抽象父类。</li>
</ul>
<h3 id="uml-1"><a class="header" href="#uml-1">UML</a></h3>
<p>JDK中主要的类UML图如下：</p>
<img width="600" alt="desc" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ec3a5ac25154cfeaaeecbf6c6b833de~tplv-k3u1fbpfcp-watermark.image"/>
<img width="600" alt="desc" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1eb46d280c44f479fbbe4f0de6b202c~tplv-k3u1fbpfcp-watermark.image"/>
<ul>
<li><code>FileReader</code> 和 <code>FileWriter</code> :用于读取和写入字符文件</li>
<li><code>BufferedReader</code> 和 <code>BufferedWriter</code> :带缓冲的文件字符流,可以提高读写效率</li>
<li><code>CharArrayReader</code> 和 <code>CharArrayWriter</code> :读取和写入内存字符数组</li>
<li><code>PipedReader</code> 和 <code>PipedWriter</code> :pipe输入流、输出流,线程间通信</li>
<li><code>InputStreamReader</code> 和 <code>OutputStreamWriter</code>:将字节流转化为字符流,作为桥梁使用</li>
</ul>
<p><em>不再展示使用方式</em></p>
<h2 id="缓冲流"><a class="header" href="#缓冲流">缓冲流</a></h2>
<p>缓冲流内部有一个缓冲区,可以减少实际读取数据的次数,从而提高流的读取、写入效率。</p>
<p>缓冲流是一种加强的流, 内部拥有一个 <code>缓冲区</code> ,可以 <strong>减少系统调用的次数,从而提高读写效率</strong> 。</p>
<p>Java 提供了以下的缓冲流:</p>
<ul>
<li>字节缓冲流 <code>BufferedInputStream</code> 和 <code>BufferedOutputStream</code> : 对 <code>FileInputStream</code> 和 <code>FileOutputStream</code>  加以缓冲</li>
<li>字符缓冲流 <code>BufferedReader</code> 和 <code>BufferedWriter</code> : 对 <code>FileReader</code> 和 <code>FileWriter</code> 加以缓冲</li>
</ul>
<h2 id="打印流"><a class="header" href="#打印流">打印流</a></h2>
<p><code>PrintStream</code> 和 <code>PrintWriter</code> 可以打印各种数据类型，<code>PrintWriter</code> 的打印格式更加丰富一些,支持字符串的格式化输出。</p>
<p>两者主要区别:</p>
<ul>
<li><code>PrintStream</code> 是字节流, <code>PrintWriter</code> 是字符流。</li>
<li><code>PrintStream</code> 不支持写入文件之外的其他sink, 但 <code>PrintWriter</code> 支持。</li>
<li>在API丰富性上，<code>PrintStream</code> 只有 <code>print()</code> 和 <code>println()</code> 两个打印API, <code>PrintWriter</code> 更丰富,且支持格式化输出。</li>
<li><code>PrintWriter</code> 可能抛出 <code>IOException</code>。</li>
</ul>
<p><code>PrintStream</code> 存在少许性能优势，但在大多数情况下 PrintWriter 比 PrintStream 更实用。</p>
<h2 id="随机访问流"><a class="header" href="#随机访问流">随机访问流</a></h2>
<p><code>RandomAccessFile</code> 可以随机访问文件中的任意位置，它既可以作为输入流也可以作为输出流。</p>
<p>它具有两个构造方法:</p>
<ul>
<li><code>RandomAccessFile(File file, String mode)</code></li>
<li><code>RandomAccessFile(String name, String mode)</code></li>
</ul>
<p><code>mode参数</code> 指定打开文件的模式,有以下几种:</p>
<ul>
<li>r: 只读模式</li>
<li>rw: 读写模式</li>
<li>rws: 读写同步模式</li>
<li>rwd: 读写,同步元数据</li>
</ul>
<blockquote>
<p><code>rws</code>,比rw的写多了同步，同步写入指的是将文件内容和元数据同步写入磁盘,保证数据不丢失。</p>
<p>例如,我们写入一些数据,关闭流后,数据实际上还在操作系统的缓冲区,还没有真正写入磁盘，如果系统出现异常，缓冲区数据会丢失。</p>
<p><code>rwd</code>,比rw多了同步元数据，元数据是描述数据属性和结构的信息,文件系统会维护每个文件的元数据,如:</p>
<ul>
<li>文件大小</li>
<li>创建时间</li>
<li>最后修改时间</li>
<li>文件权限</li>
<li>文件类型等
rwd模式会在修改文件内容后自动更新文件的元数据,保证元数据的同步性</li>
</ul>
</blockquote>
<p>在文件断点续传需求场景下，<code>RandomAccessFile</code> 具有极高适用性，结合切片处理的思路，可以充分发挥带宽和多核多线程优势。</p>
<h2 id="结语-7"><a class="header" href="#结语-7">结语</a></h2>
<p>本篇文章简单梳理了Java 经典IO的基础知识，并未深入，应对客户端中的需求场景已基本够用，下一篇，我们将继续梳理Java NIO的基础知识。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java-io-系列--nio-10一文速览"><a class="header" href="#java-io-系列--nio-10一文速览">Java IO 系列 | NIO-1.0一文速览</a></h1>
<h2 id="前言-20"><a class="header" href="#前言-20">前言</a></h2>
<p>上篇文章中，我们梳理了Java 经典IO，虽未详尽，但已基本满足日常知识储备需求。</p>
<p>本篇文章，我们顺着Java IO的发展史，梳理 NIO-1.0 的基础知识，显然，1.0体现了版本的概念，此时 <code>NIO</code> 应解释为 <code>Java new IO</code> 更加合理。</p>
<p>本篇将按照以下脉络展开，已经熟练掌握的章节，建议直接跳过</p>
<img width="600" alt="desc" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26515eb07b3a464092121a7872caa8aa~tplv-k3u1fbpfcp-watermark.image"/>
<h2 id="nio-10概述"><a class="header" href="#nio-10概述">NIO-1.0概述</a></h2>
<p>在先前多线程系列中，我们提到JVM的线程非常贴近操作系统中的线程；在JAVA经典IO中，IO的阻塞会体现到JVM中的线程上。</p>
<p>因此，在高并发IO场景下，如果以"线程-IO一对一"的方式实现，开启、调度线程的资源消耗会演变为性能瓶颈。</p>
<p>在JAVA 1.4 的 NIO-1.0 中，对此情况进行了设计改进，使用：<code>通道（Channel）</code>+ <code>选择器（Selector）</code>+ <code>缓冲区（Buffer）</code> 形成组合拳。</p>
<h2 id="channel概述"><a class="header" href="#channel概述">Channel概述</a></h2>
<p>经典IO中，立足于 <strong>数据的流动</strong> 的角度进行了抽象，提出了 <code>Stream</code>，在 NIO-1.0中，立足于 <strong>IO操作</strong>，对IO中的关键角色进行了抽象，<code>Channel</code> 是整个操作的中心。</p>
<p>JDK文档中这样描述：</p>
<blockquote>
<p>A nexus for I/O operations.</p>
<p>A channel represents an open connection to an entity such as a hardware device, a file, a network socket, or a program component that is capable of performing one or more distinct I/O operations, for example reading or writing.</p>
<p>A channel is either open or closed. A channel is open upon creation, and once closed it remains closed. Once a channel is closed, any attempt to invoke an I/O operation upon it will cause a ClosedChannelException to be thrown. Whether or not a channel is open may be tested by invoking its isOpen method.</p>
<p>Channels are, in general, intended to be safe for multithreaded access as described in the specifications of the interfaces and classes that extend and implement this interface.</p>
</blockquote>
<p>大体信息如下：</p>
<blockquote>
<p>Channel 是 I/O 操作的中心。</p>
<ol>
<li>Channel 代表与实体(如硬件设备、文件、网络套接字或程序组件)的打开连接,它能够执行一种或多种不同的 I/O 操作,例如读取或写入。</li>
<li>一个 Channel 要么打开要么关闭。Channel 在创建时打开,关闭后将保持关闭状态。一旦 <code>Channel</code> 关闭, 在其上调用 I/O 操作时，都会导致抛出 <code>ClosedChannelException</code>。可以通过 isOpen 方法来测试 Channel 是否打开。</li>
<li>通常,Channel 旨在支持多线程访问安全，与其接口、扩展和实现类中所陈述的规范保持一致。</li>
</ol>
</blockquote>
<p>用一个草图描述：<code>通道</code> 、 <code>数据</code>、<code>应用</code>、<code>输入源/输出目标</code> 之间的关系：</p>
<img width="600" alt="desc" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27de340b4d81446aaf090395575f8be5~tplv-k3u1fbpfcp-watermark.image"/>
<p>不难理解：它是 I/O操作的中心</p>
<p>主要的 <code>Channel</code> 类有:</p>
<ul>
<li><code>FileChannel</code>: 主要用于文件IO</li>
<li><code>DatagramChannel</code>: 主要用于UDP网络IO</li>
<li><code>SocketChannel</code>: 主要用于TCP网络IO</li>
<li><code>ServerSocketChannel</code>: 主要用于监听TCP连接</li>
</ul>
<p><strong>值得注意：虽然Channel宣称是线程安全的，但不代表多线程并发写入都是合理的，仍然需要考虑写入的顺序和位置，以避免数据覆盖等问题，Zero-Copy暂不讨论</strong></p>
<p>排除掉大量干扰后，可摘出如下UML图：</p>
<img width="600" alt="desc" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f5fb4bd8d5b46138f9c3a4b0c0774d1~tplv-k3u1fbpfcp-watermark.image"/>
<h2 id="buffer-概述"><a class="header" href="#buffer-概述">Buffer 概述</a></h2>
<p><code>Buffer</code> 是特定基本类型的数据容器, 因 <code>Channel</code> 本身并不专注于内存中存储数据的细节，它配合 <code>Channel</code> 实现数据传输。</p>
<p>Buffer 可以从 <code>数据类型</code> 、<code>是否使用堆内存</code>、<code>访问方式</code> 三个维度进行分类</p>
<blockquote>
<p>按照数据类型分，JDK中主要包含有:</p>
</blockquote>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>FloatBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>ShortBuffer</li>
</ul>
<p>见名知意，不在赘述，均直接继承自抽象类 <code>Buffer</code></p>
<img width="600" alt="desc" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0075627688e4b69adee4f4fa53d6d4d~tplv-k3u1fbpfcp-watermark.image"/>
<p>整体实现思路一致，暂不展开。</p>
<blockquote>
<p>按照是否使用堆内内存可以分为</p>
</blockquote>
<ul>
<li>继承自 <code>XXXXBuffer</code> 的 <code>HeapXXXXBuffer</code>，如 <code>HeapByteBuffer</code>，它们使用JVM可以管理的堆内内存。</li>
<li><code>DirectBuffer</code> 接口实现类，如 <code>DirectByteBuffer</code>，它们使用堆外内存，所谓堆外是相对概念，此内存区不受JVM管理，使用Unsafe类自行管理</li>
</ul>
<blockquote>
<p>按照访问方式裂变出 只读Buffer，如 <code>HeapByteBufferR</code>, <code>DirectByteBufferR</code></p>
</blockquote>
<h2 id="channelbuffer-基本使用代码示例"><a class="header" href="#channelbuffer-基本使用代码示例">Channel+Buffer 基本使用代码示例</a></h2>
<p>以读取文件举例，使用方式大体如下：</p>
<pre><code class="language-java">import java.io.FileInputStream;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;

public class FileChannelRead {
    public static void main(String[] args) throws IOException {
        String filePath = "/path/of/file";
        FileInputStream fis = new FileInputStream(filePath);
        FileChannel channel = fis.getChannel();

        ByteBuffer buffer = ByteBuffer.allocate(1024);

        while (channel.read(buffer) != -1) {
            // Prepare for reading
            buffer.flip();

            while (buffer.hasRemaining()) {
                byte b = buffer.get();
                // Do something with b
            }

            // Prepare for writing
            buffer.clear();
        }

        channel.close();
        fis.close();
    }
}
</code></pre>
<h2 id="selector-模型"><a class="header" href="#selector-模型">Selector 模型</a></h2>
<p>文首我们提到：</p>
<blockquote>
<p>在JAVA经典IO中，IO的阻塞会体现到JVM中的线程，在高并发IO场景下，开启、调度线程的资源消耗也会演变为性能瓶颈。</p>
</blockquote>
<p>原因在于：经典IO无法在单一线程中应对多个IO等待数据就绪的场景。</p>
<p>不难理解，NIO1.0 需要解决这一问题，因此需要设计有 <code>Selector</code> ，它允许单个线程处理多个 <code>Channel</code>，具体表现为：
<code>Selector</code> 可检测多个注册的Channel上是否有新连接、数据可读或数据可写事件，据此遴选出Channel进行处理。这样可以实现：<strong>单一线程管理多个channel</strong>。</p>
<p>其工作原理本质为多路复用。可以体现为：</p>
<ul>
<li>将 Channel 注册到 Selector 上,并指定监听事件</li>
<li>反复调用 selector.select() 方法，该方法会一直阻塞,直到监测到 Channel 有事件发生</li>
<li>select() 方法返回后,可以通过 Selector 获得的 SelectionKey 集合,判断事件发生的 Channel</li>
<li>对 Channel 执行 IO 操作</li>
</ul>
<p>模型示意图如下：</p>
<img width="600" alt="desc" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71ac73dd54924178912332f420d68b6f~tplv-k3u1fbpfcp-watermark.image?"/>
<p><em>此图片通过某度图片检索获得，未得到具体出处，如有侵权请留言联系删除</em></p>
<p>Selector的具体实现不再展开，它由spi机制实现特定提供。如果读者诸君感兴趣，可自行阅读 <code>EPollSelectorImpl</code> 等源码。</p>
<p>JDK中的 <code>DefaultSelectorProvider</code> 是默认的提供逻辑，根据 <code>不同的操作系统</code> 创建不同的 <code>SelectorProvider</code>，用于提供 <code>SelectorImpl</code>：</p>
<ul>
<li>Windows操作系统，则创建 <code>WindowsSelectorProvider</code> 实例。</li>
<li>MacOS操作系统，则创建 <code>KQueueSelectorProvider</code> 实例。</li>
<li>Linux操作系统，则创建 <code>EPollSelectorProvider</code>、<code>PollSelectorProvider</code> 实例。</li>
</ul>
<h2 id="selector使用-与-selectionkey"><a class="header" href="#selector使用-与-selectionkey">Selector使用 与 SelectionKey</a></h2>
<p><em>读者诸君，可还记得上文中Channel的UML类图，<code>Selector</code> 面向 <code>SelectableChannel</code> 因此，<code>FileChannel</code> 是无法使用的。</em></p>
<h3 id="selectionkey"><a class="header" href="#selectionkey">SelectionKey</a></h3>
<p><code>SelectionKey</code> 是 可选择通道在 <code>Selector</code> 中注册的令牌， <code>SelectionKey</code> 有4个事件类型：</p>
<pre><code class="language-java">/**
 * 读事件：0000 0001
 */
public static final int OP_READ = 1 &lt;&lt; 0;
 
/**
 * 写事件：0000 0100
 */
public static final int OP_WRITE = 1 &lt;&lt; 2;
 
/**
 * 连接事件：0000 1000，连接操作，Client端支持的一种操作
 */
public static final int OP_CONNECT = 1 &lt;&lt; 3;
 
/**
 * 接受事件：0001 0000，可接受操作，仅ServerSocketChannel支持
 */
public static final int OP_ACCEPT = 1 &lt;&lt; 4;
</code></pre>
<h4 id="常用api"><a class="header" href="#常用api">常用API</a></h4>
<blockquote>
<p><code>interestOps()</code></p>
</blockquote>
<p>返回在Selector中注册的关注事件集，可以通过位运算反解判断 <code>Channel</code> 是否在 <code>Selector</code> 中注册某关注事件</p>
<p>参考如下：</p>
<pre><code>// 获取selectionKey 关注事件集
int interestSet = selectionKey.interestOps(); 
 
boolean isInterestedInAccept = (interestSet &amp; SelectionKey.OP_ACCEPT) != 0;
boolean isInterestedInConnect = interestSet &amp; SelectionKey.OP_CONNECT != 0;
boolean isInterestedInRead = interestSet &amp; SelectionKey.OP_READ != 0;
boolean isInterestedInWrite = interestSet &amp; SelectionKey.OP_WRITE != 0;
</code></pre>
<blockquote>
<p><code>readyOps()</code></p>
</blockquote>
<p>获取此selectionKey 对应的通道上已经就绪的事件集。可使用位运算判断相应事件，也可以直接使用API：</p>
<ul>
<li>boolean isAcceptable()</li>
<li>boolean isConnectable()</li>
<li>boolean isReadable()</li>
<li>boolean isWritable()</li>
</ul>
<blockquote>
<p><code>channel()</code></p>
</blockquote>
<p>获取注册时对应的Channel</p>
<pre><code>Channel channel = selectionKey.channel();
</code></pre>
<blockquote>
<p><code>selector()</code></p>
</blockquote>
<p>获取注册时目标Selector</p>
<pre><code class="language-java">Selector selector = selectionKey.selector();
</code></pre>
<blockquote>
<p>attachment()</p>
</blockquote>
<p>SelectionKey支持绑定一个附加对象</p>
<pre><code class="language-java">//注册时绑定
SelectionKey selectionKey = channel.register(selector,SelectionKey.OP_READ,obj);

//更新绑定
selectionKey.attach(obj);
</code></pre>
<p>通过 <code>selectionKey.attachment();</code> 可获取该附加对象。</p>
<p>需要注意：当不再需要该附加对象时，需解除绑定 <code>selectionKey.attach(null)</code>，否则影响GC</p>
<p>SelectionKey的底层实现细节不再展开。</p>
<h3 id="selector-常用api"><a class="header" href="#selector-常用api">Selector 常用API</a></h3>
<blockquote>
<p>select(),select(timeout),selectNow()</p>
</blockquote>
<p>获取 存在已就绪事件的通道 的数量，</p>
<p>当返回值不为0时，可进行IO处理</p>
<blockquote>
<p>selectedKeys()</p>
</blockquote>
<p>获取注册于该 <code>Selector</code> 上的 <code>事件就绪</code> 的 <code>SelectionKey</code>，参考上文中 SelectionKey进行使用，以下代码是一个使用示例：</p>
<pre><code>Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();
 
Iterator&lt;SelectionKey&gt; it = selectedKeys.iterator();
 
while(it.hasNext()) {
    SelectionKey key = keyIterator.next();
 
    if(key.isXXXXable()) {
     //处理 XXXX 事件
    }
 
   it.remove();
}
</code></pre>
<blockquote>
<p>wakeUp()</p>
</blockquote>
<p>当调用 <code>select()</code> 阻塞时，于另一个线程调用 <code>wakeup()</code> 可强行唤醒阻塞的线程，即select()方法立即返回。</p>
<p>如果调用wakeup()时，没有线程阻塞于 <code>select()</code> 上，下次调用 <code>select()</code> 将立即返回，不会进入阻塞状态。和 <code>LockSupport.unpark()</code> 类似。</p>
<blockquote>
<p><code>close()</code></p>
</blockquote>
<p>关闭 <code>Selector</code>，已注册的 <code>SelectionKey</code> 将失效，但不影响 <code>Channel</code></p>
<h2 id="buffer-api图解"><a class="header" href="#buffer-api图解">Buffer API图解</a></h2>
<p>缓冲区本质上是一个数组,但是它通过一系列的方法来追踪和访问数据,这使得它看起来像一个列表或队列。JDK中原汁原味的描述："a linear, finite sequence of elements of a specific
primitive type."</p>
<p>去掉其包含的内容数据不谈，缓冲区有3个属性:</p>
<ul>
<li>容量(Capacity):最大存储量，初始化时确定，不可改变</li>
<li>位置(Position):下一个要读或写的元素索引</li>
<li>限制(Limit):缓冲区不可操作的下一个元素的位置，limit &lt;= capacity</li>
</ul>
<p>沿用上文中读取文件的代码示例，其主要使用方式：</p>
<ul>
<li>向 <code>Buffer</code> 中写入数据，如 <code>channel.read(buffer)</code>，此时为写模式</li>
<li>调用 <code>flip()</code> 切换为读模式</li>
<li>从 <code>Buffer</code> 中取出数据，如 <code>buffer.get()</code></li>
<li>调用 <code>clear()</code> 或 <code>compact()</code> 切换为写模式</li>
</ul>
<p>重复直到读取完成（或异常）。</p>
<h3 id="api"><a class="header" href="#api">API</a></h3>
<p>下文将结合以下Demo代码介绍API，图示其属性变化</p>
<pre><code class="language-java">class Demo {
    void demo() {
        // 创建一个长度为10的ByteBuffer
        ByteBuffer buffer = ByteBuffer.allocate(10);

        // 写入5个字节到缓冲区
        buffer.put((byte) 1);
        buffer.put((byte) 2);
        buffer.put((byte) 3);
        buffer.put((byte) 4);
        buffer.put((byte) 5);

        // 翻转缓冲区 准备读取 
        buffer.flip();

        // 读取2个字节 
        byte a = buffer.get();
        byte b = buffer.get();

        buffer.rewind();

        // 清空缓冲区  
        buffer.clear();
    }
}
</code></pre>
<h4 id="分配空间"><a class="header" href="#分配空间">分配空间</a></h4>
<p>使用JVM堆内存的Buffer：</p>
<pre><code>ByteBuffer#allocate(int capacity)
</code></pre>
<p>使用堆外内存的Buffer：</p>
<pre><code>ByteBuffer#allocateDirect(int capacity)
</code></pre>
<p>申请一个容量为10的Buffer，此时：</p>
<ul>
<li>position 指向0</li>
<li>limit 和 capacity 为10，指向最大的位置9</li>
</ul>
<img width="600" alt="desc" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f48c34f0094e4b8481ab7ea7d894075f~tplv-k3u1fbpfcp-watermark.image"/>
<h4 id="向buffer中写入数据"><a class="header" href="#向buffer中写入数据">向Buffer中写入数据</a></h4>
<p>以ByteBuffer为例,具有以下重载API，参数见名知意：</p>
<pre><code class="language-html">ByteBuffer#put(byte b)
ByteBuffer#put(int index, byte b)
ByteBuffer#put(ByteBuffer src)
ByteBuffer#put(byte[])
ByteBuffer#put(byte[] src, int offset, int length)
</code></pre>
<p>而在 <code>CharBuffer</code> 等Buffer子簇中，<strong>针对其目标数据类型具有相应的API</strong> 。</p>
<p><em>而JDK中以Byte为主要数据类型进行基础功能的实现，下文中如无必要，将只讨论以Byte为目标数据的功能实现类。</em></p>
<p><em>作者按：读者诸君，如果您对JAVA的泛型和设计模式有一定了解，可能会思考 "为何JDK中的代码不利用泛型进行更系统性的抽象"，但注意：JDK1.4中尚无泛型</em></p>
<p>依次写入5个byte之后：</p>
<ul>
<li>position 指向5</li>
<li>limit 和 capacity 为10，指向最大的位置9</li>
</ul>
<img width="600" alt="desc" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55aababd441842ff82ed871cf6acdc6b~tplv-k3u1fbpfcp-watermark.image"/>
<h4 id="flip"><a class="header" href="#flip">flip</a></h4>
<p>翻转Buffer：</p>
<pre><code>Buffer#flip()

public Buffer flip() {
    limit = position;
    position = 0;
    mark = -1;
    return this;
}
</code></pre>
<p>如Doc所描述，flip干三件事情：The limit is set to the current position and then the position is set to zero. If the mark is defined then it is discarded.</p>
<p>不难理解，它的设计意图是将Buffer从 "写" 的工作模式切换到 "读" 的工作模式，并限定读取的边界。</p>
<p>在写入5个数据后flip：</p>
<ul>
<li>position 指向0</li>
<li>limit 为5, capacity 为10</li>
</ul>
<img width="600" alt="desc" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1616d5de97b045dc998703c14a1b02bc~tplv-k3u1fbpfcp-watermark.image"/>
<h4 id="从buffer中读出数据"><a class="header" href="#从buffer中读出数据">从Buffer中读出数据</a></h4>
<pre><code>ByteBuffer#get() :byte
ByteBuffer#get(int index) :byte
ByteBuffer#get(byte[] dst)
ByteBuffer#get(byte[] dst, int offset, int length)
</code></pre>
<p>参数见名知意，不再赘述。</p>
<p>继续flip后的操作，读取两个byte数据，此时：</p>
<ul>
<li>position 指向2</li>
<li>limit 为5, capacity 为10</li>
</ul>
<img width="600" alt="desc" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3ededd7518041c28d702bbbe7c45ae8~tplv-k3u1fbpfcp-watermark.image"/>
<h4 id="rewind"><a class="header" href="#rewind">rewind</a></h4>
<pre><code>public Buffer rewind() {
    this.position = 0;
    this.mark = -1;
    return this;
}
</code></pre>
<p>使用rewind可以重置 <code>mark标记</code> 和 <code>position</code>，此时可以从头再次读取缓冲区内容。</p>
<h4 id="clear--compact"><a class="header" href="#clear--compact">clear &amp; compact</a></h4>
<pre><code>public Buffer clear() {
    this.position = 0;
    this.limit = this.capacity;
    this.mark = -1;
    return this;
}

//HeapByteBuffer
public ByteBuffer compact() {
    int var1 = this.position();
    int var2 = this.limit();

    assert var1 &lt;= var2;

    int var3 = var1 &lt;= var2 ? var2 - var1 : 0;
    System.arraycopy(this.hb, this.ix(var1), this.hb, this.ix(0), var3);
    this.position(var3);
    this.limit(this.capacity());
    this.discardMark();
    return this;
}
</code></pre>
<p>clear 将重置所有属性，与初始化的状态一致，但并不会清除数据。不难理解：各个标记已经保障读写安全，因此历史缓冲不会导致脏数据问题</p>
<p>compact 将清除已读数据，并将属性处理为满足 "在未读数据后写入"</p>
<img width="600" alt="desc" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cfc82f01d0dd4b91bc12afd974fa367f~tplv-k3u1fbpfcp-watermark.image"/>
<h4 id="mark--reset"><a class="header" href="#mark--reset">mark &amp; reset</a></h4>
<p>mark和reset需要合并使用, mark用于在当前position打标记，进过一些行为后可能position发生变化，通过reset将position恢复到先前的标记。</p>
<pre><code>public Buffer mark() {
    this.mark = this.position;
    return this;
}

public Buffer reset() {
    int var1 = this.mark;
    if (var1 &lt; 0) {
        throw new InvalidMarkException();
    } else {
        this.position = var1;
        return this;
    }
}
</code></pre>
<h2 id="唠叨几句"><a class="header" href="#唠叨几句">唠叨几句</a></h2>
<p>上个月立了个FLAG，放言端午前写完IO系列。在内心也希望在今年多产出一些基础文章。</p>
<ul>
<li>一来是看看温故是否能知新；</li>
<li>二来是基础文章对刚入行或者准备入行的小兄弟们帮助大一些；</li>
<li>三来是对阐述理念类的文章还没有做好充足的准备；</li>
</ul>
<p>但计划赶不上变化，我也未能想到，在不换坑的情况下，我的工作性质发生了巨大改变，这种改变尚未到谈论好坏的阶段，但确实要耗费太多心神，以至于我的零碎时间往往用于情绪垃圾回收，而没心思再做它顾。</p>
<p>过于絮叨了。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java-io系列--nio-10拾遗nio-20--零拷贝必吹的牛皮"><a class="header" href="#java-io系列--nio-10拾遗nio-20--零拷贝必吹的牛皮">Java IO系列 | NIO-1.0拾遗、NIO-2.0 &amp; 零拷贝必吹的牛皮</a></h1>
<h2 id="前言-21"><a class="header" href="#前言-21">前言</a></h2>
<p>上一篇系列文章中，我们已经对NIO中的 Buffer、Channel、Selector 做了较为系统的梳理，凭借其内容，Android的同学应该能跨过侃大山的门槛了。</p>
<p>在 NIO-1.0 中，仍有两块儿内容值得展开：</p>
<ul>
<li>Scatter/Gather</li>
<li>零拷贝 Zero Copy</li>
</ul>
<p>而NIO-2.0中的内容，往底层深挖时确实量不少，但Android同学能拿来侃大山的知识相对很少，我们合并成一篇。</p>
<h2 id="jdk中的scattergather"><a class="header" href="#jdk中的scattergather">JDK中的Scatter&amp;Gather</a></h2>
<p><em>作者按：读者诸君务必注意，本章节中讨论的内容，均为JDK中体现 Scatter&amp;Gather 特性的内容，并非是操作系统层面的内容</em></p>
<p><code>Scatter</code> 译为 <code>分散</code> ， <code>Gather</code> 译为 <code>聚集</code></p>
<p><code>Scatter</code> 在NIO-1.0中的应用是 <code>Scattering Reads</code> ，是指数据从一个Channel读取到多个 <code>Buffer</code> 中:</p>
<img width="400" alt="desc" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63b6a3e7aa0243fda125305843064876~tplv-k3u1fbpfcp-watermark.image"/>
<p>一种典型的应用方向是实现数据协议，从应用编写角度看，编码思路更加简单。</p>
<p>例如，约定一个数据分包协议进行数据传输，每一个包包含 "10byte的Header" 和 "50byte的Body（不足进行填充）"</p>
<pre><code class="language-java">//ignore imports

public class ScatterExample {
    public static void main(String[] args) {

        try (SocketChannel channel = SocketChannel.open()) {
            channel.connect(new InetSocketAddress("localhost", 8080));

            ByteBuffer headerBuffer = ByteBuffer.allocate(10);
            ByteBuffer bodyBuffer = ByteBuffer.allocate(50);

            ByteBuffer[] buffers = {headerBuffer, bodyBuffer};

            long bytesRead = channel.read(buffers);

            headerBuffer.flip();
            bodyBuffer.flip();

            // Process the data in buffers, hexString代指16进制两位补齐的字符串
            System.out.println("Header: " + hexString(headerBuffer.array()));
            System.out.println("Body: " + hexString(bodyBuffer.array()));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}


</code></pre>
<p>不难想象，我们可以比较容易地实现：Header信息识别、内容拼包。</p>
<p><em>当然，一个健壮的协议不会如此简单，仅作为示意。</em></p>
<p>值得注意的是：Scattering Reads适合 "定长" 的读取情况。</p>
<p>相应的，<code>Gather</code> 在NIO-1.0中的应用是 <code>Gathering Writes</code>，指数据从多个Buffer按序写入同一个Channel中：</p>
<img width="400" alt="desc" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d42415585594bbb98b17c1d7af88843~tplv-k3u1fbpfcp-watermark.image"/>
<p>以下是一个简单使用Demo</p>
<pre><code class="language-java">//ignore imports
public class GatherExample {
    public static void main(String[] args) {
        try {
            // 创建SocketChannel并连接到服务器
            SocketChannel socketChannel = SocketChannel.open();
            socketChannel.connect(new InetSocketAddress("localhost", 8080));

            // 准备多个缓冲区
            ByteBuffer buffer1 = ByteBuffer.wrap("Hello,".getBytes());
            ByteBuffer buffer2 = ByteBuffer.wrap(" World!".getBytes());

            // 将多个缓冲区的数据写入到通道中
            ByteBuffer[] buffers = {buffer1, buffer2};
            socketChannel.write(buffers);

            // 关闭SocketChannel
            socketChannel.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p>与 <code>Scatter</code> 不同的是，<code>Gather</code> 擅长 <code>动态长度</code></p>
<h2 id="os中的零拷贝"><a class="header" href="#os中的零拷贝">OS中的零拷贝</a></h2>
<p><em>作者按：诸君请注意，本文中讨论零拷贝、Zero-Copy时，均指操作系统中的相关内容，如与Java间存在关联，会单独说明</em></p>
<!--而之所以普遍地将Zero-Copy和Java IO放在一起讨论，大抵有如下原因：

* 错误信息被不断分享
* 知识间有关联性，Java IO底层涉及到操作系统部分机制，很容易设置面试陷阱，考察知识完整性-->
<p>首先需要记住，<strong>零拷贝中并非没有拷贝，而是指新增各种机制，以减少主内存中不必要的拷贝，例如免去从内核态到用户态的拷贝</strong>。</p>
<p>发展历程中涉及到的技术：</p>
<ul>
<li>mmap</li>
<li>sendfile</li>
<li>splice 等</li>
</ul>
<p>我们以“将文件系统中的文件通过网卡发出“为例，简单讨论。</p>
<h3 id="传统io"><a class="header" href="#传统io">传统IO</a></h3>
<p>在JAVA中使用传统IO实现该需求时，即前文中所述经典IO，需要将文件系统中的文件内容，拷贝到应用内部，继而通过 <code>Socket</code> 从网卡发送.</p>
<p>包含两个关键操作：</p>
<pre><code>read()
write()
</code></pre>
<p>流程图和数据拷贝过程如下图：</p>
<img width="700" alt="desc" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc6b107010c540578d571e3beaaaf429~tplv-k3u1fbpfcp-watermark.image"/>
<blockquote>
<p>DMA: Direct Memory Access, 直接内存访问, 计算机总线架构提供的功能，它能使数据从附加设备（如磁盘驱动器）直接发送到计算机主板的内存上。</p>
</blockquote>
<p>整个过程中，发生两次系统调用，共发生了 4次用户态与内核态的 <code>上下文切换</code>，和4次数据拷贝：</p>
<ul>
<li><code>第一次拷贝</code> ，把磁盘上的数据拷贝到操作系统内核的缓冲区里，通过 DMA 搬运。</li>
<li><code>第二次拷贝</code> ，把内核缓冲区的数据拷贝到用户的缓冲区里，于是我们应用程序就可以使用这部分数据了，由 CPU 完成。</li>
<li><code>第三次拷贝</code> ，把刚才拷贝到用户的缓冲区里的数据，再拷贝到内核的 socket 的缓冲区里，由 CPU 完成。</li>
<li><code>第四次拷贝</code> ，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，通过 DMA 搬运。</li>
</ul>
<p>很显然，这一过程中，文件数据进入用户缓存区再离开，并没有附加必不可少的操作，上下文切换也比较多，存在改进的空间。</p>
<h3 id="mmap取代read"><a class="header" href="#mmap取代read">mmap取代read</a></h3>
<p>使用 <code>mmap</code> 取代 <code>read</code> 后，整个过程包含两个关键操作：</p>
<pre><code>mmap()
write()
</code></pre>
<p>先补充一张 <code>虚拟内存</code> 的原理示意图，如下：</p>
<img width="700" alt="desc" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f93635b183ef49828843c0f50518449a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp"/>
<p>使用虚拟地址取代物理地址后，多个虚拟内存可以指向同一个物理地址，虚拟内存表示的空间可以大于实际物理内存空间。</p>
<p>将 <code>用户空间缓存区</code> 中的部分虚拟内存 和 <code>内核空间缓存区</code> 中的部分虚拟内存，映射到同一物理内存区域时，可以减少不必要的拷贝。</p>
<p>在Linux中，<code>mmap</code> 将一个文件或一块设备内存（如设备寄存器）映射到进程的地址空间，实现 <code>文件磁盘地址</code> 或 <code>设备io地址</code> 与进程虚拟地址空间中一段虚拟地址建立映射，<code>ioremap</code> 实现向内核空间映射 。</p>
<p>使用该技术后，可减少一次CPU拷贝，但上下文切换次数不变，流程图和数据流示意图如下：</p>
<img width="700" alt="desc" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f185eb4d5d624e39b6e9ae1d3d7f0306~tplv-k3u1fbpfcp-watermark.image"/>
<p>3次 <code>数据拷贝</code>，系统调用次数不变，4次 <code>上下文切换</code>。</p>
<p>java中使用Demo，从上层编码也能体现一二：</p>
<pre><code class="language-java">class Demo {
    public static void main(String[] args) {
        try {
            // 获取文件
            FileChannel readChannel = FileChannel.open(Paths.get("/..../test1.txt"), StandardOpenOption.READ);
            MappedByteBuffer data = readChannel.map(FileChannel.MapMode.READ_ONLY, 0, readChannel.size());
            FileChannel writeChannel = FileChannel.open(Paths.get("/..../test2.txt"),
                    StandardOpenOption.WRITE, StandardOpenOption.CREATE);
            //数据传输
            writeChannel.write(data);
            readChannel.close();
            writeChannel.close();
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
    }
}
</code></pre>
<h3 id="sendfile-取代-mmapwrite"><a class="header" href="#sendfile-取代-mmapwrite">sendfile 取代 mmap+write</a></h3>
<p>上文提到，将文件数据读入用户空间内存后并没有附加必不可少的操作，那么就存在减少系统调用的优化空间。</p>
<p>Linux 2.1 版本开始，Linux 引入了 <code>sendfile</code> 替换 <code>mmap+write</code>方式，简化流程。</p>
<p>流程图和数据流示意图如下：</p>
<img width="700" alt="desc" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c35ce9cbf96549a1b690b6c0e417214c~tplv-k3u1fbpfcp-watermark.image"/>
<p>共发生 3次 <code>数据拷贝</code> ，1次 <code>系统调用</code>, 即2次 <code>上下文切换</code></p>
<h3 id="scattergather-优化的-sendfile方式"><a class="header" href="#scattergather-优化的-sendfile方式">scatter/gather 优化的 sendfile方式</a></h3>
<p>在 <code>sendfile</code> 中，还有CPU拷贝的过程，能不能进一步优化呢？</p>
<p>Linux 2.4 内核进行了优化，提供了带有 <code>scatter/gather</code> 的 <code>sendfile</code> 操作，可以减少拷贝的内容，注意，仍然有描述信息需要拷贝。</p>
<p>原理为：</p>
<ul>
<li>目标：内核空间 Read Buffer 和 Socket Buffer 之间不做数据复制</li>
<li>将 Read Buffer 的内存地址、偏移量信息等拷贝到 Socket Buffer 中。参考虚拟内存的解决思路实现目标。</li>
</ul>
<p><em>Read Buffer 的内存地址、偏移量信息等，即所谓描述信息</em></p>
<p>流程图和数据流示意图如下：</p>
<img width="700" alt="desc" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62c79b1f254741979b07127accc1991e~tplv-k3u1fbpfcp-watermark.image"/>
<p><em>从内核缓冲区到网卡的DMA拷贝，为 Gather Copy</em></p>
<p>sendfile只适用于将数据从文件拷贝到套接字上，限定了它的使用范围。</p>
<p>Linux在2.6.17版本引入splice，用于在两个文件描述符中移动数据：</p>
<pre><code class="language-c">#define _GNU_SOURCE         /* See feature_test_macros(7) */
#include &lt;fcntl.h&gt;
ssize_t splice(int fd_in, loff_t *off_in, int fd_out, loff_t *off_out, size_t len, unsigned int flags);
</code></pre>
<p><code>splice</code> 在两个文件描述符之间移动数据，从 <code>fd_in</code> 拷贝长度为 <code>len</code> 的数据到 <code>fd_out</code>，有一方必须是管道设备。</p>
<h3 id="以java中的transferto为例"><a class="header" href="#以java中的transferto为例">以java中的transferTo为例</a></h3>
<p>在Java中，<code>transferTo</code> 底层使用零拷贝技术，但从上层编码并不能体现出来：</p>
<pre><code class="language-java">class Demo {
    public static void main(String[] args) {
        try {
            FileChannel readChannel = FileChannel.open(Paths.get("/..../test1.txt"), StandardOpenOption.READ);
            long len = readChannel.size();
            long position = readChannel.position();
            FileChannel writeChannel = FileChannel.open(Paths.get("/..../test2.txt"), StandardOpenOption.WRITE, StandardOpenOption.CREATE);
            readChannel.transferTo(position, len, writeChannel);
            readChannel.close();
            writeChannel.close();
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
    }
}
</code></pre>
<p>在 zulu版本的实现中：</p>
<pre><code class="language-java">class FileChannelImpl {
    public long transferTo(long position, long count,
                           WritableByteChannel target)
            throws IOException {
        ensureOpen();
        //ignore

        long n;

        // Attempt a direct transfer, if the kernel supports it
        if ((n = transferToDirectly(position, icount, target)) &gt;= 0)
            return n;

        // Attempt a mapped transfer, but only to trusted channel types
        if ((n = transferToTrustedChannel(position, icount, target)) &gt;= 0)
            return n;

        // Slow path for untrusted targets
        return transferToArbitraryChannel(position, icount, target);
    }
}
</code></pre>
<p>通过注释与方法名可以看出端倪，感兴趣的读者可继续追溯源码，本文不再展开。</p>
<h2 id="nio-20"><a class="header" href="#nio-20">NIO-2.0</a></h2>
<h3 id="操作系统中的aio"><a class="header" href="#操作系统中的aio">操作系统中的AIO</a></h3>
<p>还请读者诸君回忆一下 <a href="https://juejin.cn/post/7231540022595141693">总纲</a> 中提到的AIO，</p>
<img width="400" alt="desc" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73a8f4e05bf5483da29e79cb6d012256~tplv-k3u1fbpfcp-watermark.image"/>
<p>很显然，这是操作系统中的AIO，例如，Windows 中提供了 <code>IOCP（I/O CompletionPort，I/O完成端口）</code></p>
<h3 id="java中的nio-20"><a class="header" href="#java中的nio-20">Java中的NIO-2.0</a></h3>
<p>回想一下Java中经典IO（BIO），和NIO-1.0，并没有在JDK层面提供开箱即用的异步IO编程框架。当然，这和Java的多线程编程、异步编程发展有关。</p>
<p>而在JDK1.7中，配套提供了异步IO的编程框架，同样置于nio包下，惯称为NIO-2.0，也有人称之为AIO。</p>
<p><em>注意，阅读其他文章时，对于 <code>异步</code> 、 <code>阻塞</code> 的讨论，要界定清楚讨论的对象和范围</em></p>
<p>在应用程序部分，发起IO调用和执行IO操作是异步的，但在JVM中，是否使用了操作系统异步IO则需要看操作系统平台，像Linux是通过 <code>epoll</code>，模拟了AIO。</p>
<p>在 <code>Java.nio.channels</code> 包下增加了四个异步通道：</p>
<ul>
<li>AsynchronousSocketChannel</li>
<li>AsynchronousServerSocketChannel</li>
<li>AsynchronousFileChannel</li>
<li>AsynchronousDatagramChannel</li>
</ul>
<p>结合 <code>Future</code> 进行异步编程，例如：</p>
<pre><code class="language-java">import java.nio.channels.AsynchronousFileChannel;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.nio.ByteBuffer;
import java.util.concurrent.Future;

class Demo {
    public static void main(String[] args) {
        Path file = Paths.get("/path/to/file.txt");
        AsynchronousFileChannel channel = AsynchronousFileChannel.open(file, StandardOpenOption.READ);
        ByteBuffer buffer = ByteBuffer.allocate(1024);
        Future&lt;Integer&gt; operation = channel.read(buffer, 0);
        while (!operation.isDone()) {
            // can do other work here while reading is in progress asynchronously  
        }
        buffer.flip();
        byte[] data = new byte[buffer.limit()];
        buffer.get(data);
        System.out.println(new String(data));
        channel.close();
    }
}
</code></pre>
<p>当然，也可以使用 <code>Callback</code></p>
<p>这些异步通道，通过 <code>Future</code> + <code>Callback</code> + <code>线程池</code> + <code>Native API</code> 实现了 <strong>文件异步非阻塞 IO</strong></p>
<ul>
<li>其中 Native API 的部分，对应到操作系统中的AIO。</li>
<li><code>Future</code> 、 <code>Callback</code> 、 <code>线程池</code> 为异步程序编写提供了框架支持。</li>
</ul>
<h2 id="结语-8"><a class="header" href="#结语-8">结语</a></h2>
<p>至此，Java IO系列已告一段落，作为一个Android程序员，会再写一篇关于 <code>Okio</code> 的文章，毕竟 <code>OKHttp</code> 几乎是Android程序员吃饭的家伙了。</p>
<p>前段时间因为工作内容的变化，尚未适应过来，这篇文章的草稿攒了月余时间，期间也进行了多次思考，基础系列的文章确实相当枯燥，后面可能会靠好玩系列、三思系列进行调节。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="io系列--一文掌握okhttp中的okio为什么这么ok"><a class="header" href="#io系列--一文掌握okhttp中的okio为什么这么ok">IO系列 | 一文掌握OKHTTP中的OKIO为什么这么OK</a></h1>
<h2 id="前言-22"><a class="header" href="#前言-22">前言</a></h2>
<p>本篇是 <a href="https://juejin.cn/post/7231540022595141693">IO系列</a>
的第4篇，前三篇文章中，我们已经对JAVA经典IO设计、JAVA－NIO内容、操作系统IO架构基础概念、Zero－Copy做了较为系统的回顾。</p>
<p>而绝大部分Android应用中都会涉及到网络模块，<code>Retrofit</code>、<code>Okhttp</code> 几乎是必用的框架， <code>Okio</code> 作为 <code>Okhttp</code> 中的重要模块，原先用于处理网络模块中的IO问题，随着其项目发展，Okio也开始面向其他问题。</p>
<p>这一篇，我们一同对OKIO做一次系统的梳理，搞明白OKIO为什么OK，做到在面试中自如的吹牛批、在日常工作中灵活使用。</p>
<p><em>编者按：面试吹牛批需要把握尺度，避免远超岗位预期，导致浪费时间</em></p>
<p>因文章篇幅较长，可结合内容导图阅读：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2d1c33d42e24465ba66782ec42e6aa2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1682&amp;h=1466&amp;e=png&amp;b=3c3c3c" alt="okio.png" /></p>
<h2 id="okio的主旨与架构"><a class="header" href="#okio的主旨与架构">okio的主旨与架构</a></h2>
<p>在OKIO项目的 wiki 中，对其主旨有如下介绍：</p>
<blockquote>
<p>Okio is a library that complements java.io and java.nio to make it much easier to access, store, and process your data. It started as a component of OkHttp, the capable HTTP client included in Android. It’s well-exercised and ready to solve new problems.</p>
</blockquote>
<p>简单直译为中文如下：</p>
<blockquote>
<p>Okio是一个类库，对 <code>java.io</code> 和 <code>java.nio</code> 进行了补充，使得访问、存储和处理数据变得更加容易。它最初是OkHttp的一个组件，OkHttp是安卓中的一个功能强大的HTTP客户端。它非常健壮，可以解决新问题。</p>
</blockquote>
<p>简言之：为了更简单的访问、存储、处理数据,基于 <code>java.io</code> 和 <code>java.nio</code> 进行了功能补充</p>
<p>wiki中，简单介绍了设计中的几个重点角色：</p>
<ul>
<li>ByteStrings and Buffers</li>
<li>Sources and Sinks</li>
</ul>
<p>分层架构中相对扁平、简单：在应用和Java IO 之间增加了一层，即OKIO本身，包含 <code>数据封装</code> 、 <code>输入输出</code> 、 <code>超时机制</code></p>
<p>体现在类图上还是比较复杂的：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fedeb0bc77f2443489e62d72e907db32~tplv-k3u1fbpfcp-watermark.image?" alt="图片.png" /></p>
<p>在库内部，<code>ByteStrings</code> 的使用不多，对 <code>Buffer</code> 数据包装后为上层应用服务，单独拎出。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae6e6dcdbd4e4666b063727b186228ac~tplv-k3u1fbpfcp-watermark.image?" alt="KtsampleOkioDiagramReport2.png" /></p>
<p>信息噪声比较多，去掉功能装饰的实现类后较为精简：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2a3eb53e0844ec8a0116ed6eaa9b380~tplv-k3u1fbpfcp-watermark.image?" alt="KtsampleOkioDiagramReport.png" /></p>
<h2 id="与java的输入输出的对比"><a class="header" href="#与java的输入输出的对比">与Java的输入输出的对比</a></h2>
<p>Java经典IO中的输入输出定义为Stream，在 <a href="https://juejin.cn/post/7231804508082159675">系列文章</a> 中进行了介绍。<em>字符流类似，图略</em></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b37be911d88b4b97a3fa12dc1cc0cb8c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="" /></p>
<p>在JDK的IO框架中，使用装饰模式建立了规模庞大、功能丰富的输入输出流。从OKIO的主旨出发，不难理解其设计者希望类库尽可能简单、易扩展、内建部分功能足够完善。因此，OKIO会适当的另起炉灶，不会全面的使用JDK中的Stream。</p>
<p>OKIO中使用了自定义的输入、输出，即 <code>Source</code> 和 <code>Sink</code> ，注意淡黄色、淡粉色部分：</p>
<blockquote>
<p>Sink 在计算机领域有特定含义：指程序或者线程，可以接收数据，并且可以处理或者发送这些数据</p>
</blockquote>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2a3eb53e0844ec8a0116ed6eaa9b380~tplv-k3u1fbpfcp-watermark.image?" alt="KtsampleOkioDiagramReport.png" /></p>
<h3 id="差异点"><a class="header" href="#差异点">差异点</a></h3>
<p>在wiki中提到如下内容：</p>
<blockquote>
<p>An elegant part of the java.io design is how streams can be layered for transformations like encryption and compression. Okio includes its own stream types called Source and Sink that work like InputStream and OutputStream, but with some key differences:</p>
<ul>
<li>Timeouts.</li>
<li>Easy to implement.</li>
<li>Easy to use.</li>
<li>No artificial distinction between byte streams and char streams.</li>
<li>Easy to test.</li>
</ul>
</blockquote>
<p>简单翻译下， Java IO的设计中有一处非常优雅：可以调整流的分层包装以实现加密、压缩等转换。OKIO包含自有的流类型 <code>Source</code>、<code>Sink</code>，与Java的 <code>InputStream </code>、 <code>OutputStream</code>
功能类似，但是有几点关键的不同：</p>
<ul>
<li>超时机制</li>
<li>更容易实现</li>
<li>更容易使用</li>
<li>字节流、字符流之间没有人为的差异</li>
<li>更容易测试</li>
</ul>
<p><strong>从输入方面看</strong>：</p>
<p>在JDK中，<code>InputStream</code> 使用多种层（以及复合层）处理种类繁多的各类数据</p>
<ul>
<li><code>DataInputStream</code> 用于处理基础数据类型</li>
<li><code>BufferedInputStream</code> 处理缓冲</li>
<li><code>InputStreamReader</code> 处理文本字符串</li>
</ul>
<p>而OKIO在这些层之上建立了 <code>BufferedSource</code>，Source避免了一些无法实现 <code>available()</code> 方法的困境, 转而由调用者指定它们需要的byte个数</p>
<p>在实现一个Source时，不必操心 <code>read()</code> 方法，它难以有效实现且需从257种值中返回一个 ，<em>注：null &amp; [0x00，0xFF]</em></p>
<p><strong>从输出方面看</strong>：</p>
<p>类似的，在JDK中 <code>OutputStream</code> 使用多种层（以及复合层）处理种类繁多的各类数据，而Sink也非常容易采用分层设计</p>
<h3 id="相同点"><a class="header" href="#相同点">相同点</a></h3>
<ul>
<li><code>Source</code> 、 <code>Sink</code> 的功能与 <code>InputStream</code> 、 <code>OutputStream</code> 、 <code>Reader</code> 、 <code>Writer</code> 相同</li>
<li>使用时可以通过装饰追加功能</li>
</ul>
<p>对于功能相同，wiki中提到如下内容：</p>
<blockquote>
<p>Sources and sinks interoperate with InputStream and OutputStream. You can view any Source as an InputStream, and you can view any InputStream as a Source. Similarly for Sink and OutputStream.</p>
</blockquote>
<p>下文的Source、Sink详解中，解析他们与IOStream 为何 “等价”、如何“互操作”</p>
<h2 id="sourcesink-详解"><a class="header" href="#sourcesink-详解">Source、Sink 详解</a></h2>
<h3 id="source-体系"><a class="header" href="#source-体系">Source 体系</a></h3>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55d27ea70bc94f1db95aa190a2b1a567~tplv-k3u1fbpfcp-watermark.image?" alt="KtsampleOkio-sourceDiagramReport.png" /></p>
<p>抛开功能类（压缩、哈希、加密、装饰等），主要关注：</p>
<ul>
<li>Source</li>
<li>BufferedSource</li>
<li>Buffer</li>
<li>RealBufferedSource</li>
</ul>
<p>Source的定义中规中矩：</p>
<pre><code>interface Source : Closeable {

  @Throws(IOException::class)
  fun read(sink: Buffer, byteCount: Long): Long

  fun timeout(): Timeout

  @Throws(IOException::class)
  override fun close()
}
</code></pre>
<p>其中的 <code>timeout</code> 将在下文超时机制章节中展开。</p>
<p>BufferedSource接口约定使用 <code>Buffer</code> 承接实际数据，并且定义了一系列方便使用的接口，如：</p>
<ul>
<li>读取Int</li>
<li>读取Short</li>
<li>读取字符串</li>
<li>内容选择 等，不做罗列</li>
</ul>
<p><code>RealBufferedSource</code> 实现了 <code>BufferedSource</code> 接口，从本质上可以认为是 <code>Buffer</code> 类的代理，增加了边界校验</p>
<p><code>Buffer</code> 实现了 <code>BufferedSource </code> 接口，包含 <strong>读</strong> 的具体实现</p>
<h3 id="sink-体系"><a class="header" href="#sink-体系">Sink 体系</a></h3>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f80924dedbd412894570f28664e99ca~tplv-k3u1fbpfcp-watermark.image?" alt="KtsampleOkio-sinkDiagramReport.png" /></p>
<p>抛开功能类（压缩、哈希、加密、装饰等），主要关注：</p>
<ul>
<li>Sink</li>
<li>BufferedSink</li>
<li>Buffer</li>
<li>RealBufferedSink</li>
</ul>
<pre><code>interface Sink : Closeable {
  @Throws(IOException::class)
  fun write(source: Buffer, byteCount: Long)

  @Throws(IOException::class)
  fun flush()

  fun timeout(): Timeout

  @Throws(IOException::class)
  override fun close()
}
</code></pre>
<p>同样，Sink接口的定义也中规中矩。</p>
<p>类似的，<code>BufferedSink</code> 接口继承了 <code>Sink</code> 接口，约定了使用 <code>Buffer</code> 承接实际数据, <code>RealBufferedSink</code> 是具体实现，从本质上是 <code>Buffer</code> 作为 <code>Sink</code>
时的代理，进行了边界校验。</p>
<p><code>Buffer</code> 实现了 <code>BufferedSink </code> 接口，包含 <strong>写</strong> 的具体实现</p>
<h3 id="sourcesink与io-stream的互操作"><a class="header" href="#sourcesink与io-stream的互操作">Source、Sink与I/O-Stream的互操作</a></h3>
<p><em>作者按：请仔细思考一下 <code>互操作</code> ，其本质是：<strong>使用一种实例对象的API去操作另一种对象实例的API</strong>, 请留意直接操作和间接操作，国内程序员更习惯使用 “转”、“转换” ，着眼点是从一种实例对象获得另一种实例对象。</em>
<em>从转换角度思考时，容易陷入误区，枚举出没必要地转换情况、忽略掉必要的间接转换。</em></p>
<p>首先明确一点：<strong>在基于I/O-Stream进行读写时，InputStreamSource、 OutputStreamSink 是 I/O-Stream的读写代理； I/O-Stream 是 InputStreamSource、
OutputStreamSink 的读写委托。</strong></p>
<p>依靠转换API：</p>
<pre><code>fun InputStream.source(): Source = InputStreamSource(this, Timeout())
fun OutputStream.sink(): Sink = OutputStreamSink(this, Timeout())
</code></pre>
<p>排除此 <strong>“基本情况1”</strong> ，还有一种 <strong>基本情况2</strong> ，即我们希望使用I/O-Stream的API去实质操作OKIO。不难想象，此时必然存在用OKIO实现的定制业务，即数据的实质处理，OKIO选择了 <code>BufferedSink</code>
和 <code>BufferedSource</code> 而非 <code>Sink</code> 、 <code>Source</code>，此时 <code>BufferedSink</code> 和 <code>BufferedSource</code> 是 I/O-Stream 的业务委托。</p>
<p>API如下：</p>
<pre><code>interface BufferedSink : Sink, WritableByteChannel {
   //... ignore

  /** Returns an output stream that writes to this sink. */
  fun outputStream(): OutputStream
}
</code></pre>
<pre><code>interface BufferedSource : Source, ReadableByteChannel {
  //... ignore

  /** Returns an input stream that reads from this source. */
  fun inputStream(): InputStream
}
</code></pre>
<h4 id="更复杂的情况----基于基本情况加各类业务的组合"><a class="header" href="#更复杂的情况----基于基本情况加各类业务的组合">更复杂的情况 -- 基于基本情况加各类业务的组合</a></h4>
<p>排除掉这些基本情况，还需要需要互操作时，意味着存在两套模块，一套使用Okio的Source、Sink，一套使用Java的InputStream、OutputStream。假定使用Sink、Source的模块为A，使用I/O-Stream的模块为B。</p>
<p>以写为例，进行分析，有两种可能：</p>
<ul>
<li>操作模块A，数据从A流向B，进而写入 (一般来说，B存在业务定制，否则是基本情况1)</li>
<li>操作模块B，数据从B流向A，进而写入（A最终使用了基本情况1，此情况属于基本情况2的复杂版）</li>
</ul>
<h5 id="1-数据从a流向b进而写入"><a class="header" href="#1-数据从a流向b进而写入">1. 数据从A流向B，进而写入</a></h5>
<p>关注A模块的数据出口，A模块可能的设计</p>
<ul>
<li>A1:接受一个Sink实例，或者接受一些参数构建Sink实例</li>
<li>A2:对外提供一个Source实例，由外界自行消费 -- <em>这种设计思路比较奇葩</em></li>
<li>接受回调函数，提供实际数据 -- 不属于实际讨论范畴，忽略</li>
</ul>
<p>关注B模块的数据入口，B模块可能的设计</p>
<ul>
<li>B1:接受一个InputStream实例，或者接受一些参数构建InputStream实例，消费其数据 -- <em>这种设计思路比较奇葩</em></li>
<li>B2:对外提供一个OutputStream实例，由外界控制实际写</li>
<li>暴露使用ByteArray等写入API -- 不属于实际讨论范畴，忽略</li>
</ul>
<h6 id="a1b1-情况的伪代码"><a class="header" href="#a1b1-情况的伪代码">A1+B1 情况的伪代码</a></h6>
<blockquote>
<p>A1:接受一个Sink实例，或者接受一些参数构建Sink实例</p>
<p>B1:接受一个InputStream实例，或者接受一些参数构建InputStream实例，消费其数据</p>
</blockquote>
<pre><code class="language-kotlin">class Client {
    fun demo() {
        //使用Sink、Source的模块A
        val moduleA = A()

        //使用I/O-Stream的模块B
        val moduleB = B()

        val buffer = Buffer()

        //设置模块A的数据出口
        moduleA.setSink(buffer)
        //设置模块B的数据入口
        moduleB.setInputStream(buffer.inputStream())

        //假定最终写入file：
        moduleB.setOutputFile(File("/target.txt"))

        //调用模块A开始写入
        moduleA.write("some thing")
    }
}
</code></pre>
<p>值得注意的是，需要在Buffer区的数据被消费后，进行清理，以避免内存占用越来越多，而因为B模块的奇葩设计，往往带入多线程问题，编程难度较大</p>
<h6 id="a1b2-情况的伪代码"><a class="header" href="#a1b2-情况的伪代码">A1+B2 情况的伪代码</a></h6>
<blockquote>
<p>A1:接受一个Sink实例，或者接受一些参数构建Sink实例</p>
<p>B2:对外提供一个OutputStream实例，由外界控制实际写</p>
</blockquote>
<pre><code class="language-kotlin">class Client {
    fun demo() {
        //使用Sink、Source的模块A
        val moduleA = A()

        //使用I/O-Stream的模块B 
        val moduleB = B()
        //假定其写入方式为：moduleB.writer().write("xxx")， moduleB.writer()获得OutputStream实例
        //假定最终写入file：
        moduleB.setOutputFile(File("/target.txt"))

        //使用B的入口，套接到模块A的数据出口
        moduleA.setSink(moduleB.writer().sink())

        //调用模块A开始写入
        moduleA.write("some thing")
    }
}
</code></pre>
<h6 id="a2b1-情况的伪代码"><a class="header" href="#a2b1-情况的伪代码">A2+B1 情况的伪代码</a></h6>
<blockquote>
<p>A2:对外提供一个Source实例，由外界自行消费</p>
<p>B1:接受一个InputStream实例，或者接受一些参数构建InputStream实例，消费其数据</p>
</blockquote>
<pre><code class="language-kotlin">class Client {
    fun demo() {
        //使用Sink、Source的模块A
        val moduleA = A()

        //使用I/O-Stream的模块B 
        val moduleB = B()
        //假定最终写入file：
        moduleB.setOutputFile(File("/target.txt"))

        //此情况需要moduleA.getSource() 提供 BufferedSource实例，
        //如果实现了Sink而并未实现BufferedSource, 需要模块提供者自己考虑接口系统的转换
        moduleB.setInputStream(moduleA.getSource().inputStream())

        //调用模块A开始写入
        moduleA.write("some thing")
    }
}
</code></pre>
<h6 id="a2b2-情况的伪代码"><a class="header" href="#a2b2-情况的伪代码">A2+B2 情况的伪代码</a></h6>
<blockquote>
<p>A2:对外提供一个Source实例，由外界自行消费</p>
<p>B2:对外提供一个OutputStream实例，由外界控制实际写</p>
</blockquote>
<pre><code class="language-kotlin">class Client {
    fun demo() {
        //使用Sink、Source的模块A
        val moduleA = A()

        //使用I/O-Stream的模块B 
        val moduleB = B()
        //假定最终写入file：
        moduleB.setOutputFile(File("/target.txt"))

        val resultFromA = moduleA.getSource()

        val buffer = Buffer()
        while (resultFromA.read(buffer, count) != -1) {
            buffer.writeTo(moduleB.writer())
            buffer.clear()
        }

        //调用模块A开始写入
        moduleA.write("some thing")
    }
}
</code></pre>
<h5 id="2-数据从b流向a进而写入"><a class="header" href="#2-数据从b流向a进而写入">2. 数据从B流向A，进而写入</a></h5>
<p>关注A模块的数据入口，A模块可能的设计</p>
<ul>
<li>A1:接受一个Source实例，或者接受一些参数构建Source实例 -- <em>这种设计思路比较奇葩，在主动拥抱复杂</em></li>
<li>A2:对外提供一个Sink实例，由外界自行控制写入</li>
<li>暴露使用ByteArray等写入API -- 不属于实际讨论范畴，忽略</li>
</ul>
<p>关注B模块的数据出口，B模块可能的设计</p>
<ul>
<li>B1:接受一个OutputStream实例，或者接受一些参数构建OutputStream实例</li>
<li>B2:对外提供一个InputStream实例，由外界自行消费数据 -- <em>这种设计思路比较奇葩</em></li>
<li>接受回调函数，提供实际数据 -- 不属于实际讨论范畴，忽略</li>
</ul>
<p><em>简单归纳伪代码如下</em></p>
<pre><code>//A1 + B1 同样会有内存释放、多线程编程难度问题
val buffer = Buffer()
moduleA.setSource(buffer)
moduleB.setWriter(buffer.outputStream())

//A1 + B2
// moduleB.getResult() 返回InputStream实例
moduleA.setSource(moduleB.getResult().source())

//A2 + B1
moduleB.setWriter(moduleA.getSink().outputStream())

//A2 + B2
val resultFromB:InputStream = moduleB.getResult()
val buffer = ByteArray(1024)
while ((len = in.read(buffer))!=-1) {
    moduleA.sink().write(buffer,0,len)
}

</code></pre>
<p>很显然，OKIO提供的转化方式，能够满足正常的设计，而剩余的奇葩设计，自然需要设计者自行处理内存、多线程问题。</p>
<p><strong>而读的例子也是类似的，考虑到篇幅已经很长，读者诸君可以自行梳理。</strong></p>
<p><strong>在读和写都能够完成两套系统的互操作时，即可随心随意地构建出更加复杂的层叠layer，亦不再展开</strong></p>
<h2 id="buffer-详解"><a class="header" href="#buffer-详解">Buffer 详解</a></h2>
<p>顾名思义，OKIO 中的 Buffer 是特意设计的缓冲区。它在 <code>数据处理</code> 和 <code>数据读写</code> 之间进行缓冲</p>
<p><code>class Buffer : BufferedSource, BufferedSink, Cloneable, ByteChannel</code></p>
<p>它的设计意图可以概括为三个方面，这三方面并不孤立互斥：</p>
<ul>
<li>内存中的读写缓冲区</li>
<li>更方便的API</li>
<li>和 Java IO 互操作</li>
</ul>
<blockquote>
<p>更方便的API：系列文章中提到过，数据的实质内容可以编码成ByteArray，Buffer提供了更方便的编解码</p>
</blockquote>
<blockquote>
<p>和 Java IO 互操作：除了上文中已经提及的内容，还包含 <code>readFrom(input: InputStream)</code> , <code>fun writeTo(out: OutputStream, byteCount: Long = size)</code> 等API，这些也可以算为更方便的API</p>
<p>Buffer实现了ByteChannel接口，可以适应NIO的设计体系，当然此时它又是内存中的读写缓冲区</p>
</blockquote>
<p>API方面，读者诸君可自行研读代码，内容比较简单。让我们将精力放在 <code>缓冲区</code> 上，看一看它的实现原理。</p>
<h3 id="核心实现"><a class="header" href="#核心实现">核心实现</a></h3>
<p>移除掉干扰代码后, 可以发现它的重点为 <code> head: Segment</code> ，代码简单扫一眼有个印象即可：</p>
<pre><code>class Buffer : /*BufferedSource, BufferedSink,*/ Cloneable, ByteChannel {
  internal var head: Segment? = null

  var size: Long = 0L
    internal set

  @Throws(EOFException::class)
  override fun readByte(): Byte = commonReadByte()
  //和下面的read类似，仅作为Source的API示例

  @Throws(IOException::class)
  override fun read(sink: ByteBuffer): Int {
    val s = head ?: return -1

    val toCopy = minOf(sink.remaining(), s.limit - s.pos)
    sink.put(s.data, s.pos, toCopy)

    s.pos += toCopy
    size -= toCopy.toLong()

    if (s.pos == s.limit) {
      head = s.pop()
      SegmentPool.recycle(s)
    }

    return toCopy
  }

  override fun write(source: ByteArray): Buffer = commonWrite(source)
  //也用到了writableSegment(1)，可类比下面的write代码，仅留作Sink的API示例

  @Throws(IOException::class)
  override fun write(source: ByteBuffer): Int {
    val byteCount = source.remaining()
    var remaining = byteCount
    while (remaining &gt; 0) {
      val tail = writableSegment(1)

      val toCopy = minOf(remaining, Segment.SIZE - tail.limit)
      source.get(tail.data, tail.limit, toCopy)

      remaining -= toCopy
      tail.limit += toCopy
    }

    size += byteCount.toLong()
    return byteCount
  }
}

</code></pre>
<p>而Segment是什么呢？是一个链表数据结构：</p>
<pre><code>internal class Segment {
  @JvmField val data: ByteArray
  @JvmField var pos: Int = 0
  @JvmField var limit: Int = 0
  @JvmField var shared: Boolean = false
  @JvmField var owner: Boolean = false
  @JvmField var next: Segment? = null
  @JvmField var prev: Segment? = null
  
  //ignore
}
</code></pre>
<p>包含了三种内容：</p>
<ul>
<li>实际数据 data</li>
<li>标记 pos+limit和读写有关，shared、owner和数据保护有关</li>
<li>上下游节点，链表的本质</li>
</ul>
<p>而 <code>SegmentPool</code> 是很典型的池化设计，毕竟 <code>ByteArray</code> 需要分配内存空间，使用池化可以很好地减少无效内存管理（频繁分配回收）</p>
<p>不难得出总结：</p>
<ul>
<li><code>Segment</code> 是实现了方便使用的API的ByteArray链表</li>
<li><code>Buffer</code> 是使用 <code>Segment</code> 包装而成的数据缓冲区，实现了方便使用的API，实现了和JAVA IO间的互操作</li>
<li><code>Buffer</code> 既可以作为上游 <code>Source</code> 角色，也可以作为下游 <code>Sink</code> 角色</li>
<li>在设计 <code>Buffer</code> 和 <code>Segment</code> 时，结合了日常使用场景进行了特定优化，例如通过转移、分享数据而非拷贝实质数据</li>
</ul>
<h2 id="bytestring-概述"><a class="header" href="#bytestring-概述">ByteString 概述</a></h2>
<p>在Okio中，ByteString也是一个重要的、方便使用的设计，但比Buffer简单的多。</p>
<p><em>它的命名也非常有趣，计算机领域中，String一词对应字符串，它本身拥有一个更宽泛的含义就是“一串”。 在不足够严谨的讨论场景下，我们可以认为 <code>String</code>
就是指定了编码的CharArray或ByteArray。而CharSequence又太过于抽象，设计者似乎仅希望将一些特定的具体情况进行封装，因此制造了ByteString。</em></p>
<pre><code>open class ByteString
internal actual constructor(
  internal actual val data: ByteArray,
) : Serializable, Comparable&lt;ByteString&gt; {}
</code></pre>
<p>_
作者按：我在开发一些蓝牙应用时，数据传输层和应用协议层有一些特定的数据操作，例如：信息摘要计算、CRC校验、AES加解密、Hex-String转换用作日志输出。在很多年前才接触Android时，使用HttpUrlConnection，对body也有类似的处理。属实枯燥繁琐_</p>
<p>它是一个内容不可变byte序列，这一点可以通过观测API发现，它并不提供修改内容的相关API。但它封装了一系列好用的API，例如：</p>
<ul>
<li>utf8(): String</li>
<li>string(charset: Charset)</li>
<li>fun base64()</li>
<li>fun md5() = digest("MD5")</li>
<li>fun sha1() = digest("SHA-1")</li>
<li>digest(algorithm: String): ByteString 等等</li>
</ul>
<p>相比于定义与使用Utility类，代码可读性更强。</p>
<p><strong>值得注意</strong> ：虽然它在设计意图上是内容不可变的，但注意它的构造函数，它只保留了引用，并没有对内容进行拷贝，这意味实质内容可以在外部篡改</p>
<p>它实现了 <code>Comparable</code> 接口，值得一提的是，它按照无符号数大小进行 “字典序” 比对。</p>
<ul>
<li>"字典序" 比对，即按照从头到尾的顺序，依次比对，脑补一下英文词典。</li>
<li>Byte使用8bit表示，0xFF（补码）如果视作符号数为255，排在0x00后面，如果视作有符号数，则为-1，排在0x00前面</li>
</ul>
<h2 id="超时机制"><a class="header" href="#超时机制">超时机制</a></h2>
<p>简单思考一下，你的BOSS是如何按照Deadline来检查你的工作的。</p>
<p>如果你没有提前告知已完成，</p>
<ul>
<li>最理想的BOSS会在到期时查你</li>
<li>宽松一点的BOSS会在Deadline当天或提前一天过问一下，到点再查一下</li>
<li>焦虑一点的BOSS会频繁一点</li>
<li>有毛病的BOSS会一天到晚盯着你</li>
</ul>
<p>显然，需要先约定一个超时的信息：</p>
<pre><code>class Timeout {
  private var hasDeadline = false
  private var deadlineNanoTime = 0L
  private var timeoutNanos = 0L
}
</code></pre>
<p>假定有一项具体工作，当你和BOSS约定好时间，他会记录这一信息，得到一个<code>timeout</code>，<em>当然，并非所有事情都会有Deadline</em></p>
<p>此时，你去执行这一事项：</p>
<pre><code>timeout.withTimeout {
	//具体的事项
}
</code></pre>
<p>而你的BOSS，则会根据是否有真实Deadline，决定是否记录到他的检查单上。</p>
<p>很显然，你的BOSS需要跟踪的事项进度比较多，他按照到期时间先后顺序对检查单内容进行整理，这样他就省事了，他只需要盯着第一个到期时间进行追踪即可。</p>
<p>当发现超时时，他会将这一项移除，调整他的检查单，并通报此项已经超时...</p>
<p>不难想象，如果他的检查单上没有追踪项，他不会给自己来一个遥遥无期的休假，否则有后续事项没被跟踪，他就惨了，但一直盯着有没有新事项产生会很累，所以他每两小时就会看一下，是否有事项需要写入检查单。即便写入检查单时此事已经延期，但一个2小时内就会到Deadline的事情，稍微拖延了一会去追查，也没啥毛病。</p>
<p>将BOSS的这部分工作写成代码如下：</p>
<details>
<pre><code class="language-kotlin">internal fun awaitTimeout(): AsyncTimeout? {
    // Get the next eligible node.
    val node = head!!.next

    // The queue is empty. Wait until either something is enqueued or the idle timeout elapses.
    if (node == null) {
        val startNanos = System.nanoTime()
        condition.await(IDLE_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS)
        return if (head!!.next == null &amp;&amp; System.nanoTime() - startNanos &gt;= IDLE_TIMEOUT_NANOS) {
            head // The idle timeout elapsed.
        } else {
            null // The situation has changed.
        }
    }

    var waitNanos = node.remainingNanos(System.nanoTime())

    // The head of the queue hasn't timed out yet. Await that.
    if (waitNanos &gt; 0) {
        condition.await(waitNanos, TimeUnit.NANOSECONDS)
        return null
    }

    // The head of the queue has timed out. Remove it.
    head!!.next = node.next
    node.next = null
    return node
}

private class Watchdog internal constructor() : Thread("Okio Watchdog") {
    init {
        isDaemon = true
    }

    override fun run() {
        while (true) {
            try {
                var timedOut: AsyncTimeout? = null
                AsyncTimeout.lock.withLock {
                    timedOut = awaitTimeout()

                    // The queue is completely empty. Let this thread exit and let another watchdog thread
                    // get created on the next call to scheduleTimeout().
                    if (timedOut === head) {
                        head = null
                        return
                    }
                }

                // Close the timed out node, if one was found.
                timedOut?.timedOut()
            } catch (ignored: InterruptedException) {
            }
        }
    }
}
</code></pre>
</details>
<p>再回到你这边，如果你的工作完成了，你去会找BOSS汇报工作，让他处理检查单：</p>
<pre><code class="language-kotlin">inline fun &lt;T&gt; withTimeout(block: () -&gt; T): T {
    var throwOnTimeout = false
    enter()
    try {
        val result = block()
        throwOnTimeout = true
        return result
    } catch (e: IOException) {
        throw if (!exit()) e else `access$newTimeoutException`(e)
    } finally {
        // 找BOSS汇报工作，让他处理检查单
        val timedOut = exit()
        if (timedOut &amp;&amp; throwOnTimeout) throw `access$newTimeoutException`(null)
    }
}
</code></pre>
<p>此时轮到BOSS来处理，如果这个事项并没有真实Deadline，他并不会额外做什么。否则他会重新维护检查单内容，但如果没有在检查单中发现这一项，则说明该项在之前通报过已经超时。</p>
<pre><code class="language-kotlin">fun exit(): Boolean {
    return cancelScheduledTimeout(this)
}

private fun cancelScheduledTimeout(node: AsyncTimeout): Boolean {
    AsyncTimeout.lock.withLock {
        if (!node.inQueue) return false
        node.inQueue = false

        // Remove the node from the linked list.
        var prev = head
        while (prev != null) {
            if (prev.next === node) {
                prev.next = node.next
                node.next = null
                return false
            }
            prev = prev.next
        }

        // The node wasn't found in the linked list: it must have timed out!
        return true
    }
}
</code></pre>
<p>我们通过一个故事演示了一种异步的超时检测机制，在Okio中，对应了 <code>AsyncTimeout</code> 。当然，实际场景中还有一些更复杂的，例如两个事项合并。</p>
<p>甚至，我们可以直接借用此机制：</p>
<p>演示代码：</p>
<details>
<pre><code class="language-kotlin">class Job&lt;T&gt;(
    val block: () -&gt; T,
    private val onTimeout: ((afterResult: Boolean, result: T?) -&gt; Boolean)? = null
) {
    @Volatile
    private var timeout = false

    @Volatile
    private var timeoutHandled = false

    @Volatile
    private var execFinished = false

    fun exec(): T = block().also { result -&gt;
        execFinished = true
        if (timeout &amp;&amp; !timeoutHandled) {
            onTimeout?.let {
                timeoutHandled = it(true, result)
            }
        }
    }

    fun timeout() {
        if (execFinished) return

        timeout = true
        onTimeout?.let {
            timeoutHandled = it(false, null)
        }
    }
}

class JobsAsyncTimeout&lt;T&gt;(private val job: Job&lt;T&gt;) : AsyncTimeout() {
    override fun timedOut() {
        job.timeout()
    }
    override fun timeout(timeout: Long, unit: TimeUnit): JobsAsyncTimeout&lt;T&gt; {
        super.timeout(timeout, unit)
        return this
    }

    fun delegate(): () -&gt; T {
        return {
            withTimeout {
                job.exec()
            }
        }
    }
}


fun &lt;T&gt; (() -&gt; T).timeoutJob(
    timeout: Long,
    timeUnit: TimeUnit,
    onTimeout: ((afterResult: Boolean, result: T?) -&gt; Boolean)? = null
): () -&gt; T {
    return JobsAsyncTimeout(Job(block = this, onTimeout = onTimeout))
        .timeout(timeout = timeout, unit = timeUnit)
        .delegate()
}
</code></pre>
</details>
<p>以一个效率低下的递归计算斐波那契数列进行演示(如果你的机器性能异常的好，可以适当调大入参)：</p>
<p>Demo 代码 :</p>
<details>
<pre><code class="language-kotlin">class Demo {
    @Test
    fun testTimeOut() {
        val fib30 = {
            fibonacci(30)
        }.timeoutJob(1, TimeUnit.NANOSECONDS) { afterResult, result -&gt;
            if (!afterResult) {
                // 如果是可以打断的操作，执行打断；除非你仍然想要结果,这样使用超时机制是很牵强的
                println("on timeout, callback before result, you should interrupt the job")
                // 返回true则意味着已经消费
                false
            } else {
                //如果 afterResult 为false时，已经返回true，则不会有此轮回调
                //除非你真的需要结果

                println("on timeout, callback after result, $result")
                //返回true则意味着已经消费
                false
            }
        }

        //超时是会抛出InterruptedIOException
        assertThrows(InterruptedIOException::class.java) {
            println("fib100-&gt; ${fib30()}")
        }
    }

    @Throws(Exception::class)
    fun fibonacci(n: Int): Long {
        when {
            n &lt; 0 -&gt; throw Exception("n为非法值！")
            else -&gt; return when (n) {
                0 -&gt; 0
                1 -&gt; 1
                else -&gt; fibonacci(n - 1) + fibonacci(n - 2)
            }
        }
    }
}
</code></pre>
</details>
<h2 id="结语-9"><a class="header" href="#结语-9">结语</a></h2>
<p>至此，IO系列告一段落。</p>
<p>按照惯例，再絮叨几句。在去年放缓节奏后，读了一些书、想了一些事、观了一些人。近期于《孟子》中得一句：</p>
<blockquote>
<p>或劳心，或劳力；劳心者治人，劳力者治于人；治于人者食人，治人者食于人：天下之通义</p>
</blockquote>
<p>下个系列还在构思斟酌中，下个月再见。</p>
<div style="break-before: page; page-break-before: always;"></div><h4 id="gradle-文章目录"><a class="header" href="#gradle-文章目录">Gradle 文章目录</a></h4>
<p>本章节包含基于Gradle-MavenPublish插件发布内容至MavenCentral的完整实践过程，
以及组件化场景下，Gradle项目的实践方案探讨</p>
<ul>
<li>组件化：<a href="Gradle/Modularization/post_18.html">三思系列：组件化场景下module依赖优雅实践方案</a></li>
<li>发布：<a href="Gradle/Publish/post_17.html">迁移到MavenCentral--再不行动起来，你的托管的library就没了</a></li>
<li><a href="Gradle/./post_22.html">Gradle | 依赖管理最佳实践</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="三思系列组件化场景下module依赖优雅实践方案"><a class="header" href="#三思系列组件化场景下module依赖优雅实践方案">三思系列：组件化场景下module依赖优雅实践方案</a></h1>
<h2 id="前言-23"><a class="header" href="#前言-23">前言</a></h2>
<p><a href="https://leobert-lan.github.io/info/about_sansi_series.html">关于三思系列</a></p>
<blockquote>
<p>背景：
如果没有记错，15年那会Android项目逐步转向使用Gradle构建，时至今日，组件化已经不再是一个新颖的话题。</p>
<p>虽然我将这篇文章放在了<code>Gradle分类</code>中，但是我们知道，使用gradle构建的后端项目，
热点聚焦在：实现<code>微服务化</code>，项目是拆开的，决定了依赖库已经是静态jar包，和我们
要讨论的场景是不一致的。所以我们还是在<code>Android</code>领域中讨论这个问题.</p>
<p>在各种方案的组件化实施中，一定会将<code>部分功能模块拆分</code>，进行<code>library下沉</code>。
于是，就有了<code>处理依赖</code>的场景。</p>
<p>相信大家思考过这样一个问题：如果下沉的<code>library</code>也提前编译好<code>静态aar包</code>，我们的项目编译时间会缩短。
毋庸置疑，这样做会直接从<code>源头解决</code> <code>编译时间长的问题</code>，就是<code>减少编译内容</code>。</p>
<p><code>但是</code>，项目合并在一起，难免就想在开发下层library时，直接用上层业务集成进行冒烟。 <em>ps:这个做法并不好，应当为library配置好冒烟测试环境，虽然会耗费掉一定的时间</em></p>
<p>理想归理想，最终还是会败给现实，这个问题就变成了<code>鱼和熊掌想要兼得</code>的问题</p>
</blockquote>
<p>为了让阅读的目标更加明确，我们先思考一个问题：</p>
<p><img src="Gradle/Modularization/post_18/APP.png" alt="依赖关系" /></p>
<p>这样一个项目依赖关系，如果做到<code>改动B</code> 的内容，却不需要重新编译A，运行APP，验证B的修改</p>
<p>我们下面会进行一定地展开，来体悟这个问题。</p>
<h2 id="为什么使用远程仓库中的依赖包比使用本地静态aar要方便"><a class="header" href="#为什么使用远程仓库中的依赖包比使用本地静态aar要方便">为什么使用远程仓库中的依赖包比使用本地静态aar要方便</a></h2>
<p>我们知道，对于一个module，我们对其进行编译生成静态aar包，只会处理它自身的内容。那么他的依赖是如何传递的？</p>
<p><code>通过pom文件</code></p>
<p>举个例子：</p>
<p>我们新建一个module，看一下依赖：</p>
<pre><code class="language-groovy">dependencies {

    implementation "org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version"
    implementation 'androidx.core:core-ktx:1.3.2'
    implementation 'androidx.appcompat:appcompat:1.2.0'
    implementation 'com.google.android.material:material:1.2.1'
    testImplementation 'junit:junit:4.+'
    androidTestImplementation 'androidx.test.ext:junit:1.1.2'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.3.0'
}
</code></pre>
<p>利用maven plugin 进行发布，会有任务生成pom文件，如下：</p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd" xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;leobert&lt;/groupId&gt;
  &lt;artifactId&gt;B&lt;/artifactId&gt;
  &lt;version&gt;1.0.0&lt;/version&gt;
  &lt;packaging&gt;aar&lt;/packaging&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;
      &lt;artifactId&gt;kotlin-stdlib&lt;/artifactId&gt;
      &lt;version&gt;1.4.21&lt;/version&gt;
      &lt;scope&gt;compile&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;androidx.core&lt;/groupId&gt;
      &lt;artifactId&gt;core-ktx&lt;/artifactId&gt;
      &lt;version&gt;1.3.2&lt;/version&gt;
      &lt;scope&gt;compile&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;androidx.appcompat&lt;/groupId&gt;
      &lt;artifactId&gt;appcompat&lt;/artifactId&gt;
      &lt;version&gt;1.2.0&lt;/version&gt;
      &lt;scope&gt;compile&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;com.google.android.material&lt;/groupId&gt;
      &lt;artifactId&gt;material&lt;/artifactId&gt;
      &lt;version&gt;1.2.1&lt;/version&gt;
      &lt;scope&gt;compile&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;

</code></pre>
<p>我们发现，关于测试相关的依赖并<code>没有</code>被收录到pom文件中。这很合理，测试代码是针对该module的，并不需要提供给使用方，其依赖自然也不需要传递。</p>
<p>我们知道，AGP中现在有4种声明依赖的方式（除去testXXX这种变种）</p>
<ul>
<li>api</li>
<li>implementation</li>
<li>compileOnly</li>
<li>runtimeOnly</li>
</ul>
<p>runtimeOnly对应以前的apk方式声明依赖，我们直接忽略掉，测试一下生成的pom文件。</p>
<pre><code class="language-groovy">dependencies {

    api "org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version"
    implementation 'androidx.core:core-ktx:1.3.2'
    compileOnly 'androidx.appcompat:appcompat:1.2.0'
    compileOnly 'com.google.android.material:material:1.2.1'


    testImplementation 'junit:junit:4.+'
    androidTestImplementation 'androidx.test.ext:junit:1.1.2'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.3.0'
}
</code></pre>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd" xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;leobert&lt;/groupId&gt;
  &lt;artifactId&gt;B&lt;/artifactId&gt;
  &lt;version&gt;1.0.0&lt;/version&gt;
  &lt;packaging&gt;aar&lt;/packaging&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;
      &lt;artifactId&gt;kotlin-stdlib&lt;/artifactId&gt;
      &lt;version&gt;1.4.21&lt;/version&gt;
      &lt;scope&gt;compile&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;androidx.core&lt;/groupId&gt;
      &lt;artifactId&gt;core-ktx&lt;/artifactId&gt;
      &lt;version&gt;1.3.2&lt;/version&gt;
      &lt;scope&gt;compile&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;

</code></pre>
<p>使用compileOnly方式的并没有被收录到pom文件中，而api和implementation 方式，在pom文件中，都表现为
采用compile的方案应用依赖。</p>
<blockquote>
<p><em>ps:api和implementation在编码期的不同，不是我们讨论的重点，略。</em></p>
</blockquote>
<p><strong>回到我们开始的问题</strong>，将library发布时，按照约定，会将library本身的依赖收录到pom文件中。相应的，使用方使用
仓库中的依赖项时，gradle会拉取其对应的pom文件，并添加依赖。</p>
<p>所以，如果我们直接使用一个编译好的静态包，而丢弃了他对应的pom文件时，可能会丢失依赖，出现打包失败或者运行异常。
这意味着我们需要人为维护依赖传递</p>
<p><strong>我们记住这些内容，并先放到一边</strong>。</p>
<h2 id="下沉后library会有多个层级"><a class="header" href="#下沉后library会有多个层级">下沉后，library会有多个层级</a></h2>
<blockquote>
<p>例如图中：APP =&gt; A =&gt; B， 即APP依赖A，A依赖B，而A和B都是library</p>
</blockquote>
<p>我们知道，对于B，并不会有什么说法，只会出现在A和APP</p>
<p>如果不使用静态包，那么A会声明：</p>
<pre><code class="language-groovy">api project(':B')
//或者
implementation project(':B')
</code></pre>
<p>我们先看一下，这样生成的library-A的pom文件</p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd" xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;leobert&lt;/groupId&gt;
  &lt;artifactId&gt;A&lt;/artifactId&gt;
  &lt;version&gt;1.0.0&lt;/version&gt;
  &lt;packaging&gt;aar&lt;/packaging&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;Demo&lt;/groupId&gt;
      &lt;artifactId&gt;B&lt;/artifactId&gt;
      &lt;version&gt;unspecified&lt;/version&gt;
      &lt;scope&gt;compile&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;

</code></pre>
<p>会得到groupID是项目名，artifactId是module名，version是未知的一个依赖项。</p>
<p>假如我将A编译为静态包并发布到仓库，并运用了pom中的依赖描述，一定会得到无法找到:<code>Demo-B-unspecified.pom</code> 的问题。
当然，这个问题可以通过<code>在APP中重新声明 B的依赖</code> 来解决。</p>
<blockquote>
<p>这意味着，我们需要时刻保持警惕，维护各个module的依赖。否则，我们无法同时享受：<code>静态包减少编译</code> &amp; <code>随心的修改局部并集成测试</code></p>
</blockquote>
<p>这显然是一件不人道主义的事情。</p>
<p>反思一下，对于A而言，它需要B，但仅在两个时机需要：</p>
<ul>
<li>编译时受检，完成编译</li>
<li>运行时</li>
</ul>
<p>作为一个library，它本身并不对应运行时，所以，<code>compileOnly</code> 是其声明对B的依赖的最佳方式。</p>
<p>这意味着，最终对应<code>运行时</code> 的内容，即APP，需要在<code>编译时加入</code> 对B的依赖。在原先 A 使用 Api方式声明对B的依赖时，是通过gradle
分析pom文件实现的依赖加入。而现在，需要<code>人为维护</code>，只需要实现 <code>人道主义</code>，就可以鱼和熊掌兼得。</p>
<h2 id="反思依赖传递的本质"><a class="header" href="#反思依赖传递的本质">反思依赖传递的本质</a></h2>
<p><img src="Gradle/Modularization/post_18/APP.png" alt="依赖关系" /></p>
<p>一般我们会像下面的演示代码一样声明依赖：</p>
<pre><code class="language-groovy">//APP:
implementation project('A')
implementation project('Foo')

//A:
implementation project('B')
implementation project('Bar')
</code></pre>
<p>因为依赖传递性，APP其实依赖了A，Foo，B，Bar。</p>
<p>其实就是一颗树中，除去根节点的节点集合。而对于一个非根节点，它被依赖的形式只有两种：</p>
<ul>
<li>静态包，不需要重新编译，节约编译时间</li>
<li>module，需要再次编译，可以运用最新改动</li>
</ul>
<p>我们可以定义这样一个键值对信息：</p>
<pre><code class="language-groovy">project.ext.depRules = [
        "B": "p",
        "A": "a"
]
</code></pre>
<p><code>"p"</code>代表使用project，<code>"a"</code>代表使用静态包。</p>
<p>并将这颗树的内容表达出来：<strong>我们先忽略掉Foo和Bar</strong></p>
<pre><code class="language-groovy">project.ext.deps = [
        "A"  : [
                "B": [
                        "p": project(':B'),
                        "a": 'leobert:B:1.0.0'
                ]
        ],
        "APP": [
                "A": [
                        "p": project(':A'),
                        "a": 'leobert:A:1.0.0'
                ]
        ]
].with(true) {
    A.each { e -&gt;
        APP.put(e.key, e.value)
    }
}
</code></pre>
<p>以A为例，我们可以通过代码实现动态添加依赖：</p>
<pre><code class="language-groovy">project.afterEvaluate { p -&gt;
        println("handle deps for:" + p)
        deps.A.each { e -&gt;
            def rule = depRules.get(e.key)
            println("find deps of A: rule is" + rule + " ,dep is:" + e.value.get(rule).toString())
            project.dependencies.add("compileOnly", e.value.get(rule))
        }
    }
</code></pre>
<p>同理，对于APP：</p>
<pre><code class="language-groovy">project.afterEvaluate { p-&gt;
        println("handle deps for:" + p)
        deps.APP.each { e -&gt;
            def rule = depRules.get(e.key)
            println("find deps of App:rule is" + rule + " ,dep is:" + e.value.get(rule).toString())
            project.dependencies.add("implementation", e.value.get(rule))
        }
    }
</code></pre>
<p>查看输出：</p>
<blockquote>
<p>Configure project :A</p>
<p>handle deps for:project ':A'</p>
<p>find deps of A: rule isp ,dep is:project ':B'</p>
</blockquote>
<blockquote>
<p>Configure project :app</p>
<p>handle deps for:project ':app'</p>
<p>find deps of App:rule isa ,dep is:leobert:A:1.0.0</p>
<p>find deps of App:rule isp ,dep is:project ':B'</p>
</blockquote>
<p>这样，我们就可以通过修改对应节点的依赖方式配置而实现鱼和熊掌兼得。不再受pom文件的约束。</p>
<p>当时，我们回到上面说的<code>不人道主义</code>之处，我们通过了<code>with</code> 函数，将A自身的依赖信息，注入到APP中。
但是当树的规模变大时，人为维护就很累了。这是<code>必须要解决的</code>，当然，这很容易解决。我们直接使用递归处理即可</p>
<h2 id="贴近人的直观感受才优雅逐步实现人道主义"><a class="header" href="#贴近人的直观感受才优雅逐步实现人道主义">贴近人的直观感受才优雅，逐步实现人道主义</a></h2>
<p>我们添加一个全局闭包：</p>
<pre><code class="language-groovy">ext.utils = [
        applyDependency: { project, e -&gt;
            def rule = depRules.get(e.key)
            println("find deps of App:rule is " + rule + " ,dep is:" + e.value.get(rule).toString())
            project.dependencies.add("implementation", e.value.get(rule))

            try {
                println("try to add sub deps of:" + e.key)
                def sub = deps.get(e.key)
                if (sub != null &amp;&amp; sub.get("isEnd") != true) {
                    sub.each { se -&gt;
                        ext.utils.applyDependency(project, se)
                    }
                }
            } catch (Exception ignore) {

            }
        }
]
</code></pre>
<p>注意，因为我们定义的依赖信息是：moduleName-&gt; (moduleName -&gt; (scopeName-&gt; depInfo)) 的方式。</p>
<p>这导致我们判断末端节点有一定的困难，即递归的尾部判断存在困难,我们需要人为标记一下末端节点</p>
<p>这时，我们只需描述一下树即可：<strong>同样忽略Foo，Bar</strong></p>
<pre><code class="language-groovy">project.ext.deps = [
        "A"  : [
                "B": [
                        "isEnd": true,
                        "p"    : project(':B'),
                        "a"    : 'leobert:B:1.0.0'
                ]
        ],
        "APP": [
                "A": [
                        "p": project(':A'),
                        "a": 'leobert:A:1.0.0'
                ]
        ]
]
</code></pre>
<p>问题基本得到解决了，但是并不优雅。</p>
<h3 id="优雅优雅优雅"><a class="header" href="#优雅优雅优雅">优雅，优雅，优雅</a></h3>
<p>我们不妨再修改一下对依赖树的描述方式，将节点信息和树结构分开，重新改进：</p>
<p>更人道主义的依赖描述</p>
<pre><code class="language-groovy">project.ext.deps = [
        "A"  : ["B"],
        "app": ["A"]
]

project.ext.modules = [
        "A": [
                "p": project(':A'),
                "a": 'leobert:A:1.0.0'
        ],
        "B": [
                "p"    : project(':B'),
                "a"    : 'leobert:B:1.0.0'
        ]
]

project.ext.depRules = [
        "B": "p",
        "A": "a"
]
</code></pre>
<p>抽象添加依赖的过程，递归处理<code>每一个节点</code>的<code>依赖收集</code>，并<code>向宿主module添加</code>，当某个节点在ext.deps中没有任何依赖时，<code>归</code>：</p>
<pre><code class="language-groovy">ext.utils = [
            applyDependency: { project, scope, e -&gt;
                def rule = depRules.get(e)
                def eInfo = ext.modules.get(e)
                println("find deps of " + project + ":rule is " + rule + " ,dep is:" + eInfo.get(rule).toString())
                project.dependencies.add(scope, eInfo.get(rule))

                def sub = deps.get(e) //list deps of e
                println("try to add sub deps of:" + e + " ---&gt; " + sub)

                if (sub != null &amp;&amp; !sub.isEmpty()) {
                    sub.each { dOfE -&gt;
                        ext.utils.applyDependency(project, scope, dOfE)
                    }
                }
            }
    ]
</code></pre>
<p>每个module只需要指定自己的scope：</p>
<pre><code class="language-groovy">//:app
project.afterEvaluate { p -&gt;
    println("handle deps for:" + p)
    deps.get(p.name).each { e -&gt;
        rootProject.ext.utils.applyDependency(p,"implementation",e)
    }
}

//:A
project.afterEvaluate { p -&gt;
    println("handle deps for:" + p.name)
    deps.get(p.name).each { e -&gt;
        rootProject.ext.utils.applyDependency(p,"compileOnly",e)
    }
}

</code></pre>
<p>只要不是独立运行的module，就是<code>compileOnly</code>，否则就是 <code>implementation</code>。</p>
<p>输出也容易拍错：</p>
<pre><code class="language-shell">&gt; Configure project :A
handle deps for:A
find deps of project ':A':rule is p ,dep is:project ':B'
try to add sub deps of:B ---&gt; null

&gt; Configure project :app
handle deps for:project ':app'
find deps of project ':app':rule is a ,dep is:leobert:A:1.0.0
try to add sub deps of:A ---&gt; [B]
find deps of project ':app':rule is p ,dep is:project ':B'
try to add sub deps of:B ---&gt; null
</code></pre>
<h2 id="测试一个复杂场景"><a class="header" href="#测试一个复杂场景">测试一个复杂场景</a></h2>
<p>我们再上图的基础上，让B和Foo依赖Base</p>
<pre><code class="language-groovy">project.ext.deps = [
        "app": ["A", "Foo"],
        "A"  : ["B", "Bar"],
        "Foo": ["Base"],
        "B"  : ["Base"],
]

project.ext.modules = [
        "A": [
                "p": project(':A'),
                "a": 'leobert:A:1.0.0'
        ],
        "B": [
                "p": project(':B'),
                "a": 'leobert:B:1.0.0'
        ],
        "Foo": [
                "p": project(':Foo'),
        ],
        "Bar": [
                "p": project(':Bar'),
        ],
        "Base": [
                "p": project(':Base'),
        ]
]

project.ext.depRules = [
        "B"   : "p",
        "A"   : "a",
        "Foo" : "p",
        "Bar" : "p",
        "Base": "p"
]
</code></pre>
<pre><code class="language-shell">&gt; Configure project :A
handle deps for:A
find deps of project ':A':rule is p ,dep is:project ':B'
try to add sub deps of:B ---&gt; [Base]
find deps of project ':A':rule is p ,dep is:project ':Base'
try to add sub deps of:Base ---&gt; null
find deps of project ':A':rule is p ,dep is:project ':Bar'
try to add sub deps of:Bar ---&gt; null

&gt; Configure project :app
handle deps for:project ':app'
find deps of project ':app':rule is a ,dep is:leobert:A:1.0.0
try to add sub deps of:A ---&gt; [B, Bar]
find deps of project ':app':rule is p ,dep is:project ':B'
try to add sub deps of:B ---&gt; [Base]
find deps of project ':app':rule is p ,dep is:project ':Base'
try to add sub deps of:Base ---&gt; null
find deps of project ':app':rule is p ,dep is:project ':Bar'
try to add sub deps of:Bar ---&gt; null
find deps of project ':app':rule is p ,dep is:project ':Foo'
try to add sub deps of:Foo ---&gt; [Base]
find deps of project ':app':rule is p ,dep is:project ':Base'
try to add sub deps of:Base ---&gt; null

&gt; Configure project :Bar
handle deps for:Bar

&gt; Configure project :Base
handle deps for:Base

&gt; Configure project :Foo
handle deps for:Foo
find deps of project ':Foo':rule is p ,dep is:project ':Base'
try to add sub deps of:Base ---&gt; null
</code></pre>
<blockquote>
<p>随着，树规模的增大，阅读依赖关系还算明显，但是阅读日志，又不太优雅了。</p>
</blockquote>
<h2 id="总结和展望-1"><a class="header" href="#总结和展望-1">总结和展望</a></h2>
<p>我们通过探寻，发现了一种可以 <code>鱼和熊掌兼得</code> 地依赖处理方式，让我们在Android领域组件化场景下（单项目，多module），能够灵活地切换：</p>
<ul>
<li>静态包依赖，缩短编译时间</li>
<li>项目依赖，快速部署变更进行集成测试</li>
</ul>
<p>对了，上面我们没有重点提到如何切换，其实非常地简单：
只需要修改 <code>project.ext.depRules</code> 中对应的配置项即可。</p>
<p>如果后面还有闲情逸致的话，可以再写一个studio的插件，获取 <code>dependency.gradle</code> 的信息，
输出可视化的依赖树；rule配置，直接做成多个开关，<code>优雅，永不过时</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="再不行动起来你的托管的library就没了"><a class="header" href="#再不行动起来你的托管的library就没了">再不行动起来，你的托管的library就没了</a></h1>
<h2 id="前言-24"><a class="header" href="#前言-24">前言</a></h2>
<p>相信不少朋友都有自己进行维护的作品，并托管在三方Library仓库开放使用。
而距离Jcenter宣布停止对非付费用户的各项运营政策已经有一段时间了，再不行动起来，托管在Jcenter和Jfrog的 <code>library就要没了</code>。</p>
<p>本文带你走一遍 <code>sonatype账号注册</code> 、<code>申请groupId</code> 和 <code>MavenCentral发布</code> ，并提供一个更加方便的 <code>Gradle插件</code> 用于发布。</p>
<h2 id="背景-1"><a class="header" href="#背景-1">背景</a></h2>
<p>今年Jfrog宣布了 <a href="https://jfrog.com/blog/into-the-sunset-bintray-jcenter-gocenter-and-chartcenter/">这项决定</a> ：</p>
<blockquote>
<p>UPDATE: To better support the community in this migration,
JFrog has extended the JCenter new package versions submission deadline through March 31st 2021.</p>
<p>To clarify, the JCenter repository will keep serving packages for 12 months until February 1st 2022.
Only the JCenter REST API and UI will be sunsetted on May 1st 2021.</p>
</blockquote>
<p>这就很尴尬了，随着时间的推移，未付费用户托管的library将无法再被获取。</p>
<p>扯点题外话，Google也被这一波操作秀到了，按照Google的尿性，可能会在未来支撑这件事业，但毕竟八字没一撇。</p>
<p>所以，我们剩下的选择不多了：</p>
<ul>
<li>成为 <code>尊贵的付费用户</code></li>
<li>转投 <code>sonatype</code> 的怀抱，使用免费的MavenCentral</li>
</ul>
<h2 id="注册-sonatype-账户"><a class="header" href="#注册-sonatype-账户">注册 sonatype 账户</a></h2>
<p>sonatype的玩法很溜，使用了敏捷开发管理的知名工具 <code>JIRA</code> 进行事物管理，所以第一件事情是 <code>注册sonatype的JIRA账户</code></p>
<p><a href="https://issues.sonatype.org/secure/Signup!default.jspa">注册地址</a></p>
<p>按照信息指导填写即可。</p>
<h2 id="申请groupid"><a class="header" href="#申请groupid">申请GroupId</a></h2>
<blockquote>
<p>一个托管在三方仓库的Library由三个信息确定：GroupId，ArtifactId，version</p>
</blockquote>
<p>不难理解，我们需要先申请一个可用的GroupId。开始申请之前，请先阅读以下内容，避免无用操作：</p>
<blockquote>
<p>按照sonatype的运营策略，他们利用了一些巧妙的方式来管理GroupId并且规避抢注风险</p>
<p>首先分为两种类型：</p>
<ul>
<li>你拥有域名</li>
<li>你没有域名</li>
</ul>
<p>第一类的验证方法我没有测试过，拥有域名的可以按照官网介绍试一下：</p>
<ul>
<li>Add a TXT record to your DNS referencing this JIRA ticket: (JIRA-TASK-ID) (Fastest)</li>
<li>Setup a redirect to your Github page (if it does not already exist) You can find more information here: https://central.sonatype.org/publish/</li>
</ul>
<p>第二类需要利用到第三方（如：Github、Gitlab、Gitee 等）
通过第三方 "对于其用户名的唯一性约束" 和 "Pages服务"，可以得到一个托管在三方平台的网站，以github为例：
开通Pages后，简单配置可以得到网站：https://leobert-lan.github.io/</p>
</blockquote>
<h3 id="创建pages网站"><a class="header" href="#创建pages网站">创建Pages网站</a></h3>
<p><em>以github为例，Gitee等应该类似</em></p>
<p><a href="https://pages.github.com/">官方介绍</a></p>
<p>创建一个 {github_user_name}.github.io 的仓库</p>
<p><img src="Gradle/Publish/post_17/pages_create.png" alt="pages_create.png" /></p>
<p><em>如果已经有个人博客，也可以利用HEXO或者Git-Book等工具，生成相关博客网页进行托管</em></p>
<p>下载仓库并添加一个 <code>不太离谱</code> 的 <code>index.html</code></p>
<p>注意：</p>
<ul>
<li>sonatype 仅关注这个域名是否存在，按照映射规则，GroupId为 io.github.{github_user_name}，如果这个域名不存在，不会颁发对应的GroupId给你</li>
<li>sonatype 并不关注网页的内容是啥（哪怕和项目无关），但不要弄得太离谱：政治、宗教、不良信息等不要乱来即可</li>
</ul>
<p>随后进入项目的设置
<img src="Gradle/Publish/post_17/pages_setting.png" alt="img.png" /></p>
<p>选定分支和路径后保存，可以很快得到部署结果，部署成功后可以自行验证下。</p>
<h3 id="jira创建申请task"><a class="header" href="#jira创建申请task">JIRA创建申请task</a></h3>
<ul>
<li>点击新建Task后，类型等均为默认，简单描述你的意图；</li>
<li>按照映射规则，填写GroupId：io.github.{github_user_name} <em>gitlab、gitee同理</em></li>
<li>填写你的Github项目的仓库信息等</li>
</ul>
<p>提交后等待，一般会先有 <code>机器人</code> 进行答复，告知你平台的运营政策、相关注意事项。</p>
<p><strong>注意：不要一直盯着等待，注册时填写了邮箱，一旦流程状态发生了变更，会有邮件通知</strong></p>
<p>收到邮件后，通过备注进行回复可以改变流程状态，随后等待人工审核（如果信息均无误，可能机器直接过审）</p>
<p>随后进入账户归属权认证</p>
<h3 id="验证账号归属权"><a class="header" href="#验证账号归属权">验证账号归属权</a></h3>
<p>当然，这里是Github或者Gitee等账号的归属权。</p>
<p>前面我们利用这些平台得到了唯一的域名，但是sonatype需要判断 <code>这个域名是你的</code>，因为：</p>
<ul>
<li>账号和Pages一一对应</li>
<li>Pages和GroupId一一对应</li>
<li>Task中对GroupId进行了唯一性校验</li>
</ul>
<p>所以sonatype要求在对应的Github账号下创建一个和TaskID一致的仓库
例如：</p>
<blockquote>
<p>Please create a public repo called https://github.com/leobert-lan/OSSRH-67741 to verify github account ownership.</p>
<p>If you do not own this github account, please read:
https://central.sonatype.org/publish/requirements/coordinates/</p>
</blockquote>
<p>创建成功后，再回来评论一次推进流程，等审核通过后，就获得了GroupId</p>
<hr />
<p>到此为止我们就获取了GroupId。接下来我们需要 <code>准备签名工具</code></p>
<p><em>Library的信息全部存在pom文件中，如果没有签名机制，就有可能出现李代桃僵的事情。</em></p>
<p>这里我们需要用到 <code>GPG</code> ，<a href="https://www.gnupg.org/">gpg官网</a> ，有兴趣的可以多研究研究。</p>
<p><em>注意:macOs &gt;= 10.15时，暂无法安装gpg，你可能需要寻找一台window电脑来生成签名密钥，不用担心，密钥是可以导出的</em></p>
<h2 id="生成gpg签名密钥"><a class="header" href="#生成gpg签名密钥">生成GPG签名密钥</a></h2>
<h3 id="生成"><a class="header" href="#生成">生成</a></h3>
<pre><code class="language-shell">gpg --full-generate-key
</code></pre>
<p>使用命令进入密钥生成，</p>
<ul>
<li>选择 RSA(仅用于签名)即可</li>
<li>设置密钥长度，使用密钥默认长度 2048</li>
<li>设置过期时间，永久有效即可，<em>没必要自己折腾自己</em></li>
<li>确认信息后输入 "真实姓名"，"邮箱"，"密钥Comment"，Comment不参与任何校验、用于备注他的作用</li>
<li>确定信息或者再次修改，确认后需要输入两次密码，请不要忘记你的密码</li>
<li>生成完成后会输出信息</li>
</ul>
<p>当然，没有必要死记这些信息，</p>
<p>利用：</p>
<pre><code class="language-shell">gpg --list-keys
</code></pre>
<p>或者</p>
<pre><code class="language-shell">gpg -K
</code></pre>
<p>可以查看所有生成的key，每个key都有一段很长的ID，这是其公钥的ID，长41位，当然，它的后八位也可以作为其ID，在使用上两者是等价的，一般用 <code>后八位</code> 即可。</p>
<h3 id="上传公钥到公共服务器"><a class="header" href="#上传公钥到公共服务器">上传公钥到公共服务器</a></h3>
<p>我选择了"pool.sks-keyservers.net"，当然还有其他公共服务器可以托管。</p>
<pre><code class="language-shell">gpg --keyserver hkp://pool.sks-keyservers.net --send-keys 公钥 ID
</code></pre>
<p>检查是否上传成功：</p>
<pre><code class="language-shell">gpg --keyserver hkp://pool.sks-keyservers.net --recv-keys 公钥 ID
</code></pre>
<h3 id="导出公钥密钥钥匙串keyring"><a class="header" href="#导出公钥密钥钥匙串keyring">导出公钥、密钥、钥匙串（KeyRing）</a></h3>
<pre><code class="language-shell">#导出公钥到 public-file.key 文件：
gpg -a -o public-file.key --export KeyId 

#导出私钥到 private-file.key 文件：
gpg -a -o private-file.key --export-secret-keys KeyId

#导出钥匙串到 secring.gpg 文件：
gpg --keyring secring.gpg --export-secret-keys
</code></pre>
<p>保管好你的钥匙！！</p>
<h2 id="配置项目"><a class="header" href="#配置项目">配置项目</a></h2>
<p>此时，我们的准备工作已经到位，开始修改你的项目：</p>
<h3 id="更改plugin"><a class="header" href="#更改plugin">更改plugin</a></h3>
<p>考虑到 <code>Gradle 7.0</code> 会弃用 <code>maven插件</code> ，我们选用 <code>maven-publish</code> 插件</p>
<pre><code class="language-groovy">plugins {
//    其他必要的插件
    
    id 'signing'
    id 'maven-publish'
}
</code></pre>
<p>添加 <code>maven-publish</code> 用于发布
添加 <code>signing</code> 用于签名</p>
<h3 id="添加签名的必要信息"><a class="header" href="#添加签名的必要信息">添加签名的必要信息</a></h3>
<pre><code class="language-properties">signing.keyId=公钥ID，后八位即可
signing.password= GPG密钥的密码
signing.secretKeyRingFile=/Users/leobert/.gnupg/secring.gpg #钥匙串地址
</code></pre>
<p>比较遗憾的是我没有找到在local.properties中配置的方法，似乎signing插件内部直接读取了属性。</p>
<p>考虑到密钥安全性，可以将gradle.properties 文件从Git中移除并忽略。</p>
<h3 id="配置生成javadoc和sources的task"><a class="header" href="#配置生成javadoc和sources的task">配置生成JavaDoc和Sources的Task</a></h3>
<pre><code class="language-groovy">task sourcesJar(type: Jar) {
    classifier = 'sources'
    from sourceSets.main.java.srcDirs
}

//android 项目需要额外定义一下task，java-library等项目插件自带task
//task javadoc(type: Javadoc) {
//    source = android.sourceSets.main.java.srcDirs
//    classpath += project.files(android.getBootClasspath().join(File.pathSeparator))
//}

task javadocJar(type: Jar, dependsOn: javadoc) {
    classifier = 'javadoc'
    from javadoc.destinationDir
}

tasks.withType(Javadoc) {
    options.addStringOption('Xdoclint:none', '-quiet')
    options.addStringOption('encoding', 'UTF-8')
    options.addStringOption('charSet', 'UTF-8')
}
</code></pre>
<p><em>注意：android 项目需要额外定义一下javadoc 的 task，java-library等项目插件自带task，并注意路径</em></p>
<h3 id="配置发布信息"><a class="header" href="#配置发布信息">配置发布信息</a></h3>
<p>注意，在任务Evaluated之后进行配置，即配置在 <code>afterEvaluate</code> 闭包内</p>
<pre><code class="language-groovy">afterEvaluate {
    publishing {
        publications {
            mavenAndroid(MavenPublication) {
                groupId GROUP_ID
                artifactId ARTIFACT_ID
                version VERSION_NAME
                artifact sourcesJar
                artifact javadocJar
                artifact('build/libs/xxx.jar') //
                // 配置 pom 文件格式
                pom {
                    packaging = 'jar'
                    name = ARTIFACT_ID
                    description = ARTIFACT_ID
                    url = siteUrl
                    licenses {
                        license {
                            name = 'The Apache Software License, Version 2.0'
                            url = 'http://www.apache.org/licenses/LICENSE-2.0.txt'
                        }
                    }
                    developers {
                        developer {
                            id = 'leobert'
                            name = 'leobert'
                            email = 'leobert.l@hotmail.com'
                        }
                    }
                    scm {
                        connection = siteUrl
                        developerConnection = gitUrl
                        url = siteUrl
                    }
                }
            }
        }
        // 配置远程仓库
        repositories {
            maven {
                url = 'https://s01.oss.sonatype.org/service/local/staging/deploy/maven2/'
                credentials {
                    username ACCOUNT
                    password PASSWORD
                }
            }
        }
    }

    signing {
        sign publishing.publications.mavenAndroid
    }
}
</code></pre>
<p>这是一个简单的样板，当然，协议部分、开发者部分、贡献者部分等还可以继续扩展。
<code>ACCOUNT</code> 和 <code>PASSWORD</code> 为sonatype的账密，</p>
<p>build之后，执行publish task 即可进行签名和上传</p>
<h2 id="最后一步"><a class="header" href="#最后一步">最后一步</a></h2>
<p>使用sonatype的账密 登录 <a href="https://s01.oss.sonatype.org/#stagingRepositories">sonatype 的maven仓库</a></p>
<p>左侧导航进入：stagingRepositories，找到提交的内容，再次检查下所有的校验已通过，close，刷新后进行release。</p>
<p>确认成功后，关闭sonatype-jira的task。</p>
<p><em>上述操作成功后，提交的Components应当已经进入sonatype的release仓库，大约1小时内同步到MavenCentral</em></p>
<p>之后更新版本，理论上会自动同步。</p>
<h2 id="编写gradle插件让配置更加简单"><a class="header" href="#编写gradle插件让配置更加简单">编写Gradle插件让配置更加简单</a></h2>
<p>其实maven-publish插件还支持更加复杂的配置，但个人项目中可能很少用到，挑选了"够用"的配置项后，我们编写一个Gradle插件，
这样可以省略重复样板。</p>
<p><a href="https://github.com/leobert-lan/EsayPublish">插件源码仓库</a>,</p>
<ul>
<li>gradle.properties 中 写入签名必要的信息</li>
</ul>
<blockquote>
<p>考虑到本篇的主题是分享MavenCentral发布的经验，略去Gradle插件的相关知识，以及本插件的源码介绍。有兴趣的朋友可以<strong>通过仓库的源码自行了解</strong>。</p>
<p><em>PS：很多时候我们都是copy了野生配置，而且往往是Groovy代码，出于Groovy语言的特殊性，这些闭包配置项出现错误时，大概率会被兼容，插件使用Kotlin编写，
阅读其源码可以加深对于maven-publish等插件API的认知</em></p>
</blockquote>
<pre><code class="language-properties">signing.keyId=公钥ID，后八位即可
signing.password= GPG密钥的密码
signing.secretKeyRingFile=/Users/leobert/.gnupg/secring.gpg #钥匙串地址
</code></pre>
<ul>
<li>local.properties 中写入sonatype 账密信息：</li>
</ul>
<pre><code class="language-properties">nexus_user=sonatype账号
nexus_pwd= sonatype密码
</code></pre>
<ul>
<li>引入插件后，build.gradle进行必要的配置：</li>
</ul>
<pre><code class="language-groovy">plugins {
    id 'osp.leobert.maven.publish'
}

EasyPublish {
    sourceSet = android.sourceSets.main.java.srcDirs
    docClassPathAppend = project.files(android.getBootClasspath().join(File.pathSeparator)).asPath
    docExcludes = ["a/b/c/*"]
    artifact {
        value = "build/outputs/aar/android-lib-demo-release.aar"
    }

    developer {
        id = 'leobert'
        name = 'leobert'
        email = 'leobert.l@hotmail.com'
    }

    //append developers
//    developer {
//        id = 'aa'
//        name = 'bb'
//        email = 'cc'
//    }

    groupId = "io.github.leobert-lan"
    artifactId = "android-demo"
    version = "1.0.0"
    packaging = "aar"
    siteUrl = "https://github.com/leobert-lan/EsayPublish"
    gitUrl = "https://github.com/leobert-lan/EsayPublish.git"
    licenseName = 'Apache 2.0'
    licenseUrl = 'https://github.com/leobert-lan/EsayPublish/blob/master/LICENSE'

    mavenRepoUrl = "https://s01.oss.sonatype.org/service/local/staging/deploy/maven2/"
}
</code></pre>
<p>即可进行发布。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gradle--依赖管理最佳实践"><a class="header" href="#gradle--依赖管理最佳实践">Gradle | 依赖管理最佳实践</a></h1>
<h2 id="写在最前-4"><a class="header" href="#写在最前-4">写在最前</a></h2>
<p>笔者最近接受了 <code>躺平</code>（<em>不是等死</em>），换了一份新工作。</p>
<p>这部分内容，也是从前东家的 <code>实际情况</code> 出发的，可惜无法亲手去推广落地了。</p>
<p>在前段时间，我发布过一篇拙见：<a href="https://juejin.cn/post/6925629544946892813">三思系列：组件化场景下module依赖优雅实践方案</a>,
该文在组件化背景下，探索了一种方案，可以同时满足 <code>减少编译数量以减少编译时间</code>、<code>便捷的修改依赖树以灵活改动任意层级的Module内容</code>。
<em>具体内容可以阅读前文，不再赘述</em></p>
<p>除却Module依赖，还有 <code>库包依赖</code> ，本文着重于探索 <code>库包依赖项</code> 的管理方式，而且是狭义上的 <code>仓库下的库包</code></p>
<p>并 <code>斗胆</code> 称之为 <code>最佳实践</code>。</p>
<h2 id="问题背景和必要知识"><a class="header" href="#问题背景和必要知识">问题背景和必要知识</a></h2>
<p>首先确定一件事情：</p>
<pre><code class="language-gradle">implementation fileTree(dir: 'libs', include: ['*.jar'])
</code></pre>
<p>此类方式，引入的库包不属于 <code>仓库</code> 范畴，仅讨论基于Maven仓库的范畴，赘述一句，仓库按照习惯又可以分为两种类型：</p>
<ul>
<li>Local：特指Maven的MavenLocal仓库，或者Gradle的Cache，<em>MavenLocal和Gradle的Cache本质是一致</em></li>
<li>Remote：通过Uri指定的特定位置的仓库，最为常见的是MavenCentral和JCenter仓库。当然，可以将本机的目录指定为 "远程仓库" 位置。</li>
</ul>
<p><strong>当然，这并不影响本文的讨论</strong></p>
<hr />
<p>众所周知，使用Gradle确定仓库的库包需要三个因素：</p>
<ul>
<li>GroupId</li>
<li>ArtifactId</li>
<li>version ，<em>'+'号通配符表达 <code>最新</code> 的含义</em></li>
</ul>
<p>for example：</p>
<pre><code class="language-gradle">androidx.core:core-ktx:1.3.2
</code></pre>
<ul>
<li>GroupId 为 "androidx.core"</li>
<li>ArtifactId 为 "core-ktx"</li>
<li>version 为 "1.3.2"</li>
</ul>
<hr />
<h3 id="问题背景"><a class="header" href="#问题背景">问题背景</a></h3>
<p><strong>以Android为例</strong>，商业项目中，<code>一个Project仅存在一个Module</code> 的情况应该 <strong>非常少见</strong> 了，
往往一个Project下会存在多个Module，而且存在一定的依赖关系。</p>
<blockquote>
<p>如果没有合适的管理手段，那么每个Module均声明自身的依赖项，当发生版本变更时：</p>
<ul>
<li><code>修改过于零碎</code></li>
<li><code>同一个依赖项在不同Module下可能出现版本差异</code>，这也是上一点所带来的后果</li>
</ul>
</blockquote>
<p>举个更典型的例子，以 <strong>后端项目为例</strong>，<code>微服务</code> 的概念大家一定不陌生.</p>
<blockquote>
<p><em>即使未曾深入了解，也知道后端将整个服务体系进行了拆分，用多个子系统项目（微服务）共同</em>
<em>支撑完整的服务体系。 以此达到 <strong>降低复杂度</strong>、 <strong>根据业务特性使用不同框架</strong>、 <strong>根据业务权重定制运维策略</strong> 等目的</em></p>
</blockquote>
<p>而微服务之间通过RPC进行通信，而此处势必牵涉一个最大的 <code>痛点</code> ：<code>Service方法签名和DTO数据保持一致</code>，否则会带来 <code>方法不存在</code> 或者 <code>数据遗失、解析错误</code> 等问题。</p>
<h2 id="传统做法及其优劣"><a class="header" href="#传统做法及其优劣">传统做法及其优劣</a></h2>
<p>比较早期的做法，是在Gradle构建时的运行环境中，创建或者利用Project级别的集合对象，将依赖项信息全部写入其中，各个Module使用时，达成了统一。</p>
<p><em>大家对这种做法很熟悉，不再用代码举例。</em> 往往需要用到Extension扩展，为了方便描述，我们将：<code>存储依赖项信息的Project级别集合</code> 称为 <code>Ext.deps</code></p>
<p><strong>优点</strong>：</p>
<ul>
<li>统一管理入口。一次修改，全Project生效</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>无法进行代码提示</li>
<li>一般无法兼容于构建工具的 <code>新版本提示</code></li>
<li>仅针对单Project，无法应对多Project，<em>后端的微服务往往是多Project</em></li>
</ul>
<h3 id="改良版"><a class="header" href="#改良版">改良版</a></h3>
<p>利用Gradle 可以apply 远程构建脚本 <em>(xxx.gradle)</em> 的特性，进行方案改进。</p>
<p>将 "构建 Ext.deps 信息" 的 <code>脚本</code>，存储于网络特定位置，以解决多Project难以管理的问题。</p>
<p><strong>一般需要对脚本文件按照版本命名，并保有所有版本的脚本。</strong></p>
<p>这样可以避免：项目回溯版本功能时，出现额外问题。</p>
<h2 id="利用gradle留的后门"><a class="header" href="#利用gradle留的后门">利用Gradle留的后门</a></h2>
<p>Gradle编译项目是很有意思的事情，我们知道：在成功加载完Gradle项目后，会 <code>编译Gradle脚本</code> 并生成各类Gradle任务，<em>实际情况会更加复杂</em>，为了方便，我们将之称为
<code>Task编译</code></p>
<p>既然存在编译过程，Gradle团队索性留了一个后门：</p>
<blockquote>
<p>如果根项目下存在"buildSrc", gradle 认为这是在Task编译过程中需要编译的内容，这些内容可能包含了：</p>
<ul>
<li>Gradle插件内容</li>
<li>插件设置内容</li>
<li>等等</li>
</ul>
<p>并且其编译结果对于该项目下的Gradle内容<strong>透明</strong></p>
</blockquote>
<p><em>这并不是一个新的特性，它至少已经有五年的历史了</em></p>
<p><a href="https://docs.gradle.org/current/userguide/organizing_gradle_projects.html">Gradle官方指导文档</a> ，官方文档对其使用方式做了概要的描述。</p>
<h3 id="勘误"><a class="header" href="#勘误">勘误</a></h3>
<p>因为buildSrc机制已经不是一个新特性了，故而利用这个机制去 <code>管理Gradle依赖信息</code> 已经是一个老话题了。</p>
<p>可能是<code>巧合</code>，该做法出现在开发者视野中时，刚好是 gradle开始对 <code>kotlin-dsl</code> 进行支持，<em>同样不是新特性，大约是三年前的Gradle-4.10</em>。</p>
<p>而开始流行的做法又恰好对新特性进行了尝鲜，并且在讲解视频中留下了一些坑，于是这一做法的着重点，便被吸引到了 <code>如何正确使用kotlin管理Gradle项目的依赖项</code>这一话题上。</p>
<blockquote>
<p>这一做法和kotlin、kts脚本并无实质关联</p>
</blockquote>
<h3 id="做法-4"><a class="header" href="#做法-4">做法</a></h3>
<p>在buildSrc目录下，按照标准sourceSet结构建立目录，并新增类文件例如：</p>
<pre><code>buildSrc/src/main/java/Deps.java

public class Deps {
    public static String junit = "junit:junit:4.13.0";
}
</code></pre>
<p>sync后，类会被编译，我们可以在项目下的Gradle脚本中，只用使用，例如：</p>
<pre><code class="language-groovy">dependencies {
    //...
    
    testImplementation Deps.junit
//    'junit:junit:4.+'
    androidTestImplementation 'androidx.test.ext:junit:1.1.2'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.3.0'
}
</code></pre>
<p>并且可以享有 <code>代码提示</code> 、 <code>跳转</code> 、 <code>javaDoc弹窗</code> 功能</p>
<hr />
<p>而可查询到的常见做法，往往是使用kotlin类，那么就需要让buildSrc <code>在编译时支持kotlin</code> ，那么自然需要 <code>添加插件</code> ：</p>
<p>在buildSrc下新建 <code>build.gradle</code> 并添加插件：</p>
<pre><code class="language-groovy">apply plugin: "kotlin"

buildscript {
    ext.kotlin_version = "1.4.21"
    repositories {
        jcenter()
    }
    dependencies {
        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
    }
}
repositories {
    jcenter()
}
</code></pre>
<p>即可，此时添加的kotlin类即可被编译。</p>
<pre><code>buildSrc/src/main/java/KDeps.kt

object KDeps {
    @JvmStatic
    val ext_junit = "androidx.test.ext:junit:1.1.2"
}
</code></pre>
<p>使用示例：</p>
<pre><code class="language-groovy">dependencies {
    testImplementation Deps.junit
//    'junit:junit:4.+'
    androidTestImplementation KDeps.ext_junit
    //'androidx.test.ext:junit:1.1.2'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.3.0'
}
</code></pre>
<p>同样可以享有 <code>代码提示</code> 、 <code>跳转</code> 、 <code>javaDoc弹窗</code> 功能</p>
<p>而网传的 <code>kts脚本</code> 以及添加 <code>kotlin-dsl</code>支持，其实在这个需求中，并无真正的有效用途，只不过是应用了kts脚本后，
本身就需要编译kotlin内容，所以 <code>默认使用了kotlin编译插件</code></p>
<hr />
<p>言归正传，使用这种管理方式后，我们解决了无代码提示的弊端，再次 <code>利用机器解放生产力</code>。</p>
<p>但是，我们没有解决服务端例子中的问题</p>
<h3 id="将依赖信息打包发布"><a class="header" href="#将依赖信息打包发布">将依赖信息打包发布</a></h3>
<p>我想你已经深刻意识到了buildSrc机制的本质是啥：</p>
<blockquote>
<p>利用Gradle 编译 buildSrc内容，产物供 <code>后续的</code> <code>该项目的</code> <code>Gradle编译过程</code> 使用</p>
</blockquote>
<p>那么你一定可以想到，buildSrc可以申明自身的依赖！</p>
<p>于是，我们对常用库包进行分析后，选取对象并确定版本后，即可编写一个Library，</p>
<ul>
<li>将库包信息写成常量</li>
<li>对Library建立版本机制</li>
<li>发布Library并在buildSrc中使用</li>
</ul>
<p>这是最简单的做法，即可在多个Project下，以最小的人力成本管理依赖并满足 <code>一致性需求</code></p>
<h3 id="进阶"><a class="header" href="#进阶">进阶</a></h3>
<p>Library依赖 Gradle后，可以编写 Gradle-Task内容配置 的过程代码，封装 <code>依赖添加</code> 和 <code>依赖检查</code> 等内容。</p>
<p>举个简单的例子：</p>
<pre><code class="language-kotlin">object KDeps {
    //    @JvmStatic
    const val ext_junit = "androidx.test.ext:junit:1.1.2"
}
</code></pre>
<pre><code class="language-java">public class Deps {
    public static String junit = "junit:junit:4.13.0";

    public static void applyAll(Project project) {
        project.getDependencies().add(
                "testImplementation", junit
        );
        project.getDependencies().add(
                "androidTestImplementation",KDeps.ext_junit
        );
    }
}

</code></pre>
<p>buildSrc/build.gradle</p>
<pre><code class="language-groovy">apply plugin: "kotlin"

buildscript {
    ext.kotlin_version = "1.4.21"
    repositories {
        jcenter()
    }
    dependencies {
        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
//        implementation 'com.android.tools.build:gradle:4.1.1'
        //gradle sdk
        gradleApi()
    }
}
repositories {
    jcenter()
}
</code></pre>
<p>在app 的build.gradle中，可以这样使用：</p>
<pre><code class="language-groovy">plugins {
    id 'com.android.application'
    id 'kotlin-android'
}

android {
    //略
}

dependencies {
    //略
    
    //修改为直接在 afterEvaluate 后调用函数设置
//    testImplementation Deps.junit
//    androidTestImplementation KDeps.ext_junit
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.3.0'
}

afterEvaluate {
    Deps.applyAll(project)
}
</code></pre>
<p>当然，我们在这个过程中还可以使用各类编程技巧。</p>
<p>此时，我们已经拥有了无限可能，<code>根据项目的实际需求</code> ，自行拓展吧。</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="groovy"><a class="header" href="#groovy">Groovy</a></h3>
<ul>
<li><a href="Groovy/./why_write_groovy.html">为什么撰写这个系列</a></li>
<li><a href="Groovy/./post_23.html">Groovy：MOP一文打尽</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="为何产生编写groovy系列的想法"><a class="header" href="#为何产生编写groovy系列的想法">为何产生编写Groovy系列的想法</a></h1>
<p>一言以蔽之："被刺激到了，很多事情不知其所以然"</p>
<h2 id="事件一"><a class="header" href="#事件一">事件一：</a></h2>
<p><strong>Android从业者</strong> 或者 <strong>对新技术比较敏感的朋友</strong> 都知道：Jetbrain 的 Compose 项目即将 <em>甚至已经</em> 掀起热潮，而Google 借着从 <code>Kotlin语言</code>
传承而来的友好合作关系，也大搞特稿 <code>Jetpack Compose</code>，并且 Android势必会成为重要战场。</p>
<ul>
<li>Gradle项目的源码中，Groovy代码量第一</li>
<li>使用 <code>Kotlin Script</code> 并使用 <code>Kotlin-dsl</code> 时，往往需要对Gradle本身的内容有深入的了解</li>
<li>Compose必须结合Kotlin，无巧不巧，<em>据笔者目测盲目统计</em>，绝大多数的项目均使用了 <code>Kotlin Script</code> 进行Gradle项目配置</li>
<li>阅读Compose代码时，发现了kotlin脚本中有令笔者 <code>惊奇</code> 的内容</li>
</ul>
<h2 id="事件二"><a class="header" href="#事件二">事件二</a></h2>
<p>编写插件时尝试了使用kotlin，但发现无法"直译" groovy的脚本内容，发现groovy脚本使用了一些 <code>神奇的</code> 内容。</p>
<hr />
<p><strong>无意冒犯</strong>，大家对 <code>Gradle本身的内容</code> 、 <code>Groovy语言</code> 、甚至是原先的 <code>Gradle Script</code> 可能都没有较深的了解</p>
<p>诚然，单纯用于构建项目，总会找到 <code>脚手架</code> ，并且 <code>依葫芦画瓢的</code> 使用。</p>
<p>在一连串的事件下，痛定思痛，还是先简单学习下 <code>Groovy语言的高级特性</code>，这样就可以：</p>
<ul>
<li>理解原先的 <code>Gradle Script</code> 内容含义</li>
<li>具有快速阅读 <code>Gradle</code> 源码的能力</li>
<li>明白使用 <code>Kotlin Script</code> 时需要对哪些问题对症下药</li>
<li>通过编写Gradle插件解决问题时，得心应手</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="groovymop一文打尽"><a class="header" href="#groovymop一文打尽">Groovy：MOP一文打尽</a></h1>
<h2 id="写在最前-5"><a class="header" href="#写在最前-5">写在最前</a></h2>
<p>Groovy已经不再是一门新出现的语言，而笔者是在2013年左右接触到它的，并且在2017年时，有机会尝试使用它编写了基于SpringBoot的后端项目。</p>
<p>但说来惭愧，在很长的一段时间里，我都没有系统的学习它。并且时至今日，我也 <code>不推荐</code> 大家再去 <code>系统的学习</code> 它，毕竟 <code>使用它的机会越发地少了</code>，
但是我依旧认为大家有必要花费一些零碎的时间，快餐式的了解它。</p>
<p>这一篇讲MOP，之后还有一篇闭包</p>
<p>文章代码已发布于：<a href="https://github.com/leobert-lan/GroovyWorkshop">GroovyWorkshop</a></p>
<h3 id="为何产生编写groovy系列的想法-1"><a class="header" href="#为何产生编写groovy系列的想法-1">为何产生编写Groovy系列的想法</a></h3>
<p>一言以蔽之："被刺激到了，很多事情不知其所以然".</p>
<p><a href="https://leobert-lan.github.io/Groovy/why_write_groovy.html">完整了解</a></p>
<h2 id="metaobject-protocol-元对象协议"><a class="header" href="#metaobject-protocol-元对象协议">MetaObject Protocol 元对象协议</a></h2>
<p>本文直接从MOP开始，忽略掉Groovy的大量基础部分，因为这些基础部分，基本和Java一致。</p>
<p>MOP的目标在于：<code>运行期进行实时变化</code>，听起来有点像Java的反射，但是要比Java的反射更加强大。可以：</p>
<ul>
<li>修改方法名、属性名，</li>
<li>动态增加类的方法、属性 等等</li>
</ul>
<h3 id="神奇的方法分配---invokemethod-和-methodmissing"><a class="header" href="#神奇的方法分配---invokemethod-和-methodmissing">神奇的方法分配-- <code>invokeMethod</code> 和 <code>methodMissing</code></a></h3>
<p>首先我们简单了解一下Groovy的方法分配机制：</p>
<div style="background-color: white">
<img src="https://upload-images.jianshu.io/upload_images/6168671-819123f425c9c5bc.png" alt="invokemethod_methodmissing" />
</div>
<p><em>图片来自网络</em></p>
<p><strong>本节内容，结果上看起来很神奇，但内容比较枯燥，并且对非语言使用者帮助不大，可以泛读，有个印象即可</strong></p>
<h4 id="invokemethod-拦截示例"><a class="header" href="#invokemethod-拦截示例">invokeMethod 拦截示例</a></h4>
<p>我们先看一个简单的例子：</p>
<pre><code class="language-groovy">class Demo1 {

    def foo() {
        println 'foo'
    }

    def invokeMethod(String name, Object args) {
        return "unknown method $name(${args.join(',')})"
    }

    static void main(String[] args) {
        def demo = new Demo1()
        demo.foo()
        println demo.bar("A", "B")
    }

}
</code></pre>
<p>如果是Java或者Kotlin，很明显，<code>Demo1</code> 中并没有 <code>bar</code> 方法，编译不能通过，但Groovy可以通过编译，得到运行结果：</p>
<pre><code class="language-shell">&gt; Task :Demo1.main()
foo
unknown method bar(A,B)
</code></pre>
<p>这就是所谓的 <code>invokeMethod</code>，Groovy中设计了一个顶层接口：<code>GroovyObject</code></p>
<pre><code class="language-groovy">public interface GroovyObject {
    Object invokeMethod(String var1, Object var2);

    Object getProperty(String var1);

    void setProperty(String var1, Object var2);

    MetaClass getMetaClass();

    void setMetaClass(MetaClass var1);
}
</code></pre>
<p>编译结果：</p>
<pre><code class="language-groovy">package osp.leobert.groovyworkshop.mop;

import groovy.lang.GroovyObject;
import groovy.lang.MetaClass;
import groovy.transform.Generated;
import org.codehaus.groovy.runtime.GStringImpl;
import org.codehaus.groovy.runtime.callsite.CallSite;

public class Demo1 implements GroovyObject {
    @Generated
    public Demo1() {
        CallSite[] var1 = $getCallSiteArray();
        super();
        MetaClass var2 = this.$getStaticMetaClass();
        this.metaClass = var2;
    }

    public Object foo() {
        CallSite[] var1 = $getCallSiteArray();
        return var1[0].callCurrent(this, "foo");
    }

    public Object invokeMethod(String name, Object args) {
        CallSite[] var3 = $getCallSiteArray();
        return new GStringImpl(new Object[]{name, var3[1].call(args, ",")}, new String[]{"unknown method ", "(", ")"});
    }

    public static void main(String... args) {
        CallSite[] var1 = $getCallSiteArray();
        Object demo = var1[2].callConstructor(Demo1.class);
        var1[3].call(demo);
        var1[4].callStatic(Demo1.class, var1[5].call(demo, "A", "B"));
    }
}

</code></pre>
<p>我们发现，调用 <code>foo()</code> 方法时，并未执行 <code>invokeMethod</code> 中的逻辑，而Groovy中还有一个特殊的接口：<code>GroovyInterceptable</code>，如果实现它的话：</p>
<pre><code class="language-groovy">class Demo2 implements GroovyInterceptable {

    def foo(String s) {
        return "foo:$s"
    }

    def invokeMethod(String name, Object args) {
        return "unknown method $name(${args.join(',')})"
    }

    static void main(String[] args) {
        def demo = new Demo2()
        println demo.foo("a")
        println demo.bar("A", "B")
    }
}
</code></pre>
<p>我们将得到如下结果：</p>
<pre><code class="language-shell">&gt; Task :Demo2.main()
unknown method foo(a)
unknown method bar(A,B)
</code></pre>
<p><code>foo()</code> 方法并未被分配!!, 这个场景很容易让我们联想到 <code>Java的动态代理</code> 并 <code>拦截、自行分配方法执行</code></p>
<h4 id="methodmissing示例"><a class="header" href="#methodmissing示例">methodMissing示例</a></h4>
<pre><code class="language-groovy">class Demo3 {

    def foo(String s) {
        return "foo:$s"
    }

    def invokeMethod(String name, Object args) {
        return "unknown method $name(${args.join(',')})"
    }

    def methodMissing(String name, Object args) {
        return "methodMissing $name(${args.join(',')})"
    }

    static void main(String[] args) {
        def demo = new Demo3()
        println demo.foo("a")
        println demo.bar("A", "B")
    }
}
</code></pre>
<p>按照前文的分派流程图，我们猜到结果为：</p>
<pre><code class="language-shell">&gt; Task :Demo3.main()
foo:a
methodMissing bar(A,B)
</code></pre>
<p>而实现了 <code>GroovyInterceptable</code> 的情况下，就无法再利用methodMissing机制拦截，而是按照 <code>GroovyInterceptable</code> 走 invokeMethod拦截</p>
<pre><code class="language-groovy">class Demo4 implements GroovyInterceptable {

    def foo(String s) {
        return "foo:$s"
    }

    def invokeMethod(String name, Object args) {
        return "unknown method $name(${args.join(',')})"
    }

    def methodMissing(String name, Object args) {
        return "methodMissing $name(${args.join(',')})"
    }

    static void main(String[] args) {
        def demo = new Demo4()
        println demo.foo("a")
        println demo.bar("A", "B")
    }
}
</code></pre>
<pre><code class="language-shell">&gt; Task :Demo4.main()
unknown method foo(a)
unknown method bar(A,B)
</code></pre>
<h3 id="动态处理类的属性"><a class="header" href="#动态处理类的属性">动态处理类的属性</a></h3>
<blockquote>
<p>一个有关的题外话</p>
<p>一个传统的 <code>简单JavaBean</code>，在很多场景下又称为 <code>POJO</code> ，大家对此不会陌生，它包含了属性和属性的Getter、Setter并且不包含任意逻辑。</p>
<p>我们知道, POJO需要添加Getter、Setter，<em>哪怕通过IDE生成，并且编译时如果可能，会被inline优化</em>，为此，还有 <code>是否该使用Lombok之争</code></p>
<p>但是，对于 "应当有Getter、Setter，但是不应当由编写者处理，而是应该由编译器处理" 是多数人认同的</p>
</blockquote>
<p>Groovy中对此进行了尝试，提供了 <code>GPath</code>机制：通过编译器直接生成Getter、Setter，编码时形如属性访问,用"."符 <code>foo.bar</code>，实际却相对复杂。</p>
<p><em>kotlin中也有类似的机制。</em></p>
<pre><code class="language-groovy">class GpathDemo {

    static class Foo {
        String bar

        def getBaz() {
            return "baz"
        }
    }

    static void main(String[] args) {
        Foo foo = new Foo(bar:"bar")
        foo.bar = "bar 2"
        println(foo.bar)
        println(foo.baz)
    }
}
</code></pre>
<p>我们可以发现，生成的类：</p>
<pre><code class="language-groovy"> public static class Foo implements GroovyObject {
    private String bar;

    @Generated
    public Foo() {
        CallSite[] var1 = $getCallSiteArray();
        super();
        MetaClass var2 = this.$getStaticMetaClass();
        this.metaClass = var2;
    }

    public Object getBaz() {
        CallSite[] var1 = $getCallSiteArray();
        return "baz";
    }

    @Generated
    public String getBar() {
        return this.bar;
    }

    @Generated
    public void setBar(String var1) {
        this.bar = var1;
    }
}
</code></pre>
<pre><code class="language-groovy">public static void main(String... args) {
    CallSite[] var1 = $getCallSiteArray();
    GpathDemo.Foo foo = (GpathDemo.Foo)ScriptBytecodeAdapter
            .castToType(var1[0].callConstructor(GpathDemo.Foo.class,
                    ScriptBytecodeAdapter.createMap(new Object[]{"bar", "bar"})),
                    GpathDemo.Foo.class);
    String var3 = "bar 2";
    ScriptBytecodeAdapter.setProperty(var3, (Class)null, foo, (String)"bar");
    var1[1].callStatic(GpathDemo.class, var1[2].callGetProperty(foo));
    var1[3].callStatic(GpathDemo.class, var1[4].callGetProperty(foo));
}
</code></pre>
<p>读者可能已经注意到了，通过手动添加Getter，也可以利用GPath机制，用"."访问；</p>
<p>另外，读者可能也注意到：设置bar属性时，并未直接访问Setter，此处，我们可以动态的添加属性！</p>
<pre><code class="language-groovy">class GpathDemo {

    static class Bar {
    }

    static void main(String[] args) {
        Bar.metaClass."getBaz" = { -&gt;
            return "baz"
        }

        Bar bar = new Bar()
        println(bar.baz)
    }
}
</code></pre>
<p>从编译结果看：</p>
<pre><code class="language-groovy">public static class Bar implements GroovyObject {
    @Generated
    public Bar() {
        CallSite[] var1 = $getCallSiteArray();
        super();
        MetaClass var2 = this.$getStaticMetaClass();
        this.metaClass = var2;
    }
}

// main：
public static void main(String... args) {
    CallSite[] var1 = $getCallSiteArray();
    final class _main_closure1 extends Closure implements GeneratedClosure {
        public _main_closure1(Object _outerInstance, Object _thisObject) {
            CallSite[] var3 = $getCallSiteArray();
            super(_outerInstance, _thisObject);
        }

        public Object doCall() {
            CallSite[] var1 = $getCallSiteArray();
            return "baz";
        }
    }

    _main_closure1 var4 = new _main_closure1(GpathDemo.class, GpathDemo.class);
    ScriptBytecodeAdapter.setProperty(var4, (Class)null, 
            var1[5].callGetProperty(GpathDemo.Bar.class), (String)"getBaz");
    
    GpathDemo.Bar bar = (GpathDemo.Bar)ScriptBytecodeAdapter.castToType(
            var1[6].callConstructor(GpathDemo.Bar.class),
            GpathDemo.Bar.class);
    var1[7].callStatic(GpathDemo.class, var1[8].callGetProperty(bar));
}
</code></pre>
<p>此时，在运行期增加了属性！</p>
<p><em>如果对Kotlin的扩展和代理比较熟悉，此处应该不难理解</em></p>
<p>但Groovy的设计更加有趣：</p>
<p>追踪：</p>
<ul>
<li><code>org.codehaus.groovy.runtime.InvokerHelper#getProperty</code></li>
<li><code>org.codehaus.groovy.runtime.InvokerHelper#setProperty</code></li>
</ul>
<p>发现会进入：<code>GroovyObject</code>，前面已经接触过</p>
<pre><code class="language-groovy">public interface GroovyObject {
    Object invokeMethod(String var1, Object var2);

    Object getProperty(String var1);

    void setProperty(String var1, Object var2);

    MetaClass getMetaClass();

    void setMetaClass(MetaClass var1);
}
</code></pre>
<p>那么借助集合，如 <code>Map</code> ，并复写 <code>getProperty</code> 、 <code>setProperty</code>，就可以做一些有趣的事情</p>
<h4 id="特殊的expando类"><a class="header" href="#特殊的expando类">特殊的Expando类</a></h4>
<p>哈哈，这个有趣的事情Groovy已经做了,这就是 <code>Expando</code> 类。</p>
<pre><code class="language-groovy">class ExpandoDemo {

    static void main(String[] args) {
        Expando expando = new Expando()
        expando.foo = "foo"
        println(expando.foo)
        expando.bar = "bar"
        println(expando.bar)

        expando.properties.forEach(new BiConsumer() {
            @Override
            void accept(Object o, Object o2) {
                println("key:$o,value:$o2")
            }
        })
    }
}
</code></pre>
<pre><code>&gt; Task :ExpandoDemo.main()
foo
bar
key:bar,value:bar
key:foo,value:foo
</code></pre>
<h3 id="利用expandometaclass实现mixin机制"><a class="header" href="#利用expandometaclass实现mixin机制">利用ExpandoMetaClass实现Mixin机制</a></h3>
<p>Mixin 即 Mix In，混合, 我们可以笼统地认为：<code>Mixin 即为 在一个类中混入其他类的内容</code>。</p>
<ul>
<li>对于支持多继承的语言，往往是在讨论 <code>多继承</code> 的问题；</li>
<li>对于单继承的语言，Java是利用 <code>接口</code> 制造多继承的表现，基于 <code>组合</code>，<code>委托</code> 等方式在目标类中 <code>混入</code>，
从 <code>规格继承</code> 变相解决问题；Ruby 等语言则引入 <code>Minin</code> 从 <code>实现继承</code> 变相解决问题。</li>
</ul>
<p>我们不再对此概念进行纠缠，可以认为 "多继承语言可以解决很多问题并带来更多的关联问题，单继承语言想要好处又要规避坏处，部分语言提出了Minin机制"</p>
<p>而Groovy的Minin，除了 <code>编译期</code> 要能混入，还要 <code>运行期混入</code></p>
<p>看个例子，<em>虽然它的场景很不合理，你一定有一万种理由劝说我使用各类设计模式，但不要较真</em></p>
<pre><code class="language-groovy">class MixinDemo {
    static class Paint {
        def draw(Drawable drawable) {
            println("paint ${drawable.name}")
        }
    }

    static class Drawable {
        String name
    }

    static void main(String[] args) {
        def paint = new Paint()
        Drawable.metaClass.draw = paint.&amp;"draw"
        def drawable = new Drawable(name: "test")
        drawable.draw(drawable)
    }
}
</code></pre>
<p>例子中，我们动态的给Drawable添加了draw方法</p>
<p>如果我们将这一过程适当的封装：</p>
<pre><code class="language-groovy">class MixinDemo2 {

    static class MixinDelegate {
        private targetClass

        MixinDelegate(targetClass) {
            this.targetClass = targetClass
        }

        def mixin(String asMethodName, Closure closure) {
            targetClass.metaClass."$asMethodName" = closure
        }
    }

    static void main(String[] args) {
        def mixin = new MixinDelegate(MixinDemo.Drawable)
        mixin.mixin("draw",new MixinDemo.Paint().&amp;"draw")
        def drawable = new MixinDemo.Drawable(name: "test")
        drawable.draw(drawable)
    }
}
</code></pre>
<p>这将会变得很有趣！！！</p>
<p>假设我们有一套 <code>控制协议</code> ，在此之前，我们只能在编译期决定好 <code>指令的执行</code> -- 即控制协议实现，即使运用一些巧妙的设计模式，自由程度也很低，
但现在可以在运行时更为自由地扩展、修改</p>
<p>当然，结合前面的知识，我们可以让它更加的酷炫：</p>
<pre><code class="language-groovy">class MixinDemo3 {

    static class MixinDsl implements GroovyInterceptable{
        private targetClass

        MixinDsl(targetClass) {
            this.targetClass = targetClass
        }

        def invokeMethod(String s, o) {
            if (s.startsWith("mixinFun") &amp;&amp; s.length() &gt; 8 &amp;&amp; o[0] instanceof Closure) {
                def methodName = s[8].toLowerCase() + s[9..-1]
                targetClass.metaClass."$methodName" = o[0]
                return null
            } else {
                println("cannot handle")
            }
        }
    }

    static void main(String[] args) {
        (new MixinDsl(MixinDemo.Drawable)).mixinFunDraw new MixinDemo.Paint().&amp;"draw"

        def drawable = new MixinDemo.Drawable(name: "test")
        drawable.draw(drawable)
    }
}
</code></pre>
<p>此时，添加方法的写法呈现出 <code>DSL的风格</code></p>
<h3 id="运行时的其他修改"><a class="header" href="#运行时的其他修改">运行时的其他修改</a></h3>
<p>前面我们已经学习了在运行时给类添加方法，接下来再了解更多的内容：</p>
<h4 id="添加构造器"><a class="header" href="#添加构造器">添加构造器</a></h4>
<p>这个例子要和Java进行对比</p>
<pre><code class="language-groovy">class RuntimeDemo {

    static class Bean {
        String a
        String b
        String c
        String d
        
        @Override
        public String toString() {
            return "Bean{" +
                    "a='" + a + '\'' +
                    ", b='" + b + '\'' +
                    ", c='" + c + '\'' +
                    ", d='" + d + '\'' +
                    '}';
        }
    }

    static class ConstructorDemo {

        void main() {
            Bean.metaClass.constructor = { String a -&gt;
                new Bean(a: a, b: "b", c: "c", d: "d")
            }
            def bean = new Bean("a")
            println(bean)
        }
    }

    static void main(String[] args) {
        def bean = new Bean(a: "a", b: "b", c: "c")
        println(bean)
        new ConstructorDemo().main()
    }
}
</code></pre>
<p>本身Groovy允许我们在构造时设置属性值，但这并不是有重载的构造器！如果没有这个机制，我们就不得不建立一系列重载的构造器，或者老老实实赋值。</p>
<p>但Groovy可以添加构造器</p>
<h4 id="添加静态方法"><a class="header" href="#添加静态方法">添加静态方法</a></h4>
<p>类比前面提到的添加方法，我们只需要添加关键字 <code>static</code> 就可以添加静态方法。</p>
<pre><code class="language-groovy">static void main(String[] args) {
    GpathDemo.Foo.metaClass.'static'.hello = { args1 -&gt;
        return "RuntimeDemo：hello,${args1}"
    }
    println GpathDemo.Foo.hello("foo")
}
</code></pre>
<h4 id="为对象添加方法"><a class="header" href="#为对象添加方法">为对象添加方法</a></h4>
<p>前文已经介绍过给类添加方法，不再赘述。这里注意，我们可以单独给对象添加方法，而不累及该类的其他实例。</p>
<pre><code class="language-groovy">static void main(String[] args) {
    def bean = new Bean(a: "a", b: "b", c: "c")
    
    //为对象添加方法
    try {
        bean.hello()
    } catch(Exception e) {
        println(e.message)
    }

    def emc = new ExpandoMetaClass(Bean.class, false)
    emc.hello = { println "hello" }
    emc.initialize()
    bean.metaClass = emc
    bean.hello()

    try {
        new Bean().hello()
    } catch(Exception e) {
        println(e.message)
    }
}
</code></pre>
<p>很显然，第一次得到Exception，第二次正常打印hello，第三次得到Exception</p>
<h3 id="自省"><a class="header" href="#自省">自省</a></h3>
<p>前文讲了如此之多的运行时修改，很显然，Groovy可以自省，我们简单了解一下以下知识，毕竟这些内容使用不多。</p>
<h4 id="反射"><a class="header" href="#反射">反射</a></h4>
<p>Groovy承袭了Java，那么自然可以使用Java的反射，但是注意：</p>
<blockquote>
<p>基于MOP添加的内容，均无法通过Java反射获知</p>
</blockquote>
<h4 id="respondsto-和-hasproperty"><a class="header" href="#respondsto-和-hasproperty">respondsTo 和 hasProperty</a></h4>
<pre><code class="language-groovy">class ResponseToDemo {
    static class Demo {
        def p = "p"
        def foo() {
            println("foo")
        }
    }

    static void main(String[] args) {
        Demo.metaClass."bar" = { -&gt;
            println 'bar'
        }

        def demo = new Demo()
        if (demo.metaClass.respondsTo(demo, 'bar')) {
            println 'bar ok'
        }

        if (demo.metaClass.respondsTo(demo, 'foo')) {
            println 'foo ok'
        }

        if (demo.metaClass.hasProperty(demo, 'p')) {
            println 'p ok'
        }
    }
}


//&gt; Task :ResponseToDemo.main()
//bar ok
//foo ok
//p ok
</code></pre>
<p>利用respondsTo和hasProperty，可以分析固有属性、方法以及MOP添加的内容。</p>
<h4 id="hasmetamethod-和-hasmetaproperty"><a class="header" href="#hasmetamethod-和-hasmetaproperty">hasMetaMethod 和 hasMetaProperty</a></h4>
<p>这里直接给出结论：</p>
<blockquote>
<p>这一组方法仅可对类进行分析，而针对对象利用MOP添加的属性和方法，利用respondsTo和hasProperty 可以分析得到。</p>
</blockquote>
<h3 id="借助interceptor实现aop能力"><a class="header" href="#借助interceptor实现aop能力">借助Interceptor实现AOP能力</a></h3>
<p>相信各位对AOP（Aspect-Orient-Program）都有或多或少的了解，在Java中也有大名鼎鼎的AspectJ，而在Groovy中，
本身就可以利用 <code>Interceptor机制</code> 进行简单的AOP，而不必借助框架的力量。</p>
<p>看一个简单的例子：</p>
<pre><code class="language-groovy">class InterceptorDemo {
    static class Demo {
        void foo() {
            println("foo")
        }
    }

    static class DemoInterceptor1 implements Interceptor {

        @Override
        Object beforeInvoke(Object o, String s, Object[] objects) {
            println("before $s")
            return o
        }

        @Override
        Object afterInvoke(Object o, String s, Object[] objects, Object o1) {
            println("after $s")
            return o1
        }

        @Override
        boolean doInvoke() {
            return true
        }
    }

    static void main(String[] args) {
        def proxy = ProxyMetaClass.getInstance(Demo)
        proxy.interceptor = new DemoInterceptor1()

        proxy.use {
            def demo = new Demo()
            demo.foo()
        }
    }
}
</code></pre>
<p>得到的结果会如何呢？</p>
<pre><code>&gt; Task :InterceptorDemo.main()
before ctor
after ctor
before foo
before println
foo
after println
after foo
</code></pre>
<p>如果 <code>doInvoke</code> 返回false，那么 foo() 方法将被拦截。</p>
<p>接下来我们做个有趣的事情，先做一定的修改：</p>
<pre><code class="language-groovy">class InterceptorDemo {
    static class Demo {
        def String s

        String foo() {
            return "foo $s"
        }


        @Override
        public String toString() {
            return "Demo{" +
                    "s='" + s + '\'' +
                    '}';
        }
    }

    static class DemoInterceptor1 implements Interceptor {

        def tmp = new Demo(s: "DemoInterceptor1")

        @Override
        Object beforeInvoke(Object o, String s, Object[] objects) {
            if (s == "foo") {
                println("before $s, $o")
                o.s = "aaaaa"
            }
            return tmp
//            return o
        }

        @Override
        Object afterInvoke(Object o, String s, Object[] objects, Object o1) {
            if (s == "foo") {
                println("after $s, $o")
                return "hahaha"
            }
            return o1
        }

        @Override
        boolean doInvoke() {
            return true
        }
    }

    static void main(String[] args) {
        def proxy = ProxyMetaClass.getInstance(Demo)
        proxy.interceptor = new DemoInterceptor1()

        proxy.use {
            def demo = new Demo(s: "demo")
            println demo.foo()
        }
    }
}
</code></pre>
<p>会得到怎么的输出呢？</p>
<p>不难推测：</p>
<ul>
<li>最开始会打印 "before foo, Demo{s='demo'}"</li>
<li>最终会打印 "hahaha"</li>
</ul>
<p>那么afterInvoke会打印什么呢？</p>
<pre><code>after foo, Demo{s='aaaaa'}
</code></pre>
<p>如果将doInvoke设为false，又会打印什么呢？</p>
<pre><code>&gt; Task :InterceptorDemo.main()
foo DemoInterceptor1
</code></pre>
<p>确实有趣，感兴趣的同学可以继续研究。我们言归正传。</p>
<p>上面的例子是比较简单的，结合大家的编程经验，不难想到，可以添加助手类和拦截器逻辑，针对各种类采用拦截器了。</p>
<p>如果有进行实践的同学，是否在折腾过程中出现了堆栈溢出？这里补充一个知识：</p>
<blockquote>
<p>在调用方法时添加 <code>&amp;</code>，例如：demo.&amp;foo() , 使得本身拦截的方法不被拦截，本身不拦截的方法会被拦截。</p>
<p>显然,会出现堆栈溢出，应该对方法进行了拦截并且不断拦截。</p>
</blockquote>
<p>当然，还有一个很简单的技巧，分别在before和after中，<code>先将拦截器移除，执行完业务后再添加回去</code></p>
<h3 id="对java类使用上述特性"><a class="header" href="#对java类使用上述特性">对Java类使用上述特性</a></h3>
<p>拦截器是Groovy的运行机制，所以依旧可以使用。</p>
<h4 id="使用代理对象"><a class="header" href="#使用代理对象">使用代理对象</a></h4>
<pre><code class="language-groovy">ExpandoMetaClass emc = new ExpandoMetaClass(JavaClz, false)
emc.foo = { return "hello,world!" }
emc.initialize()

def foo = new groovy.util.Proxy().wrap(new JavaClz())
foo.setMetaClass(emc)
println foo.foo()
</code></pre>
<p>除此之外，还可以利用委托，向上下文注册Java类的MetaClass为一个委托，进而实现一些动态性，因为和上文的做法有一定区别，不再扩展，有兴趣的同学
可以搜索 <code>groovy.lang.DelegatingMetaClass</code> 了解更多。</p>
<h2 id="结语-10"><a class="header" href="#结语-10">结语</a></h2>
<p>MOP是Groovy的高阶内容之一，可能短期内你都不会使用到它，甚至不作为主语言时，你永远不会用到它，但再次遇到gradle项目采用了 "神奇方案" 来解决问题时，
有能力弄明白为何这会生效！！</p>
<p>如果你觉得笔者的博客对你有帮助，希望可以点个赞或者留个言，让我知道这达到了正向的效果！！</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="review"><a class="header" href="#review">Review</a></h3>
<p>问题复盘、开源项目复盘、年终总结等</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="造完了这个轮子--mocker却让我感到很羞愧项目复盘"><a class="header" href="#造完了这个轮子--mocker却让我感到很羞愧项目复盘">造完了这个轮子--Mocker，却让我感到很羞愧|项目复盘</a></h1>
<blockquote>
<p>有必要声明，这篇文章不是标题党，内容也不是凡尔赛。</p>
</blockquote>
<p>作为一个Android开发者，我这5年造了 <code>很多</code> 轮子, 粗略数一下：</p>
<ul>
<li>基于FastJson修改了一些漏洞，并兼容了ThinkPHP框架 <code>简化JSON结构的机制</code> -- 单元素数组直接变对象</li>
<li>MagicBox -- <code>注解</code> + <code>运行时反射</code> 简化SaveInstanceState样板代码</li>
<li>JSBridge -- 基于消息队列机制建立Android和WebView桥接</li>
<li>RetrofitExt -- <code>注解</code> + <code>APT</code> + <code>动态代理</code> 实现Retrofit请求生命周期管理</li>
<li>DDComponentForAndroid(后改为JIMU)组件化套件
<ul>
<li>Gradle Plugin 优化</li>
<li>路由中间件</li>
<li>消息中间件</li>
<li>Maat -- 代码隔离场景下的模块加载框架</li>
</ul>
</li>
<li>Pandora套件
<ul>
<li>Pandora -- 适用于复杂列表页面的数据结构</li>
<li>Pandorarv -- RecyclerView 多样式表</li>
<li>Pandora Plugin -- Intellij 插件，快速生成 <code>数据代理</code> + <code>ViewHolder</code> + <code>基础布局</code></li>
</ul>
</li>
<li>Reporter -- 注解生成文档</li>
<li>DaVinCi -- 干掉shape xml</li>
<li><strong><a href="https://github.com/leobert-lan/Mocker">Mocker</a> -- 注解约束的Mock框架</strong></li>
<li>UiBinding -- 取代ButterKnife&amp;更方便的使用ViewBinding、DataBinding</li>
</ul>
<p>至于自定义视图，RecyclerView相关套件等等，也是一大堆。</p>
<p>其中：</p>
<ul>
<li>有一些是项目不得不拥有</li>
<li>有一些，是项目中遇到了效率问题，为了解决开发效率问题而开发的，例如Pandora套件</li>
<li>还有一些，纯粹是出于 <code>兴趣</code> ，<code>好玩</code> 例如 Reporter，利用注解生成文档。</li>
</ul>
<p><strong>但是，有这么一个轮子，写完之后，让我自己感觉很羞愧，并且 <code>为团队</code> 感到羞愧。标题中提到的 <code>Mocker</code> -- 注解约束的Mock框架</strong></p>
<hr />
<h2 id="为什么我造了那么多轮子却要复盘这个"><a class="header" href="#为什么我造了那么多轮子却要复盘这个">为什么我造了那么多轮子却要复盘这个？</a></h2>
<p><a href="https://github.com/leobert-lan/Mocker">Mocker</a></p>
<ul>
<li>这个轮子，和其他的有 <code>本质区别</code>，可以说，别的轮子，都是服务于 <code>业务实现</code>、<code>效率</code>，而Mocker，服务于 <code>测试</code>。</li>
<li>这是复盘系列的第一篇，我希望利用形式来践行：<code>先思败</code>，<code>避开失败点，自然走向成功</code></li>
</ul>
<p>我属于 <code>极限编程</code> 的极力反对者，毫无疑问，我认为 <code>单元测试</code> 用例长期有效即具有<code>长效性</code> ，并值得 <code>持续维护</code>。而我们的项目团队，单元测试覆盖量近乎于1%。</p>
<p><code>创业团队</code>，<code>价值导向</code>，<code>快才是好，越快越好</code>，<code>快也不是出错的理由</code> 这是目前的团队背景标签。
处于这样的背景下，还身在前端团队，大力推行 <code>TDD</code> 阻力很大，但这不是不作为的理由。</p>
<h2 id="把握测试的粒度"><a class="header" href="#把握测试的粒度">把握测试的粒度</a></h2>
<p>前面提到一句："大力推行 TDD 阻力很大"，Why？</p>
<p>对TDD有一定了解的读者不难理解：设计、编写单测用例的时间 ＞ 开发对应模块功能的时间</p>
<p><code>打工人</code> 和 <code>资本家</code>难以就此达成理念一致，能够被接受的，只是一个权衡下的结果，这要求我们 <code>把握测试的粒度</code>。</p>
<p>我们知道：<code>单元测试</code> 的本质是 对软件中的最小可测试单元进行检查和验证。</p>
<p>而在Android客户端代码中，必然有一道分水岭，隔开了 <code>业务</code> 和 <code>框架</code>。</p>
<p><strong>对于框架</strong>，引入的三方框架，进行一定的<code>冒烟</code>即可，而对于自研的框架，最好严格的遵循TDD。但是注意，这部分工作和 <code>业务层的测试</code> 是无关的。</p>
<p><em>不见得会天天折腾框架，但一定天天要处理业务。</em></p>
<p><strong>对于业务</strong>，基本可以分为3块：</p>
<ul>
<li>视图</li>
<li>业务逻辑</li>
<li>数据</li>
</ul>
<p>一般而言：</p>
<ul>
<li>视图层的，集成测试即可，哪怕自己写完了运行下过过眼。</li>
<li>数据层的，对Web-Service进行的测试不需要前端，基于本地DB建立的业务，作为业务逻辑测试。</li>
<li>业务逻辑，把握重点。</li>
</ul>
<p>另外，项目中会存在各种 <code>数据类代理</code>，<code>数据中介者</code>，<code>Wrapper</code>，这些类基于基础数据类进行了读写封装，或者功能装饰，也值得进行逻辑测试</p>
<h2 id="测试时的障碍--为什么造这个轮子"><a class="header" href="#测试时的障碍--为什么造这个轮子">测试时的障碍--为什么造这个轮子</a></h2>
<p>在前面的复盘中，我们已经清楚了对哪些内容进行单测，即粒度问题。而我们项目的分层架构，基本是：</p>
<ul>
<li>MVC</li>
<li>MVP</li>
<li>MVVM</li>
<li>一些变种 如MVI</li>
</ul>
<p>那么，测试的主要对象就是：C，P，VM，I这些层。而对于这些内容测试时，需要：注入<code>Model</code>和<code>View</code>，这一点无法避免。</p>
<p>如果说，设计时考虑了 <code>可测性</code>，那么至少在这些业务层，考虑了<code>依赖注入</code>，<code>依赖抽象</code>。那么在此基础上，我们不用担心 <code>View的复杂性</code>，
因为View层东西都不参与测试，而且不应当干预到测试。</p>
<p>但是Model层不一样。这些业务层的业务就是：</p>
<blockquote>
<p>响应视图层交互 -&gt; 执行附加业务 -&gt;操作Model-&gt; .... -&gt; 响应Model的变化 -&gt; 执行附加业务 -&gt; 反馈到视图层显示</p>
</blockquote>
<p>而利用真实的Model来进行测试，太重，并且可能对测试产生干扰项。所以 <code>不可避免</code> 的，我们需要 <code>设计Model的状态</code> 并进行 <code>Mock</code>，参与业务层测试。</p>
<p>如果能够以 <code>最小的时间</code> 代价，准确地获得期望的 Model实例，那是极好的。</p>
<h2 id="轮子有了却没有车"><a class="header" href="#轮子有了却没有车">轮子有了，却没有车</a></h2>
<p>非常遗憾，我花费了半个月的个人时间实现了轮子，转过头来，车并没有来。这一点，我 <code>为团队</code> 感到一丝羞愧。</p>
<p>分明大家都知道，一旦开始考虑TDD：</p>
<ul>
<li>设计会变得更加合理、健壮</li>
<li>编码会变得目的明确</li>
<li>bug会变少、交付质量提升</li>
<li>用例作为资产，可以检验迭代需求的合理性</li>
</ul>
<p>除此之外，我更为自己感到羞愧，因为 <code>自己没有极力推行</code> 并 <code>证明这样做给团队带来的改变</code>。</p>
<h2 id="知耻而后勇"><a class="header" href="#知耻而后勇">知耻而后勇</a></h2>
<p>自我鞭策，在项目中真正落地。自我检讨到此为止。</p>
<h2 id="关于项目本身"><a class="header" href="#关于项目本身">关于项目本身</a></h2>
<p>存在一个和Mock <code>相对</code> 的一个概念： <code>Bean Validation</code>，Bean Validation 是契约式编程的一种体现，<code>基于契约</code> 对数据类进行数据、状态校验。</p>
<p>而Mock 是基于契约生成假数据，构建数据类，但往往这个契约的 <code>约束内容较少</code>。</p>
<p>因为使用场景是单测，所以性能并不是第一要素，我很大胆的尝试了 <code>Kotlin的运行时反射</code>，并第一次在项目中直接使用Unsafe，收益良多。</p>
<h3 id="设计概要"><a class="header" href="#设计概要">设计概要</a></h3>
<p>mock的思路还是比较清晰的，大体上需要处理三类事情：</p>
<ul>
<li>数组和集合
<ul>
<li>结构性</li>
<li>泛型</li>
<li>元素赋值</li>
</ul>
</li>
<li>数据类
<ul>
<li>泛型</li>
<li>依赖注入</li>
<li>基本数据类型赋值</li>
</ul>
</li>
<li>深度问题，举个例子：单链表导致mock死循环</li>
</ul>
<p>在设计契约约束时，采用了 <code>注解表达</code>，例如：IntRange 和 IntDef，可以分别表示 <code>取值范围</code> 和 <code>取值枚举</code></p>
<p>只需要为 <code>基础数据类型</code> 和 <code>String</code> 设计一个 <code>池</code>，可以表达 <code>范围</code> 和 <code>枚举</code>，并且可以获知 <code>size</code>，即可利用Random，得到随机值。</p>
<p>水到渠成地，在反射数据类时，获取 <code>field</code> 信息以及其注解信息， 在为 <code>基本数据类型及其箱体类型</code> &amp; <code>String</code> field 赋值时，
先维护类型取值池，再Random取值即可达成：<code>取值受限</code> 和 <code>随机性</code>。</p>
<p>而结构型和数据类的构建，对Gson项目比较熟悉的读者就 <code>熟稔于心</code> 了，项目采用了类似实现。</p>
<p>但是在 <code>深度问题</code> 上，我 <code>并没有</code> 想到比较好的方案，目前只是尽力规避了死循环，并在绝大多数场景下，复用了先前创建的对象。</p>
<h2 id="总结-4"><a class="header" href="#总结-4">总结</a></h2>
<p>在活动的驱使下，这篇复盘思考了 <code>Mocker项目</code> 和 <code>公司商业应用在单测方面的不足</code>。既然复盘，那就需要 <code>规划改善不足</code>。</p>
<p>对于Mocker：</p>
<ul>
<li>参考 <code>Jsr303</code> 和 <code>Jsr380</code>，提供更广兼容、并且打通顺势造一个Android中轮子，一套注解服务于Mock 和 Bean Validation。</li>
<li>尝试解决深度问题。</li>
</ul>
<p>对于公司项目，推进好的idea落地。</p>
<p>最后引用一句名人名言：</p>
<blockquote>
<p>在需要面前，一切理想主义都是虚伪的 -- 尼采</p>
</blockquote>
<p>本文正在参与「掘金 2021 春招闯关活动」, 点击查看 <a href="https://juejin.cn/post/6939329638506168334">活动详情</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="三思系列前人用greendao留下的坑全线被扣了绩效"><a class="header" href="#三思系列前人用greendao留下的坑全线被扣了绩效">三思系列：前人用GreenDao留下的坑，全线被扣了绩效</a></h1>
<h2 id="前言-25"><a class="header" href="#前言-25">前言</a></h2>
<p>本篇文章，您将从一个GreenDao使用的事故开始，围观事故现场，并获得问题分析结论。跟随作者再次巩固GreenDao的整体设计，并实践 <code>APT</code> 、 <code>Gradle Plugin</code> 两种方案，通过不断地总结、对比和深度反思扫荡盲区，将知识融会贯通！</p>
<blockquote>
<p>创作三思系列是我学习、总结、反思的一种方式，着重于:<strong>问题分析</strong>、<strong>技术积累</strong>、<strong>视野拓展</strong>。<a href="https://leobert-lan.github.io/info/about_sansi_series.html">了解三思系列</a></p>
</blockquote>
<p>去年年末，出了一个可大可小的事故，<strong>导致开发、测试一条线都被扣了绩效</strong>。</p>
<p>背景是这样的：</p>
<ul>
<li>项目的部分业务数据存储于 <strong>本地数据库</strong></li>
<li>数据库业务使用了ORM框架--GreenDao</li>
<li>采用了类似 <a href="https://github.com/yuweiguocn/GreenDaoUpgradeHelper">GreenDaoUpgradeHelper</a> 的方案处理 "数据库版本升级"</li>
</ul>
<p>然而，最终事故发生在调用 <strong>Migration</strong> 时，<strong>遗漏了Dao</strong>，如果读者对这类 <strong>粗犷的</strong> 升级方案有所了解，一定猜到了最终结果：<strong>表数据丢失！！！</strong></p>
<p>很显然，导致最终结果的原因是多元的：</p>
<ul>
<li>前人采用的数据库升级方案就很危险</li>
<li>特殊渠道包的更新频次低、时间跨度长，测试覆盖粒度不够细（仅回归主功能、增量实现、从主包同步的bug修改和优化）导致一直未发现问题</li>
<li>轻易地相信了一个老项目，没有对基建部分进行详细的review</li>
<li>...</li>
</ul>
<p><em>作者按：可大可小的原因--性质比较恶劣的研发测试流程问题；值得庆幸的是这部分数据不会影响使用正确性，且发生在特殊用途的增量包中，影响范围很小，通过日志分析可回滚弥补。</em></p>
<p>显然，诸位亲爱的读者点进来，除了围观事故现场，还想看点别的！那自然不能辜负读者厚爱，本篇会同读者一起做一些有趣的事情。</p>
<h2 id="前人的使用方式概览"><a class="header" href="#前人的使用方式概览">前人的使用方式概览</a></h2>
<p><em>在真正开始之前，我们还需要耐心地看一下前人的使用方式</em>，<strong>此乃前车之鉴，如果你的项目中也有类似的用法，可能需要尽早地、仔细地Review一遍</strong>。</p>
<ul>
<li>正常的导包、应用plugin -- 没问题</li>
<li>gradle配置 <code>GreendaoOptions</code> -- 没问题， <em>targetGenDir配置到了常规sourceSet中，增加一些代码提交和merge conflict 问题不大</em></li>
<li>用注解标识Entity -- 参数都是默认的，问题不大，<strong>没有隐藏的大坑</strong></li>
<li>自实现了 <code>DaoMaster.OpenHelper</code> -- 没问题</li>
<li>自定义了数据库升级的helper，类似前文提到的GreenDaoUpgradeHelper -- 坑比较大：
<ul>
<li>性能问题</li>
<li>临时表名产生的制约</li>
<li><strong>人工维护传入的dao -- 直接导致的事故</strong></li>
</ul>
</li>
</ul>
<p>可能大多数项目的使用方式都是类似的，那么有三大问题丞待解决：</p>
<ul>
<li>需要人工维护升级的dao参数 -- 人的记性差，容易遗漏。不符合GreenDaoUpgradeHelper 等工具的设计初衷，<em>即不需要人工维护升级细节</em></li>
<li>restore时的效率问题</li>
<li>临时表名无形中产生的制约</li>
</ul>
<p><strong>限于篇幅，本篇只解决第一个问题，点出第二个问题，分析第三个问题。</strong></p>
<h3 id="greendao-如何进入升级降级"><a class="header" href="#greendao-如何进入升级降级">GreenDao 如何进入升级（降级）</a></h3>
<p>我们知道： Sqlite 存在有 <code>PRAGMA</code> 命令，可以在 SQLite 环境内控制各种环境变量和状态标志。而数据库的版本信息存储为 环境变量 <code>user_version</code></p>
<p>通过以下sql进行查询和设置：</p>
<pre><code class="language-roomsql">#查询
PRAGMA user_version;

#设置
PRAGMA user_version = {version}
</code></pre>
<p>而GreenDao配置的schemaVersion：</p>
<pre><code class="language-groovy">greendao {
    schemaVersion 1000
}
</code></pre>
<p>将通过gradle-task：<code>greendao</code> 写入生成的 <code>DaoMaster</code> 中,并作为 <code>SQLiteOpenHelper</code> 的 <code>version</code> 参数，与数据库的 <code>user_version</code>
比对后，判断是否需要进行创建、升级、降级。</p>
<pre><code class="language-java">public class DaoMaster extends AbstractDaoMaster {
    public static final int SCHEMA_VERSION = 1000;
    //...


    public static abstract class OpenHelper extends DatabaseOpenHelper {
        public OpenHelper(Context context, String name) {
            super(context, name, SCHEMA_VERSION);
        }

        public OpenHelper(Context context, String name, CursorFactory factory) {
            super(context, name, factory, SCHEMA_VERSION);
        }
        //...
    }
}
</code></pre>
<p>节选 <code>SQLiteOpenHelper</code> 一段代码如下：</p>
<pre><code>db.beginTransaction();
try {
    if (version == 0) {
        onCreate(db);
    } else {
        if (version &gt; mNewVersion) {
            onDowngrade(db, version, mNewVersion);
        } else {
            onUpgrade(db, version, mNewVersion);
        }
    }
    db.setVersion(mNewVersion);
    db.setTransactionSuccessful();
} finally {
    db.endTransaction();
}
</code></pre>
<p>您一定注意到：此处已经开启了数据库事务，如果将升级任务置于额外的线程执行，也存在风险！<strong>做好设计，减少甚至杜绝表结构变更</strong> 是最佳实践！</p>
<h3 id="升级helper概览"><a class="header" href="#升级helper概览">升级Helper概览</a></h3>
<p>几乎所有可以搜索到的工具，均以以下流程作为实现方案：</p>
<p><img src="Review/./post_40/img_1.png" alt="" /></p>
<p>表名关系：诸如 <code>临时表名 = {原表名}+"_TEMP"</code></p>
<p><em>作者按：为了方便，下文以 <code>tempTableName</code> 指代临时表名，<code>oTableName</code> 指代Entity对应的表名</em></p>
<p><strong>1.创建临时表</strong></p>
<ul>
<li>删除临时表 <code>DROP TABLE IF EXISTS {tempTableName}</code> -- 看似没有毛病，但如果存在业务设计的临库临表，就被误删除了</li>
<li>创建临时表 <code>CREATE TEMPORARY TABLE {tempTableName} AS SELECT * FROM {oTableName}</code></li>
</ul>
<p>比较奇怪的是：为何不:</p>
<ol>
<li>先判断临时表名是否存在，如存在则抛错，</li>
<li>然后再判断新增表是否会和临时表重名，如果存在则抛错，</li>
<li>继而在同一数据库内使用 <code>ALTER TABLE {oTableName} RENAME TO {tempTableName}</code> 修改表名</li>
</ol>
<blockquote>
<p><em>作者按：此处仅为一个设想，是Sqlite支持的SQL，但并未在Android项目中实践验证以及推理可能出现的问题。</em></p>
<p><em>可以预见的是：即便增加校验，也无法避免用户绕开GreenDao进行数据库操作所带来的隐性冲突可能。</em></p>
<p><em>GreenDaoUpgradeHelper在新的临时数据库中处理临时表，作者公司项目中的代码在原数据库中处理</em></p>
</blockquote>
<p><strong>2.调用DaoMaster删除表</strong></p>
<p>逻辑借用了GreenDao生成的代码，细节忽略</p>
<p><strong>3.调用DaoMaster生成表</strong></p>
<p>逻辑借用了GreenDao生成的代码，细节忽略</p>
<p><strong>4.restore数据</strong>
根据 <code>tempTableName</code> 和 <code>oTableName</code> 两张表的结构，构建SQL，迁移数据，细节忽略</p>
<h3 id="小结-1"><a class="header" href="#小结-1">小结</a></h3>
<p>至此，我们已经完成了问题2、3的基本分析：</p>
<blockquote>
<ol>
<li>人工维护需要升级的dao</li>
<li>restore时的效率问题 -- <strong>不需要升级的表也进行了I/O，不需要变更的字段也进行了I/O</strong></li>
<li>临时表名无形中产生的制约 -- <strong>同库情况下产生制约，创建无冲突的临库则无影响，但会增加I/O</strong></li>
</ol>
</blockquote>
<p>显而易见：问题2、3可以通过 "健壮的、可靠的数据库设计以降低升级数据库的需求"、"更加细致、高效的升级SQL" 加以解决。</p>
<p><em>作者按：虽然前文为它们花费了较长的篇幅，但它们不是这篇文章的主角，以后时间充裕的话，我会考虑造一个更好用、高效的轮子</em></p>
<p>而问题1的原因更加明显：GreenDao 并没有设计相关功能 <strong>用以提供需要升级的DAO信息</strong> 。而从数据库升级的算法流程分析，<strong>需要的DAO信息为全部的DAO类集合即可</strong></p>
<blockquote>
<p>经过前文大篇幅的分析，我们已经完成了第一次扣题：思危 -- 发现、分析危险。</p>
<p>如果有读者已经很不幸地处于危险之中，则需要开始思退。</p>
</blockquote>
<h2 id="两种可行的额外技术手段"><a class="header" href="#两种可行的额外技术手段">两种可行的额外技术手段</a></h2>
<p>此时让我们退一步，冷静地思考下：为什么先前的开发人员选择了 <strong>人工维护DAO类的Collection</strong> 呢？</p>
<p>诚然，GreenDao 没有帮助开发者维护 <strong>需要升级的表信息</strong> ，这种小事也没有必要提issue；</p>
<p>进一步思考：GreenDao将升级都交由开发者自行维护，Entity也由开发者自行创建，更没有理由提供这一信息；</p>
<p>更进一步思考：GreenDao还存在着 <strong>高级用法</strong> ，此时表可以交由开发者创建、维护。当自由度提升，没有 <strong>可靠的机制</strong> 帮助GreenDao判断开发者需要哪些信息；</p>
<p><strong>终极思考：是否GreenDao提供了，但开发者没注意到？</strong></p>
<p>但不用担心，我们自己动手，依旧可以丰衣足食，<em>虽然方案的出发点本身存在不合理之处</em>。</p>
<h3 id="方案1注解处理技术"><a class="header" href="#方案1注解处理技术">方案1：注解处理技术</a></h3>
<p>GreenDao使用 <code>@Entity</code> 对实体类进行注解，例如：</p>
<pre><code class="language-java">
@Entity(indexes = {
        @Index(value = "text, date DESC", unique = true)
})
public class Note {
    @Id
    private Long id;

    @NotNull
    private String text;
    private String comment;
    private java.util.Date date;

    @Convert(converter = NoteTypeConverter.class, columnType = String.class)
    private NoteType type;
}
</code></pre>
<p>依据 <code>@Entity</code> 注解，通过APT机制，我们可以很轻易的收集Entity对应的 <code>AbstractDao</code> 类信息</p>
<p><em>作者按：APT stands for Annotation Processing Tool. Sun shipped an API for APT in JDK 1.5, which can be viewed
at <a href="https://docs.oracle.com/javase/1.5.0/docs/guide/apt/mirror/index.html">一个你不愿意打开，打开了也不乐意看的网站😂</a></em></p>
<h3 id="方案2greendao插件"><a class="header" href="#方案2greendao插件">方案2：GreenDao插件</a></h3>
<p>众所周知，GreenDao通过Gradle Plugin完成了：</p>
<ul>
<li>Entity 发现</li>
<li>Entity 中表字段关系、索引、约束分析，源码级代码插桩</li>
<li>Dao 生成</li>
<li>DaoMaster生成</li>
</ul>
<p>如果我们可以 "入侵" 这一系列的流程，显然也可以达成目标，毕竟，生成的DaoMaster类头注释了：<strong>knows all DAOs.</strong></p>
<pre><code class="language-java">/**
 * Master of DAO (schema version 1000): knows all DAOs.
 */
public class DaoMaster extends AbstractDaoMaster {
    //...
}
</code></pre>
<h2 id="小时牛刀--注解处理"><a class="header" href="#小时牛刀--注解处理">小时牛刀--注解处理</a></h2>
<p>先简单回顾一下Entity注解的源码：</p>
<pre><code class="language-java">
/**
 * Annotation for entities
 * greenDAO only persist objects of classes which are marked with this annotation
 */
@Retention(RetentionPolicy.SOURCE)
@Target(ElementType.TYPE)
public @interface Entity {

    /**
     * Specifies the name on the DB side (e.g. table name) this entity maps to. By default, the name is based on the entities class name.
     */
    String nameInDb() default "";

    /**
     * Indexes for the entity.
     * &lt;p/&gt;
     * Note: To create a single-column index consider using {@link Index} on the property itself
     */
    Index[] indexes() default {};

    /**
     * Advanced flag to disable table creation in the database (when set to false). This can be used to create partial
     * entities, which may use only a sub set of properties. Be aware however that greenDAO does not sync multiple
     * entities, e.g. in caches.
     */
    boolean createInDb() default true;

    /**
     * Specifies schema name for the entity: greenDAO can generate independent sets of classes for each schema.
     * Entities which belong to different schemas should &lt;strong&gt;not&lt;/strong&gt; have relations.
     */
    String schema() default "default";

    /**
     * Whether update/delete/refresh methods should be generated.
     * If entity has defined {@link ToMany} or {@link ToOne} relations, then it is active independently from this value
     */
    boolean active() default false;

    /**
     * Whether an all properties constructor should be generated. A no-args constructor is always required.
     */
    boolean generateConstructors() default true;

    /**
     * Whether getters and setters for properties should be generated if missing.
     */
    boolean generateGettersSetters() default true;

    /**
     * Define a protobuf class of this entity to create an additional, special DAO for.
     */
    Class protobuf() default void.class;

}
</code></pre>
<p>作用在 <code>TYPE</code> 上，保存至源码级别，显然没有限制。</p>
<p>剩下来的工作非常简单：</p>
<ul>
<li>实现 <code>AbstractProcessor</code> 并完成SPI注册，进入到AnnotationProcessor流程</li>
<li>通过获取 <code>Entity</code> 注解类对应的 <code>TypeElement</code> ，判断项目是否正确配置</li>
<li>获取被注解的类，收集必要的信息</li>
<li>可选项1：甄别是否会出现临时表表名冲突，<em>编译期抛错优于运行期</em></li>
<li>可选项2：排除Kotlin类等干扰项，<em>GreenDao仅支持Java</em></li>
<li>生成代码</li>
</ul>
<p><em>具体代码可参考 <a href="https://github.com/leobert-lan/GreenDaoCollector">GreenDaoCollector</a> 中的 greendao-collector 部分</em></p>
<p><em>作者按：相信诸位读者对APT都有一定程度的掌握，如果掌握程度还不够熟练，在有时间条件的基础下，可以结合本案例展开一次练习</em></p>
<h3 id="额外的风险"><a class="header" href="#额外的风险">额外的风险</a></h3>
<p><em>看至此处，您一定已经对 <code>可选项2：排除Kotlin类等干扰项，GreenDao仅支持Java</code> 这句话进行了思考，并对我将 <code>Entity</code> 注解的源码全文粘贴于上这一 <code>水字数</code>
的行为表示了鄙夷。</em></p>
<p>但是请注意：</p>
<ul>
<li>GreenDaoCollector 没有考虑注解中 <code> boolean createInDb() default true;</code> 等方法</li>
<li>GreenDao存在一些限制，例如不支持Kotlin，GreenDaoCollector 采用了一个取巧的方案来甄别排除不支持的类</li>
<li>越精密的机器越容易出现故障，对于复杂的机制也是如此</li>
</ul>
<p><em>作者按：这一取巧的方案为：使用GreenDao时一般会为Entity生成相应的构造函数和Getter、Setter，追加的构造函数代码会被 <code>@Generated</code> 注解，基于此排除不支持的类，但请注意这一行为可以被关闭而造成误判。</em></p>
<p>很显然，该方案将承受巨大的风险，<strong>它仿刻了GreenDao的结果，但采用了不同的机制</strong> ，出现问题的机率会大增！</p>
<h2 id="渐入佳境--插件魔改"><a class="header" href="#渐入佳境--插件魔改">渐入佳境--插件魔改</a></h2>
<blockquote>
<p>莫非命也，顺受其正，是故知命者不立乎岩墙之下。尽其道而死者，正命也；桎梏死者，非正命也。</p>
<p>防祸于先而不致于后伤情。知而慎行，君子不立于危墙之下，焉可等闲视之</p>
<p>-- 《孟子》</p>
</blockquote>
<p>此时我们已经充分意识到第一个方案的风险，让我们来思考第二个方案，并做出对比。</p>
<p>您一定知道：GreenDao plugin 提供了两个 Gradle Task：</p>
<ul>
<li>greendaoPrepare</li>
<li>greendao</li>
</ul>
<p><em>作者按：GreenDao的插件并未开源，我们选择尊重GreenDao的团队，文中不讨论通过反编译才能得到的信息</em></p>
<h3 id="窥一斑而见全豹--分析其设计"><a class="header" href="#窥一斑而见全豹--分析其设计">窥一斑而见全豹--分析其设计</a></h3>
<p>如果您先前了解过Gradle Plugin，那一定知道Gradle的Task均有其输入和输出。</p>
<p>而顾名思义，<code>greendaoPrepare</code> 一定是一个准备工作，将它的输出做为 <code>greendao</code> Task的输入，</p>
<p>结合 GreenDaoCollector 项目中的sample可以获知，其输出为：</p>
<pre><code>// 相对路径：build/cache/greendao-candidates.list

1649475279008
{略去}/GreenDaoCollector/app/src/main/java/osp/leobert/android/gdc/entity/JavaDemoEntity.java
{略去}/GreenDaoCollector/app/src/main/java/osp/leobert/android/gdc/entity/JavaDemoEntityTemp.java
</code></pre>
<p>并且您一定注意到了，<code>JavaDemoEntityTemp</code> 已经被全文注释</p>
<p>从结果来看， <code>greendaoPrepare</code> 一定不是 <strong>基于编译或者基于AST</strong> 的方案，它必然是一个从源码文件中 <strong>快速筛选</strong> 可能存在Entity的方案，用以减少 <code>greendao</code> Task
的性能开销，可以很轻易的推断出 <strong>通过字符串匹配</strong> 实现这一功能。</p>
<p>言归正传，您一定知道：gradle借助pom文件实现library依赖管理，通过greendao plugin 的pom文件可知： 插件依赖 <code>greendao-code-modifier</code>。</p>
<p><code>greendao-code-modifier</code> 同样未开源，通过pom文件分析其依赖：</p>
<ul>
<li><a href="https://github.com/greenrobot/greenDAO">greendao-api</a> 开源，greendao中的注解和基础interface</li>
<li><a href="https://github.com/greenrobot/greenDAO">greendao-generator</a> 开源，生成源码部分</li>
<li>greenrobot-jdt，Repackaged version of JDT</li>
<li><a href="https://github.com/greenrobot/essentials">essentials</a> ， 开源，用于计算Hash</li>
</ul>
<p><em>作者按：相关的pom文件，可以于MavenCentral中检索，或者查看gradle/maven
的本地cache，或者在 <a href="https://github.com/leobert-lan/GreenDaoCollector">GreenDaoCollector 的files目录中</a> 查阅。考虑到阅读体验，重要部分摘录附于文末</em></p>
<p>至此，我们得出结论：</p>
<blockquote>
<p>通过 greendaoPrepare 任务，基于源码内容做字符串检索，快速筛选出可能是Entity的源码，信息输出到文件：greendao-candidates.list</p>
<p>读取greendao-candidates.list 文件内容，基于jdt分析其源码语法树（AST）</p>
<p>基于AST和注解解析Entity、主键、索引、约束、关联等</p>
<p>调用greendao-generator生成源码</p>
</blockquote>
<p><em>作者按：<a href="http://www.eclipse.org/jdt/">JDT</a> 是eclipse为Java提供的一组工具，可以实现APT、支持Java editing等</em></p>
<p>如果您对Intellij中 <strong>与Java、Kotlin源码相关</strong> 的插件开发有一定的了解，对其早期使用的 <code>lombok-ast</code> 和后来使用的 <code>uast</code> 一定不会感到陌生，JDT也是类似的工具。</p>
<p>言归正传，我们只需要改变 <code>greendao-generator</code> 生成代码的实现即可实现需求！</p>
<p>阅读 <code>greendao-generator</code> 源码后，您将获悉：它因为 <strong>业务非常复杂</strong> 而使用<a href="https://freemarker.apache.org/">FreeMaker</a>作为模板引擎生成源码。</p>
<p><strong>难道要使用字节码技术，直接修改加载模板处的源码，增加新的模板</strong>，这么轻易就放大招了吗？</p>
<h3 id="大象无形--利用加载机制做文章"><a class="header" href="#大象无形--利用加载机制做文章">大象无形--利用加载机制做文章</a></h3>
<p>可以发现，greenDao对FreeMaker的初始化代码如下：</p>
<pre><code class="language-java">public class DaoGenerator {
    private Configuration getConfiguration(String probingTemplate) throws IOException {
        Configuration config = new Configuration(Configuration.VERSION_2_3_29);
        config.setClassForTemplateLoading(getClass(), "/");
    }
}
</code></pre>
<p>简单查看源码：</p>
<pre><code>public void setClassForTemplateLoading(Class resourceLoaderClass, String basePackagePath) {
    setTemplateLoader(new ClassTemplateLoader(resourceLoaderClass, basePackagePath));
}

/**
 * A {@link TemplateLoader} that can load templates from the "classpath". Naturally, it can load from jar files, or from
 * anywhere where Java can load classes from. Internally, it uses {@link Class#getResource(String)} or
 * {@link ClassLoader#getResource(String)} to load templates.
 */
public class ClassTemplateLoader extends URLTemplateLoader {
//ignore 看类注释
}
</code></pre>
<p>如果您了解 <code>Class.getResource(String name)</code> 方法，并且对打包有了解，则可以得出结论：</p>
<blockquote>
<p>关键点在于 <code>ClassLoader#getResource</code> 并且存在 <code>Parent-delegate</code> 机制。</p>
<p><strong>只需要在plugin中增加同名模板，在plugin被运行时，该模板将被先加载</strong>。</p>
</blockquote>
<p><em>作者按：此处不再展开，否则十篇文章也写不完。</em></p>
<p><strong>实现目标只需要两步</strong>：</p>
<ul>
<li>新建插件，通过继承或者使用组合，直接使用GreenDao插件逻辑，<em>选用组合,因为无法继承</em></li>
<li>新增同名模板，并增加相关逻辑用以生成代码，<em>最终选用dao-master模板</em></li>
</ul>
<p>重点代码如下： <em>具体代码可参考 <a href="https://github.com/leobert-lan/GreenDaoCollector">GreenDaoCollector</a> 中的 greendao-plugin-wrapper 部分</em></p>
<pre><code class="language-Kotlin">//插件
class GreenDaoPluginWrapper : Plugin&lt;Project&gt; {
    private val wrapper: Plugin&lt;Project&gt; = Greendao3GradlePlugin()
    override fun apply(project: Project) {
        wrapper.apply(project)
    }
}
</code></pre>
<pre><code>//模板
/**
* Master of DAO (schema version ${schema.version?c}): knows all DAOs.
*/
public class ${schema.prefix}DaoMaster extends AbstractDaoMaster{
  public static final int SCHEMA_VERSION=${schema.version?c};
  
  // all dao need to create in db, do not modify, created by leobert
  public static final List&lt;Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;&gt;allDao=new java.util.ArrayList();
  
      static {
  &lt;#list schema.entities as entity&gt;
  &lt;#if!entity.skipCreationInDb&gt;
          allDao.add(${entity.classNameDao}.class);
  &lt;/#if&gt;
  &lt;/#list&gt;
      }
          
      //其他略
}
</code></pre>
<p>读者应该还记得前文的 <code>Entity</code> 注解以及我提到的只言片语，开发者可以自行创建数据库，或者从某处获得数据库直接使用，那么可以通过 <code>boolean createInDb()</code> 等配置 令GreenDao忽略表的创建与删除。</p>
<p>示例模板中通过 <code>&lt;#if!entity.skipCreationInDb&gt;</code> 的判断，排除了无需GreenDao协助建表的DAO。但请务必留心，<strong>数据库表升级永远是业务级别的工作</strong>，框架和工具再好，也需要 <strong>根据实际业务进行调整</strong>
！</p>
<p>应用插件后效果如下：</p>
<pre><code class="language-java">// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.

/**
 * Master of DAO (schema version 1): knows all DAOs.
 */
public class DaoMaster extends AbstractDaoMaster {
    public static final int SCHEMA_VERSION = 1;

    // all dao need to create in db, do not modify, created by leobert
    public static final List&lt;Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;&gt; allDao = new java.util.ArrayList();

    static {
        allDao.add(JavaDemoEntityDao.class);
    }

    /** Creates underlying database table using DAOs. */
    public static void createAllTables(Database db, boolean ifNotExists) {
        JavaDemoEntityDao.createTable(db, ifNotExists);
    }

    /** Drops underlying database table using DAOs. */
    public static void dropAllTables(Database db, boolean ifExists) {
        JavaDemoEntityDao.dropTable(db, ifExists);
    }
    //其他略
}
</code></pre>
<h3 id="与方案1对比"><a class="header" href="#与方案1对比">与方案1对比</a></h3>
<p>显而易见，方案2借用了greendao的插件业务逻辑，除了在模板中增加少许内容，再无其他，无论风险性还是简易性均优于方案1。</p>
<p>模板中基于 <code>&lt;#if!entity.skipCreationInDb&gt;</code> 判断，收集的dao信息与 <code>createAllTables、dropAllTables</code> 中保持一致！当然，亦可以移除判断，收集所有的dao ，**
需结合业务做出选择**。</p>
<p>不具备编译时临时表名冲突检测功能。</p>
<h2 id="前车之鉴--大彻大悟一个错误犯两次"><a class="header" href="#前车之鉴--大彻大悟一个错误犯两次">前车之鉴--大彻大悟,一个错误犯两次</a></h2>
<blockquote>
<p>前车已覆，后未知更，何觉时？</p>
<p>-- 《荀子·成相》</p>
</blockquote>
<p>这句话讲的是成语前车之鉴，让我们回顾一下：</p>
<p><strong>导致问题的原因：</strong></p>
<ul>
<li>前人采用的数据库升级方案就很危险</li>
<li>特殊渠道包的更新频次低、时间跨度长，测试覆盖粒度不够细，导致一直未发现问题</li>
<li><strong>轻易地相信了一个老项目，没有对基建部分进行详细的review</strong></li>
<li>...</li>
</ul>
<p><strong>升级方案丞待解决的问题：</strong></p>
<ul>
<li>需要人工维护升级的dao参数，容易遗漏，存在风险</li>
<li>restore时的效率问题</li>
<li>临时表名无形中产生的制约</li>
</ul>
<p><strong>采用的手段</strong></p>
<p>使用了 <code>APT</code> 和 <code>包装插件替换模板</code> 两种技术手段，为一个 <strong>非最佳的数据库表升级方案</strong> 解决了 <strong>需要人工维护参数</strong> 的问题。</p>
<p>显而易见，最佳的实践方案应当为：</p>
<blockquote>
<p>替换一套健壮、高效的数据库升级方案: 自动收集需要升级的表 -- 排除无效迁移工作提升效率、使用自动化替代人工规避人的错误。同时满足 <strong>可测性</strong></p>
</blockquote>
<p>那么立足当下，<strong>方案1、2就是最佳实践了吗</strong>？请重读下面这两句话：</p>
<ul>
<li><strong>轻易地相信了一个老项目，没有对基建部分进行详细的review</strong></li>
<li>Master of DAO (schema version 1000): knows all DAOs.</li>
</ul>
<p>同一个错误又犯了一次: <strong>我们轻易地否定了一个老项目，没有对它的代码进行详细的review</strong></p>
<pre><code class="language-kotlin">val allDao: List&lt;Class&lt;AbstractDao&lt;*, *&gt;&gt;&gt; = DaoMaster(
    SQLiteDatabase.create(null)
).newSession().allDaos.map {
    it.javaClass
}.toCollection(arrayListOf())
</code></pre>
<p><code>DaoMaster</code> 的模板中，为其构造函数实现了所有Dao的注册，无论是否创建表，它们都会被汇总到
<code>Map&lt;Class&lt;?&gt;, AbstractDao&lt;?, ?&gt;&gt; AbstractDaoSession#entityToDao</code> 中。</p>
<p>但您需要始终牢记，这是在为一个非最佳方案服务，一旦使用了更好的方案，这一方式将不再适用！</p>
<h2 id="总结-5"><a class="header" href="#总结-5">总结</a></h2>
<p>本篇，我们从一个事故开始，展开了问题分析，并提出技术方案，实现方案并进行了知识巩固，通过不断地总结、对比和深度反思扫荡盲区！</p>
<p>如果单纯的服务于解决问题，这篇博客将不会存在，区区10行代码即可。但三思系列是学习、总结、反思的一种方式，着重于:<strong>问题分析</strong>、<strong>技术积累</strong>、<strong>视野拓展</strong> ，看完这一篇，我相信你收获的内容 <strong>远远超过</strong> 一个bug的解法。</p>
<h2 id="附-1"><a class="header" href="#附-1">附</a></h2>
<h3 id="项目源码"><a class="header" href="#项目源码">项目源码</a></h3>
<p><a href="https://github.com/greenrobot/greenDAO">GreenDao</a></p>
<p>作为数据库版本升级方案示例的： <a href="https://github.com/yuweiguocn/GreenDaoUpgradeHelper">GreenDaoUpgradeHelper</a></p>
<p>Sample代码，APT, Plugin 及部分资料均开源 ：<a href="https://github.com/leobert-lan/GreenDaoCollector">GreenDaoCollector</a></p>
<h3 id="pom文件摘要"><a class="header" href="#pom文件摘要">pom文件摘要</a></h3>
<pre><code class="language-xml">&lt;!--greendao-gradle-plugin-3.3.0.pom--&gt;
&lt;groupId&gt;org.greenrobot&lt;/groupId&gt;
&lt;artifactId&gt;greendao-gradle-plugin&lt;/artifactId&gt;
&lt;version&gt;3.3.0&lt;/version&gt;
&lt;name&gt;greenDAO Gradle Plugin&lt;/name&gt;
&lt;description&gt;Gradle Plugin for greenDAO, the light and fast ORM for Android&lt;/description&gt;
&lt;url&gt;https://github.com/greenrobot/greenDAO&lt;/url&gt;
    &lt;!--  略--&gt;
&lt;dependencies&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.greenrobot&lt;/groupId&gt;
    &lt;artifactId&gt;greendao-code-modifier&lt;/artifactId&gt;
    &lt;version&gt;3.3.0&lt;/version&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
&lt;!--    略--&gt;
&lt;/dependencies&gt;


    &lt;!--greendao-code-modifier-3.3.0.pom--&gt;
&lt;groupId&gt;org.greenrobot&lt;/groupId&gt;
&lt;artifactId&gt;greendao-code-modifier&lt;/artifactId&gt;
&lt;version&gt;3.3.0&lt;/version&gt;
&lt;name&gt;greenDAO Code Modifier&lt;/name&gt;
&lt;description&gt;Code modifier for greenDAO, the light and fast ORM for Android&lt;/description&gt;
&lt;url&gt;https://github.com/greenrobot/greenDAO&lt;/url&gt;
    &lt;!--  略--&gt;
&lt;dependencies&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.greenrobot&lt;/groupId&gt;
    &lt;artifactId&gt;greendao-api&lt;/artifactId&gt;
    &lt;version&gt;3.3.0&lt;/version&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.greenrobot&lt;/groupId&gt;
    &lt;artifactId&gt;greendao-generator&lt;/artifactId&gt;
    &lt;version&gt;3.3.0&lt;/version&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.greenrobot&lt;/groupId&gt;
    &lt;artifactId&gt;greenrobot-jdt&lt;/artifactId&gt;
    &lt;version&gt;3.20.0&lt;/version&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.greenrobot&lt;/groupId&gt;
    &lt;artifactId&gt;essentials&lt;/artifactId&gt;
    &lt;version&gt;3.0.0-RC1&lt;/version&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
&lt;!--  略--&gt;
&lt;/dependencies&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="谈一谈在两个商业项目中使用mvi架构后的感悟"><a class="header" href="#谈一谈在两个商业项目中使用mvi架构后的感悟">谈一谈在两个商业项目中使用MVI架构后的感悟</a></h1>
<h2 id="前言-26"><a class="header" href="#前言-26">前言</a></h2>
<p>MVI并非新兴事物，在2020年时亦曾有通过撰写一篇文章与诸位读者探讨一二的念头。</p>
<p>当时项目采用MVP分层设计，组员的代码风格差异也较大，代码中类职责赋予与封装风格各成一套，随着业务急速膨胀，代码越发混乱。试图用 <code>MVI架构</code> + <code>单向流</code> 形成 <code>掣肘</code> 带来一致风格。
但这种做法不够以人为本，最终采用 <strong>"在MVP的基础上进行了适当改造+设计约定的方式"</strong> 解决了问题，并未将MVI投入到商业项目中，于是 <strong>放弃了纸上谈兵</strong>。</p>
<p>在半年前终于有机会在商业项目中进行实践，同诸位谈一谈使用后的 <strong>个人感悟</strong> ，并藉此讲透MVI等架构。</p>
<p>所有内容将按照以下要点展开：</p>
<ul>
<li>从架构的理念出发 -- <strong>简单列明各种 <code>MVX</code> 的理念</strong> ， <em>MVX：指代 MVC、MVP、MVVM、MVI</em></li>
<li>拥抱复杂的同时实现简化 -- <strong>通过对比理解单向数据流动所解决的痛点、设计Intent的原因等问题</strong></li>
<li>单一可信数据源，不可僵化信奉</li>
<li>要想优雅，需要工具 -- <strong>借助声明式、响应式编程工具，构建<code>流</code></strong>，<em>屏蔽命令式编程中的细节，同样是聚焦和简化</em></li>
<li>状态和事件分家，绝不是吃饱了撑的 -- <strong>为什么要裂变出状态和事件，如何界定</strong></li>
</ul>
<p><em>内容会很长，我会酌情再写一些 <code>解</code> ，结合实例和代码演示内容。</em></p>
<h3 id="两个项目的基本情况"><a class="header" href="#两个项目的基本情况">两个项目的基本情况</a></h3>
<p>相比于之前的巨型项目，<strong>这两个项目的业务量均不大</strong>，一个是基于蓝牙和局域网的操控类APP，下午简称APP-A，一个是内部使用的工具，分析公司各个产品的日志，简称APP-B。</p>
<p>虽然他们的业务深度要比一般的APP要深，但在 <strong>本质上一致</strong> ，毕竟同类型业务量再多也仅仅是重复运用一套模式 ，并不影响本质。</p>
<p><strong>和诸多项目的本质一致</strong>，均符合如下图所示的逻辑分层，并在人机交互过程中执行业务逻辑：</p>
<p><img src="Review/post_44/img.png" alt="img.png" /></p>
<ul>
<li>APP-A 是Android项目，图方便纯kotlin</li>
<li>APP-B 是 Compose-Desktop项目，不得不kotlin</li>
</ul>
<p>过于絮叨了，我们进入正文。</p>
<h2 id="从架构的理念出发"><a class="header" href="#从架构的理念出发">从架构的理念出发</a></h2>
<blockquote>
<p>谨记，实际情况中，MVI、MVVM这些架构均先由Web应用领域提出，用于解决浏览器Web应用研发中的问题。</p>
<p>在后续的应用领域发展过程中，存在共性问题，便引入了这些设计，并结合自身特点进行了拓展。</p>
</blockquote>
<p>接下来我们聊一聊理念，不比武功。</p>
<p><img src="Review/./post_44/idea.jpg" alt="" /></p>
<p><em>图片出自电影一代宗师</em></p>
<h3 id="mvi的理念"><a class="header" href="#mvi的理念">MVI的理念</a></h3>
<p><code>MVI</code> 脱胎于 <code>Model View Intent</code></p>
<ul>
<li>Intent：驱动model发生改变的意图，以UI中的事件最为常见；</li>
<li>Model：业务模型，包含数据和逻辑，是对应 <code>客观实体</code> 的 <code>程序建模</code>；</li>
<li>View：表现层的视图，以UI方式呈现Model的状态（以及事件），接受用户输入，转换为UI事件</li>
</ul>
<p>官方的这幅图很好的呈现了三者之间的驱动关系：</p>
<p><img src="Review/./post_44/mvi-1.png" alt="" /></p>
<p>这张图非常简单，它摒弃了驱动方式的细节，只体现了角色与驱动关系。</p>
<p>注意，只要设计中满足 <code>角色和驱动关系</code> 符合上图，就是MVI架构设计，并不限制 <code>驱动方式的实现细节</code></p>
<p><em>经典的MVI驱动细节要比上图复杂很多，下文再聊。</em></p>
<p>从软件设计的原则出发：<code>职责分离并封装</code> 的目的是 <code>解耦</code> 、 <code>可独立变化</code>、<code>复用</code>。</p>
<p>显然，区别于 <code>MVVM</code> 、 <code>MVP</code> 、 <code>MVC</code>，角色上的差别在于 ViewModel、Presenter、Controller、Intent四者，而它们又是View和Model之间的纽带。除此之外，V和M亦稍有不同。</p>
<h4 id="mvcmvp"><a class="header" href="#mvcmvp">MVC、MVP</a></h4>
<p>MVC、MVP 中，C和P的职责体现为 <code>控制、调度</code>。</p>
<p>MVP中 <code>V</code> 和 <code>M</code> 完全解耦可独立变化，MVC中 <code>M</code> 直接操作 <code>V</code> 耦合高，在web应用中，<code>C</code> 需要直接操作DOM。</p>
<h4 id="mvvm"><a class="header" href="#mvvm">MVVM</a></h4>
<p>MVVM中，提倡 <code>数据驱动</code>， <code>数据源</code> 被剥离到 <code>VM</code> 中，在 <code>双向绑定框架</code> 的加持下，View层的输入反映为数据的变化，数据的变化驱动视图内容。</p>
<p>显然，VM的职责限于维护数据状态，<em>如有必要，驱动View层消费数据状态，</em> 不必再关注如何操作视图。</p>
<p><em>一般来说，双向绑定框架已经引入观察者模式实现，可响应式驱动，VM一般没有必要关心 <strong>响应式驱动和下游观察者生命周期问题</strong></em></p>
<p>简单思考之后会发现MVVM的问题，它的侧重点在于 <code>利用双向绑定让开发者专注于数据状态的维护，从操作视图更新中得以解放</code>，它难以解决 <code>无天然状态</code> 问题，例如：按钮点击这类事件。</p>
<h4 id="mvi"><a class="header" href="#mvi">MVI</a></h4>
<p>在MVI中，结合业务背景将UI事件等内容转换为 <code>Intent</code> ，驱动Model层业务，Model层的业务结果反映为 <code>视图状态</code> + <code>事件</code>。</p>
<p>因此View层和Model层之间已经解耦，并可以吸收MVVM中的优点采用如下设计：</p>
<ul>
<li>将双向绑定退化为单向绑定，View层消费UI状态流和事件流，这也意味着UI状态的职责精简，它不再承载View层的用户输入等事件</li>
<li>将UI状态独立，Model层仅产生 <code>UI状态的局部变化</code> 和 <code>事件</code></li>
</ul>
<p>下图为经典的MVI原理示意图：</p>
<p><img src="Review/./post_44/mvi-2.png" alt="" /></p>
<p>在上文中，我们已经讨论了各个角色的职责，下面逐步展开讨论角色具备的特性和细节知识。</p>
<p>在此之前，还请谨记：合适的才是最好的</p>
<blockquote>
<p>没有绝对的最好的设计，只有最合适的设计。</p>
</blockquote>
<p>再好的架构，都需要遵循其理念并结合项目因地制宜地进行调整，以获得最佳使用效果。所以请读者诸君务必在阅读时，结合自身项目的情况仔细思考以下问题：</p>
<ul>
<li><strong>引入新框架所解决的痛点、衍生的问题、是否需要进行框架调整？</strong></li>
<li><strong>框架中的角色功能，为什么出现，又有怎样的局限？</strong></li>
</ul>
<h2 id="单向数据流动"><a class="header" href="#单向数据流动">单向数据流动</a></h2>
<blockquote>
<p>MVI拥抱了结构复杂，但能够灵活应对业务编码时的各种情况，按部就班即可。</p>
</blockquote>
<p>从MVI原理图中，可以清晰的看到 <strong>"数据"</strong> 的流动方向。
起始于 <code>Intent</code>，经过分类和选择性消费后产生 <code>Result</code>，对应的reducer函数计算后，得到最新的 <code>State</code> <em>（以及裂变出必要的 <code>Event</code>，图中未体现）</em> ，驱动视图。</p>
<p>注意：</p>
<ul>
<li><code>单向</code> 是指 <strong>单一方向</strong></li>
<li>此处的 <code>数据</code> 是广义的、宽泛的。</li>
<li>仅描述数据流的 <strong>变化方向</strong> ，与数据流的数量无关，但一般 <strong>形成有效工作</strong> 均需要两条数据流（上行数据流和下行数据流）</li>
</ul>
<p>即驱动数据流变化的方向是唯一的，在英文中的术语为：<code>Unidirectional Data Flow</code> 简称 <code>UDF</code>。</p>
<h3 id="mvcmvp中的痛点"><a class="header" href="#mvcmvp中的痛点">MVC、MVP中的痛点</a></h3>
<p>前文我们提到，在MVC和MVP中，着眼于 <strong>控制、调度</strong> ，并不强调 <code>数据流</code> 的概念。</p>
<p>View和Model间之间的交互，一般有两种编码风格：双向的API调用、单向的API调用+回调：</p>
<p><em>注意：以下两图并未体现Controller和Presenter细节，仅表意，从View层出发的API调用和回到View层的UI更新</em></p>
<p><img src="Review/post_44/flow-mvc.png" alt="img.png" /></p>
<p>双向API调用如上图。</p>
<p><img src="Review/post_44/flow-mvc2.png" alt="img.png" /></p>
<p>单向API调用+回调更新UI如上图。</p>
<p>显而易见，这两种方式无法继续抽象，需根据实际业务进行命令式编码。当UI复杂时，难以写出清晰、易读的代码，维护难度激增。</p>
<h3 id="mvvm解决ui更新代码混乱问题"><a class="header" href="#mvvm解决ui更新代码混乱问题">MVVM解决UI更新代码混乱问题</a></h3>
<p>前文我们已经提到：MVVM中通过绑定框架，将UI事件转化为数据变化，驱动业务；业务结果表现为数据变化，驱动UI更新。</p>
<p><img src="Review/post_44/flow-mvvm.png" alt="img.png" /></p>
<p>显而易见，<strong>维护朴素的数据要比直接维护复杂的UI要简单</strong>。</p>
<p>但问题也同时产生，data1的变化有两个可能的原因：</p>
<ul>
<li>Model层业务结果使其变化，并期望它驱动UI更新</li>
<li>View层发生事件，反馈数据变化，并期望它驱动Model层逻辑</li>
</ul>
<p>因此，框架需要考虑标识数据变化来源、或者其他手段消除方向性所带来的问题。</p>
<p>并且MVVM难以灵活决定的 "何时调用Model层逻辑"，即大多数业务中，都需要结合多个属性的变化形成组合条件来驱动Model层逻辑。</p>
<p><strong>本篇并不重点讨论MVVM，故不再展开MVVM解决循环更新的方案，以及衍生的问题。</strong></p>
<p>尽管如此，MVVM中的数据绑定依旧解决了View层更新繁杂的问题。</p>
<h3 id="用intent灵活决定何时调用model"><a class="header" href="#用intent灵活决定何时调用model">用Intent灵活决定何时调用Model</a></h3>
<p>既然数据驱动UI有极大的益处，且View层事件驱动ViewModel的数据变化有很多弊端 <em>（需要建立很高的复杂度）</em> ，那自然需要 <strong>趋利避害</strong></p>
<p><img src="Review/post_44/flow-mvi.png" alt="img.png" /></p>
<p>仅保留数据驱动UI的部分，并增加Intent用以驱动Model层业务</p>
<p>在于 <code>MVC/MVP</code> 以及 <code>MVVM</code> 对比后不难得出结论：</p>
<ul>
<li>MVC/MVP中，View层通过调用C/P层API的方式最终调用到Model层业务，方式质朴、无难度。但业务量规模增大后接口方法数也会增多，导致C/P层尾大不掉，难以重用。</li>
<li>MVVM中，VM层总是需要利用 <code>技巧</code> 进行模型概念转换，以满足业务响应满足实际需求，需要很深厚的设计经验才能写出非常优秀的代码，这并不友好。</li>
</ul>
<p><em>作者按：我个人认为一个友好的设计，不应当剑走偏锋，而应当大巧不工，能够以力破法，达成 "使用者只需要吃透理论就可以解决各类问题" 的目标。</em></p>
<p>而MVI在架构角色中设计了Intent的角色：</p>
<ul>
<li>它包含了业务调用的意图和数据</li>
<li>从设计上可满足 <code>调用</code> 与 <code>实现</code> 的分离</li>
<li>架构模型中以Intent流的形式出现，下游对其的 <code>筛选</code> 、<code>转换</code> 、 <code>消费</code> 等行为可遵循 <code>FP范式</code> <em>（即函数式编程范式、Functional Programming Patterns）</em> ，逻辑的复用粒度为方法级，复用度更高更灵活</li>
<li>解决了MVVM中的方向性问题、MVC/MVP 中的灵活度问题等</li>
</ul>
<h2 id="单一可信数据源"><a class="header" href="#单一可信数据源">单一可信数据源</a></h2>
<p>我猜测读者诸君都曾听过这个词，将 <code>单一可信数据源</code> 拆解一下：</p>
<ul>
<li>单一</li>
<li>可信</li>
<li>数据源</li>
</ul>
<p>在MVI背景下，<code>数据源</code> 指的是视图对应的数据实体，它代表视图的内容状态。</p>
<p>可信指从数据源中获取的数据是 <code>最新的</code>、<code>完整的</code>、<code>可靠的</code>，否则是不可信的，<em>我们没有理由在编码中使用不可信的数据源</em>。</p>
<p>单一是指这样的数据源仅一个。</p>
<p>在经典设计中，其内涵如下图:</p>
<p><img src="Review/post_44/mvi-ssot.png" alt="img.png" /></p>
<ul>
<li>按照视图的 <strong>所有的</strong> 内容状态，定义一个不可变的 <code>ViewState</code></li>
<li>按照业务初始化 ViewState 实例</li>
<li>Model业务生成驱动 ViewState变化的Result</li>
<li>计算出新状态，Reduce(Pre-ViewState,Result) -&gt; New-ViewState</li>
<li>更新数据源</li>
<li>View层消费ViewState</li>
</ul>
<p>借助于数据绑定框架，可以很方便地解决视图更新的问题。</p>
<blockquote>
<p>想象一下，此时页面UI非常复杂……</p>
<p><img src="Review/img.png" alt="img.png" /></p>
</blockquote>
<p>如果僵化的信奉这样的 <code>单一</code> ，情况会如何呢？</p>
<ul>
<li>复杂（大量属性）的ViewState</li>
<li>复杂的UI更新计算，<em>e.g. 100个属性变了2个，依然需要计算98个属性未变或者全量强制更新</em></li>
</ul>
<p>在 APP-A和APP-B中，我分别使用了 DataBinding和Compose，但均无法避免该问题。</p>
<h3 id="何为单一"><a class="header" href="#何为单一">何为单一</a></h3>
<p>从机器执行程序的原理上看，我们无法实现 <strong>多个内容一致的数据源</strong> 在 <strong>任意时刻</strong> 满足 <code>最新的</code>、<code>可靠的</code>。</p>
<p>将视图视为一个整体，规定它只拥有 <strong>一个</strong> 可信的数据源。在此基础上看局部的视图，它们也顺其自然地仅拥有一个可信的数据源。</p>
<p>反过来看，当任意的局部视图仅具有一个可信数据源时，整体视图也仅有一个逻辑上的可信数据源。</p>
<p>据此，我们可以对 <code>经典MVI实现</code> 进行一定程度的改造，将ViewState进行局部分解，使得UI绑定部分的业务逻辑更 <strong>清晰、干净</strong>。</p>
<p><em>请注意，复杂度不会凭空消失，我们为了让 "UI绑定的业务逻辑更清晰、干净"、"更新UI的计算量更少"，将复杂度转移到了ViewState的拆分。拆分后，将具有 <strong>多个视图部件的单一可信数据源</strong>，注意，为了不引起额外的麻烦、并且便于维护扩展，建议遵守以下条件：</em></p>
<ul>
<li>基于业务需求，组合数据源形成新数据源</li>
<li>不在数据源的逻辑范围之外进行数据源组合操作</li>
</ul>
<blockquote>
<p>举个虚拟的例子：用户需要实名认证 且 关注博主 ，才在界面上显示某功能按钮。下面使用代码分别演示。</p>
</blockquote>
<p><em>考虑到RxJava的广泛度依旧高于Kotlin-Coroutine+flow，数据流的实现采用RxJava</em></p>
<p><em>注意，考虑到读者可能会编写demo做UDF局部的验证，下文中的代码以示例目的为主，兼顾编写场景冒烟的方便性，流的类型不一定是构建完整UDF的最佳选择。</em></p>
<h4 id="经典实现"><a class="header" href="#经典实现">经典实现</a></h4>
<p>在经典MVI实现中，需要先定义ViewState</p>
<pre><code class="language-kotlin">data class ViewState(
    /*unique id of current login user*/
    val userId: Int,
    /*true if the current login user has complete real-name verified*/
    val realNameVerified: Boolean,
    /*true if the current login user has followed the author*/
    val hasFollowAuthor: Boolean
) {
}
</code></pre>
<p>并定义ViewModel，创建ViewState流，忽略掉其初始化和其他部分</p>
<pre><code class="language-kotlin">class VM {
    val viewState = BehaviorSubject.create&lt;ViewState&gt;()

    //ignore
}
</code></pre>
<p>并定义View层，忽略掉其他部分，简单起见暂时不使用数据绑定框架</p>
<pre><code class="language-kotlin">class View {

    private val vm = VM()
    lateinit var imgRealNameVerified: ImageView
    lateinit var cbHasFollowAuthor: CheckBox
    lateinit var someButton: Button

    fun onCreate() {
        //ignore view initialize

        vm.viewState.subscribe {
            render(it)
        }
    }

    private fun render(state: ViewState) {
        imgRealNameVerified.isVisible = state.realNameVerified
        cbHasFollowAuthor.isChecked = state.hasFollowAuthor
        someButton.isVisible = state.realNameVerified &amp;&amp; state.hasFollowAuthor

        //ignore other
    }
}
</code></pre>
<p>在JS中，JSON并不能附加逻辑，基本等价于Java中的POJO，故在数据源外部处理简单逻辑的情况较为常见。而在Java、Kotlin中可以进行适当的优化，适当封装，使得代码更加干净便于维护：</p>
<pre><code class="language-kotlin">data class ViewState(
    //ignore
) {
    fun isSomeFuncEnabled():Boolean = realNameVerified &amp;&amp; hasFollowAuthor
}

class View {
    //ignore
    
    private fun render(state: ViewState) {
        //...
        
        someButton.isVisible = state.isSomeFuncEnabled()
    }
}
</code></pre>
<h4 id="拆分实现"><a class="header" href="#拆分实现">拆分实现</a></h4>
<p>依旧先定义逻辑上完整的ViewState：</p>
<pre><code class="language-kotlin">class ComposedViewState(
    /*unique id of current login user*/
    val userId: Int,
) {

    /**
     * real-name-verified observable subject,feed true if the current login user has complete real-name verified
     * */
    val realNameVerified = BehaviorSubject.create&lt;Boolean&gt;()

    /**
     * follow-author observable subject, feed true if the current login user has followed the author
     * */
    val hasFollowAuthor = BehaviorSubject.create&lt;Boolean&gt;()

    val someFuncEnabled = BehaviorSubject.combineLatest(realNameVerified, hasFollowAuthor) { a, b -&gt; a &amp;&amp; b }
}
</code></pre>
<p>定义ViewModel，子模块数据流均已定义，故而无需再定义全ViewState的流</p>
<pre><code class="language-kotlin">class VM(val userId: Int) {
    val viewState = ComposedViewState(userId)
    //ignore
}
</code></pre>
<p>编写View层的UI绑定，同样简单起见，不使用数据绑定框架</p>
<pre><code class="language-kotlin">class View {

    private val vm = VM(1)
    lateinit var imgRealNameVerified: ImageView
    lateinit var cbHasFollowAuthor: CheckBox
    lateinit var someButton: Button

    fun onCreate() {
        //ignore view initialize
        bindViewStateWithUI()
    }

    private fun bindViewStateWithUI() {
        vm.viewState.realNameVerified.subscribe {
            renderSection1(it)
        }

        vm.viewState.hasFollowAuthor.subscribe {
            renderSection2(it)
        }

        vm.viewState.someFuncEnabled.subscribe {
            renderSection3(it)
        }
        //...
    }

    private fun renderSection1(foo:Boolean) {
        imgRealNameVerified.isVisible = foo
    }

    private fun renderSection2(foo:Boolean) {
        cbHasFollowAuthor.isChecked = foo
    }

    private fun renderSection3(foo:Boolean) {
        someButton.isVisible = foo
    }
}
</code></pre>
<p>例子较为简单，在实际项目中，如果遇到复杂页面，则可以分块进行处理。</p>
<p><em>注意：实际情况中，并没有必要将每一个子数据源拆分到一个View级别的控件，那样过于啰嗦，例子因非常简单而无法丰满起来。
e.g. 针对每一块视图区，例如作者区域，定义子ViewState类，创建其数据流即可。</em></p>
<blockquote>
<p>作者按：务必评估，在一次Model业务产生的Result中，会引起数据流下游的更新次数。
为避免产生不可预期的问题，可通过类似以下方式，使下游响应次数表现和经典实现的情况一致。</p>
</blockquote>
<p>额外定义PartialChange流或者功能等价的流，它用于标识 <code>reduce</code> 计算的开始和结束，可以将此期间的数据流的变化延迟到最后发送终态</p>
<p><em>更加推荐定义功能上等价的流</em></p>
<pre><code class="language-kotlin">class ComposedViewState(
    /*unique id of current login user*/
    val userId: Int,
) {

    internal val changes = BehaviorSubject.create&lt;PartialChange&gt;()
    
    //ignore

    val someFuncEnabled =
        BehaviorSubject.combineLatest(realNameVerified, hasFollowAuthor) { a, b -&gt; a &amp;&amp; b }.sync(PartialChange.Tag, changes)
}

inline fun &lt;reified T, S&gt; Observable&lt;T&gt;.sync(tag: S, sync: BehaviorSubject&lt;S&gt;): Observable&lt;T&gt; {
    return BehaviorSubject.combineLatest(this, sync) { source, syncItem -&gt;
        if (syncItem == tag) {
            syncItem
        } else {
            source
        }
    }.filter { it is T }.cast(T::class.java)
}
</code></pre>
<p>修改PartialChange，为reduce函数添加边界：</p>
<p><em>PartialChange是Model产生的Result的表现物，封装了ViewState的reduce函数逻辑，即如何从 Pre-ViewState 生成 新 ViewState</em></p>
<pre><code class="language-kotlin">sealed class PartialChange {
    open fun reduce(state: ComposedViewState) {

    }

    /**
     * 同步标记，从头开始到真实PartialChange之间，流的状态生效
     * */
    object Tag : PartialChange()

    object None : PartialChange()

    class Foo(val a: Boolean, val b: Boolean) : PartialChange() {
        override fun reduce(state: ComposedViewState) {
            state.changes.onNext(Tag)
            state.realNameVerified.onNext(a)
            state.hasFollowAuthor.onNext(b)
            state.changes.onNext(this)
        }
    }
}
</code></pre>
<h2 id="要想优雅需要工具"><a class="header" href="#要想优雅需要工具">要想优雅，需要工具</a></h2>
<h3 id="采用响应式流避免命令式编码"><a class="header" href="#采用响应式流避免命令式编码">采用响应式流，避免命令式编码</a></h3>
<p>想来这一点已不需要多做解释。</p>
<p>在Android中，存在 <code>LiveData</code> 组件，它通过简单的方式封装了可观测的数据，但实现方式简单也限制了它的功能 <strong>不够强大</strong> 。因此，建议使用 <code>RxJava</code> 或者 <code>Kotlin-Coroutine &amp; flow</code> 构建数据流。</p>
<p>本节便不再展开。</p>
<h3 id="采用数据绑定框架"><a class="header" href="#采用数据绑定框架">采用数据绑定框架</a></h3>
<p>采用 <code>jetpack-compose</code> 或者 <code>DataBinding</code> 均可以移除枯燥的UI命令式逻辑，在APP-A中我使用了DataBinding，在APP-B中我使用了Compose。</p>
<p>在 ViewState的代码很棒时，均可以获得优秀的编程体验，从啰嗦的UI中解放出来。</p>
<blockquote>
<p>作者的个人观点:</p>
<p>关于Compose。Compose依旧属于较新的事物，在商业项目中使用存在学习门槛和造轮工作。在目标用户具有较高容忍度的情况下，已然可以进行尝试。</p>
<p>关于DataBinding。一个近乎毁誉参半的工具，关于它的批判，大多集中于：<strong>xml中实现的逻辑难以阅读、维护</strong>，这实际上是对DataBinding设计的误解而带来的错误使用。</p>
<p>DataBinding本身具有生成VM层的功能，但这一功能并不足够强大，且没有完善的使用指导，而在官方Demo中过度宣传了它，导致大家认为DataBinding就该这样使用。</p>
<p>仅使用基础的数据绑定功能、和Resource或者Context有关的功能（例如字符串模板）、组件生命周期绑定等，适度自定义绑定。</p>
</blockquote>
<h2 id="何为状态何为事件最后的一公里"><a class="header" href="#何为状态何为事件最后的一公里">何为状态、何为事件。最后的一公里</a></h2>
<p>首先区别于上文提到的UI事件，这里的状态和事件均产生于数据流的末段，而UI事件处于数据流的首段。</p>
<blockquote>
<p>UI事件属于：A possible action that the user can perform that is monitored by an application or the operating system (event listener). When an event occurs an event handler is called which performs a specific task</p>
</blockquote>
<p>在展开之前，先用一张图回顾总结上文中对于 <code>单向数据流</code> &amp; <code>单一可信数据源</code> 的知识</p>
<p><img src="Review/post_44/MVI-UDF.png" alt="img_1.png" /></p>
<p>在 <strong>单向数据流动</strong> 章节中，提到了MVI的UDF设计：</p>
<ul>
<li>系统捕获的UI事件、其他侦听事件（例如熄屏、应用生命周期事件），生成Intent，压入Intent流中</li>
<li>ViewModel层中筛选、转换、处理Intent，实际是使用Model层业务，产生业务结果，即PartialChange</li>
<li>PartialChange经过Reducer计算处理得到最新的ViewState，压入ViewState流</li>
<li>View层（广义的表现层）响应并呈现最新的ViewState</li>
</ul>
<p>在 <strong>单一可信数据源</strong> 章节中，提到View层应当采用 <code>单一可信数据源</code></p>
<p>在这张图中，我们仅体现了 <code>状态</code> 即 ViewState。</p>
<h3 id="关于gui程序的认知"><a class="header" href="#关于gui程序的认知">关于GUI程序的认知</a></h3>
<p>在展开前，先聊点理念上的内容。请读者诸君思考下自己对于GUI程序的认知。</p>
<blockquote>
<p>作者的理解：</p>
<p>程序狭义上是计算机能识别和执行的一组指令集，编程工作是在程序世界对 <code>客观实体</code> 、 <code>业务逻辑</code> 进行 建模和逻辑表达。</p>
<p>而GUI程序拥有 <code>用户图形界面</code> , 除了结合硬件接收用户交互输入外，可以将 <code>程序世界中的模型</code> 以 <code>用户图形界面</code> 等方式表现给用户。</p>
<p>表现出来的内容代表着客观实体</p>
<p>其本质目的在于：通过 <strong>描述特征属性</strong> 、 <strong>描述变化过程</strong> 等方式让用户感知并理解 <code>客观实体</code></p>
</blockquote>
<p>而除了通过 <strong>程序语言描述</strong> 、 <strong>程序世界模拟展现</strong> 外，同样可以通过 <strong>自然语言描述</strong> 达到目的，这也是产品经理的工作。</p>
<p><em>当然，产品经理往往需要借助一些工具来提升自己的自然语言表达能力，但无奈的是能用数学公式和逻辑推演表达需求的产品经理太少见了。</em></p>
<p>写这段只是为了引入 <code>他山之石</code> 。</p>
<h3 id="first-order-logic"><a class="header" href="#first-order-logic">First-Order logic</a></h3>
<p>在数学、哲学、语言学、计算机科学中，有一个概念 <code>First-Order logic</code>，无论是产品需求还是计算机程序，<strong>都可以建立FOL表达</strong>。</p>
<p><em>当然，本篇不讨论FOL，那是一个很庞大且偏离主题的事情。我仅仅是想借用其中的概念。</em></p>
<p>FOL表达 Event或者State时：</p>
<ul>
<li>Event 体现的是特定的变化</li>
<li>State 体现的是客观实体在任意时刻都适用的一组情况，即一段时间内无变化的条件或者特征</li>
</ul>
<p>不难理解，变化是瞬时的，连续的变化是可分的。</p>
<p>但在人机交互中，瞬时意义很小，我们的目的在于让用户感知。</p>
<p>例如："好友向你发送了一条消息的场景中"，消息抵达就是Event，它背后潜藏着 "消息数的变化"、"最新消息内容的变化" 等。 在常见的设计中:</p>
<ul>
<li>应用需要弹出一个气泡通知用户这一事件</li>
<li>应用需要更新消息数，消息列表内容等，以呈现出最新的State</li>
</ul>
<p>而为了让用户感知到，气泡呈现时长并不是瞬时的，但在产品交互设计中依旧将其定义为事件。</p>
<h3 id="分离状态和事件不是吃饱撑得"><a class="header" href="#分离状态和事件不是吃饱撑得">分离状态和事件，不是吃饱撑得</a></h3>
<blockquote>
<p>看山是山、看水是水</p>
</blockquote>
<p>此时此刻，答案已经很明显。</p>
<p>在通用的产品设计中，状态和事件有不同的意义，如果程序中不分离出两者，则必然是自找麻烦，这是公然挑衅 <code>面向对象编程</code> 的行为。如果不明确定义不同的Class，则势必导致代码混乱不堪，毕竟这是违背编程原则的事情。</p>
<p>在大多MVVM设计中，状态和事件未分家，导致bug丛生，这一点便不再展开。</p>
<h3 id="如何区分event和state"><a class="header" href="#如何区分event和state">如何区分Event和State</a></h3>
<p>State是一段时间内无变化的条件或者特征，它天然的 <strong>契合</strong> 了位于表现层的主体内容所对应的 <strong>数据模型特征</strong>。</p>
<p>Event是特定的变化，它在表现层体现，但与State的生命周期不一致，且并无一一对应的关系。</p>
<p>基于经验主义，我们可以机械地、笼统地认为：页面主体静态内容所需要的数据属于State范畴，气泡提醒等短暂的物体所需要的数据属于Event范畴。</p>
<p>从逻辑推演的角度出发，进行 <strong>等价逻辑推断</strong> 和 <strong>条件限定下的逻辑推断</strong> ，一定序列的Event可以模型转换为State。</p>
<h3 id="事件粘性导致重复只是框架设计的bug"><a class="header" href="#事件粘性导致重复只是框架设计的bug">事件粘性导致重复？只是框架设计的bug</a></h3>
<blockquote>
<p>看山不是山，看水不是水</p>
</blockquote>
<p>前面提到，State是一段时间内无变化的条件或者特征，所以在程序设计中State具有粘性的特征。</p>
<p>如果Event也设计出这样的粘性特征并造成重复消费，明显是违背需求的，无疑是框架设计的Bug。此问题在各大论坛中很常见。</p>
<p><em>注意，我们无法脱离实际需求去二元化的讨论事件本身该不该有粘性特征，只能结合实际讨论框架功能是否存在bug</em></p>
<p>如果要实现以力破法，在框架设计层面上 <strong>Event体系的设计要比State体系要复杂</strong> 。因为从交互设计上：</p>
<ul>
<li>State 只需要考虑呈现的准确性和及时性，<em>除去美观、可理解性等等</em></li>
<li>Event 需要考虑准确性、优先级、及时性、按条件丢弃等等，<em>除去美观、可理解性等等</em></li>
</ul>
<p>举个例子：网络连接问题导致的Web-API调用失败需要使用Toast提示网络连接失败</p>
<p>不难想象：</p>
<ul>
<li>可能一瞬间的断开网络连接，会导致多个连接均返回失败</li>
<li>可能连接问题未修复，10秒前请求失败，当前请求又失败了</li>
</ul>
<p>难道连续弹出吗？难道和上一次Event一致就不消费吗？...</p>
<p>或许您会使用一些 <code>剑走偏锋的技巧</code> 来解决问题，但技巧总是建立在特定条件下生效的，一旦条件发生变化，就会带来烦恼，您很难控制上游的PM和交互设计师。</p>
<p>所以在框架层面需要针对产品、交互设计的泛化理念，设计准确的、灵活的Event体系。</p>
<h3 id="准确的灵活的event体系"><a class="header" href="#准确的灵活的event体系">准确的、灵活的Event体系</a></h3>
<blockquote>
<p>看山还是山，看水还是水</p>
</blockquote>
<p>回到FOL中，为了更加准确的表达Event和State的含义，还需要一些额外的参数，例如：<code>参与者</code>、<code>地点</code>、<code>时间</code> 等。</p>
<p>想通这一点会发现，产品中定义的Event事件、及其消费逻辑均含有隐藏属性，例如：</p>
<ul>
<li>发生时间</li>
<li>客观有效期</li>
<li>判断有效的条件（如呈现的条件）</li>
<li>判断失效的条件 ，用于实现提前失效</li>
</ul>
<p><em>产品经理和交互设计师一般会使用 "响应时间"、"优先级" 等词描述它们，但一般不严谨、不成体系，带来期望不一致的问题</em></p>
<p>反观State流，它代表了界面主体内容在时间轴上的完整变化，任意一个时间点均可以得出界面内容所对应的条件和特征。一旦State流中出现一个新的状态，它均被及时的、准确的在表现层予以体现。</p>
<p>不难理解，一个State的生命周期为 <code>从init或者reducer计算生成开始</code> 至 <code>reducer计算出新State、宿主生命期结束为止</code>，在State流中已然暗含：</p>
<ul>
<li>State之间无生命周期重叠</li>
<li>所有State的生命周期相加可填满时间轴</li>
</ul>
<blockquote>
<p>前文提到Event是瞬时的，所以Event本身并没有实质意义上的生命周期，为了方便表述，我们将 "Event从生成到在表现层不可观测的阶段" 定义为Event生命周期</p>
</blockquote>
<p>而Event流 <strong>不同于</strong> State流 ，因为Event的生命周期情况更加复杂：</p>
<ul>
<li>Event可能存在生命周期重叠</li>
<li>所有Event的生命周期相加可能无法覆盖完整的时间轴</li>
</ul>
<p><strong>需要额外设计实现</strong> 。实现这一点后，从Event流中分流（以及裂变+组合）出的 <strong>子流</strong> 将和State流 <strong>性质一致</strong>。</p>
<p>此刻，您会发现，根据不同类型的事件交互控件所对应的交互特征，又将Event流结合条件流衍生出各个State流。完整的数据流细节如下：</p>
<p><img src="Review/./post_44/mvi-udf2.png" alt="" /></p>
<p><em>作者按：在图中省略了Event分流转变为子State流的过程，因为它需要遵循特定产品交互机制</em></p>
<h2 id="结语-11"><a class="header" href="#结语-11">结语</a></h2>
<p>这篇文章，从5月计划写，到6月动笔，断断续续，草稿写了很长，几经删改依旧留有很长的篇幅，虽已竭力尽智，但任觉文字上有表意未通透之处，欢迎在评论区讨论。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="review--这三个坑你遇到了吗"><a class="header" href="#review--这三个坑你遇到了吗">Review | 这三个坑你遇到了吗？</a></h1>
<h2 id="前言-27"><a class="header" href="#前言-27">前言</a></h2>
<p>6-7月的事情着实有点多。没有清风亦没有鲜花，连蝉都热到燥不动了，人自然也变得慵懒了许多。</p>
<p>月头计划和诸君探讨下Compose（Compose-Desktop）和MVI实际投产后的感受，眼看即将到月底，低头看着才写一半的草稿，沉默良久，大抵这个月是没有希望成稿了。</p>
<p>终究，只能挑一些最近遇到的问题写一写，欺骗自己还未曾摆烂。</p>
<h2 id="android-rs中的外部文件管理权限"><a class="header" href="#android-rs中的外部文件管理权限">Android R、S中的外部文件管理权限</a></h2>
<blockquote>
<p>想来是舒适太久了，目前负责的核心项目均是面向特定Android-Pad开发的，在 <code>Android 9</code> 已经躺了一年，已经快忘记了 <code>适配</code> 这一祖传包袱。</p>
<p>但还有部分即将推出的项目是面向普通用户的，顺便谈一谈这个 <code>老问题</code></p>
</blockquote>
<p>在 <code>Android 10</code> 中提出了分区存储，对于外部存储空间的读写，除了需要处理FileProvider外，还需要配置 <code>requestLegacyExternalStorage</code> 。</p>
<p>在 <code>Android R、S</code> 中，进行了更严格的限制，需要获取完整的外部存储控制权限。</p>
<p><em>作者按：笔者负责的项目受技术之外因素的影响，改变现有的文件存储路径的阻力非常大</em></p>
<h3 id="判断与申请完全的控制权限"><a class="header" href="#判断与申请完全的控制权限">判断与申请完全的控制权限</a></h3>
<p>补充声明权限</p>
<pre><code class="language-xml">
&lt;uses-permission android:name="android.permission.MANAGE_EXTERNAL_STORAGE"/&gt;
</code></pre>
<p>那么，相关权限如下：</p>
<pre><code class="language-xml">
&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt;
&lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/&gt;
&lt;uses-permission android:name="android.permission.MANAGE_EXTERNAL_STORAGE"/&gt;
</code></pre>
<p>并且需要运行时动态获取权限，关键代码如下：</p>
<pre><code class="language-kotlin">if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.R) {
    if (!Environment.isExternalStorageManager()) {
        //略去引导弹窗等相关交互逻辑
        startActivityForResult(Intent(Settings.ACTION_MANAGE_ALL_FILES_ACCESS_PERMISSION), REQ_CODE_FILE_MANAGE)
        return
    }
}
// do something
</code></pre>
<p>可以结合 <code>ActivityResultContracts</code> 改造 onActivityResult，不再赘述。</p>
<p>用户对软件授予权限后可读写文件。</p>
<h3 id="如何快速改造"><a class="header" href="#如何快速改造">如何快速改造</a></h3>
<blockquote>
<p>随着Compose跨平台技术越来越热，将应用的业务在多个平台上复用也越发有价值，而平台的差异性内容应当在平台内部解决。</p>
</blockquote>
<p>那么 <code>如何在不修改Presenter/ViewModel 和 Model层的前提下，便捷的解决此类适配问题</code> 越发具有价值。</p>
<p>当然，此类问题的解决不能脱离实际空谈，便不做具体展开。目前在项目中先运用了 <code>Proxy</code> 方式，对业务层追加了前置逻辑，进行了简单处理。</p>
<p>我已经设想了一个框架，<em>并非PermissionX之类处理Android动态权限的框架</em>，有后续实质进展后再与诸君分享。</p>
<h2 id="蓝牙居然搜索不到设备"><a class="header" href="#蓝牙居然搜索不到设备">蓝牙居然搜索不到设备</a></h2>
<blockquote>
<p>如果直接适配Android 12，大概率不会出现该问题（未经过大量rom验证），target是低版本，以往的业务代码不到位就有可能受到影响</p>
</blockquote>
<p>未适配Android 12 蓝牙权限的应用，在部分手机上发现未打开 <strong>"访问我的位置信息"</strong> 时（不是定位权限！！），会导致搜索不到蓝牙设备。大抵是ROM厂商的杰作。</p>
<p>参考地图类SDK的操作，增加以下检测代码：</p>
<pre><code class="language-java">LocationManager locationManager = (LocationManager) context.getSystemService(Context.LOCATION_SERVICE);
if (!locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER)) {
    //引导用户开启定位：Intent(Settings.ACTION_LOCATION_SOURCE_SETTINGS)
}
</code></pre>
<p>在 target Android12 中：</p>
<ul>
<li>请求精确位置，需同时申请 ACCESS_FINE_LOCATION 和 ACCESS_COARSE_LOCATION 权限</li>
<li>（动态）申请蓝牙相关权限时，不再需要申请设备位置信息相关权限</li>
</ul>
<p>理论上不需要再加这一检测，但仍需经过大量ROM测试。建议保留该段检测逻辑。</p>
<h2 id="一个高star库中的io和多线程的综合性问题"><a class="header" href="#一个高star库中的io和多线程的综合性问题">一个高star库中的I/O和多线程的综合性问题</a></h2>
<p>前几日和好友闲聊时，好友提到他们的项目中使用了一个开源的下载库 <code>Aria</code>，但时不时会出现下载图片失败的问题，实质是库的bug。</p>
<p>阅读源码后感到问题出在细节知识上，本篇也需要水一下字数，索性拿来讨论一二。</p>
<p>库中运用到的技术:</p>
<ul>
<li>多线程&amp;锁</li>
<li>IO</li>
<li>Android的Handler</li>
</ul>
<p>其中，多线程和锁的知识本篇不谈，我亦写有相关系列；库作者使用Android中的Handler简化多线程间的通信，也不再展开；IO部分系统展开也很长，我已有系列文章计划，本篇结合问题简单谈一谈。</p>
<p>和文件服务器对比，移动端的文件上传下载并发量很小，其速度制约一般在于：<code>服务器单连接流量限制</code>，<code>网络条件</code>。</p>
<p>对于单个文件采用多线程方式上传、下载，只能突破 <code>单连接流量限制</code>，以充分使用网络资源。<strong>多个文件并行上下载的产品意义远大于充分吃掉网络带宽资源</strong>。</p>
<p><em>注意：上下载的高带宽占用一定程度上会影响其他网络层业务</em></p>
<p>一般对于下载而言，使用多线程时用常规的 "碎文件合并" 的思路即可。用 <code>RandomAccessFile</code>并不是一个好主意。</p>
<p><em>多线程写RandomAccessFile并非一件很美好的事情，以后的文章中细聊</em></p>
<p>在使用Java经典IO时，使用Buffer减少IO次数可以获得很好的性能提升，需要注意及时 <code>flush</code>，该库中用Buffer设计对 <code>RandomAccessFile</code> 进行了一层封装。<em>想来也是源自三方库.</em></p>
<p>将部分代码简化后类似如下代码：</p>
<pre><code class="language-kotlin">class Demo {
    @Test
    fun mockDownload() {
        Looper.prepare()

        val appContext = InstrumentationRegistry.getInstrumentation().targetContext

        val file = File(appContext.cacheDir, "testtmp")
        if (file.exists()) {
            file.delete()
        }

        file.createNewFile()

        assertEquals(0, file.length())
        val data = "hello".encodeToByteArray()
        val bFile = BufferedRandomAccessFile(file, "rwd", 1024)


        val handler = object : Handler(Looper.myLooper()) {
            override fun handleMessage(msg: Message?) {
                super.handleMessage(msg)
                //模拟文件合并线程，仅断言文件大小
                if (msg?.what == 1) {
                    assertEquals(data.size.toLong(), file.length())
                    Looper.myLooper()?.quit()
                }
            }
        }

        //模拟下载线程
        thread(priority = 1) {
            val ins = ByteArrayInputStream(data)
            try {

                val buffer = ByteArray(1024)
                var len: Int
                while (ins.read(buffer).also { len = it } != -1) {
                    bFile.write(buffer, 0, len)
                }

                //模拟下载完成消息
                handler.sendEmptyMessage(1)
//                Thread.yield() -- 模拟一下线程被切换或者因为锁导致的同步
            } finally {
                ins.close()
//                bFile.flush() will be invoked in close
                bFile.close()
            }
        }

        Looper.loop()
    }
}
</code></pre>
<p>观察这段代码可以发现，存在不安全因素：最后一个buffer块的内容大小未必是1024，需等到 <code>bFile.close()</code>时方可写入文件。</p>
<p>虽然 <code> handler.sendEmptyMessage(1)</code> 发送的消息会被异步执行，但并不意味着 <code>bFile.close()</code> 一定会先执行。锁、AQS、系统线程调度等均可能会导致该问题。</p>
<h2 id="后记-2"><a class="header" href="#后记-2">后记</a></h2>
<p>很无耻的水了一篇文章。惭愧惭愧。实在不想在迈过30的第一天就突破 <code>每月发一章博客</code> 的底线，见谅见谅。</p>
<p>最近除了在编写几篇有技术深度的博客外，还筹划写点 <code>技术之外</code> 和诸君一同探讨 <strong>如何在工作中成功</strong> ，有进展了再向诸位汇报。</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="repo"><a class="header" href="#repo">repo</a></h3>
<p>个人开源项目，以及有趣的方案分享</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="davinci-达芬奇"><a class="header" href="#davinci-达芬奇">DaVinCi （达·芬奇）</a></h1>
<h2 id="是什么"><a class="header" href="#是什么">是什么</a></h2>
<p>在Android上取代xml方式定义 Shape/GradientDrawable 以及 ColorStateList的方案。</p>
<ul>
<li>支持在 <code>Java/Kotlin 业务代码</code> 中使用</li>
<li>配合 <code>DataBinding</code> 可以在 <code>XML布局文件</code> 中使用</li>
</ul>
<p><a href="https://github.com/leobert-lan/DaVinCi">项目地址</a></p>
<p>几篇相关拙作：</p>
<ul>
<li>实现原理解析，详见拙作：<a href="repo/../Android/Drawable/post_4.html">好玩系列：拥有它，XML文件少一半--更方便的处理View背景</a></li>
<li>关于注解处理器（ksp实现）以及实现的核心目标，详见拙作： <a href="repo/../Android/KSP/post_24.html">好玩系列 | 拥抱Kotlin Symbol Processing(KSP),项目实战</a></li>
</ul>
<h2 id="为何会产生这一想法"><a class="header" href="#为何会产生这一想法">为何会产生这一想法</a></h2>
<p>出于多方面原因，使用XML定义 <code>shape资源</code>， <code>gradient drawable 资源</code> ， <code>color state list 资源</code> 太麻烦了。诸如：</p>
<ul>
<li>xml本身很啰嗦</li>
<li>命名是一件很麻烦的事情（数量达到一定规模后管理也很麻烦）</li>
<li>很多样式 <code>复用度并不高</code></li>
<li>UI在高强度模式下也难以做到 <code>对每个样式都规范化管理</code></li>
<li>切换一个文件打断思路的成本太高 等等</li>
</ul>
<p>所以我产生了这一想法：</p>
<ul>
<li>建立Builder机制构建这些资源 （<em>构建变得简单且灵活</em>）</li>
<li>基于纯文本化的DSL，描述这些资源，并利用Builder进行构建（<em>方便向皮肤包过渡，或者任何基于配置的形式运行</em>）</li>
<li>建立OO封装，让构建更加简单</li>
</ul>
<h2 id="实现原理解析"><a class="header" href="#实现原理解析">实现原理解析</a></h2>
<p>详见拙作：<a href="repo/../Android/Drawable/post_4.html">好玩系列：拥有它，XML文件少一半--更方便的处理View背景</a></p>
<h2 id="如何使用-5"><a class="header" href="#如何使用-5">如何使用</a></h2>
<h3 id="添加mavencentral仓库声明"><a class="header" href="#添加mavencentral仓库声明">添加MavenCentral仓库声明</a></h3>
<pre><code>//{project root}/build.gradle
subprojects {
    repositories {
        mavenCentral()
        //...
    }
}
</code></pre>
<h3 id="声明依赖"><a class="header" href="#声明依赖">声明依赖</a></h3>
<p>以下是包依赖信息</p>
<pre><code class="language-kotlin">/*
* 注解，用于Style类注解或者StyleFactory类注解，以及预览时的可选配置注解
* */
const val annotation = "io.github.leobert-lan:davinci-anno:0.0.2"

/*
* 注解处理器，支持ksp或者kapt或者annotationProcessor
* */
const val ksp = "io.github.leobert-lan:davinci-anno-ksp:0.0.2"

/*
* 核心包
* */
const val api = "io.github.leobert-lan:davinci:0.0.5"

/*
* 如果要预览style定义，利用debugImplementation 声明
* */
const val viewer = "io.github.leobert-lan:davinci-style-viewer:0.0.1"
</code></pre>
<p>关于注解处理器（ksp实现）以及实现的核心目标，详见拙作： <a href="repo/../Android/KSP/post_24.html">好玩系列 | 拥抱Kotlin Symbol Processing(KSP),项目实战</a></p>
<p>使用注解处理器简化Style注册时，需要配置参数：</p>
<pre><code class="language-groovy">kapt {
    arguments {
        arg("daVinCi.verbose", "true") //日志
        arg("daVinCi.pkg", "com.example.simpletest") //生成类包名
        arg("daVinCi.module", "App") //生成类的前缀
        arg("daVinCi.preview", "true") //生成预览配置的注入代码
    }
}
</code></pre>
<p>下面会展开这几个部分：</p>
<ul>
<li>构建一个Shape 和诸多API</li>
<li>构建一个ColorStateList 和诸多API</li>
<li>在XML中使用DaVinCi</li>
<li>定义Style，及其初始化方式以及使用方式</li>
<li>预览Style</li>
</ul>
<h3 id="构建一个shape"><a class="header" href="#构建一个shape">构建一个Shape</a></h3>
<pre><code class="language-kotlin">DaVinCiExpression.shape(): Shape
</code></pre>
<h4 id="指定shape的类型"><a class="header" href="#指定shape的类型">指定Shape的类型，</a></h4>
<p>一般常用的是rectAngle 和 oval</p>
<pre><code class="language-kotlin">fun rectAngle(): Shape
fun oval(): Shape
fun ring(): Shape
fun line(): Shape
</code></pre>
<h4 id="rectangle时的圆角"><a class="header" href="#rectangle时的圆角">rectAngle时的圆角：</a></h4>
<pre><code class="language-kotlin">fun corner(@Px r: Int): Shape
fun corner(str: String): Shape
fun corners(@Px lt: Int, @Px rt: Int, @Px rb: Int, @Px lb: Int): Shape
</code></pre>
<p>尺寸均可以 "xdp" 表达dp值，如"3dp"即为 3个dp，"3"则为3个px。</p>
<h4 id="填充色"><a class="header" href="#填充色">填充色：</a></h4>
<pre><code class="language-kotlin">fun solid(str: String): Shape //色值 "#ffffffff" 或者 "rc/颜色资源名"
fun solid(@ColorInt color: Int): Shape
</code></pre>
<h4 id="描边"><a class="header" href="#描边">描边：</a></h4>
<pre><code class="language-kotlin">fun stroke(width: String, color: String): Shape
fun stroke(width: String, color: String, dashGap: String, dashWidth: String): Shape
fun stroke(@Px width: Int, @ColorInt colorInt: Int): Shape 
</code></pre>
<h4 id="渐变"><a class="header" href="#渐变">渐变：</a></h4>
<pre><code class="language-kotlin">fun gradient(
    type: String = Gradient.TYPE_LINEAR,
    @ColorInt startColor: Int,
    @ColorInt endColor: Int,
    angle: Int = 0
): Shape

fun gradient(
    type: String = Gradient.TYPE_LINEAR, @ColorInt startColor: Int,
    @ColorInt centerColor: Int?, @ColorInt endColor: Int,
    centerX: Float,
    centerY: Float,
    angle: Int = 0
): Shape

fun gradient(startColor: String, endColor: String, angle: Int): Shape

fun gradient(type: String = Gradient.TYPE_LINEAR, startColor: String, endColor: String, angle: Int = 0): Shape

fun gradient(
    type: String = Gradient.TYPE_LINEAR,
    startColor: String,
    centerColor: String?,
    endColor: String,
    centerX: Float,
    centerY: Float,
    angle: Int
): Shape

</code></pre>
<h4 id="设置view的背景"><a class="header" href="#设置view的背景">设置View的背景</a></h4>
<pre><code class="language-kotlin">@BindingAdapter(
    "daVinCi_bg", "daVinCi_bg_pressed", "daVinCi_bg_unpressed",
    "daVinCi_bg_checkable", "daVinCi_bg_uncheckable", "daVinCi_bg_checked", "daVinCi_bg_unchecked",
    requireAll = false
)
fun View.daVinCi(
    normal: DaVinCiExpression? = null,
    pressed: DaVinCiExpression? = null, unpressed: DaVinCiExpression? = null,
    checkable: DaVinCiExpression? = null, uncheckable: DaVinCiExpression? = null,
    checked: DaVinCiExpression? = null, unchecked: DaVinCiExpression? = null
)
</code></pre>
<h3 id="构建一个colorstatelist"><a class="header" href="#构建一个colorstatelist">构建一个ColorStateList</a></h3>
<pre><code class="language-kotlin">DaVinCiExpression.stateColor(): ColorStateList
</code></pre>
<h4 id="设置状态色"><a class="header" href="#设置状态色">设置状态色</a></h4>
<pre><code class="language-kotlin">class ColorStateList {
    fun apply(state: State, color: String): ColorStateList
    fun apply(state: String, color: String): ColorStateList
    fun apply(state: State, @ColorInt color: Int): ColorStateList
}
</code></pre>
<p>示例：</p>
<pre><code class="language-kotlin">DaVinCiExpression.stateColor().apply(
    state = State.STATE_PRESSED_TRUE, color = Color.parseColor("#00aa00")
).apply(
    state = State.STATE_PRESSED_FALSE, color = Color.parseColor("#667700")
).apply(
    state = State.STATE_CHECKED_TRUE.name, color = "#ff0000"
).apply(
    state = State.STATE_CHECKED_FALSE, color = "#000000"
)
    .let {
        binding.cb1.daVinCiColor(it)
    }
</code></pre>
<h4 id="应用颜色"><a class="header" href="#应用颜色">应用颜色：</a></h4>
<pre><code class="language-kotlin">@BindingAdapter("daVinCiTextColor")
fun TextView.daVinCiColor(expressions: DaVinCiExpression.ColorStateList)
</code></pre>
<h3 id="在xml中使用"><a class="header" href="#在xml中使用">在XML中使用</a></h3>
<pre><code class="language-xml">
&lt;layout&gt;
    &lt;data&gt;
        &lt;import type="osp.leobert.android.davinci.DaVinCiExpression"/&gt;
    &lt;/data&gt;

    &lt;LinearLayout
        daVinCi_bg="@{DaVinCiExpression.shape().solid(`#eaeaea`)}"
    /&gt;
&lt;/layout&gt;
</code></pre>
<p>更多 <a href="https://github.com/leobert-lan/DaVinCi">参考Demo</a></p>
<h3 id="定义style"><a class="header" href="#定义style">定义Style</a></h3>
<p>当部分样式复用度较高时，我们可以定义Style，以减少创建过程</p>
<pre><code class="language-kotlin">@DaVinCiStyle(styleName = "btn_style.main")
@StyleViewer(
    height = 40, width = ViewGroup.LayoutParams.MATCH_PARENT,
    type = StyleViewer.FLAG_CSL or StyleViewer.FLAG_BG, background = "#ffffff"
)
class DemoStyle : StyleRegistry.Style("btn_style.main") {
    init {
        this.register(
            state = State.STATE_ENABLE_FALSE,
            expression = DaVinCiExpression.shape().rectAngle().solid("#80ff3c08").corner("10dp")
        ).register(
            state = State.STATE_ENABLE_TRUE,
            expression = DaVinCiExpression.shape().rectAngle().corner("10dp")
                .gradient("#ff3c08", "#ff653c", 0)
        ).registerCsl(
            exp = DaVinCiExpression.stateColor().apply(
                state = State.STATE_ENABLE_FALSE,
                color = "#ffffff"
            ).apply(
                state = State.STATE_ENABLE_TRUE,
                color = "#333333"
            )
        )
    }
}
</code></pre>
<p>或者利用Factory延迟创建过程</p>
<pre><code class="language-kotlin">@DaVinCiStyleFactory(styleName = "btn_style.main")
class DemoStyleFactory : StyleRegistry.Style.Factory() {
    override val styleName: String = "btn_style.main"

    override fun apply(style: StyleRegistry.Style) {
        style.register(
            state = State.STATE_ENABLE_FALSE,
            expression = DaVinCiExpression.shape().rectAngle().solid("#80ff3c08").corner("10dp")
        ).register(
            state = State.STATE_ENABLE_TRUE,
            expression = DaVinCiExpression.shape().rectAngle().corner("10dp")
                .gradient("#ff3c08", "#ff653c", 0)
        )
    }
}
</code></pre>
<h4 id="进行初始化"><a class="header" href="#进行初始化">进行初始化</a></h4>
<pre><code class="language-kotlin">class MainApplication : Application() {

    override fun onCreate() {
        super.onCreate()
        AppDaVinCiStyles.register()

        //不对预览进行额外配置可忽略
        AppDaVinCiStylePreviewInjector.register()

        //如果不使用注解，则需要手动罗列注入，数量多了后，非常啰嗦 ：
        //StyleRegistry.registerFactory(DemoStyleFactory())
    }
}
</code></pre>
<h4 id="使用style"><a class="header" href="#使用style">使用Style</a></h4>
<pre><code class="language-kotlin">@BindingAdapter("daVinCiBgStyle")
fun View.daVinCiBgStyle(styleName: String) {
    with(StyleRegistry.find(styleName)) {

        this?.applyTo(
            DaVinCi(null, this@daVinCiBgStyle)
        )
            ?: Log.d(DaVinCiExpression.sLogTag, "could not found style with name $styleName")
    }
}
</code></pre>
<pre><code class="language-xml">&lt;TextView
    daVinCiBgStyle="@{`btn_style.main`}"/&gt;
</code></pre>
<p>如果将style定义下沉到Module，则可以使用生成的名称常量</p>
<p><em>目前0.0.5版本扩展了较多功能编码仓促，部分API名称不恰当，会逐步新增，使得API名称和功能更加贴切</em></p>
<h3 id="预览style"><a class="header" href="#预览style">预览Style</a></h3>
<p>如果在AS中扩展预览功能，那么需要付出太多的工作量。于是采用了取巧的方式</p>
<p>一旦添加了 <code>"io.github.leobert-lan:davinci-style-viewer:0.0.1"</code> 库，则会包含一个Activity，展示所有已注册的样式。</p>
<p>例如：</p>
<p><img src="repo/./DaVinCi/img.png" alt="Demo" /></p>
<p>很显然，条目第一行是样式名，第二行是预览区，第三行是Check和Enable的设置，更多设置将会逐步开放。</p>
<p>利用注解可以进行一定的配置：</p>
<pre><code class="language-kotlin">public annotation class StyleViewer(
    val height: Int = 48,
    val width: Int = -1 /*android.view.ViewGroup.LayoutParams.MATCH_PARENT = -1*/,
    val background: String = "#ffffff",
    val type: Int = FLAG_BG or FLAG_CSL,
) {
    public companion object {
        public const val FLAG_BG: Int = 1 shl 0
        public const val FLAG_CSL: Int = 1 shl 1
    }
}
</code></pre>
<ul>
<li>设置宽高，单位dp，</li>
<li>预览区背景为白色，如果和样式比较贴近，可以设置背景区颜色</li>
<li>如果是明确的背景样式，且尺寸较小时，可以设置type为 FLAG_BG，移除文字显示</li>
</ul>
<h2 id="以后的工作"><a class="header" href="#以后的工作">以后的工作</a></h2>
<ul>
<li>继续添加更加方便的API</li>
<li>扩展DSL</li>
<li>优化在Java/Kotlin 代码中使用DaVinCi的简便性</li>
<li>内部功能进一步解耦 <em>如果有必要</em> ， <em>可迁移到其他</em></li>
<li>优化预览
<ul>
<li>更多模态状态设置</li>
<li>搜索 <em>如果有必要</em></li>
<li>分组 <em>如果有必要</em></li>
</ul>
</li>
</ul>
<p>如果你觉得DaVinCi很有趣，不妨点个Star，欢迎一起交流想法。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="好玩系列白嫖一个优雅的类图生成工具"><a class="header" href="#好玩系列白嫖一个优雅的类图生成工具">好玩系列：白嫖一个优雅的类图生成工具</a></h1>
<h2 id="前言-28"><a class="header" href="#前言-28">前言</a></h2>
<p>首先必须声明，<strong>这不是一篇广告或者标题党</strong>。 而是我开源了一个工具，可以优雅的为Java or Kotlin 项目生成 <code>Class Diagram</code>。</p>
<p>我推测列为读者会进来阅读，原因无非以下两点：</p>
<ul>
<li>获得一个生成类图的工具，并通过文章快速了解是否 <code>方便</code> 且 <code>好用</code></li>
<li>了解一下我是如何折腾的</li>
</ul>
<p>仅关心如何使用的，可以移步 <a href="Android/Idea/post_32.html#demo">使用示例</a></p>
<p>我们将按照下面的脑图顺时针展开，揭开这一工具的诞生过程</p>
<p><img src="Android/Idea/./post_32/class-diagram-guide.png" alt="" /></p>
<h2 id="主要问题与方案"><a class="header" href="#主要问题与方案">主要问题与方案</a></h2>
<h3 id="背景-2"><a class="header" href="#背景-2">背景</a></h3>
<blockquote>
<p>背景：笔者今年换了份工作，所在的公司属于 <code>医疗器械</code> 下的细分领域，而相比于 <code>纯互联网行业</code> 领域，<code>医疗器械</code> 领域所属的配套软件，
都有明确的文档要求，并非 <code>可有可无</code> ，而且公司管理层比较重视细节（<em>核心产品为颅内、体内植入的医疗器械，确实需要非常认真仔细</em>）。</p>
</blockquote>
<p>毋庸置疑，<code>准确的</code> 、<code>关键的</code> 算法流程图，时序图，组件图，状态图，类图等， 对于产品本身的维护及发展具有很大帮助！</p>
<p>对于研发工作者而言，高度概括流程、设计、算法等的专业工具图对工作有极大帮助。既然需要审核的文档中也需要这些内容，又对工作有帮助，<strong>何不做的好一些呢</strong>。</p>
<p>上文提到的各类UML图中， <code>类图 Class-Diagram</code> 是非常特殊的, 它表述的是 <code>类之间的关系</code> ，<strong>基于源码文件分析可以得出准确的结果</strong>。
而 <code>流程图</code> 、<code>时序图</code> 、<code>状态图</code> 、 <code>组件图</code> 等则不行。</p>
<h3 id="问题"><a class="header" href="#问题">问题</a></h3>
<p>随着行业的发展，软件开发也演变为 <code>以迭代的方式，依次实现最重要的功能，持续性交付</code>，顺其自然的，我们已经不再像几十年前的前辈们那样：代码未动，文档与UML图先行。
一般概要设计后，方案可行便进行编码了。</p>
<p><em>根据我的实际情况，复杂的功能一般在草稿纸上画画草图，简单的就脑子里想想，难以留下存档</em></p>
<p>在这一工作模式下，笔者也遇到了一些问题：</p>
<ul>
<li>业务迭代后或者代码改进后，文档（uml图）未及时更新</li>
<li>手动维护耗时耗力</li>
</ul>
<p>如果这件事情可以交给机器来做，那显然是极好的！而让机器维护类图是最容易实现的！</p>
<p>综上所述：我们需要一款工具或者插件，可以直接基于源码生成类图 <em>（或者中间产物，例如：plant-uml文件）</em> ，能够配合其他工具链，直接进行归档。</p>
<p><em>当然，最重要是免费， 这省去了说服公司进行购买</em></p>
<blockquote>
<p>留有类图的好处：</p>
<ul>
<li>方便向他人介绍业务和代码</li>
<li>项目庞大或者复杂时，更容易找到需求对应的关注点，重新维护时日久远的业务时，状态来的快</li>
<li>图比代码亲切而且保护隐私🤣</li>
</ul>
</blockquote>
<h3 id="解决方案"><a class="header" href="#解决方案">解决方案</a></h3>
<p>众所周知，Intellij-Idea的官方插件可以分析出类图，但是Idea是收费软件，付费支持官方插件是一个省时省力的方案，这是个兜底方案。最终没辙时，我们再考虑它。</p>
<h4 id="编码时分析"><a class="header" href="#编码时分析">编码时分析</a></h4>
<p>仿照官方插件的思路，基于源码文档树进行分析，在Intellij的支持下，基于 PSI和uast 即可分析出类之间的关系。这需要一定的PSI、uast知识基础。</p>
<h4 id="编译时分析"><a class="header" href="#编译时分析">编译时分析</a></h4>
<p>在整个编译环节中，有一些切面应对特定问题，例如："注解处理" 、 "Gradle Transformer" ，在此切面处，我们可以基于编译中间产物，间接分析出类之间的关系。</p>
<p>最简单的是 <strong>注解处理阶段</strong> 介入，<strong>这只需要对 Element 和 TypeMirror 有一定的知识基础即可</strong>。</p>
<h4 id="运行时反射分析"><a class="header" href="#运行时反射分析"><del>运行时反射分析</del></a></h4>
<p>显然这不是一个太好的切入点，直接pass。</p>
<hr />
<blockquote>
<p>考虑到PSI方面的知识体系掌握地不太完善，Intellij跨越大版本时，会有较大变更，
而注解处理方面的知识还过的了关，搞个类图生成问题不大。</p>
<p><em>PS: AndroidStudio 基于Intellij核心二次开发，PSI插件跟随Idea大版本进行适配</em>；</p>
<p><strong>所以最终方案为：从注解处理阶段入手，分析编译中间产物，最终生成类图</strong></p>
</blockquote>
<hr />
<h2 id="问题分治与解决"><a class="header" href="#问题分治与解决">问题分治与解决</a></h2>
<h3 id="分治1----简化输出产物"><a class="header" href="#分治1----简化输出产物">分治1 -- 简化输出产物</a></h3>
<p>确定了大方向之后，我们需要再思考下整个问题的方方面面。生成类图有两大问题需要解决：</p>
<ul>
<li>从<del>源码</del>、或者编译的中间产物中分析出类关系； <em>ps:我们已经确定了要从编译中间产物出发</em></li>
<li>将类关系转变为图</li>
</ul>
<p>显然，"开发一个用来生成图的引擎"，这件事情成本过大且没有必要。所幸的是，UML不是一个新生物，业内也有大名鼎鼎的PlantUml。</p>
<blockquote>
<p><a href="https://plantuml.com/zh/">PlantUml</a> 基于 <a href="http://www.graphviz.org/">Graphviz</a> ， Graphviz 本身使用Dot语法描述元素与元素关系，
直接使用 Graphviz 比较朴素，PlantUml通过自定义语法，使得内容可阅读性提升，且无须关注转换图片时进行各类装饰问题</p>
</blockquote>
<p>于是，我们可以将问题转化为：从编译的中间产物中分析出类关系，将关系按照PlantUml语法生成puml文件，它的内容是纯文本。</p>
<h3 id="分治2----确定分析的起始点"><a class="header" href="#分治2----确定分析的起始点">分治2 -- 确定分析的起始点</a></h3>
<p>如果从最终结果看，我们得到的是一个 <code>有方向的图</code>，那么 <strong>按照图本身的起始点出发</strong> 比较符合习惯。</p>
<p>也就是说，我们将在起始点所对应的类上添加注解，作为注解处理的目标起始点</p>
<p>例如：</p>
<p><img src="Android/Idea/post_32/img.png" alt="img.png" /></p>
<p>Cat 和 Dog 将作为起始点。</p>
<p>因为只需要标记类，我们约定注解：</p>
<pre><code class="language-kotlin">@Target(AnnotationTarget.CLASS)
annotation class GenerateClassDiagram {}
</code></pre>
<p>在代码上，将表现为：</p>
<pre><code class="language-kotlin">class Animal

@GenerateClassDiagram
class Dog : Animal()

@GenerateClassDiagram
class Cat : Animal()
</code></pre>
<p>在示例中，当我们处理 <code>GenerateClassDiagram</code> 时，可以扫描获得 <code>Cat</code> 以及 <code>Dog</code> 类对应的
<code>javax.lang.model.element.Element</code> 示例，下文简称 <code>Element</code></p>
<blockquote>
<p><em>几点可能存在的疑惑</em>:</p>
<ul>
<li>为何不 "双向" 分析：<em>继承和实现关系，双向分析会带来额外的复杂度，且在使用上规则不清晰，依赖关系难以双向分析。</em> 但是，如果使用规则上可以做到清晰明了，这一点值得实现</li>
<li>为何不标注在Animal上，进行反向分析： <em>如果高层级的类在库包中，则需要修改库包，这不利于日常管理与维护</em></li>
<li>如果只标注了Cat而没有标注Dog，Dog将不会体现在图中？：<em>是的</em></li>
<li>如果全部标注了，是否产生不良影响 ：<em>不会，但是没有必要</em></li>
</ul>
</blockquote>
<h3 id="分治3----确定关系的分析方法"><a class="header" href="#分治3----确定关系的分析方法">分治3 -- 确定关系的分析方法</a></h3>
<h4 id="继承实现"><a class="header" href="#继承实现">继承&amp;实现</a></h4>
<p>因为注解的标记对象是类 <em>或者接口</em>，我们理应得到 <code>TypeElement</code>，基于 <code>Element</code> 的访问者模式实现，这一点并不难。</p>
<pre><code class="language-java">public interface TypeElement extends Element, Parameterizable, QualifiedNameable {

    TypeMirror getSuperclass();

    List&lt;? extends TypeMirror&gt; getInterfaces();

    //其他无关代码略去
}
</code></pre>
<p>不言自明，我们可以通过 <code>TypeMirror getSuperclass();</code> 得到继承关系，通过 <code>List&lt;? extends TypeMirror&gt; getInterfaces();</code> 得到实现关系</p>
<blockquote>
<p>注意，此处可以细分，接口和枚举仅需要分析实现关系即可，通过 <code>Element#getKind():ElementKind</code> 可以判断类型</p>
</blockquote>
<h4 id="依赖关联聚合组合"><a class="header" href="#依赖关联聚合组合">依赖&amp;关联&amp;聚合&amp;组合</a></h4>
<blockquote>
<p>这四个关系非常的类似但又不同，<strong>先降低复杂度</strong>，均认为是依赖关系，<em>在后续迭代中，可以进一步增加功能，将关系细化</em></p>
</blockquote>
<p>进一步降低复杂度，我们仅从类的属性出发，分析依赖关系，忽略掉 <strong>方法声明</strong> <em>(可分析)</em>、<strong>方法体</strong> <em>(无法分析)</em> 、<strong>静态块</strong> <em>(无法分析)</em> 中 所包含的关系。</p>
<pre><code class="language-java">public interface TypeElement extends Element, Parameterizable, QualifiedNameable {

    List&lt;? extends Element&gt; getEnclosedElements();
    //无关代码略去
}
</code></pre>
<p>不言自明，通过这一API，配合 <code>ElementFilter#fieldsIn(Iterable&lt;? extends Element&gt;):List&lt;VariableElement&gt;</code> 可以得到声明的 fields；</p>
<p>通过Element的API可以很轻易的得到 <code>命名</code> 以及 <code>修饰</code>；</p>
<p>通过 <code>Element#asType():TypeMirror</code> API 将其转换为TypeMirror后， 基于其Visitor模式设计可以得到field的类型 <code>DeclaredType</code> 并通过
<code>DeclaredType#asElement():Element</code> API重新得到Element</p>
<h3 id="分治4----确定分析的终点"><a class="header" href="#分治4----确定分析的终点">分治4 -- 确定分析的终点</a></h3>
<p>在分治2中，我们已经确定了分析的起点 <em>(可能有多个)</em> ， 在分治3中，我们已经确定了关系的分析方式。为了方便表述，我们以：</p>
<pre><code>Relation(From,End) 表述 从From 到 End 的关系
</code></pre>
<p>执行一轮 分治2&amp;分治3，我们将得到一系列的 Relation(From,End)，此时我们将所有的 <code>End</code> 作为 <code>新的From</code>，不断迭代这一过程，即可完成图的遍历！</p>
<p>那么合适结束这一过程呢？</p>
<p>我们只需要维护一个集合 Sfrom，存储迭代过程中的 <code>From</code> ，每次得到的 <code>End</code> 只有满足 "不存在于Sfrom中" 这一条件时，才是 <code>新的From</code>，当无法获得
<code>新的From</code> 时，迭代结束</p>
<h3 id="分治5----分治3的补充处理集合数组泛型"><a class="header" href="#分治5----分治3的补充处理集合数组泛型">分治5 -- 分治3的补充，处理集合、数组、泛型</a></h3>
<p>按照分治3中的约定，我们将集合、数组涉及的类型，以及泛型去泛化时的类型，都认为和当前类型是 <code>依赖关系</code>；<em>虽然这并不严谨</em></p>
<p>得益于 <code>TypeMirror</code> 的 <code>Visitor模式</code> 实现，<strong>我们很容易写出以下代码，获取我们关心的内容</strong>！</p>
<pre><code class="language-kotlin">private abstract class CastingTypeVisitor&lt;T&gt; constructor(private val label: String) :
    SimpleTypeVisitor6&lt;T, Void?&gt;() {
    override fun defaultAction(e: TypeMirror, v: Void?): T {
        throw IllegalArgumentException("$e does not represent a $label")
    }
}

private class FetchClassTypeVisitor : CastingTypeVisitor&lt;List&lt;DeclaredType&gt;&gt;(label = "") {
    override fun defaultAction(e: TypeMirror, v: Void?): List&lt;DeclaredType&gt; {
        //ignore it
        return emptyList()
    }

    override fun visitArray(t: ArrayType, p: Void?): List&lt;DeclaredType&gt; {
        return t.componentType.accept(this, p)
    }

    override fun visitWildcard(t: WildcardType, p: Void?): List&lt;DeclaredType&gt; {
        val ret = arrayListOf&lt;DeclaredType&gt;()

        t.superBound?.let {
            ret.addAll(it.accept(this, p))
        }
        t.extendsBound?.let {
            ret.addAll(it.accept(this, p))
        }
        return ret
    }

    override fun visitDeclared(t: DeclaredType, p: Void?): List&lt;DeclaredType&gt; {
        val ret = arrayListOf(t)
        t.typeArguments?.forEach {
            ret.addAll(it.accept(this, p))
        }
        return ret.toSet().toList()
    }

    override fun visitError(t: ErrorType, p: Void?): List&lt;DeclaredType&gt; {
        return visitDeclared(t, p)
    }

    override fun visitTypeVariable(t: TypeVariable, p: Void?): List&lt;DeclaredType&gt; {
        val ret = arrayListOf&lt;DeclaredType&gt;()

        t.lowerBound?.let {
            ret.addAll(it.accept(this, p))
        }
        t.upperBound?.let {
            ret.addAll(it.accept(this, p))
        }
        return ret
    }
}

fun TypeMirror.fetchDeclaredType(): List&lt;DeclaredType&gt; {
    return this.accept(FetchClassTypeVisitor(), null)
}
</code></pre>
<h3 id="分治6----关系的存储"><a class="header" href="#分治6----关系的存储">分治6 -- 关系的存储</a></h3>
<p>显然，我们需要一个合适的数据结构用以存储图，得益于我去年在 <a href="https://juejin.cn/post/6884492604370026503/">组件化：组件的按序初始化</a>
方面的一些探索，当时我开发了 <a href="https://github.com/leobert-lan/Maat">Maat</a> 其中包含 <strong>组件依赖关系的有向无环图分析</strong>，其中包含DAG的实现。</p>
<p>很显然，我们将 "无环检测" 禁用，就可以直接将数据结构拿来使用了，不需要再制造轮子！</p>
<p>显而易见，Relation的各种情况可以和 <code>度</code> 建立映射关系，人为维护一个 <code>虚拟顶点</code> 作为遍历的起始点可以减少很多麻烦。</p>
<h3 id="分治7----类型的细节处理"><a class="header" href="#分治7----类型的细节处理">分治7 -- 类型的细节处理</a></h3>
<p>在分治3中，我们已经已经对类型 <em>(enum、class、interface)</em> 进行了很充分的分析，但还遗漏了一些细节，例如方法、修饰符等；</p>
<p>在分治6中，我们确定了关系存储方案，我们还需要描述图的顶点。</p>
<p>我们定义 UmlElement类来进行描述</p>
<pre><code class="language-kotlin">abstract class UmlElement(val diagram: ClassDiagram?, val element: Element?) {
    /**
     * return: plant-uml 中相应的文本
     * */
    abstract fun umlElement(context: MutableSet&lt;UmlElement&gt;): String
    
    abstract fun parseFieldAndMethod(diagram: ClassDiagram,
                                     graph: DAG&lt;UmlElement&gt;,
                                     cache: MutableSet&lt;UmlElement&gt;)
    
    abstract fun drawField(fieldDrawer: FieldDrawer, 
                           builder: StringBuilder,
                           context: MutableSet&lt;UmlElement&gt;)
    
    abstract fun drawMethod(methodDrawer: MethodDrawer,
                            builder: StringBuilder,
                            context: MutableSet&lt;UmlElement&gt;)
}
</code></pre>
<p>并实现：</p>
<ul>
<li>UmlInterface：接口</li>
<li>UmlEnum： 枚举</li>
<li>UmlClass： 类</li>
<li>UmlStub：分治6中提到的虚拟顶点</li>
</ul>
<p>定义：IElementDrawer 接口 与 IJavaxElementDrawer 接口</p>
<pre><code class="language-kotlin">interface IElementDrawer {
    fun drawAspect(builder: StringBuilder, element: UmlElement, context: MutableSet&lt;UmlElement&gt;)
}

interface IJavaxElementDrawer {
    fun drawAspect(builder: StringBuilder, element: Element, context: MutableSet&lt;UmlElement&gt;)
}
</code></pre>
<p>并参考Plant-Uml的语法规则，<strong>实现了一系列的切面处理</strong>，例如：修饰符解析与输出，类型解析与输出，名称解析与输出，方法解析与输出 <strong>等</strong></p>
<p><em>此处使用了责任链，将Element转化plantUml语法进行了链式切分，并定义了一系列的切面处理。<strong>限于篇幅不做展开，有兴趣的读者可以在文末获取源码了解更多</strong></em></p>
<p>例如：</p>
<pre><code class="language-kotlin">abstract class SuperClz : SealedI {
    var superI: Int = 0
}
</code></pre>
<p>其Element被处理后，将转变为如下的文本内容：</p>
<pre><code class="language-puml">abstract class "SuperClz"{
  .. fields ..
  {field}-superI : int
  .. methods ..
  {method}+ getSuperI(): int
  {method}+ setSuperI(int): void
}
</code></pre>
<p>由PlantUml处理后形如：</p>
<p><img src="Android/Idea/post_32/img2.png" alt="img.png" /></p>
<h3 id="分治8----输出为plantuml文件"><a class="header" href="#分治8----输出为plantuml文件">分治8 -- 输出为PlantUml文件</a></h3>
<p>得益于我先前的一些探索，我曾开发过一款用于生成文档的注解处理器，通过 <a href="https://blog.csdn.net/a774057695/article/details/106603455">博客连接</a> 简单了解 。</p>
<p>设计中采用了SPI机制，我们可以很轻松地实现一个扩展，实现上面提到的所有内容，并且轻松地输出文本文档。</p>
<p><em>虽然在APT中输出一些文本文档是一件很简单的事情，但我决定使用以前造的轮子，毕竟它本身就是为了生成文档而开发的</em></p>
<hr />
<p>至此，我们已经对整个问题的主要流程进行了推演，可以得出结论：这件事情可以成！</p>
<p><strong>感谢我老婆早早就买到了中秋节回家的高铁票</strong>，在 <strong>回家的途中</strong> 便完成了方案的推演，并进行了框架编写与冒烟。 而现在整理博客的时间远远超过了编码🤣</p>
<hr />
<h2 id="保持优雅"><a class="header" href="#保持优雅">保持优雅</a></h2>
<p>显而易见，上述的内容仅止于 "解决问题" ， 还不能 "出色地解决问题"。</p>
<p>例如：</p>
<ul>
<li>绘制多张ClassDiagram</li>
<li>增加配置，屏蔽一些输出，例如：不想看见 <code>private</code> 修饰的fields</li>
<li>包名是在是太长了，存在阅读干扰</li>
</ul>
<p>等。</p>
<p>下面继续雕琢</p>
<h3 id="维持简单"><a class="header" href="#维持简单">维持简单</a></h3>
<p>在继续雕琢功能的同时，我们必须兼顾 <code>简单性</code> ，这一点非常重要！</p>
<p>一方面，我们不要过早的考虑用不着的功能，维持功能体系的简单。另一方面，功能使用要简单，方法或规则要明确。</p>
<p>例如在实现 "绘制多张ClassDiagram" 功能时：</p>
<ul>
<li>我最先想到的是在 <code>GenerateClassDiagram</code> 中添加<code>qualifier:List&lt;String&gt;</code>, 可以将被标识的类分配到不同的组别。但是它看起来并不太友好</li>
<li>于是我产生了：将配置与标识分离的想法。定义一个注解，可以进行配置，它仅可被标识于注解。</li>
</ul>
<pre><code class="language-kotlin">@Target(AnnotationTarget.ANNOTATION_CLASS)
annotation class ClassDiagram(
    val qualifier: String = "",
    val fieldVisible: Array&lt;Visible&gt; = [Visible.Private, Visible.Protected, Visible.Package, Visible.Public],
    val methodVisible: Array&lt;Visible&gt; = [Visible.Private, Visible.Protected, Visible.Package, Visible.Public],
)
</code></pre>
<p>这样使用者可以自由的定义注解，例如：</p>
<pre><code class="language-kotlin">@ClassDiagram("Demo")
annotation class DemoDiagram
</code></pre>
<p>这样，注解处理器需要关心的注解将变为两个：</p>
<ul>
<li>ClassDiagram : 标识注解表达分组，并且包含配置</li>
<li>GenerateClassDiagram ：标识类图中的分析起始点</li>
</ul>
<p>如此，我们使用时的规则更加清晰！注意，被GenerateClassDiagram 注解的类，必须添加分组注解，即 <code>被DemoDiagram注解的注解</code> 否则将被忽略</p>
<p>例如：</p>
<pre><code class="language-kotlin">@GenerateClassDiagram
@DemoDiagram
class Clz : SuperClz(), SealedI {
    val int: Int? = null
}
</code></pre>
<p><em>目前增加的功能，仅仅是在前文大流程上的细节优化，实现不再展开</em></p>
<p><em>结合我目前的工作使用了一段时候后，插件的功能还够用，就先不做超前的功能实现了</em></p>
<h3 id="减少侵入"><a class="header" href="#减少侵入">减少侵入</a></h3>
<p>我们从上文获知，使用这一插件，需要在代码中进行侵入修改，增加注解标注。理论上而言，侵入应该最少越好！在后续功能迭代设计中，同样需要考虑这一点。</p>
<p>在分治3中，我们将组合、聚合等关系暂时全部认为是依赖关系。</p>
<blockquote>
<p><em>在最初的设计中，需要使用者通过注解标识其关系，但侵入性大大提升</em>。</p>
</blockquote>
<p>过多的注解会 <code>影响源码可读性</code> 以及 <code>增大侵入</code> ！</p>
<p>在我的构想中，将通过 <code>ClassDiagram</code> 对 <code>依赖</code> 、 <code>关联</code> 、 <code>组合</code> 等进行一些约定，以解决这一问题并尽可能地减少侵入。</p>
<h3 id="扩展能力"><a class="header" href="#扩展能力">扩展能力</a></h3>
<p>目前还有一些功能尚未有优雅的解决方案，在前文已经提及。
我预留了足够多的扩展性用于装饰Plant-Uml语法文档，如果读者有处理方案，可以直接扩展后提PR。</p>
<p><em>因本文 <strong>并非</strong> 为 <strong>介绍编程技巧</strong> 或者 <strong>剖析如何提升项目的扩展能力</strong> ，故不再展开</em></p>
<p><a href="https://github.com/leobert-lan/ReportPrinter/">项目地址</a></p>
<h2 id="使用示例"><a class="header" href="#使用示例"><a id="demo">使用示例</a></a></h2>
<h3 id="添加依赖"><a class="header" href="#添加依赖">添加依赖</a></h3>
<pre><code>implementation "io.github.leobert-lan:class-diagram-reporter:1.0.0"
annotationProcessor "io.github.leobert-lan:report-anno-compiler:1.1.4"
annotationProcessor "io.github.leobert-lan:class-diagram-reporter:1.0.0"
</code></pre>
<p>均已发布到MavenCentral，最新版本号可参考以下：</p>
<p>*<img src="https://img.shields.io/static/v1?label=MavenCentray&message=report-anno-compiler"/>
*<a href="https://search.maven.org/search?q=g:io.github.leobert-lan%20And%20a:report-anno-compiler"><img src="https://img.shields.io/maven-central/v/io.github.leobert-lan/report-anno-compiler.svg?label=latest%20release"/></a></p>
<p>*<img src="https://img.shields.io/static/v1?label=MavenCentray&message=class-diagram-reporter"/>
*<a href="https://search.maven.org/search?q=g:io.github.leobert-lan%20And%20a:class-diagram-reporter"><img src="https://img.shields.io/maven-central/v/io.github.leobert-lan/class-diagram-reporter.svg?label=latest%20release"/></a></p>
<p>配置信息：</p>
<pre><code class="language-groovy">kapt {
    arguments {
        arg("module", "ktsample") //模块名称
        arg("mode", "mode_file") 
        arg("active_reporter", "on")
    }
}
</code></pre>
<h3 id="自行定义注解"><a class="header" href="#自行定义注解">自行定义注解</a></h3>
<p>该注解需被 <code>ClassDiagram</code> 注解，其他自行配置</p>
<p>例如：</p>
<pre><code class="language-kotlin">@ClassDiagram(qualifier = "BridgePattern")
annotation class BridgePatternDiagram

//or

@ClassDiagram(
    qualifier = "AAAB",
    fieldVisible = {Visible.Package, Visible.Public}
)
public @interface AAAB {
}
</code></pre>
<p>配合 <code>GenerateClassDiagram</code> 注解使用</p>
<p>此处以桥接模式示例，一个满足桥接模式的代码实现如下：</p>
<pre><code class="language-kotlin">class BridgePattern {

    @ClassDiagram(qualifier = "BridgePattern")
    annotation class BridgePatternDiagram

    interface MessageImplementor {
        fun send(message: String, toUser: String)
    }

    abstract class AbstractMessage(private val impl: MessageImplementor) {
        open fun sendMessage(message: String, toUser: String) {
            impl.send(message, toUser)
        }
    }

    @BridgePatternDiagram
    @GenerateClassDiagram
    class CommonMessage(impl: MessageImplementor) : AbstractMessage(impl)

    @BridgePatternDiagram
    @GenerateClassDiagram
    class UrgencyMessage(impl: MessageImplementor) : AbstractMessage(impl) {
        override fun sendMessage(message: String, toUser: String) {
            super.sendMessage("加急：$message", toUser)
        }
    }

    @BridgePatternDiagram
    @GenerateClassDiagram
    class MessageSMS : MessageImplementor {
        override fun send(message: String, toUser: String) {
            println("使用系统内短消息的方法，发送消息'$message'给$toUser")
        }
    }

    @BridgePatternDiagram
    @GenerateClassDiagram
    class MessageEmail : MessageImplementor {
        override fun send(message: String, toUser: String) {
            println("使用邮件短消息的方法，发送消息'$message'给$toUser")
        }
    }
}
</code></pre>
<p>编译后，我们得到的puml文件，渲染后得到：</p>
<p><img src="Android/Idea/post_32/bridge-pattern1.png" alt="img.png" /></p>
<p><em>😂恰好满足了plant-uml中package的语法，正常情况不会有package</em></p>
<p>我们可以注意到，关系上没有太大问题，AbstractMessage 与 MessageImplementor 之间表现为关联更加恰当。</p>
<p>除此之外，从阅读习惯上而言，图中的一些位置关系，还需要再调整，我们可以在后续的版本加，添加相应的配置方式。</p>
<h2 id="絮叨"><a class="header" href="#絮叨">絮叨</a></h2>
<p>从中秋节开始设计，零零碎碎完成开发，再到国庆准备写博客，又陆续做了几次修改。期间，家中也出了意外，在此也诚挚的希望各位读者注意身体，多花些时间在家人身上。代码是写不完的，知识是学不完的，但健康和生命都是有尽头的。</p>
<p><a href="https://leobert-lan.github.io/Info/about_haowan_series.html">了解好玩系列</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="初体验动手搭建小清新式局域网文档系统"><a class="header" href="#初体验动手搭建小清新式局域网文档系统">初体验：动手搭建"小清新式"局域网文档系统</a></h1>
<blockquote>
<p>您所在的团队是否拥有良好的文档分享氛围？文档是否方便查询和阅读？更新文档是否非常繁琐？</p>
</blockquote>
<p>想象一下，如果您所在的团队拥有这样一套项目文档网站，是否 <strong>项目的长期维护会很轻松</strong> ？</p>
<p>就像Square公司的开源项目,通过聚合页引导至不同的项目 ：</p>
<p><img src="Speculative/./post_43/square.png" alt="img.png" /></p>
<p>每个项目又拥有主题分明、聚合于目录导航下的网页文档，例如：</p>
<ul>
<li><a href="https://square.github.io/okhttp/">https://square.github.io/okhttp/</a></li>
<li><a href="https://square.github.io/retrofit/">https://square.github.io/retrofit/</a></li>
<li>...</li>
</ul>
<blockquote>
<p>诚然，通过 Github.IO 及类似方式，可以较为简单的部署一套在线静态文档网站。</p>
<p>但公司项目文档并不适合对外公开，您是否想在公司局域网范围内，自己动手搭建一套用于 <code>版本控制</code>、<code>自动部署</code>、<code>持续集成</code> 的网页文档呢？</p>
</blockquote>
<h2 id="以往的繁琐-与-如今的简明"><a class="header" href="#以往的繁琐-与-如今的简明">以往的繁琐 与 如今的简明</a></h2>
<p><img src="Speculative/post_43/1.png" alt="" /></p>
<p>曾经，我像图中这样，在本地或EDM软件维护文档空间，经历繁琐地检索、排查找到文档，再进行分享、阅读。</p>
<p><img src="Speculative/post_43/img.png" alt="img.png" /></p>
<p>而现在，我习惯像这样，访问网页，通过不超过3级的目录，直接定位到文档内容，进行阅读</p>
<h2 id="实现思路"><a class="header" href="#实现思路">实现思路</a></h2>
<p>核心思路：对重点内容编写轻量级文档，并以某种便于查找的索引方式聚合文档内容，将其托管于方便访问的网站。</p>
<p>典型的方式：</p>
<ul>
<li>使用Markdown形式的轻量级文档，撰写重点内容，每一篇都主题鲜明</li>
<li>按照主题与项目模块的之间的关系、主题之间的关联性，组织目录结构，形成 "索引"</li>
<li>是用Gitbook、博客生成器等软件，将其制作成静态网站</li>
<li>部署静态网站</li>
</ul>
<p>在此基础上，再加上自动部署、版本控制</p>
<p>涉及到的技能树，<em>其中蓝色高亮部分一般能让人眼前一亮</em>：</p>
<p><img src="Speculative/./post_43/3.png" alt="" /></p>
<h2 id="判断是否需要继续阅读"><a class="header" href="#判断是否需要继续阅读">判断是否需要继续阅读</a></h2>
<p>可能您已经 <strong>满怀期待</strong> 地准备开始跟随博客 <strong>展开实践</strong>，但出于责任心，我建议您结合下述 <strong>流程图</strong> 和 <strong>参考经历</strong> 判断下 <strong>是否真的需要继续</strong> 。</p>
<p>如果您已经确定要了解笔者是如何实现这一系统的，可以直接进入下一个章节</p>
<p><img src="Speculative/post_43/should_continue.png" alt="img.png" /></p>
<h3 id="供参考的例子"><a class="header" href="#供参考的例子">供参考的例子</a></h3>
<p><strong>A公司</strong></p>
<p>背景：</p>
<ul>
<li>研发团队百人规模，4-5条业务线，业务线之间存在一定数量的人员共享（例如移动端，web端后端救火队员）</li>
<li>业务线之间有（业务、技术）交流，流动人员需要接入、交出</li>
<li>除去服务端接口文档（YApi or Swagger），项目设计类文档一般托管于 <code>Confluence</code></li>
</ul>
<p>团队有强烈的 <strong>"基于文档交流、存档备份、查阅回顾、知识转移" 的需求</strong> ， <strong>有分享氛围</strong></p>
<p>遇到的典型困难：</p>
<ul>
<li>当不熟悉文档空间时，查找的难度大</li>
<li>维护文档空间内容索引难</li>
</ul>
<p><strong>B公司</strong></p>
<p>背景：</p>
<ul>
<li>业务线独立，互不干涉，基本没有技术沟通（私下的交流除外）</li>
<li>业务线研发团队30-40人规模</li>
<li>技术资料无明确要求</li>
</ul>
<p>仅在小组范围内存在 <strong>"碎片化"</strong> 的文档材料，可能托管于印象笔记、可能托管于项目代码库，可能在某电脑中</p>
<p>典型困难：</p>
<ul>
<li>聊胜于无，最终基本以查代码解决问题</li>
</ul>
<p><strong>C公司</strong></p>
<p>背景：</p>
<ul>
<li>涉足医疗行业</li>
<li>文档等资料的编写和管理发行遵照法规条款，受各种部门监管</li>
<li>使用EDM系统</li>
</ul>
<p>典型困难：</p>
<ul>
<li>各种文档的出发点契合法规需求，内容不一定满足研发人员的诉求（例如：往往我们需要详尽的类图、活动图、时序图、状态图、组件及对象生命周期关系，但文档一般只从系统角度给出程序流程图）</li>
<li>针对"查询设计细节点"而言，存在大量的内容噪声信息</li>
<li>文档空间大、内容多、检索难度高</li>
</ul>
<blockquote>
<p>从上述的三个案例来看，主要矛盾是文档内容不契合使用者诉求。</p>
<p>文档系统难用是次要矛盾。</p>
<p>在公司推行这一方案时，首先要确定主要矛盾能被解决，即团队愿意编写、维护一系列的文档（或内容资料）。
当团队拥有这些长期维护的文档、资料时，就可以着手解决系统不好用的问题。</p>
<p>否则不能有效推行，那此时只能退而求其次，尝试掌握额外的技能。</p>
</blockquote>
<h2 id="开始动手"><a class="header" href="#开始动手">开始动手</a></h2>
<h3 id="明确环境"><a class="header" href="#明确环境">明确环境</a></h3>
<p>按照我们的目标，可以确定，我们需要以下必要环境：</p>
<ul>
<li>一个局域网，不能有AP隔离、网段不能访问隔离（即设备间可以互相访问）</li>
<li>一台部署文档服务的机器</li>
<li>多台访问设备</li>
</ul>
<p><em>作者按：如果您已经开始在公司正式开始推行，大概率会申请到一台Linux虚机或者Docker；小范围尝试时，可能是使用自己的办公电脑，一般是Windows or macOS系统，Linux概率较低。</em></p>
<p><em>作者手边有一台 macOS10.15.7的机器，下文所有内容均以此版本为背景，注意：不同的操作系统可能会遇到不同的问题。</em></p>
<p>接下来我们需要搞定以下软件环境，<em>注意目前处于macOS 10.15.7环境下</em></p>
<ul>
<li>Gitlab 服务 及账号（至少具备创建、读取、提交项目的权限），版本无特定要求，用公司现成的即可</li>
<li>Docker 4.7.0 (77141)，未调查版本特定要求，该版本已确定可用，较新</li>
<li>Docker-ubuntu 镜像，未调查版本特定要求，可使用最新版本</li>
<li>Gitbook 3.2.3, 版本无特定要求，用于生成Gitbook，结合需求选用版本</li>
</ul>
<h3 id="docker"><a class="header" href="#docker">Docker</a></h3>
<p>接下来我们开始安装Docker，并从基本镜像开始搭建静态网站</p>
<h4 id="安装"><a class="header" href="#安装">安装</a></h4>
<p>首先<a href="https://www.docker.com/products/docker-desktop/">下载</a> 并安装Docker，这一步基本不会遇到问题</p>
<p>安装完成后，通过 <code>docker version</code> 命令，可以获得docker各个模块的版本信息</p>
<h4 id="获取ubuntu镜像"><a class="header" href="#获取ubuntu镜像">获取ubuntu镜像</a></h4>
<pre><code>docker image pull ubuntu:latest
</code></pre>
<p>以上命令可以获取官方镜像仓库中的最新的Ubuntu镜像</p>
<h4 id="生成容器"><a class="header" href="#生成容器">生成容器</a></h4>
<pre><code>docker run -p 80:80 --name doc -i -t ubuntu /bin/bash
</code></pre>
<p>通过以上命令可以 <strong>基于ubuntu镜像</strong> 得到一个 <strong>名为 doc 的容器</strong> ，映射本机80端口和容器的80端口，可使用bash。</p>
<pre><code>docker run [OPTIONS] IMAGE [COMMAND] [ARG...]
</code></pre>
<p><em>docker run 等价于 docker container run，在docker的迭代中，功能越来越多，增加了分组</em></p>
<p>注意：我在第一次体验docker时，没有处理好端口映射（随机端口分配），带来了很多问题，后面会给出专门的解决方案。</p>
<blockquote>
<p>读者朋友可以结合以下内容做一些尝试，体会下各种功能</p>
</blockquote>
<p>常用选项说明：</p>
<ul>
<li>-d, --detach=false， 指定容器运行于前台还是后台，默认为false</li>
<li>-i, --interactive=false， 打开STDIN，用于控制台交互</li>
<li>-t, --tty=false， 分配tty设备，该可以支持终端登录，默认为false</li>
<li>-u, --user=""， 指定容器的用户</li>
<li>-a, --attach=[]， 登录容器（必须是以docker run -d启动的容器）</li>
<li>-w, --workdir=""， 指定容器的工作目录</li>
<li>-c, --cpu-shares=0， 设置容器CPU权重，在CPU共享场景使用</li>
<li>-e, --env=[]， 指定环境变量，容器中可以使用该环境变量</li>
<li>-m, --memory=""， 指定容器的内存上限</li>
<li>-P, --publish-all=false， 指定容器暴露的端口</li>
<li>-p, --publish=[]， 指定容器暴露的端口</li>
<li>-h, --hostname=""， 指定容器的主机名</li>
<li>-v, --volume=[]， 给容器挂载存储卷，挂载到容器的某个目录</li>
<li>--volumes-from=[]， 给容器挂载其他容器上的卷，挂载到容器的某个目录</li>
<li>--cap-add=[]， 添加权限，权限清单详见：http://linux.die.net/man/7/capabilities</li>
<li>--cap-drop=[]， 删除权限，权限清单详见：http://linux.die.net/man/7/capabilities</li>
<li>--cidfile=""， 运行容器后，在指定文件中写入容器PID值，一种典型的监控系统用法</li>
<li>--cpuset=""， 设置容器可以使用哪些CPU，此参数可以用来容器独占CPU</li>
<li>--device=[]， 添加主机设备给容器，相当于设备直通</li>
<li>--dns=[]， 指定容器的dns服务器</li>
<li>--dns-search=[]， 指定容器的dns搜索域名，写入到容器的/etc/resolv.conf文件</li>
<li>--entrypoint=""， 覆盖image的入口点</li>
<li>--env-file=[]， 指定环境变量文件，文件格式为每行一个环境变量</li>
<li>--expose=[]， 指定容器暴露的端口，即修改镜像的暴露端口</li>
<li>--link=[]， 指定容器间的关联，使用其他容器的IP、env等信息</li>
<li>--lxc-conf=[]， 指定容器的配置文件，只有在指定--exec-driver=lxc时使用</li>
<li>--name=""， 指定容器名字，后续可以通过名字进行容器管理，links特性需要使用名字</li>
<li>--net="bridge"， 容器网络设置:
<ul>
<li>bridge 使用docker daemon指定的网桥</li>
<li>host //容器使用主机的网络</li>
<li>container:NAME_or_ID &gt;//使用其他容器的网路，共享IP和PORT等网络资源</li>
<li>none 容器使用自己的网络（类似--net=bridge），但是不进行配置</li>
</ul>
</li>
<li>--privileged=false， 指定容器是否为特权容器，特权容器拥有所有的capabilities</li>
<li>--restart="no"， 指定容器停止后的重启策略:
<ul>
<li>no：容器退出时不重启</li>
<li>on-failure：容器故障退出（返回值非零）时重启</li>
<li>always：容器退出时总是重启</li>
</ul>
</li>
<li>--rm=false， 指定容器停止后自动删除容器(不支持以docker run -d启动的容器)</li>
<li>--sig-proxy=true， 设置由代理接受并处理信号，但是SIGCHLD、SIGSTOP和SIGKILL不能被代理</li>
</ul>
<h4 id="为容器内的app安装nginx"><a class="header" href="#为容器内的app安装nginx">为容器内的APP安装nginx</a></h4>
<p>通过nginx可以很方便的代理静态站点，已经基于Ubuntu镜像，所以可以通过apt进行各类软件安装</p>
<p>先更新apt的资源，如果源出现问题，可以自行换源</p>
<pre><code>apt-get update
</code></pre>
<p>安装nginx</p>
<pre><code>apt-get install -y nginx
</code></pre>
<p>此处的过程一般不会出现问题</p>
<h4 id="为容器内的app安装vim"><a class="header" href="#为容器内的app安装vim">为容器内的APP安装Vim</a></h4>
<p>因为是通过终端操作，Vim是必须的。</p>
<p><em>值得注意的是,docker中使用vim只能使用最基本的指令，需要适应</em></p>
<pre><code>apt-get install -y vim
</code></pre>
<h4 id="修改nginx配置"><a class="header" href="#修改nginx配置">修改nginx配置</a></h4>
<p>此时，您可以先确定好静态网站内容的存放文件目录，笔者将其托管于Gitlab，并clone到了docker 容器中.</p>
<blockquote>
<p><code>apt-get install git</code> 安装git</p>
</blockquote>
<p>通过 <code> whereis</code> 命令找到nginx的安装位置 <code> whereis nginx</code> ，按照惯例：<strong>/etc 下存放配置文件</strong>，/sbin、/bin下是可执行文件</p>
<p>进入配置文件目录，使用VIM修改 <code>default</code> 文件内容</p>
<p>修改 root 配置，指定为静态网站根目录。</p>
<p>例如：</p>
<pre><code>##
# You should look at the following URL's in order to grasp a solid understanding
# ... 注释内容移除
##

# Default server configuration
#
server {
    listen 80 default_server;
    listen [::]:80 default_server;
    root /usr/local/work/doc/_book;


    server_name _;

    location / {
        # First attempt to serve request as file, then
        # as directory, then fall back to displaying a 404.
        try_files $uri $uri/ =404;
    }
}
</code></pre>
<p>保存。</p>
<p>输入 <code>nginx</code> 启动nginx ，<em>理论上环境变量已完善，若出现问题可自行配置环境变量</em></p>
<p>输入 <code>ps -ef</code> 可查看进程，确保nginx已经启动</p>
<h4 id="确认端口映射"><a class="header" href="#确认端口映射">确认端口映射</a></h4>
<p>进入mac的Terminal，可以新建也可以退出docker的交互式容器</p>
<blockquote>
<p>按序按ctrl+p,ctrl+q 可退出交互式容器</p>
</blockquote>
<p>使用 <code>docker ps</code> 命令查看运行中的容器的端口映射情况。 <code>docker ps -a</code> 可以查看全部容器的情况。</p>
<p>使用 <code>docker port "容器名"</code> 命令可以查看 容器内部端口 到 docker容器在mac上分配的端口</p>
<p>例如，上文中我们将80端口分配给静态网站，称之容器内部端口。而此docker容器运行一个依托于mac真机的虚拟平台上，mac真机为其分配了一个端口。</p>
<p>如果创建容器时没有指定端口或者启动时获取端口失败，docker容器会被分配一个端口，举个例子，可能是67890端口。</p>
<p>此时，通过访问 localhost:67890 已经可以访问到静态站内容</p>
<h4 id="通过端口映射解决"><a class="header" href="#通过端口映射解决">通过端口映射解决</a></h4>
<p>如上文所述，即便创建容器时指定了端口映射关系，也难以保障下次启动容器时还能获得一致的端口。</p>
<p>我们模拟一次docker重启</p>
<p>停止容器运行</p>
<pre><code>docker stop "容器名"
</code></pre>
<p>注意，重新启动容器应用命令为：</p>
<pre><code>docker start 容器名
</code></pre>
<p>而非 <code>docker run</code></p>
<p>如果没有配置nginx自动启动，则需要重启nginx，不进入交互式容器可使用命令：</p>
<pre><code>docker exec "容器名" nginx
</code></pre>
<p>顺带确认容器中运行的进程：</p>
<pre><code>docker top "容器名"
</code></pre>
<p>再次确认端口关系，可能会很不幸，假定已经改变为65432端口。但没有关系，挑一个喜欢的端口，例如 66666</p>
<p>进行端口映射。</p>
<blockquote>
<p>题外话，如果是Linux机器，我们可以使用iptables 命令处理转发</p>
</blockquote>
<p>有些早期的博客指导修改 /var/lib/docker/containers/[hash_of_the_container]/hostconfig.json 配置转发，但该版本的docker并没有该文件。</p>
<h5 id="通过macos的端口映射"><a class="header" href="#通过macos的端口映射">通过macOS的端口映射</a></h5>
<p><a href="https://blog.csdn.net/zealoussnow/article/details/89207260">可参考此博客</a></p>
<p>但是步骤太复杂了，如果不是系统性的运用转发机制，我这么懒的人一定会采用临时规则方案：</p>
<pre><code>echo "rdr pass proto tcp from any to any port {机器端口} -&gt; 127.0.0.1 port {docker 镜像端口}" | sudo pfctl -Ef -
</code></pre>
<p>结合我们假设的设定：</p>
<pre><code class="language-puml">echo "rdr pass proto tcp from any to any port 66666 -&gt; 127.0.0.1 port 65432" | sudo pfctl -Ef -
</code></pre>
<p>通过：</p>
<pre><code>sudo pfctl -F all -f /etc/pf.conf
</code></pre>
<p>可以删除临时规则</p>
<h3 id="gitbook-or-other"><a class="header" href="#gitbook-or-other">Gitbook or other</a></h3>
<p>在上文内容中，我们已经默认使用了 <a href="https://www.gitbook.com/">Gitbook</a> 生成文档静态网站, <a href="https://my.oschina.net/snowdreams1006/blog/3031933?hmsr=kaifa_aladdin">使用教程</a> 不再展开。</p>
<p>您也可以选用其他的软件工具生成网站</p>
<h3 id="如果存在通过路由器构建的子网"><a class="header" href="#如果存在通过路由器构建的子网">如果存在通过路由器构建的子网</a></h3>
<p>简单回顾物理拓扑：存在必不可少局域网和一台文档服务器。</p>
<p>在早期的体验阶段，我们选用了个人办公电脑架设文档服务器。</p>
<p>而出于方便办公的目的，我们很有可能自行购买了路有设备，<strong>通过路由器接入公司的局域网，将办公电脑、个人电脑、手机等接入路由器构建的子网</strong>。</p>
<p>此时，其他同事通过公司局域网访问该文档服务器就会 <strong>遇到麻烦</strong> ，不过很好解决，基于公司局域网的管理，一般个人分配的IP固定，<em>该场景下该IP对应路由器设备</em></p>
<p>分配一个路由器的端口作为访问文档服务的端口，通过路由器管理设置将该端口的访问定向转发到 <strong>部署文档服务器的机器</strong> 的文档服务端口，<em>上文中使用了66666端口</em></p>
<p><em>当然，这样处理的前提是路由器按照静态IP分配，否则需要时常维护映射关系。</em></p>
<h3 id="更新ci版本化"><a class="header" href="#更新ci版本化">更新、CI、版本化</a></h3>
<p>文档是需要长期维护的，必然会牵涉到更改、修订、新增。</p>
<p>在上文中，我们将生成的静态网站内容托管于Git，这是较差的做法，但可以在本地处理编译、生成静态网站资源时的 <strong>环境问题</strong> 而减少服务器的维护。</p>
<p>针对原始文档进行版本控制是必要的。引入健壮的环境维护机制后，在服务端进行静态网站资源编译、生成，是更佳的做法。</p>
<p>通过Git等VCS的帮助，已经拥有健全的版本管理方式，只需要采用相应的实践方式即可，例如参考Git最佳实践拆分发布、维护分支，通过tag维护发布版本</p>
<h4 id="自动获取更新部署"><a class="header" href="#自动获取更新部署">自动获取更新、部署</a></h4>
<p>以上文中的做法为例，此时仅需要 <strong>周期性的</strong> 获取Git仓库中发布分支的最新内容即可。</p>
<p>如果已经在服务端实施编译、生成，可以编写定时任务脚本进行CI，也可以进一步引入jenkins，增加构建任务，通过web-hook机制可以实现实时部署。</p>
<h4 id="同时获得多个版本"><a class="header" href="#同时获得多个版本">同时获得多个版本</a></h4>
<p>有时我们希望获得 <strong>文档、内容片段</strong> 在不同版本下的内容，在此方案基础上也容易实现。</p>
<p>针对不同的版本（tag），check-out 并编译、生成至 <strong>与版本一一映射</strong> 的文件目录，通过Nginx配置的方式即可实现。</p>
<p>此时，需要通过不同的URL访问不同的版本，这对于使用者并不友好，本着 <strong>以人为本</strong> 的原则，可以进行一次 <strong>优化</strong>：</p>
<blockquote>
<p>编写 "扫描" 程序或者脚本，扫出已经CheckOut、并在Nginx配置中有效的版本文件目录，<em>（一般做法是将各个版本的目录规整至同一路径下，将该路径作为站点Root目录）</em>
通过版本（tag）与文件目录名的映射关系、Git插件，取出版本Commit信息。聚合信息后按照模板生成入口页</p>
</blockquote>
<p>而 <strong>优化永无止境</strong> ，只要对文档、文档章节建立索引机制，将文档内容解析为AST，"比对文档章节在各个版本下的变化" 将可行，通过定制Gitbook插件的方式，
可将各章节在各个版本下的内容加以聚合、通过Spinner等方式切换阅读。</p>
<h2 id="结语-12"><a class="header" href="#结语-12">结语</a></h2>
<p>至此，我们已经完成了基础目标，而文档中提到的技能树，要全部点亮想必也需要一定的时间，尤其是结合 <code>Git</code>、<code>Markdown AST解析</code>、<code>模板引擎</code>等内容，自研一套软件用于网页生成。读者朋友们可以丰富自己的业余生活了。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="研究良久终于发现了他代码写的快且bug少的原因"><a class="header" href="#研究良久终于发现了他代码写的快且bug少的原因">研究良久，终于发现了他代码写的快且bug少的原因</a></h1>
<h2 id="前言-29"><a class="header" href="#前言-29">前言</a></h2>
<p>读者诸君，今日我们适当放松一下，不钻研枯燥的知识和源码，分享一套高效的摸鱼绝活。</p>
<p>我有一位程序员朋友，当时在一个团队中开发Android应用，历经多次考核后发现：</p>
<blockquote>
<p>在组内以及与iOS团队的对比中:</p>
<ul>
<li>他的任务量略多</li>
<li>但他的bug数量和严重度均低</li>
<li>但他加班的时间又少于其他人</li>
</ul>
<p>不禁令人产生好奇，他是如何做到代码别的又快，质量又高的</p>
</blockquote>
<p>经过多次研究我终于发现了奥秘。</p>
<p><em>为了行文方便我用"老L"来代指这位朋友。</em></p>
<h2 id="最常见的客户端bug"><a class="header" href="#最常见的客户端bug">最常见的客户端bug</a></h2>
<blockquote>
<p>"老L，听说昨晚上线，你又坐那摸鱼看测试薅别人，有什么秘诀吗？"</p>
</blockquote>
<blockquote>
<p>老L："秘诀？倒也谈不上，你这么说，我倒是有个问题，你觉得平日里最常见的bug有哪些？"</p>
</blockquote>
<blockquote>
<p>"emm，编码上不健壮的地方，例如NPE，IndexOutOfBoundsException，UI上的可就海了去了，文本长度不一导致显示不下，间距问题，乱七八糟的一大堆"</p>
</blockquote>
<blockquote>
<p>老L："哈哈，都是些看起来很幼稚、愚蠢的问题吧？是不是测试挂嘴边的那句：' 你就不能跑一跑吗，你又不瞎，跑两下不就看到了，这么明显！！！' "</p>
</blockquote>
<blockquote>
<p>我突然来了兴致，"你是说我们有必要上 TDD（test-driven-develop），按照DevOps思想，在CI（Continuous Integration）的时候，顺带跑自动化测试用例发现问题？"</p>
</blockquote>
<blockquote>
<p>老L突然打断了我："<strong>不要拽你那些词了</strong>，记住了，事情是要人干的，机器只能替代可重复劳动，现在还不能替代人的主观能动性，拽词并不能解决问题。我们已经找到了第一个问题的答案，现在换个角度"</p>
</blockquote>
<hr />
<p>平日里最常见的bug有哪些？</p>
<ul>
<li>编码不健壮, 例如NPE，IndexOutOfBoundsException</li>
<li>UI细节问题, 例如文本长度不一导致显示不下，间距，等</li>
</ul>
<h2 id="为什么很浅显的问题没有被发现"><a class="header" href="#为什么很浅显的问题没有被发现">为什么很浅显的问题没有被发现</a></h2>
<img width="220" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8120cd2c23264880b7d373c13932ab8c~tplv-k3u1fbpfcp-watermark.image?" alt="问题来了"/>
<blockquote>
<p>老L："那么问题来了，为什么这些浅显的问题，在交测前没有被发现呢？"</p>
</blockquote>
<p>我陷入了思考...</p>
<p>是开发们都很懒吗？也不至于啊！</p>
<p>是时间很紧来不及吗？确实节奏紧张，但也不至于不给调试就拿去测了！</p>
<blockquote>
<p>"emm, 可能是迭代的节奏的太频繁，压力较大，并没有整块的时间用来自测联调"</p>
</blockquote>
<img width="220" alt="问题不大" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8310c4177171446a92661e4e576df8ae~tplv-k3u1fbpfcp-watermark.image?"/>
<blockquote>
<p>老L接过话茬，"假定你说的是正确的，那么就有两种可能。"</p>
<p>"第一种，自测与联调要比开发还要耗费心思的一件事情。但实际上，你我都知道，这一点并站不住脚！"</p>
<p>"而第二种，就是在开发阶段无法及时测试，拖到开发完，简单测测甚至被催促着就交差了"</p>
</blockquote>
<p>仔细的思考后</p>
<ul>
<li>业务逐步展开，无法在任意时间自由地进行有效的集成测试</li>
<li>后端节奏并不比前端快多少，在前端的开发阶段，难以借助后端接口测试，也许接口也有问题</li>
</ul>
<blockquote>
<p>"确实，这是一个挺麻烦的问题，听你一说，我感觉除了多给几天，开发完集中自测一波才行" 我如是说到。</p>
</blockquote>
<img width="220" alt="没有问题" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ecbfafbe0104f23b8db06e31446195a~tplv-k3u1fbpfcp-watermark.image?"/>
<blockquote>
<p>"NO NO NO"，老L又打断了我："你想的过多了，你想借助一个可靠的、已经完备的后端系统来进行自测。对于你的需求来说，这个要求过高了，你这是准备干QA的活"</p>
<p>"我帮你列举一下情况"</p>
</blockquote>
<ol>
<li>一些数据处理的算法，这种没有办法，老老实实写单元测试，在开发阶段就可以做好，保障可靠性</li>
<li>UI呢，我们现在写的代码，基本都做到了UI与逻辑分层，只要能模拟数据，就能跑起来看页面</li>
<li>业务层，后端逻辑我们无法控制，但 Web-API 调用的情况可以分析下并做一下测试，而对于返回数据的JSON结构校验、约束性校验也可以考虑做一下测试</li>
</ol>
<p><strong>总而言之，我们只需要先排除掉浅显的错误</strong>。而这些浅显的错误，属于情况2、3</p>
<blockquote>
<p>老L接着说道："你先歇歇吧，我来说，你再插嘴这文章就太长了！"</p>
</blockquote>
<p>接下来就可以实现矛盾转移："如何模拟数据进行测试"，准确的说，问题分成两个子问题：</p>
<ul>
<li>如何生成模拟数据</li>
<li>如何从接缝中塞入数据，让系统得以使用</li>
</ul>
<h2 id="可能存在的接缝"><a class="header" href="#可能存在的接缝">可能存在的接缝</a></h2>
<img width="220" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8120cd2c23264880b7d373c13932ab8c~tplv-k3u1fbpfcp-watermark.image?" alt="问题来了"/>
<p>先看问题2："如何从接缝中塞入数据，让系统得以使用"</p>
<p>脑暴一下，可以得出结论：</p>
<ul>
<li>应用内部
<ul>
<li>替换调用web-api的业务模块，使用假数据调用业务链，一般替换Presenter、Controller实例</li>
<li>替换Model层，不调用web-api，返回假数据或用假数据调用回调链</li>
<li>侵入网络层实现，不进行实际网络层交互，直接使用假数据</li>
<li>遵循切面，向缓存等机制模块中植入假数据</li>
</ul>
</li>
<li>应用外部
<ul>
<li>使用代理，返回假数据</li>
<li>假数据服务器</li>
</ul>
</li>
</ul>
<p>简单分析：</p>
<ul>
<li><del>"假数据服务器"</del> 的代价太大，并且使用逻辑编造假数据的代价太大，过。</li>
<li>"使用代理，返回假数据"，可以用于特定问题的调试，不适用广泛情况，过。</li>
<li><del>"替换调用web-api的业务模块"</del>，成本过大，过。</li>
<li>"替换Model层"，对项目的依赖注入管理具有较大挑战，备选，可能带来很多冗余代码。</li>
<li>"侵入网络层实现"，优选。</li>
<li>"向缓存等机制模块中植入假数据"，操作真实的缓存较复杂，但可以考虑增加一个 Mock缓存实现模块，基于SPI等机制，可以解决冗余代码问题，备选。</li>
</ul>
<p>得出结论：</p>
<ul>
<li>方案1："侵入网络层实现"，优选</li>
<li>方案2："替换Model层"，<em>（项目的依赖注入做得很好时</em>）作为备选，可能带来冗余代码</li>
<li>方案3："向缓存等机制模块中植入假数据"，增加一个 Mock缓存实现模块，备选。<em>（基于SPI等机制，可以解决冗余代码问题）</em></li>
</ul>
<p>再仔细分析： <strong>方案1和方案3可以合并，形成一个完整的方案，但未必需要限定在缓存机制中</strong></p>
<img width="220" alt="没有问题" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ecbfafbe0104f23b8db06e31446195a~tplv-k3u1fbpfcp-watermark.image?"/>
<p>OK 我们先搁置一下这个问题，看前一个问题。</p>
<img width="220" alt="全是问题" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4959e7c21de4b7e8d41173c53210dbc~tplv-k3u1fbpfcp-watermark.image?"/>
<h2 id="创造假数据"><a class="header" href="#创造假数据">创造假数据</a></h2>
<p>简单脑暴一下，无非三种：</p>
<ul>
<li>人工介入，手动编写 -- 成本过大
<ul>
<li>可能在前期准备好，基本是纯文本</li>
<li>可能使用一个交互工具，在需要数据时介入，通过图形化操作和输入产生数据</li>
</ul>
</li>
<li>人工介入，逻辑编码</li>
<li>基于反射等自省机制，并完全随机或者基于限制生成数据</li>
</ul>
<blockquote>
<p>"第一种代价过大，暂且抛弃"</p>
<p>"第二种可以采用，但是人力成本不容忽视! 一个可以说服我使用它的理由是："可以精心设计单测数据，针对性的发现问题"</p>
<p>"第三种很轻松，例如使用Mockito，但生成合适的数据需要花费一定的精力"</p>
</blockquote>
<p>我们来扒一扒第三种方式，其核心思想为：</p>
<blockquote>
<ol>
<li>获取类信息，得到属性集</li>
<li>遍历属性填充
&gt;</li>
</ol>
</blockquote>
<ol>
<li>基础类型、箱体类型，枚举，确定取值范围，使用Random取值，赋值</li>
</ol>
<blockquote>
<pre><code>2. 普通类、泛型类，创建实例，回归步骤1
3. 集合、数组等，创建实例，回归步骤1，收集填充
</code></pre>
</blockquote>
<p>不难得出结论，这一方法虽然很强大，但 <code>创建高度定制化的数据</code> 是一件有挑战的事情。</p>
<p>举个例子，模拟字符串时，一般会使用语料集作为枚举，进行取值。要得到“地址”、“邮箱”等特定风格的数据，需要结合框架做配置，客观上存在较高地学习、使用门槛。</p>
<p>你也知道，前几年我图好玩，写了个 <a href="https://github.com/leobert-lan/Mocker">mock库</a> 。</p>
<p>必须强调的一点：“我并不认为我写的库比Mockito等库强大，仅仅是在我们开发人员够用的基础上，做到尽可能简单！”</p>
<p>你也知道，Google 在Androidx（前身为support）中提供了一套注解包： annotations。<em>但Google并未提供bean validation 实现</em>
，我之前也基于此做过一套JSR303实现，有一次突发灵感，这套注解的含义同样适用于 <code>声明假数据取值范围</code> ！！！</p>
<p>所以，我能使用它便捷的生成合适的假数据，在开发阶段及时的进行 “伪集成”</p>
<hr />
<p>此刻，我再也忍不住要发言了：“且慢，老L，你这个做法有一定的侵入性吧。而且，如果数据类在不同业务下复用的话，是否存在问题呢？”</p>
<blockquote>
<p>老L顿了顿，“确实，google的annotations是源码级注解，并不是运行时，我为了保持简单，使用了运行时反射而非代码生成。所以确实存在一定的代码侵入性”。</p>
<p>但是，我们可以基于此建立一套简单的MOCK-API，这样就不存在代码侵入了。</p>
<p>另外，也可以增加一套Annotation-Processor 实现方案，这样就可以适当沿用项目中的注解约束了，但我个人认为华而不实。</p>
<hr />
<p>看你的第二个问题，Mocker一开始确实存在这个问题，有一次从Spring的JSR380中得到灵感，我优化了注解规则，这个问题已经被解决了。得空你可以顺着这个图看看：</p>
</blockquote>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19f0a9418005492eb0533a4c3ea93ff8~tplv-k3u1fbpfcp-watermark.image?" alt="Mocker.png" /></p>
<p>或者去看看代码和使用说明：<a href="https://github.com/leobert-lan/Mocker">https://github.com/leobert-lan/Mocker</a></p>
<h2 id="再次审视如何处理接缝"><a class="header" href="#再次审视如何处理接缝">再次审视如何处理接缝</a></h2>
<p>此时我已经有点云里雾里，虽然听起来很牛，如何用起来呢？我还是很茫然，简直人麻了！不得不再次请教。</p>
<p>老L笑着说：“你问的是一个实践方案的问题，而这类问题没有银弹.不同的项目、不同的习惯都有最适宜的方法，我只能分享一下我的想法和做法，仅做参考”</p>
<blockquote>
<p>在之前的项目中，我自己建了一个Mock-API，利用我的Mocker库，写一个假数据接口就是分分钟的事情。</p>
<p>测试机挂上charles代理，有需要的接口直接进行mapping，所以在客户端代码中，你看不到我做了啥。</p>
</blockquote>
<p>当然，这个做法是在软件外部。</p>
<p>如果要在软件内部做，我个人认为这也是一个华而不实的事情。不过不得不承认是一件好玩的事情，那就提一些思路。</p>
<h3 id="基于retrofit的calladapter"><a class="header" href="#基于retrofit的calladapter">基于Retrofit的CallAdapter</a></h3>
<pre><code class="language-java">public interface CallAdapter&lt;R, T&gt; {
    Type responseType();

    T adapt(Call&lt;R&gt; call);

    abstract class Factory {
        public abstract @Nullable
        CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations,
                              Retrofit retrofit);

        protected static Type getParameterUpperBound(int index, 
                                                     ParameterizedType type) {
            return Utils.getParameterUpperBound(index, type);
        }

        protected static Class&lt;?&gt; getRawType(Type type) {
            return Utils.getRawType(type);
        }
    }
}
</code></pre>
<p>很明显，我们可以追加注解，用以区分是否需要考虑mock；</p>
<p><em>可选：对于有可能需要mock的接口，可以继续追加切面，实现在软件外部控制使用 <code>mock数据</code> 或 <code>真实数据</code></em></p>
<p>而Retrofit已经使用反射确定了方法的 <code>return Type</code> ，在Mocker中也有适应的API直接生成假数据</p>
<h3 id="基于retrofit的interceptor"><a class="header" href="#基于retrofit的interceptor">基于Retrofit的Interceptor</a></h3>
<p>相比于上一种，拦截器已经在Retrofit处理流程中靠后，此时在 <code>Chain</code> 中能够得到的内容已经属于Okhttp库的范畴。</p>
<p>所以需要一定的前置措施用于确定 "return Type"、"是否需要Mock" 等信息。可以借助Tag机制：</p>
<pre><code class="language-java">@Documented
@Target(PARAMETER)
@Retention(RUNTIME)
public @interface Tag {
}

@GET("/")
Call&lt;ResponseBody&gt; foo(@Tag String tag);
</code></pre>
<p>最终从 <code>Request#tag(type: Class&lt;out T&gt;): T?</code> 方式获取，并接入mock，并生成 <code>Response</code></p>
<h3 id="其他针对okhttp的封装"><a class="header" href="#其他针对okhttp的封装">其他针对Okhttp的封装</a></h3>
<p>思路基本类似，不再展开。</p>
<h2 id="写在最后"><a class="header" href="#写在最后">写在最后</a></h2>
<p>听完老L的思路，我若有所思，若有所悟。他的方案似乎很有效，而且直觉告诉我，这些方案中还有很多留白空间，例如：</p>
<ul>
<li>借用SPI等技术思路，可以轻易的解决 "Mock 模块集成与移除" 的问题</li>
<li>提前外部控制是否Mock的接缝，可以在加一个工具APP、或者Socket+网页端工具 用以实现控制</li>
</ul>
<p>但我似乎遗漏了问题的开始</p>
<img width="220" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8120cd2c23264880b7d373c13932ab8c~tplv-k3u1fbpfcp-watermark.image?" alt="问题来了"/>
<blockquote>
<p>是否原意做 用于约束假数据生成规则的基础建设工作呢？？？ 例如维护注解</p>
<p>事情终究是人干的，人原意做，办法总比困难多。</p>
</blockquote>
<p>最后一个小问题：</p>
<img width="220" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78b9d577bea34124a743cd5cfaaeb051~tplv-k3u1fbpfcp-watermark.image?"/>
<img width="220" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f63755e9fe44642a97d9887417db3ca~tplv-k3u1fbpfcp-watermark.image?"/>
<div style="break-before: page; page-break-before: always;"></div><h1 id="好玩系列--如果后端让你用sse接收多次返回那我们改造retrofit吧"><a class="header" href="#好玩系列--如果后端让你用sse接收多次返回那我们改造retrofit吧">好玩系列 | 如果后端让你用SSE接收多次返回，那我们改造Retrofit吧</a></h1>
<h2 id="前言-30"><a class="header" href="#前言-30">前言</a></h2>
<p>说来惭愧，最近都没写技术帖，每月写一篇原创的Flag也倒了，倒并非无内容可写，实则是因为懒惰， 虽然工作和生活牵扯了很多精力，但仍是有碎片化时间的。一篇关于DataBinding非常有趣的文章还在编写中，今天我们先看一篇轻松点的内容。</p>
<p>随着ChatGpt等生成式AI大火，SSE（Server Send Events）又回到了技术讨论当中，今天我们聊一聊，<strong>如果客户端需要获取服务端长耗时任务结果，有哪些实践方式</strong>。</p>
<blockquote>
<p>本篇博客将聚焦于4个方面：</p>
<ul>
<li>归纳获取服务端长耗时任务结果的常见实践方式</li>
<li>对SSE进行详细的讨论，尤其是其协议细节</li>
<li>实操：搭建SSE服务端、使用OKHttp搭建客户端</li>
<li>探索：对Retrofit进行了分析，扩展Retrofit使用SSE</li>
</ul>
</blockquote>
<h2 id="4种常见的实践方式"><a class="header" href="#4种常见的实践方式">4种常见的实践方式</a></h2>
<p>不外乎两种思路：</p>
<ul>
<li>客户端 polling</li>
<li>服务端 push</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ec3a01c5cc74032a71befa745dccea1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1366&amp;h=740&amp;s=71846&amp;e=png&amp;b=fffdfd" alt="4种方式.png" /></p>
<h3 id="客户端polling"><a class="header" href="#客户端polling">客户端polling</a></h3>
<p>不难理解，服务端处理一项任务，只有服务端才清晰地知道任务的状态，客户端可以通过 <strong>周期性主动轮询</strong> 直至获取任务的最终结果。</p>
<p>按照此类实践方式，可使用 <code>HTTP/HTTPs</code> 协议。</p>
<h4 id="short-polling"><a class="header" href="#short-polling">short polling</a></h4>
<p>客户端向服务端发起请求，如果服务端状态已经更新，返回结果并关闭链接；<strong>如果服务端状态尚未更新，返回一个特定的结果告知还在处理中，并关闭链接</strong></p>
<h4 id="long-polling"><a class="header" href="#long-polling">long polling</a></h4>
<p>和 <code>short polling</code> 类似，客户端向服务端发起请求，如果服务端状态已经更新，返回结果并关闭链接；</p>
<p>但如果服务端状态尚未更新，</p>
<ul>
<li>服务端会在超时时间内维持链接，进行等待，直至状态更新，返回结果并关闭链接；</li>
<li>若等待至超时也未更新状态，返回一个特定的结果告知还在处理中，并关闭链接</li>
</ul>
<h3 id="服务端push"><a class="header" href="#服务端push">服务端push</a></h3>
<p>这类实践方式中，不需要客户端采取"问"，而是当服务端状态更新时，自行通知客户端，典型的实践方式有：</p>
<ul>
<li>Server Send Events (SSE)</li>
<li>WebSocket</li>
</ul>
<h4 id="sse"><a class="header" href="#sse">SSE</a></h4>
<p>SSE是本文的讨论核心，从服务端发往客户端的消息，存在一个限制，即仅可以发送 <code>纯文本</code> 类型的消息。</p>
<p>SSE基于http协议的持久连接，<code>SSE</code> 具有 W3C 标准化的网络协议和 EventSource 客户端接口，属于 <code>HTML5</code> 标准套件。</p>
<p>有兴趣的读者可以访问 <a href="https://html.spec.whatwg.org/multipage/server-sent-events.html">扩展阅读</a> 了解协议细节</p>
<h4 id="websocket"><a class="header" href="#websocket">WebSocket</a></h4>
<p>定制性、扩展性最强的实践方案，有趣的话题实在太多，不做任何展开。</p>
<h2 id="sse协议细节"><a class="header" href="#sse协议细节">SSE协议细节</a></h2>
<p>不难理解，SSE形如消息订阅，由客户端主动发起订阅，双方维持链接，服务端向客户端推送message。</p>
<h3 id="header主要部分"><a class="header" href="#header主要部分">Header主要部分</a></h3>
<p>按照协议约定，<code>Method</code> 为 <code>GET</code>，并且需要在 <code>Header</code> 中包含以下内容：</p>
<ul>
<li>Accept: text/event-stream 指定Media Type</li>
<li>Cache-Control: no-cache 不使用cache</li>
<li>Connection: keep-alive 使用持久性连接</li>
</ul>
<p>以下是Header部分的示例：</p>
<pre><code class="language-text">GET /{path} HTTP/1.1
Accept: text/event-stream
Cache-Control: no-cache
Connection: keep-alive
</code></pre>
<p>服务端的响应Header至少包含：</p>
<ul>
<li>Content-Type: text/event-stream;charset=UTF-8 指定Media Type</li>
<li>Transfer-Encoding: chunked</li>
</ul>
<p>以下是响应Header部分的示例：</p>
<pre><code class="language-text">HTTP/1.1 200
Content-Type: text/event-stream;charset=UTF-8
Transfer-Encoding: chunked
</code></pre>
<h3 id="event-stream-解析"><a class="header" href="#event-stream-解析">Event-Stream 解析</a></h3>
<p>event-stream的内容(结构和字符)需满足以下 <a href="https://www.rfc-editor.org/rfc/rfc5234">ABNF</a> 语法范式约定</p>
<pre><code class="language-ABNF">stream        = [ bom ] *event
event         = *( comment / field ) end-of-line
comment       = colon *any-char end-of-line
field         = 1*name-char [ colon [ space ] *any-char ] end-of-line
end-of-line   = ( cr lf / cr / lf )

; characters
lf            = %x000A ; U+000A LINE FEED (LF)
cr            = %x000D ; U+000D CARRIAGE RETURN (CR)
space         = %x0020 ; U+0020 SPACE
colon         = %x003A ; U+003A COLON (:)
bom           = %xFEFF ; U+FEFF BYTE ORDER MARK
name-char     = %x0000-0009 / %x000B-000C / %x000E-0039 / %x003B-10FFFF
; a scalar value other than U+000A LINE FEED (LF), U+000D CARRIAGE RETURN (CR), or U+003A COLON (:)
any-char      = %x0000-0009 / %x000B-000C / %x000E-10FFFF
; a scalar value other than U+000A LINE FEED (LF) or U+000D CARRIAGE RETURN (CR)
</code></pre>
<p>需要逐行读取内容并进行解析，按照语法约定：<code>end-of-line = ( cr lf / cr / lf )</code>，CRLF、CR、LF都代表换行</p>
<ul>
<li>如果是空行，后续是新Event，可通俗理解为事件之间用空行分隔</li>
<li>如果是以 <code>:</code> <em>冒号，UniCode编码 U+003A</em> 开始，忽略此行</li>
<li>如果包含 <code>:</code> <em>冒号，UniCode编码 U+003A</em>，从第一个冒号开始分割
<ul>
<li>冒号前的内容为 <code>field</code></li>
<li>冒号后的内容为 <code>value</code>，如果冒号后的第一个字符为 <code>空格</code> U+0020，从 <code>value</code> 中移除</li>
</ul>
</li>
<li>非空但不包含 <code>:</code>, 内容全部作为 <code>field</code>, <code>value</code> 为空字符串</li>
</ul>
<p>field的约定：</p>
<ul>
<li>"event"：其value为 event type</li>
<li>"data"：其value为事件数据，解析后单独再尾部拼接 <code>LF</code></li>
<li>"id"：若其value不包含 <code>U+0000 即NULL</code>，值为事件的ID，否则忽略</li>
<li>"retry"：其value若只包含ASCII码表示的数值，认为是十进制数解析为Int，作为毫秒级的重连时间，<em>当链接断开，客户端应当在此时间后自动发起重连</em>，否则忽略</li>
<li>其他情况均忽略</li>
</ul>
<h3 id="last-event-id"><a class="header" href="#last-event-id">Last-Event-ID</a></h3>
<p>前文已经提到了如下内容：</p>
<ul>
<li>Header</li>
<li>Event-Stream中field为"id"、"retry"</li>
</ul>
<p>不难理解，当出现意外情况时，例如网络原因导致的链接断开，涉及到重连；显然，重连时一般不希望再获取已经收到的信息。</p>
<p>Header中存在 <code>Last-Event-ID</code> field约定，指定上次收到的Event的id，因Event有序，可避免冗余信息传输。</p>
<h2 id="纸上得来终觉浅"><a class="header" href="#纸上得来终觉浅">纸上得来终觉浅</a></h2>
<p>至此，协议部分的主要内容已经讨论完毕，让我们进入愉快的Demo环节。</p>
<h3 id="编写服务端"><a class="header" href="#编写服务端">编写服务端</a></h3>
<p>对部分读者而言，这部分可能有点超纲，但没有关系，已经准备好了Demo代码，各位只需要准备好Java环境和路由器即可。</p>
<p><a href="https://github.com/leobert-lan/SSE-Server-demo">代码仓库</a></p>
<p>在Demo中，准备了两条接口：</p>
<ul>
<li>http://{ip}:8080/sse/mvc/words , 模拟多次生成文本段落并推送至客户端</li>
<li>http://{ip}:8080/sse/mvc/folder-watch , 模拟文件夹监听</li>
</ul>
<p>启动服务后，可使用控制台和curl进行测试：</p>
<pre><code>curl -v http://localhost:8080/sse/mvc/words
</code></pre>
<h3 id="编写客户端"><a class="header" href="#编写客户端">编写客户端</a></h3>
<p>很显然，一个非新事物往往不需要普通开发者造轮子，<a href="https://github.com/square/okhttp/tree/master/okhttp-sse">OkHttp</a> 已经支持SSE</p>
<p>不同于大家熟知的 <code>Call</code>， Okhttp-SSE中封装了 <code>EventSource</code>，并通过 <code>Factory</code> 创建实例、发起请求：</p>
<p>一个朴素地使用示例如下：</p>
<pre><code class="language-java">class Demo {
    void demoCode() {

        OkHttpClient okHttpClient = new OkHttpClient();
        EventSource.Factory factory = EventSources.createFactory(okHttpClient);

        Request.Builder builder = new Request.Builder().get().url(url);

        builder.addHeader("Content-Type", "text/event-stream")
                .addHeader("Accept-Encoding", "")
                .addHeader("Accept", "text/event-stream")
                .addHeader("Cache-Control", "no-cache");

        builder.addHeader("Last-Event-ID", "2");

        Request request = builder.build();

        factory.newEventSource(request, new EventSourceListener() {
            //ignore
        });
    }
}
</code></pre>
<p>请注意，如果将其作为 <code>Call</code>，将无法获得多次推送的效果，在不出现错误或超时的情况下，形如一次响应较慢的Get请求。</p>
<p><a href="https://github.com/leobert-lan/SSE-android-Demo">demo代码仓库</a></p>
<h3 id="是否可以使用retrofit"><a class="header" href="#是否可以使用retrofit">是否可以使用Retrofit</a></h3>
<p>截至目前为止，Retrofit未对其进行适配，其实在多年前即展开过讨论，我找到了此条 <a href="https://github.com/square/retrofit/issues/1029">讨论issue</a></p>
<p>Retrofit的设计原理并不复杂：</p>
<blockquote>
<ul>
<li>通过运行时反射，建立动态代理，依据注解构建Okhttp的Call</li>
<li>通过CallAdapter，将Call的结果处理方式，进行不同的适配</li>
</ul>
</blockquote>
<p>但设计之初，仅设计了 <code>Retrofit.Call</code> 对 <code>Okhttp.Call</code> 进行Wrap，而 <code>EventSource</code> 并不继承 <code>Okhttp.Call</code>，当然，依据其特性也不应当继承自Call</p>
<p>鉴于此，若将 <code>EventSource</code> 强行包装为 <code>Retrofit.Call</code> 将会很容易引起错误，例如调用</p>
<ul>
<li><code>Response&lt;T&gt; execute() throws IOException;</code></li>
<li><code>void enqueue(Callback&lt;T&gt; callback);</code></li>
</ul>
<p>若在Retrofit中平行展开一条 <code>EventSource</code> 的处理逻辑，需要对库进行很多修改，并且考虑对生态的影响，并不划算。</p>
<p>但是使用者自己的行为是不受限的，自己结合项目情况开发，自己对其负责。</p>
<h2 id="动手写retrofit扩展库"><a class="header" href="#动手写retrofit扩展库">动手写Retrofit扩展库</a></h2>
<p>正如我上文所言，直接在Retrofit中进行扩展需要考虑对生态的影响，读者诸君可以详细阅读Jake Wharton 的post，其设计构思在考虑 "一致性" 问题。</p>
<p>但如果在Retrofit之外进行扩展，则可以回避生态问题，即便有非一致性设计，也可以不用直面。</p>
<p><a href="https://github.com/leobert-lan/SSE-android-Demo">代码仓库</a> 需切换到 <code>retrofit-sse</code> 分支！</p>
<p><strong><em>作者按：读者诸君请注意，在编写此文时，我尚未有充足的时间投入扩展库的设计与编写，代码库中的Sample代码，仅可作为指导，仍存在设计盲点，不要直接投入商用。</em></strong></p>
<p>很容易得出以下核心设计思路，<em>可看导图或下文的文字说明，较为啰嗦</em>：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/766af76c9b1a4ab1b386f0b2c930e65c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2916&amp;h=2272&amp;s=564681&amp;e=png&amp;b=fffefe" alt="扩展库.png" /></p>
<ul>
<li>将连续的Event内容转变为可观测的Source，例如Rxjava的观测源、LiveData、kotlin协程的Flow
<ul>
<li>内建 <code>EventSourceListener</code> 实现类，从回调触发源的更新</li>
<li>定义 <code>EventSourceAdapter</code>，用于将 <code>Okhttp-EventSource</code> 转变为 可观测的Source</li>
</ul>
</li>
<li>需要存在一种机制，依据Interface中Method定义的返回类型，获取 <code>EventSourceAdapter</code> 实例
<ul>
<li>应当有Factory、Factory注册池，亦可以考虑直接使用实例、实例注册池</li>
<li>需要利用反射</li>
<li>Factory注册池或Adapter实例注册池需能区分目标类型</li>
</ul>
</li>
<li>需要能够创建（<strong>完整功能应当为管理</strong>）<code>EventSource</code>
<ul>
<li>需可注册 <code>EventSource.Factory</code> 实例</li>
</ul>
</li>
<li>存在一条扩展路径，符合SSE时，走新设计；否则走原Retrofit设计
<ul>
<li>增加入口，例如 <code>RetrofitSSE</code>，承载以上设计，并包含 <code>Retrofit</code></li>
<li>扩展 <code>ServiceMethod&lt;?&gt; loadServiceMethod(Method method)</code>，新增SSE情况的执行路径</li>
<li>扩展 <code>ServiceMethod</code>，内建SSE情况的处理逻辑，即承载设计1、2</li>
</ul>
</li>
</ul>
<p>简要的代码如下：</p>
<h3 id="内建的eventsourcelistener----对应1"><a class="header" href="#内建的eventsourcelistener----对应1">内建的EventSourceListener -- 对应1</a></h3>
<blockquote>
<p>内建选择了Flow，可自行扩展其他，通过回调实现源的更新</p>
</blockquote>
<pre><code class="language-kotlin">class FlowAdapterEventListener(
    val channel: Channel&lt;Event&gt;,
) : EventSourceListener() {

    private val scope: CoroutineScope = CoroutineScope(Dispatchers.IO)

    override fun onEvent(eventSource: EventSource, id: String?, type: String?, data: String) {
        super.onEvent(eventSource, id, type, data)
        scope.launch {
            channel.send(Event(id, type, data))
        }
    }

    override fun onFailure(eventSource: EventSource, t: Throwable?, response: Response?) {
        super.onFailure(eventSource, t, response)
        scope.launch {
            channel.send(
                Event(null, null, "", t)
            )
            channel.close(t)
        }
    }
}
</code></pre>
<h3 id="定义eventsourceadapter----对应2"><a class="header" href="#定义eventsourceadapter----对应2">定义EventSourceAdapter -- 对应2</a></h3>
<pre><code class="language-kotlin">interface EventSourceAdapter&lt;T&gt; {
    fun adapt(request: Request, factory: EventSource.Factory): T

    abstract class Factory {
        abstract operator fun get(
            returnType: Type, annotations: Array&lt;Annotation&gt;, retrofitSSE: RetrofitSSE
        ): EventSourceAdapter&lt;*&gt;?
    }
}
</code></pre>
<h3 id="内建eventsourceadapter-和-factory----对应2"><a class="header" href="#内建eventsourceadapter-和-factory----对应2">内建EventSourceAdapter 和 Factory -- 对应2</a></h3>
<p>这是一个示例，以内建选择的Flow情况为例，展示Factory能区分目标类型，
Factory注册池遍历执行至非NULL返回时，认为得到目标类型的Factory</p>
<pre><code class="language-kotlin">class FlowAdapter : EventSourceAdapter&lt;Flow&lt;Event&gt;&gt; {

        override fun adapt(request: Request, factory: EventSource.Factory): Flow&lt;Event&gt; {

            val channel = Channel&lt;Event&gt;()
            return channel.receiveAsFlow()
                .shareIn(CoroutineScope(Dispatchers.IO), SharingStarted.Eagerly)
                .onSubscription {
                    factory.newEventSource(
                        request, FlowAdapterEventListener(channel)
                    )
                }
        }

        companion object {

            val Factory = object : Factory() {
                override fun get(
                    returnType: Type,
                    annotations: Array&lt;Annotation&gt;,
                    retrofitSSE: RetrofitSSE
                ): EventSourceAdapter&lt;*&gt;? {
                    if (Flow::class.java.isAssignableFrom(getRawType(returnType))) {
                        return FlowAdapter()
                    }
                    return null
                }

            }
        }
    }
</code></pre>
<h3 id="servicemethod扩展以及路径"><a class="header" href="#servicemethod扩展以及路径">ServiceMethod扩展以及路径</a></h3>
<p>新路径：</p>
<pre><code class="language-Java">abstract class ServiceMethodV2&lt;T&gt; extends ServiceMethod&lt;T&gt; {

    static &lt;T&gt; ServiceMethod&lt;T&gt; parseAnnotationsV2(RetrofitSSE retrofit, Method method) {
        RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit.retrofit, method);

        Type returnType = method.getGenericReturnType();
        if (Utils.hasUnresolvableType(returnType)) {
            throw methodError(/*ignore*/);
        }
        if (returnType == void.class) {
            throw methodError(method, "Service methods cannot return void.");
        }

        return HttpServiceMethodV2.parseAnnotations(retrofit, method, requestFactory);
    }
}
</code></pre>
<blockquote>
<p>扩展 <code>ServiceMethod</code>，内建SSE情况的处理逻辑，即承载设计1、2</p>
</blockquote>
<p>详见：<code>HttpServiceMethodV2</code>，代码较多，不做展开,当满足SSE情况时，走新逻辑，否则回归至 <code>HttpServiceMethod#parseAnnotations</code></p>
<h3 id="新入口"><a class="header" href="#新入口">新入口</a></h3>
<blockquote>
<ul>
<li>具备EventSource.Factory注册</li>
<li>具备EventSourceAdapter.Factory池，以及识别目标的能力</li>
<li>走新逻辑：<code>ServiceMethodV2.parseAnnotationsV2(this, method)</code></li>
</ul>
</blockquote>
<pre><code class="language-Java">
public final class RetrofitSSE {
    private final Map&lt;Method, ServiceMethod&lt;?&gt;&gt; serviceMethodCache = new ConcurrentHashMap&lt;&gt;();

    final Retrofit retrofit;

    @NotNull
    final EventSource.Factory eventSourceFactory;

    final List&lt;EventSourceAdapter.Factory&gt; eventSourceAdapterFactories = new ArrayList&lt;&gt;();

    public RetrofitSSE(Retrofit retrofit, @NotNull EventSource.Factory eventSourceFactory) {
        this.retrofit = retrofit;
        this.eventSourceFactory = eventSourceFactory;
    }


    @SuppressWarnings("unchecked") // Single-interface proxy creation guarded by parameter safety.
    public &lt;T&gt; T create(final Class&lt;T&gt; service) {
        //ignore
    }

    public RetrofitSSE addEventSourceAdapterFactory(EventSourceAdapter.Factory factory) {
        eventSourceAdapterFactories.add(Objects.requireNonNull(factory, "factory == null"));
        return this;
    }

    ServiceMethod&lt;?&gt; loadServiceMethod(Method method) {
        ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);
        if (result != null) return result;

        synchronized (serviceMethodCache) {
            result = serviceMethodCache.get(method);
            if (result == null) {
                result = ServiceMethodV2.parseAnnotationsV2(this, method);
                serviceMethodCache.put(method, result);
            }
        }
        return result;
    }


    public EventSourceAdapter&lt;?&gt; eventSourceAdapter(Type returnType, Annotation[] annotations) {
        return nextEventSourceAdapter(null, returnType, annotations);
    }


    public EventSourceAdapter&lt;?&gt; nextEventSourceAdapter(
            @Nullable EventSourceAdapter.Factory skipPast, Type returnType, Annotation[] annotations) {
        Objects.requireNonNull(returnType, "returnType == null");
        Objects.requireNonNull(annotations, "annotations == null");

        int start = eventSourceAdapterFactories.indexOf(skipPast) + 1;
        for (int i = start, count = eventSourceAdapterFactories.size(); i &lt; count; i++) {
            EventSourceAdapter&lt;?&gt; adapter = eventSourceAdapterFactories.get(i).get(returnType, annotations, this);
            if (adapter != null) {
                return adapter;
            }
        }

        throw new IllegalArgumentException(/*ignore*/);
    }
}

</code></pre>
<p><em>作者按：更多的代码细节，还请移步 <a href="https://github.com/leobert-lan/SSE-android-Demo">代码仓库</a> 需切换到 <code>retrofit-sse</code> 分支！</em></p>
<h2 id="结语-13"><a class="header" href="#结语-13">结语</a></h2>
<p>又到了说再见的时候，这篇文章中，我们一同完成了：</p>
<ul>
<li>获取服务端长耗时任务结果的常见实践方式的归纳</li>
<li>对SSE进行了详细的讨论，尤其是其协议细节</li>
<li>搭建SSE服务端、使用OKHttp搭建客户端，进行实操</li>
<li>对Retrofit进行了分析，探讨并发现了一条扩展路径，可通过Retrofit使用SSE</li>
</ul>
<p><strong>应当是一次有趣、好玩的历程！</strong></p>
<p>在结尾，还是再次提醒，<a href="https://github.com/leobert-lan/SSE-android-Demo">代码仓库</a> 中Retrofit-SSE的代码，并未经过严谨的设计论证并进行充分的测试，
我仅花费了数小时时间实现博客内容所需的最少设计，势必会存在BUG和设计不健全的内容，<strong>不要直接商用，以免影响绩效</strong>。</p>
<p>汇总链接如下：</p>
<p><a href="https://html.spec.whatwg.org/multipage/server-sent-events.html">SSE协议内容扩展阅读</a></p>
<p><a href="https://www.rfc-editor.org/rfc/rfc5234">ABNF语法RFC</a></p>
<p><a href="https://github.com/leobert-lan/SSE-android-Demo">服务端 SSE demo代码仓库</a></p>
<p><a href="https://github.com/square/retrofit/issues/1029">Retrofit关于SSE的讨论issue</a></p>
<p><a href="https://github.com/leobert-lan/SSE-android-Demo">Android代码仓库</a> 注意分支</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="datastructure"><a class="header" href="#datastructure">DataStructure</a></h3>
<p>数据结构温习</p>
<div style="break-before: page; page-break-before: always;"></div><p>温故：线性表|数据结构</p>
<p>对 数据结构 - <code>线性表</code> 进行温故，以期获新知</p>
<blockquote>
<p>温故系列是我尝试的一种新学习总结方式，在 <code>阅历增长</code>时，总结旧闻，以 <code>期获</code> 新知，并不断迭代。<a href="https://github.com/leobert-lan/Blog/blob/main/info/%E5%85%B3%E4%BA%8E%E6%B8%A9%E6%95%85%E7%B3%BB%E5%88%97.md">了解更多</a></p>
<p>本次温故时间：2021年3月</p>
</blockquote>
<blockquote>
<p>注：<em>部分图片来自网络检索，未找到出处，内容仅供学习，如有侵权，可留言联系 <code>要求删除</code> 或者 <code>要求指明出处</code></em></p>
</blockquote>
<h2 id="基本概念"><a class="header" href="#基本概念">基本概念</a></h2>
<p><code>线性表</code> ，全名为 <code>线性存储结构</code>，是一种 <code>有序数据项</code> 的 <code>集合</code>，其中每个数据项都有 <code>唯一</code> 的 <code>前驱</code> 和 <code>后继</code>，
<em>注意：第一个没有前驱，最后一个没有后继</em>。</p>
<p>新数据项加入到数据集中时，只会加入到原有某个数据项 <code>之前</code> 或者 <code>之后</code></p>
<p><img src="Review/DataStructure/./%E6%B8%A9%E6%95%85%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8/table1.gif" alt="table1" /></p>
<p>从上图我们可以理解，线性表是<code>将数据项串起来</code> 之后 <code>存入物理空间</code> 的一种数据结构。</p>
<p><img src="Review/DataStructure/./%E6%B8%A9%E6%95%85%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8/table2.gif" alt="table1" /></p>
<p>不同的存储方式，衍生出两种实现方式：</p>
<ul>
<li>将数据 <code>依次存储</code> 在 <code>连续的整块</code> 物理空间中，是 <code>顺序存储结构</code> 又称 <code>顺序表</code>；</li>
<li>将数据 <code>分散存储</code> 在物理空间中，并能够存储数据项之间的 <code>前、后驱</code> 关系，是 <code>链式存储结构</code> ，又称 <code>链表</code>；</li>
</ul>
<h2 id="顺序表"><a class="header" href="#顺序表">顺序表</a></h2>
<p>其性质可以直接对应到 <code>数组</code>，具有随机读写能力，使用需要先初始化，获取 <code>整块的存储空间</code>，如果使用中需要扩容，
则需要先分配一块新的存储空间，并进行内容复制。</p>
<h2 id="链表"><a class="header" href="#链表">链表</a></h2>
<p>普通链表又称单链表，用于存储逻辑关系为 "一对一" 的数据。</p>
<p>与顺序表不同，链表不限制数据的物理存储状态，即数据项的物理存储位置是随机的。</p>
<p>每个 <code>节点</code> 对应一个数据项，包含了两部分信息：</p>
<ul>
<li>数据元素本身，其所在的区域称为 <code>数据域</code>；</li>
<li>指向 <code>直接后继元素</code> 的指针，所在的区域称为 <code>指针域</code>；</li>
</ul>
<p><code>头指针</code> ：一个普通的指针，它的特点是永远指向链表第一个节点的位置。</p>
<p><code>头节点</code> ：一个 <code>不存任何数据</code> 的空节点。不是必须的，但可以解决一些实际问题：</p>
<ul>
<li>链表数据变动时，需要维护 <code>链表的引用地址</code> 即 <code>头指针</code> 的问题</li>
<li>遍历时，不需要对第一个节点进行特殊处理</li>
</ul>
<p><code>首元节点</code> ：链表中第一个存有数据的节点为首元节点。</p>
<h2 id="静态链表"><a class="header" href="#静态链表">静态链表</a></h2>
<p>比较早期的时候，并不能像C语言那样灵活的操作指针，于是用 <code>数组代替指针</code> 来描述单链表。
这种用数组描述的链表叫做静态链表，这种描述方法叫做 <code>游标实现法</code>。</p>
<h2 id="算法题小练手"><a class="header" href="#算法题小练手">算法题小练手</a></h2>
<p>206.<a href="https://leetcode-cn.com/problems/reverse-linked-list/">反转链表</a></p>
<blockquote>
<p>反转一个单链表。</p>
</blockquote>
<p>示例:</p>
<pre><code>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL
</code></pre>
<blockquote>
<p>进阶:
你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p>
</blockquote>
<p>来源：力扣（LeetCode）</p>
<p>迭代思路：遍历整个链表，将每个节点的next指向前驱，返回链表的尾端节点即可。</p>
<pre><code class="language-java">public ListNode reverseList(ListNode head) {
    ListNode prev = null;
    ListNode curr = head;
    ListNode tmp = null;
    while (curr != null) {
        tmp = curr.next;
        curr.next = prev;
        prev = curr;
        curr = tmp;
    }
    return prev;
}
</code></pre>
<p>递归思路：
<code>递</code>： 将结点的 <code>后继</code> 作为 新的链表头节点，调用reverseList，直到进行到原始链表的尾端时，即 node.next 为 null 时。此时开始归，返回新链表头节点</p>
<p><code>归</code>：归的过程中，反转链表的方向，设原先有 <code>a.next = b</code>, 现在需要转变为 <code>b.next = a</code>, 即 <code>a.next.next = a</code>,</p>
<p>边界问题：</p>
<ul>
<li>因为是在归中处理，所以相当于是从 <code>原链表尾端</code> 开始处理反转，开始位置不用担心</li>
<li>结束位置需要注意，必须将其的 next 改为 null，即 a.next = null</li>
</ul>
<p>我们再用数学归纳法复盘一下：令长度为l （L的小写，部分字体下看起来像数字1，特此说明），原链表头结点为head</p>
<ul>
<li>当l=0时，直接返回null，head也是null</li>
<li>当l=1时，直接返回head</li>
<li>当l=2时：
<ul>
<li>取head的next，作为新链表先进入处理，返回结果即newHead，新链表长度l=1，直接返回了,确实是期望的反转链表的头节点</li>
<li>反转两者(即 head 与 head.next)前后驱关系，head.next.next = head，处理head的next 为 null</li>
<li>返回newHead</li>
</ul>
</li>
<li>当l=3时：
<ul>
<li>取head的next，作为新链表先进入处理，返回的newHead 是期望的 <code>反转链表的头结点</code></li>
<li>处理head 与 head.next 的前后驱关系，head.next.next = head，处理head的next 为 null</li>
<li>返回newHead</li>
</ul>
</li>
</ul>
<p>......</p>
<ul>
<li>当l=n，n&gt;3时：
<ul>
<li>取head的next，作为新链表先进入处理，返回的newHead 是期望的 <code>反转链表的头结点</code></li>
<li>处理head 与 head.next 的前后驱关系，head.next.next = head，处理head的next 为 null</li>
<li>返回newHead</li>
</ul>
</li>
<li>当l=n+1,n&gt;3时：
<ul>
<li>取head的next，作为新链表先进入处理，返回的newHead 是期望的 <code>反转链表的头结点</code></li>
<li>处理head 与 head.next 的前后驱关系，head.next.next = head，处理head的next 为 null</li>
<li>返回newHead</li>
</ul>
</li>
</ul>
<p>我们依据数学归纳法，得出：l=0或l=1时，返回head，l &gt;= 2时，处理方式一致，<em>不再誊写</em></p>
<pre><code class="language-java">public ListNode reverseList(ListNode head) {
    //l=0时，head为null；l=1时，head.next 为null。 均直接返回head，归的特殊处理
    if (head == null || head.next == null) {
        return head;
    }
    //递
    ListNode newHead = reverseList(head.next);
    
    //归的处理
    //反转 head 与 head.next 的前后驱关系
    head.next.next = head;
    head.next = null;
    
    //返回newHead
    return newHead;
}
</code></pre>
<h2 id="温故总结"><a class="header" href="#温故总结">温故总结</a></h2>
<p>作为比较基础的内容，在更复杂的数据结构中，线性表可能会作为底层实现。在实际应用中，我们用到 <code>单链表</code> 的地方不会太多。</p>
<p>在算法练手环节中，突然发现一个 <code>很趁手</code> 的东西，以为考虑 <code>递归实现</code> 思路时，我总是要非常仔细的思考边界问题。</p>
<blockquote>
<p>但这次突然发现，若能够 <code>被递归实现</code>，一定可以用 <code>数学归纳法</code> 论证 <code>做法的正确性</code>，推导过程可以 <code>完善地</code> 讨论边界问题。
并且其推导过程非常 <code>人性化</code>。</p>
</blockquote>
<p>这篇内容很短，就到此结束了。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="温故栈数据结构"><a class="header" href="#温故栈数据结构">温故：栈|数据结构</a></h1>
<p>对数据结构-栈进行温故，以期获新知</p>
<blockquote>
<p>温故系列是我尝试的一种新学习总结方式，在 <code>阅历增长</code>时，总结旧闻，以 <code>期获</code> 新知，并不断迭代。<a href="https://github.com/leobert-lan/Blog/blob/main/info/%E5%85%B3%E4%BA%8E%E6%B8%A9%E6%95%85%E7%B3%BB%E5%88%97.md">了解更多</a></p>
<p>本次温故时间：2021年3月</p>
</blockquote>
<h2 id="基本概念-1"><a class="header" href="#基本概念-1">基本概念</a></h2>
<p>目的：存储逻辑关系为 <code>一对一</code> 的数据</p>
<p>特性：出口和入口一致，<code>后进先出、先进后出</code>，先行存储结构</p>
<p>定义：栈是一种只能从表的一端存取数据且遵循 "先进后出" 原则的 <code>线性存储结构</code>。</p>
<p><img src="Review/DataStructure/./%E6%B8%A9%E6%95%85%EF%BC%9A%E6%A0%88/stack.gif" alt="stack" /></p>
<p>操作：</p>
<ul>
<li>向栈中添加数据，即 <code>进栈</code> 、 <code>入栈</code> 、 <code>压栈</code>, 从栈顶进</li>
<li>从栈中取出数据，即 <code>出栈</code>，从栈顶出</li>
</ul>
<h3 id="线性存储结构"><a class="header" href="#线性存储结构">线性存储结构</a></h3>
<p>线性结构是一种 <code>有序数据项</code> 的 <code>集合</code>，其中每个数据项都有 <code>唯一</code> 的 <code>前驱</code> 和 <code>后继</code>，
<em>注意：第一个没有前驱，最后一个没有后继</em>。</p>
<p>新数据项加入到数据集中时，只会加入到原有某个数据项 <code>之前</code> 或者 <code>之后</code></p>
<hr />
<p>实现思路有两种：</p>
<ul>
<li>顺序栈</li>
<li>链栈</li>
</ul>
<p>区别在于：数据项存放的相对位置，顺序栈用 <code>数组</code> 作为底层实现，而链栈使用 <code>链表</code> 作为底层实现。</p>
<h2 id="jdk中的实现"><a class="header" href="#jdk中的实现">JDK中的实现</a></h2>
<pre><code class="language-java">public class Stack&lt;E&gt; extends Vector&lt;E&gt; {
    public Stack() {
    }

    public E push(E item) {
        addElement(item);

        return item;
    }

    public synchronized E pop() {
        E       obj;
        int     len = size();

        obj = peek();
        removeElementAt(len - 1);

        return obj;
    }

    public synchronized E peek() {
        int     len = size();

        if (len == 0)
            throw new EmptyStackException();
        return elementAt(len - 1);
    }

    public boolean empty() {
        return size() == 0;
    }

    public synchronized int search(Object o) {
        int i = lastIndexOf(o);

        if (i &gt;= 0) {
            return size() - i;
        }
        return -1;
    }
}
</code></pre>
<p>直接建立在Vector上，细节忽略。</p>
<h2 id="应用场景脑暴"><a class="header" href="#应用场景脑暴">应用场景脑暴</a></h2>
<ul>
<li>页面浏览特性
<ul>
<li>页面导航，面包屑导航</li>
<li>页面信息存储</li>
</ul>
</li>
<li>分步求解中，中间结果的存取特性满足 <code>后进先出</code> 特性
<ul>
<li>进制转换</li>
<li>括号等成对匹配</li>
</ul>
</li>
</ul>
<p>这些场景下，可以利用栈的特性以简化问题，不是必须（唯一性），也不一定是最佳</p>
<h2 id="算法题练练手"><a class="header" href="#算法题练练手">算法题练练手</a></h2>
<p>从LeetCode挑选两道算法题，简单练练手。</p>
<h3 id="简单题有效的括号"><a class="header" href="#简单题有效的括号">简单题：<a href="https://leetcode-cn.com/problems/valid-parentheses/">有效的括号</a></a></h3>
<p>给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<pre><code>左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
</code></pre>
<p>示例 1：</p>
<pre><code>输入：s = "()"
输出：true
</code></pre>
<p>示例 2：</p>
<pre><code>输入：s = "()[]{}"
输出：true
</code></pre>
<p>示例 3：</p>
<pre><code>输入：s = "(]"
输出：false
</code></pre>
<p>示例 4：</p>
<pre><code>输入：s = "([)]"
输出：false
</code></pre>
<p>示例 5：</p>
<pre><code>输入：s = "{[]}"
输出：true
</code></pre>
<p>提示：</p>
<pre><code>1 &lt;= s.length &lt;= 10,000 (注:原内容为10的4次方)
s 仅由括号 '()[]{}' 组成
</code></pre>
<p><em>来源：力扣（LeetCode</em>
<em>链接：https://leetcode-cn.com/problems/valid-parentheses 著作权归领扣网络所有。</em></p>
<p>读完题目之后，我们可以发现，</p>
<ul>
<li>需要从左到右遍历整个字符串，并且匹配成对的括号</li>
<li>发现 <code>左括号</code> 时，需要先作为 <code>中间结果</code></li>
<li>当发现 <code>右括号</code> 时，检查 <code>中间结果</code> 中 <code>最新</code> 的左括号是否对应:
<ul>
<li>如果不存在左括号、或者不对应，则非法</li>
<li>如果对应，则从 <code>中间结果</code> 中移除。</li>
</ul>
</li>
<li>遍历完后，<code>中间结果</code> 被完全匹配，则合法。</li>
</ul>
<p>中间结果的存取要求非常符合 <code>栈</code> 的功能特性。</p>
<pre><code class="language-java">static public class Q20 {
        private static final Map&lt;Character, Character&gt; map = new HashMap&lt;Character, Character&gt;() {{
            put('{', '}');
            put('[', ']');
            put('(', ')');
        }};

        public static boolean isValid(String s) {
            final int length = s.length();

            if (length % 2 == 1) //奇数一定不匹配，快速失败
                return false;

            final Stack&lt;Character&gt; stack = new Stack&lt;&gt;();

            for (int i = 0; i &lt; length; i++) {
                Character c = s.charAt(i);
                if (map.containsKey(c)) { //左括号存入栈
                    stack.push(c);
                } else { //右括号处理
                    // 如果不存在左括号、或者不对应，则非法
                    if (stack.isEmpty() /*右边括号多余或者先于对应的左括号*/
                            || c != map.get(stack.pop()) /*类型不匹配*/
                    )
                        return false;
                }
            }

            // 遍历完后，栈中的左括号被完全匹配，则合法。
            return stack.isEmpty();
        }
    }
</code></pre>
<h3 id="中等题-行星碰撞"><a class="header" href="#中等题-行星碰撞">中等题： <a href="https://leetcode-cn.com/problems/asteroid-collision/">行星碰撞</a></a></h3>
<blockquote>
<p>给定一个整数数组 <code>asteroids</code>，表示在同一行的行星。</p>
<p>对于数组中的每一个元素，其绝对值表示行星的大小，正负表示行星的移动方向（正表示向右移动，负表示向左移动）。每一颗行星以相同的速度移动。</p>
<p>找出碰撞后剩下的所有行星。碰撞规则：两个行星相互碰撞，较小的行星会爆炸。如果两颗行星大小相同，则两颗行星都会爆炸。两颗移动方向相同的行星，永远不会发生碰撞。</p>
</blockquote>
<p>示例 1：</p>
<pre><code>输入：asteroids = [5,10,-5]
输出：[5,10]
解释：10 和 -5 碰撞后只剩下 10 。 5 和 10 永远不会发生碰撞。
</code></pre>
<p>示例 2：</p>
<pre><code>输入：asteroids = [8,-8]
输出：[]
解释：8 和 -8 碰撞后，两者都发生爆炸。
</code></pre>
<p>示例 3：</p>
<pre><code>输入：asteroids = [10,2,-5]
输出：[10]
解释：2 和 -5 发生碰撞后剩下 -5 。10 和 -5 发生碰撞后剩下 10 。
</code></pre>
<p>示例 4：</p>
<pre><code>输入：asteroids = [-2,-1,1,2]
输出：[-2,-1,1,2]
解释：-2 和 -1 向左移动，而 1 和 2 向右移动。 由于移动方向相同的行星不会发生碰撞，
所以最终没有行星发生碰撞。
</code></pre>
<pre><code>提示：
    2 &lt;= asteroids.length &lt;= 10,000 (注:原内容为10的4次方)
    -1000 &lt;= asteroids[i] &lt;= 1000
    asteroids[i] != 0
</code></pre>
<p>来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/asteroid-collision
著作权归领扣网络所有。</p>
<p>读题之后呢,我们发现这是一个需要 <code>分步求解</code> ，中间结果满足 <code>后进先出</code> 的问题。</p>
<p>思考方向有两个，对于一颗行星：</p>
<ul>
<li>考虑它被撞击的问题</li>
<li>考虑它撞击别人的问题</li>
</ul>
<p>揪着一个思路去处理即可，不要 <code>反复横跳</code>。</p>
<p>采用 <code>考虑它撞击别人的问题</code> 这一思路开始，考虑下完整思路。</p>
<ul>
<li>定义栈A，用于存储幸存的行星</li>
<li>从 <code>asteroids</code> 按序取出行星 ast，</li>
<li><code>碰撞问题</code>：考虑 ast 与 A 中的行星可能发生的碰撞 (从栈头到栈尾)
<ul>
<li>如果无碰撞，则入栈</li>
<li>如果有碰撞，又分为3种可能
<ul>
<li>ast 赢了, A栈头的行星需要出栈，继续考虑 <code>碰撞问题</code></li>
<li>ast 输了，从 <code>asteroids</code> 取下一个行星（如果不存在，则整个过程结束），继续考虑 <code>碰撞问题</code></li>
<li>同归于尽，A栈头的行星需要出栈，从 <code>asteroids</code> 取下一个行星（如果不存在，则整个过程结束），继续考虑 <code>碰撞问题</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>我们将这一过程实现：</p>
<pre><code class="language-java">static public class Q735 {
    
  public static int[] asteroidCollision(int[] asteroids) {
    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();

    int i = 0;
    final int size = asteroids.length;
    int top;

    while (i &lt; size) {

      int target = asteroids[i];
      //init as -1 mask it not crash
      int crashResult = -1;

      // + &amp; - will crash
      while (!stack.isEmpty() &amp;&amp; stack.peek() &gt; 0 &amp;&amp; target &lt; 0) {
        top = stack.peek();

        crashResult = top + target;
        //handle crash
        // crash has 3 result:
        // positive: the target lost, next round
        // zero: both lost, next round
        // negative: left lost, if the top of current stack is positive, *if exist*, will crash
        // or just push into stack

        if (crashResult == 0) {
          //both lost
          stack.pop();
          //break the loop
          break;
        } else if (crashResult &lt; 0) {
          //target win
          stack.pop();
        } else {
          break;
        }
      }

      // target win all or won't crash,push into stack
      if (crashResult &lt; 0)
        stack.push(target);
      i++;
    }

    i = stack.size();
    int[] ret = new int[i];
    while (i &gt; 0) {
      ret[i - 1] = stack.pop();
      i--;
    }

    return ret;
  }
}
</code></pre>
<p>这样实现会写出很长的代码。如果结合 <code>for循环</code> 和 <code>label</code>，就可以 <code>直译</code> 我们的思路：</p>
<pre><code class="language-java">static public class Q735 {
  //来源：力扣（LeetCode）
  //链接：https://leetcode-cn.com/problems/asteroid-collision
  //著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
  public static int[] asteroidCollision(int[] asteroids) {
    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
    for (int ast : asteroids) {
      collision:
      {
        while (!stack.isEmpty() &amp;&amp; ast &lt; 0 &amp;&amp; 0 &lt; stack.peek()) {
          if (stack.peek() &lt; -ast) {
            stack.pop();
            continue;
          } else if (stack.peek() == -ast) {
            stack.pop();
          }
          break collision;
        }
        stack.push(ast);
      }
    }

    int[] ans = new int[stack.size()];
    for (int t = ans.length - 1; t &gt;= 0; --t) {
      ans[t] = stack.pop();
    }
    return ans;
  }
}
</code></pre>
<h2 id="温故总结-1"><a class="header" href="#温故总结-1">温故总结</a></h2>
<p>栈在底层使用较多，上层业务中，使用场景不是太多。需要用到 <code>线性存储结构</code> 来存贮 <code>中间过程值</code>，并且使用时满足 <code>后进先出</code>，就可以考虑使用栈。</p>
<p>以后在业务开发中，可以多加留心，注意是否可以利用栈简化业务。本篇就到此结束了。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="温故队列数据结构"><a class="header" href="#温故队列数据结构">温故：队列|数据结构</a></h1>
<p>本文将对 数据结构 - <code>队列</code> 进行温故、总结要点、算法题练手，以期获新知。</p>
<p>读者可以借本文反视对队列知识的掌握程度，或者在本文基础上，收集资料加深学习。</p>
<blockquote>
<p>温故系列是我尝试的一种新学习总结方式，在 <code>阅历增长</code>时，总结旧闻，以 <code>期获</code> 新知，并不断迭代。<a href="https://github.com/leobert-lan/Blog/blob/main/info/%E5%85%B3%E4%BA%8E%E6%B8%A9%E6%95%85%E7%B3%BB%E5%88%97.md">了解更多</a></p>
<p>本次温故时间：2021年3月</p>
</blockquote>
<p>队列，和 <a href="https://github.com/leobert-lan/Blog/blob/main/Review/DataStructure/%E6%B8%A9%E6%95%85%EF%BC%9A%E6%A0%88%7C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20--%202021.md">栈</a> 类似,
也是一种 <a href="https://github.com/leobert-lan/Blog/blob/main/Review/DataStructure/%E6%B8%A9%E6%95%85%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8%7C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20--%202021.md">线性存储结构</a> ，
不同的是，队列的数据项存取方式，队列是两端 <code>开口</code> 的，从数据从一端进入，从另一端取出。</p>
<blockquote>
<p>进入的一端被称为 <code>队尾</code>，取出的一端被称为 <code>队头</code>，存入数据的行为称为 <code>入队</code>，取出数据的行为称为 <code>出队</code>。</p>
</blockquote>
<p>不难理解，这是一种 <code>先进先出</code> 的线性存储结构。</p>
<p>和栈类似，实现方式也存在两种：</p>
<ul>
<li>顺序队列：在顺序表的基础上实现的队列结构</li>
<li>链队列：在链表的基础上实现的队列结构</li>
</ul>
<p><em>Android中的消息队列，就是链队列</em></p>
<p>在Java中，队列对应 <code>java.util.Queue</code></p>
<pre><code class="language-java">public interface Queue&lt;E&gt; extends Collection&lt;E&gt; {
    boolean add(E e);

    boolean offer(E e);

    E remove();

    E poll();

    E element();

    E peek();
}
</code></pre>
<ul>
<li>offer，add：达到容量上限时，继续尝试入队时，<code>add</code> 会抛出异常，<code>offer</code> 返回 false</li>
<li>poll，remove：空集时，<code>remove</code> 会抛出异常，<code>poll</code> 返回 null</li>
<li>peek，element：空集时 <code>element</code> 会抛出异常，<code>peek</code> 返回null</li>
</ul>
<h2 id="算法题练手"><a class="header" href="#算法题练手">算法题练手</a></h2>
<p>我在LeetCode上，搜索了一道和队列相关的题。</p>
<h3 id="和至少为-k-的最短子数组"><a class="header" href="#和至少为-k-的最短子数组"><a href="https://leetcode-cn.com/problems/shortest-subarray-with-sum-at-least-k/">和至少为 K 的最短子数组</a></a></h3>
<p>返回 A 的最短的非空连续子数组的长度，该子数组的和至少为 K 。</p>
<p>如果没有和至少为 K 的非空子数组，返回 -1 。</p>
<p>示例 1：</p>
<pre><code>输入：A = [1], K = 1
输出：1
</code></pre>
<p>示例 2：</p>
<pre><code>输入：A = [1,2], K = 4
输出：-1
</code></pre>
<p>示例 3：</p>
<pre><code>输入：A = [2,-1,2], K = 3
输出：3
</code></pre>
<p>提示：</p>
<pre><code>1 &lt;= A.length &lt;= 50000
-10 ^ 5 &lt;= A[i] &lt;= 10 ^ 5
1 &lt;= K &lt;= 10 ^ 9
</code></pre>
<p>来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/shortest-subarray-with-sum-at-least-k</p>
<p>乍一看到这个题目，我也有点慌，没啥思路。</p>
<p>但是没关系，我们假设存在一个算法S，可以处理这个问题。从比较基本的情况找到可行的处理方式，并利用数学归纳法进行证明。然后在实现算法。</p>
<p>按照题意，<code>需要寻找非空子数组，其和&gt;=K</code> , 设函数 F(s,e) = ∑<sub>s</sub><sup>e</sup>A[i], s,e 满足 0≤s≤e≤A.length。</p>
<p>并且我们用其代表对于的子数组。</p>
<p>我们先找到所有的子数组。</p>
<p>当length为</p>
<ul>
<li>1 时，子数组 1个，F(0,0)</li>
<li>2 时，子数组 3个，F(0,0),F(1,1),F(0,1)</li>
<li>3 时，子数组 6个，F(0,0),F(1,1),F(2,2)，F(0,1),F(1,2),F(0,2)</li>
<li>...</li>
<li>n 时，子数组 (n+1)(n)/2 个</li>
</ul>
<p>不难理解，长度为n时，<em>n&gt;0</em>，长度为 <code>a</code> 的子数组个数为 n-a+1 个，我们把a的所有取值情况都考虑进去，就可以得到所有的子数组，<em>空数组不计</em>， 这实在是太简单了，我们不再使用数学归纳法论证。</p>
<p>我们先通过一次遍历，得到一组基础情况：</p>
<pre><code>F(0,0),F(0,1),F(0,2),...,F(0,n-1)
</code></pre>
<p>在此基础上，我们可以得到</p>
<pre><code>       F(1,1),F(1,2),...,F(1,n-1)
</code></pre>
<pre><code>              F(2,2),...,F(2,n-1)
</code></pre>
<p>...</p>
<pre><code>                         F(n-1,n-1)
</code></pre>
<p>不难理解，做法就是遍历 A[i],并在原先的基础上减掉对应值。</p>
<p>下面的代码，我们就可以得到 <code>基础</code> 情况</p>
<pre><code class="language-java">class Solution {
    public int shortestSubarray(int[] A, int K) {
        int n = A.length;
        //可能会溢出，用long，第一个元素保持为0
        long[] P = new long[n + 1];
        for (int i = 0; i &lt; n; i++) {
            P[i + 1] = P[i] + (long) A[i];
        }

        return -1;
    }
}
</code></pre>
<p>得到每一层数据。</p>
<pre><code class="language-java">class Solution {
    public int shortestSubarray(int[] A, int K) {
        int n = A.length;
        //可能会溢出，用long，第一个元素保持为0
        long[] P = new long[n + 1];
        for (int i = 0; i &lt; n; i++) {
            P[i + 1] = P[i] + (long) A[i];
        }

        // 遍历 得到每一层数据
        for (int i = 1; i &lt; n; i++) {
            for (int j = i; j &lt; n; j++) {
                long tmp = P[j + 1] - A[i - 1];

                P[j + 1] = tmp;
            }
        }


        return -1;
    }
}
</code></pre>
<p>F(s,e) = F(i,j)</p>
<p>ok，我们需要找到映射关系，即 i,j 和前面 s,e 的对应关系。</p>
<p>不难得出: <code>s=i</code>,<code>e=j</code></p>
<p>而F(s,e)，对应的数组长度 len = e-s+1;</p>
<pre><code class="language-java">class Solution {
    public int shortestSubarray(int[] A, int K) {
        int n = A.length;
        int len = n + 1;

        //可能会溢出，用long，第一个元素保持为0
        long[] P = new long[n + 1];
        for (int i = 0; i &lt; n; ++i) {
            long tmp = P[i] + (long) A[i];

            if (tmp &gt;= K) {
                len = Math.min(len, i + 1);
            }

            P[i + 1] = tmp;
        }

        // 遍历 得到每一层数据
        for (int i = 1; i &lt; n; i++) {
            for (int j = i; j &lt; n; j++) {
                long tmp = P[j + 1] - A[i - 1];
                if (tmp &gt;= K) {
                    len = Math.min(len, j - i + 1);
                }

                P[j + 1] = tmp;
            }
        }

        if (len &gt; n)
            return -1;
        return len;
    }
}
</code></pre>
<p><code>居然。。没有用到队列！！！</code></p>
<p>然而现实比较残酷，这个解法 <code>超出了时间限制</code>，跪在了 84/93 用例上</p>
<p>那就想想如果减少计算次数吧:</p>
<pre><code>f(i,j) 还有一种求法，f(0,j)-f(0,i-1),即 P[j+1]-P[i]
</code></pre>
<p>但也仅多通过了一个用例。</p>
<hr />
<p>仔细思考了一下，力大砖飞法为什么不能通过 <code>时间限制</code>？因为这个方法中，进行了 <code>全计算</code>。</p>
<p>我们先做一个假设：数组中全是正数。</p>
<p>那么从下标s开始，对下标i=s开始递增，一旦找到下标e满足 <code>F(s,e)&gt;=K</code> ,那么就没有必要再对i进行递增了。</p>
<p>再回到我们的题目中，我们已近先计算了一组 <code>基础数据</code> : P[]，而且前面我们发现了，利用 <code>基础数据</code> 本身，以及 <code>减法计算</code> ，可以表达整个数组的任意 <code>非空子数组</code>。</p>
<p>那么,这个问题从</p>
<blockquote>
<p>"在&lt;s,e&gt; 满足F(s,e)&gt;=K 条件的集合中，寻找 e-s的最小值"</p>
</blockquote>
<p>转变成了：</p>
<blockquote>
<p>在&lt;s,e&gt; 满足P[e+1]-P[s]&gt;=K 条件的集合中，寻找 e-s的最小值</p>
</blockquote>
<p>经过这一步转化，就可以运用数学定理减少计算了。</p>
<p>因为有负数的存在，在P[] 中，其 <code>元素值</code> 并<code>不是</code> 随着 <code>下标</code> 而 <code>单调递增</code> 的。</p>
<p>采用示例3：输入：A = [2,-1,2], K = 3</p>
<p>那么P[] = [0,2,1,3]</p>
<p>我们发现，它不是单调递增的，但是这里有一个规律：</p>
<p>P[3]-P[2] &gt; P[3]-P[1]</p>
<p>即，3-1 &gt; 3-2</p>
<ul>
<li>如果P[3]-P[2] 不满足要求，那么P[3]-P[1]也无法满足要求</li>
<li>如果P[3]-P[2] 满足要求，那么P[3]-P[1] 是否满足已经不再重要，即使满足，长度也更大，而且，<strong>判断是否满足还需要计算，无法直接通过不等式关系推算</strong></li>
</ul>
<p>从这里，我们可以总结出：当P[i]&gt;P[i+1] 时，不需要考虑 F(i,待定) 是否满足要求。</p>
<p>这样我们就把问题简化到了单调情况。即，s的取值范围，仅需要考虑： {0,2,3},因为 P[1]&gt;P[2]</p>
<p>而且，在前面的分析中，发现都是正数的数组时：</p>
<blockquote>
<p>从下标s开始，对下标i=s开始递增，一旦找到下标e满足 <code>F(s,e)&gt;=K</code> ,那么就没有必要再对i进行递增了。</p>
</blockquote>
<p>这一点在存在负数时也同样成立。</p>
<p>稍微打住，直觉告诉我，还有进一步优化的空间，那就是e的取值范围可以进一步缩小。</p>
<p>我们发现 P[2]-P[0] &lt; P[1]-P[0]。所以e不需要考虑为2的情况，取值范围{0,1,3}.</p>
<p>则：&lt;s,e&gt; 仅需要考虑 {&lt;0,0&gt;,&lt;0,1&gt;,&lt;0,3&gt;,&lt;2,3&gt;,&lt;3,3&gt;} 这几种情况。</p>
<p>不难理解：此时再利用 <code>数组结合For循环两组下标的方式</code> 已经无法处理了，有必要引入新的数据结构，利用其特性完成这一任务。</p>
<p>而 <code>双端队列</code> 可以满足这一需求。</p>
<ul>
<li>我们维护一个双端队列 <code>deque</code>，用于存储P的下标，</li>
<li>遍历 P的下标 index</li>
<li>假如index 存入deque尾部，需要保持 <code>deque</code> 所有下标对应的P值单调递增，如果不满足这个要求，则先从尾部移除，直到 <code>deque为空</code> 或者 <code>满足单调递增</code></li>
<li>寻找 index 作为 e 时，满足条件的最适s，<em>即最大s</em>，如果找到，则维护最短的len值； <strong>这里又有一个减少计算的小窍门前面没有明确提到</strong></li>
<li>index 从尾部入队</li>
</ul>
<blockquote>
<p>做法中，提到了一个小技巧：</p>
<p>在前文，我们提到了:从下标s开始，对下标i=s开始递增，一旦找到下标e满足 <code>F(s,e)&gt;=K</code> ,那么就没有必要再对i进行递增了。</p>
<p>这其实是相对的。一旦找到这样一组&lt;s,e&gt;, 当e递增时，s直接从s+1开始考虑即可。</p>
<p>所以这个小技巧就是将 deque 的队头出队</p>
</blockquote>
<pre><code class="language-java">class Solution {
    public int shortestSubarray(int[] A, int K) {
        int n = A.length;
        int len = n + 1;

        //可能会溢出，用long，第一个元素保持为0
        long[] P = new long[n + 1];
        for (int i = 0; i &lt; n; ++i) {
//                long tmp = P[i] + (long) A[i];

            //其实重复了，后面的遍历中也有对应
//                if (tmp &gt;= K) {
//                    len = Math.min(len, i + 1);
//                }

            P[i + 1] = P[i] + (long) A[i];
        }

        final LinkedList&lt;Integer&gt; deque = new LinkedList&lt;&gt;();

        //用前置++ 减少临时变量分配内存消耗时间
        for (int index = 0; index &lt; n + 1; ++index) {
            while (!deque.isEmpty() &amp;&amp; P[deque.getLast()] &gt;= P[index]) {
                deque.removeLast();
            }

            while (!deque.isEmpty() &amp;&amp; P[index] - P[deque.getFirst()] &gt;= K) {
                len = Math.min(len, index - deque.removeFirst());
            }

            deque.add(index);
        }

        if (len &gt; n)
            return -1;
        return len;
    }
}
</code></pre>
<p>修改后通过测试用例。</p>
<h2 id="温故总结-2"><a class="header" href="#温故总结-2">温故总结</a></h2>
<p>队列也是非常常用的数据结构了，其特性需要牢牢掌握。</p>
<p>算法练手阶段出了纰漏，筛选的题目并没有着重于队列的特性。</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="review-1"><a class="header" href="#review-1">Review</a></h3>
<p>年终总结等</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2021年终总结"><a class="header" href="#2021年终总结">2021年终总结</a></h1>
<p>从时间上看，这份总结太滞后了，都快过年了。一来是前阵子又忙又懒，不想再用晚上的时间。二来是我过去一直认为："甩给陌生的读者一份个人年终总结是一个很怪异的行为"。</p>
<p>思来想去终于想开了，<strong>陌生人的年终总结无非是它山之石，用来借鉴、反思，看看是否可以攻玉</strong>，所以在 "面向领导"、"面向自我"的个人总结外，产生了这一篇<strong>面向读者的个人总结</strong>。</p>
<p>回顾2021，这3个方面可能会对读者产生启发：</p>
<ul>
<li>个人知识输出</li>
<li>工作</li>
<li>生活</li>
</ul>
<h2 id="个人知识输出"><a class="header" href="#个人知识输出">个人知识输出</a></h2>
<p>抛开开源项目，在19年开始，我将一些自认为质量还不错的技术类文章投向了郭婶个人运营的公众号，收到的反馈效果还不错，所以19年下半年我决定梳理梳理自身掌握的知识，做一定的深挖之后在社区做知识输出，2020年开始增加输出，2021年对2020年的成果进行反思后进行针对性的调整。</p>
<p>由于我的个性，这将是一件 <strong>纯粹且佛系</strong> 的事情，因为我不想被束缚，所以绝对不会向 "个人品牌" 方向去做，<strong>就是单纯地分享和交流</strong>。</p>
<p>还记得去年除夕的时候，我还在写着博客，鸿神联系到我，表示如果我的文章符合读者群体的话，会联系我转载到公众号，遗憾的是后来都没有刊载😂😂😂。</p>
<p><em>按：截至成稿时，已经实现了从0到1的突破</em></p>
<p>抛开所有的数值指标，谈一谈这件事情的收获。</p>
<h3 id="既定的目标"><a class="header" href="#既定的目标">既定的目标</a></h3>
<p>本身的三个既定目标：</p>
<ul>
<li>总结自己掌握的知识体系，在知识输出的准备过程中，尝试完成一次质变</li>
<li>对读者产生一定的帮助</li>
<li>锻炼自己技术类文章方面的写作技巧</li>
</ul>
<h3 id="总结-6"><a class="header" href="#总结-6">总结</a></h3>
<h4 id="目标一"><a class="header" href="#目标一">目标一</a></h4>
<p>没有达成，因为事情跑偏了，在去年发表的文章中，绝大多数都不是基础知识的总结。</p>
<h4 id="目标二"><a class="header" href="#目标二">目标二</a></h4>
<p>目标达成</p>
<ul>
<li>"三思系列" 的剖析对部分读者起到了认知纠正、激发探索欲的效果；</li>
<li>"好玩系列" 以及相关的开源项目、实践方案也对读者产生了帮助;</li>
</ul>
<p>并且与不少读者进行了交流，其中有字节、快手等知名公司中的中台研发，也有未透露根脚但功力深厚的研发人员，
在交流的过程中，也提升了我的知识深度和广度，<strong>这是超出既定目标的</strong>。</p>
<h4 id="目标三"><a class="header" href="#目标三">目标三</a></h4>
<p>达成60%</p>
<p>不可否认，编写技术类文章是存在技巧的，在面向 <code>不同水平层次的读者受众</code> 讲述 <code>同样的技术点</code> 时需要改变叙述方式和内容侧重点。
它不像写小说必须要拥有与生俱来的天赋，而是可以通过针对性的训练得到提升。</p>
<blockquote>
<p>鉴于公众号的读者基数和受众特性稳定，对比两年的读者互动情况：2020年的文章中，很多读者互动表示"看起来很厉害但是看不懂"，而在2021年的文章中，这一现象逐步消失。
技巧性有提升。</p>
</blockquote>
<p>并且自我意识到：这件事情锻炼了 "结构化思考、结构化输出" 能力，这一能力无论是在生活中还是在工作中都非常重要！想要深入了解的读者可以选择阅读 《金字塔原理》这本书。</p>
<h2 id="工作"><a class="header" href="#工作">工作</a></h2>
<p>读者朋友们可能要好奇了，怎么在工作方面写出面向读者的总结性内容呢？真的不是炫耀性质的水文吗？</p>
<p><em>可能有读者朋友还记得我在之前文章中提到过："我今年跳槽了", 不是大家耳熟能详的公司，而是从互联网行业跳到了医疗行业，与有荣焉的是在医疗的细分领域中是国内Top1。</em></p>
<p>想分享给各位读者朋友的有 <strong>三点</strong> ：</p>
<ul>
<li><strong>为什么</strong> 选择跳槽、我是 <strong>如何判断</strong> 应该跳槽的</li>
<li>准备过程中进入的 <strong>误区</strong></li>
<li>关于职业生涯成长的一些建议</li>
</ul>
<h3 id="分享1----为什么选择跳槽我是如何判断应该跳槽的"><a class="header" href="#分享1----为什么选择跳槽我是如何判断应该跳槽的">分享1 -- 为什么选择跳槽、我是如何判断应该跳槽的</a></h3>
<blockquote>
<p>为什么选择跳槽、我是如何判断应该跳槽的?</p>
</blockquote>
<p><code>Jack Ma</code> 先生说过员工离职无非：<code>钱少了</code>、<code>心里委屈了</code>，然而这次跳槽的根本原因不是这两点，此时不得不提提老东家了。</p>
<p>老东家的几个标签：</p>
<ul>
<li>创业阶段</li>
<li>资金流稳定且后劲足</li>
<li>摩托车论坛、车库工具、渠道等细分领域TOP1</li>
</ul>
<p>看起来还是很不错的，是有未来的公司，但在2020年我沉下心来做了一次分析，得出惊人的结论："<strong>公司应当把我们这些技术向的员工逐步辞退！</strong>"</p>
<p>大家都明白的道理：公司经营等商业性活动，一切朝 <code>利益</code> 看齐，<strong>如何获得利益就是商业画布的核心</strong>。</p>
<p>笼统地来看提升利益有两种驱动模式：</p>
<ul>
<li>技术驱动</li>
<li>市场驱动</li>
</ul>
<p>互联网企业和传统企业有别，往往只占其中一种。</p>
<p>如果是市场驱动的，那就惨了，往往意味着市场准入性低，护城河很浅，想要成功有两个要素：底蕴和时间优势。</p>
<blockquote>
<p>底蕴：拥有更多的资源，打赢消耗；能够承受更大的损失，把对手带到沟里</p>
<p>时间优势：跑在前面，乘早脱离对手攻击范围</p>
</blockquote>
<p><em>不便过多透露老东家的信息，读者朋友们自行意会</em> 。</p>
<p>不巧的是，老东家恰好是依靠市场驱动的，一切迎合市场，这意味着技术创新等方式无法给公司业绩带来质变，
对于技术向员工而言，<strong>和公司在价值观导向认同上必然存在偏差</strong> 。</p>
<p>从公司长远看，应该壮士断腕！从员工角度看应该避免沉没成本！</p>
<h3 id="分享2----准备过程中进入的误区"><a class="header" href="#分享2----准备过程中进入的误区">分享2 -- 准备过程中进入的误区</a></h3>
<blockquote>
<p>准备过程中进入的误区</p>
</blockquote>
<h4 id="面经之坑"><a class="header" href="#面经之坑">面经之坑</a></h4>
<p>因为曾经收到过来自一线大厂的朋友的邀请，所以准备过程中对算法、基础知识等内容进行了深挖，不可避免的就掉入了"面经"的坑，<strong>越刷越焦虑</strong>！</p>
<p>非常感谢 <a href="https://juejin.cn/post/6844904160337330189">刘洋巴金的这篇文章</a> , 旁观者清，当自己很重视一件事时，容易陷入其中，往往会迷途而不自知。</p>
<p>刷面经有没有用？当然有用！但是它应当作为一面镜子，对自己进行检查，而不是作为灯塔，用来导航。</p>
<blockquote>
<p>吾生也，有涯；而知也，无涯；以有涯逐无涯，殆矣。</p>
</blockquote>
<p>一个优秀的程序员应当有：</p>
<ul>
<li>清晰的头脑</li>
<li>缜密的思维</li>
<li>敏锐的直觉</li>
<li>专业的知识</li>
<li>全面的认知</li>
<li>自信、自信、自信</li>
</ul>
<p><strong>疯狂地</strong>刷面经可以让你至少损失其中的4样！</p>
<h4 id="对目标公司的认知差异之坑"><a class="header" href="#对目标公司的认知差异之坑">对目标公司的认知差异之坑</a></h4>
<p>作为 <strong>"外部人士"</strong> ，了解一个公司的渠道是很少的，这就 <strong>很难做到深入了解</strong>！</p>
<p>而面试的准备工作，除了知识准备，还有目标准备和状态准备，这三者是相辅相成的。</p>
<p>具体地说，我们需要挑选好目标行业&amp;目标公司，然后分好类别和369等， 那么势必有一些公司是拿来练状态的（其中不乏好公司），一些作为重点目标。</p>
<p>这一部分我相信大多数读者都有自己的心得，我想分享的一点是：</p>
<blockquote>
<p>"无论你在前期怎么努力的去了解一家公司，都很难达到一个深刻且准确的程度"。</p>
</blockquote>
<p>对于绝大多数读者而言，我这次跳槽的面试之旅都可以称得上："草率"、"大胆"。毕竟我只面了两场！</p>
<p>其实更新完简历后，我便在收集信息，挑选练手目标，虽然 "练手" 这件事情 <strong>略显不地道</strong> ， 但我还是有信心让对方也有所收获的。让我没想到的事情发生了：</p>
<blockquote>
<p>有一家做视频会议的公司，我已经将其作为重点目标，对他们的业务、技术栈也做了很多功课，甚至我已经和小伙伴了解过情况，待我找一下状态之后帮我内推</p>
<p>然而在我刚开始接一些猎头KPI式的职位推荐时，这家公司的HR就联系了我，直接邀约面试，这就把计划打乱了。</p>
</blockquote>
<p>做了尽可能充分的准备后去进行了面试，但是很遗憾，面试过程令我 <strong>很不愉悦</strong> ：</p>
<ol>
<li>一方面HR表示了：技术面试官看完简历后对我有很大兴趣；一方面让我感觉到两位面试官对简历内容的理解其实很浅，并且 <strong>没有为面试题做精心准备</strong>。</li>
<li>作为一个细分领域的公司，<strong>面试过程完全规避了音视频领域和网络领域</strong>，在我看来非常的 <strong>不专业且不敬业</strong> 。毕竟不是多领域业务的公司的常规性人才储备面试。<strong>这样面试完全不能保障招聘来的人员能够在短期内成为核心战力！</strong></li>
<li>居然试图在面试期间利用简历内容 "设计" 巧妙的问题。</li>
</ol>
<p>坦诚地讲，面试后半程已经让我感受到煎熬了，在准备阶段，我对该公司以及自身已经做了 <code>尝试性的</code> , <code>较充足的</code> SWOT分析，然而实质情况和外界收集的信息大相径庭。</p>
<blockquote>
<p>如果从核心岗位选出的面试官都做得很糟糕，那么便无法令人相信支撑其他工作的底层逻辑合理，无法令人相信团队综合能力能够支撑公司的愿景</p>
</blockquote>
<hr />
<p>而比较幸运的是，第二位联系我的猎头就很 <strong>专业</strong> ，分享了他在HR的角度对于公司和HC的看法（优劣、发展空间、匹配性），在我接受邀约后，为公司提供了 <code>HR专业性的</code> 人才分析评估，<em>面试过程中我眼尖瞄到了大致内容😂</em></p>
<p>技术面的面试官也很 <strong>实在</strong> :</p>
<ol>
<li>他选取了我简历中的部分内容与我进行了探讨，互动性的探讨，甚至针对探讨的中间结果设计了一些场景继续展开讨论。</li>
<li>也选取了公司业务领域中的一些问题和我探讨，<em>注意：这不是那种拿面试套方案的做法</em>，因为面试官也分享了他的见解，明显有项目支撑，基于实操的分析要比我基于理论和业务共性的分析深刻、全面。</li>
</ol>
<p><em>说来惭愧，大学时我帮不少同学做过考前冲刺资料，其实就是自己押题，一直保持了这个习惯，这次面试大约压中了8成内容。这也侧面说明面试官的逻辑和我类似，才有这么高的命中。</em></p>
<p>二面也是实打实的探讨价值观认同、职业发展规划，面试官的职业经历比我多了有十年，提出的看法也很有深度、对我有很多启发。</p>
<p>虽然是医疗行业的软件开发，相比于互联网行业已经算跨了半个行业，但：</p>
<ul>
<li>面试的体验感、</li>
<li>对方的认可、</li>
<li>公司在脑深部电刺激疗法（DBS）治疗帕金森的专业性、</li>
<li>我的大学专业属于医学、信息学、软件工程交叉领域，归属感</li>
</ul>
<p>都让我产生了期待。并且在收到了Offer后，我推掉了其他的面试邀约，我相信在苏州，还存在公司会让我心仪，但基于当时的状态，也只有 "巨硬" 才比他更有分量了。</p>
<hr />
<p>抱歉，没有压制住自己的分享欲，和各位读者朋友分享了太多的个人面试过程。</p>
<p>真正想要分享的就一句话：</p>
<blockquote>
<p>"职业生涯中的每一次选择都是大事，一定要看仔细、想清楚！利用科学的分析方法，并且留下多处验证环节"，否则踏错一步都会让自己很难受。</p>
</blockquote>
<h4 id="分享3----职业生涯的一些建议"><a class="header" href="#分享3----职业生涯的一些建议">分享3 -- 职业生涯的一些建议</a></h4>
<blockquote>
<p>职业生涯的一些建议</p>
</blockquote>
<p>每个人的职业生涯都应当自己牢牢把握，我且言之，诸位若认为有理有帮助便信之。</p>
<p>以前听过郭德纲的一句话:"一个人，30岁之前不狂也就那样了，30岁之后还狂，那也就那样了"，这句话颇有点打机锋的味道。</p>
<p>三十岁之前，拼的是冲劲，没冲劲很难成长，也不会有老板愿意赏饭给你吃，没有拼搏进取的精神，技术也不到家，你的剥削空间太有限。</p>
<p>三十岁之后，拼的是弱点。论语为政中说："十有五而志于学、三十而立"，能在前一阶段胜出，立住了的人，都有长处，想要在这部分人中胜出，靠的是立的稳，那就要弱点更少！</p>
<p>用5-8年时间，专业知识应该打磨到位了，不到位就要被淘汰了！想要再往深处走，需要有机会，想要争到机会，往往不是靠技术强点，而是更少的弱点，例如：</p>
<ul>
<li>对陌生事物的认知能力差，方法不科学</li>
<li>看问题不全面，浮躁</li>
<li>无知自傲，刚愎自用</li>
<li>不善人际，无法借力</li>
</ul>
<p>这些方面并不一定要多强 <em>（毕竟都需要时间去打磨）</em>，<strong>只要不差又比别人强，就容易获得机会</strong>。</p>
<p>在和一位HR朋友聊天时，她提到一句话："三十多岁的人，如果靠技术能力和二十多岁的人抢饭碗，多数是要被淘汰了"。</p>
<p>观察自己竞争力的方式很简单，看看你的竞争对手，如果自己拥有年纪方面的优势，说明竞争力挺强；如果是同年龄段的人竞争，说明没掉队；和低年龄段的人竞争，说明你跟不上节奏了。</p>
<p>无论是想走技术线还是想走管理线，在基础能力达标后，都需要开始针对性的消除自己的弱势，这样就容易获得机会，得到机会之时就如同当初入行时，要开始针对性的积累优势了。</p>
<p>言至此处，相信读者朋友都有自己的想法了。</p>
<blockquote>
<p>我给出的建议是：想清楚，做好计划，确定好回顾和校验方式，实行，定期回顾并迭代这个过程。</p>
</blockquote>
<h2 id="生活"><a class="header" href="#生活">生活</a></h2>
<p>我一直是一个比较偏执的人，很长一段时间里我都将我的时间给到了 "工作" 和 "能力提升"，我相信很多读者朋友也是如此，干这行多多少少都需要有兴趣支撑。</p>
<p>但是注意，这样会让你被一叶障目的！<strong>脱离生活，将失去人际能力，将失去观察能力，将忽视他人的需求，将消耗自己的兴趣！</strong></p>
<p>2020年10月的时候，我想买本《本草纲目》看的玩玩，顺带凑了点书，例如：《管子》、《墨子》、《老子》、《列子》等，一读读了个念头通达，很多问题茅塞顿开！</p>
<p>回顾自身后决定做出一些改变，尝试之后发现获益良多！当然，我不鼓吹各位去购买这些书，阅读这些书对于我而言只是一个 <strong>契机</strong> ，让我意识到了：自身的弱点还很多，要像经营国家一样按照科学的方法针对性的改进；自己对事物的认知还很粗糙，需要雕琢世界观等等。</p>
<p>红楼梦中有联："世事洞明皆学问，人情练达即文章"。让自己的生活丰富一点，不要只有工作。把自己融入丰富的生活中，去思考去尝试去改进，不经意间的一个转身，会发现处理工作也游刃有余了。</p>
<p>2021年在生活中多了读书、娱乐、陪伴和倾听，努力让自己的心慢下来，获益匪浅。</p>
<hr />
<h2 id="作者按"><a class="header" href="#作者按">作者按</a></h2>
<p>这篇总结，从决定写、回顾自身、甄选要点、起草纲要、开始编写、多次修改，历经两个月终于完稿。</p>
<p>2022年的个人计划也已经做好，各位读者会接触到的主要还是开源项目和博客，关于博客内容，今年会集中在：</p>
<ul>
<li>基础梳理：<code>多线程基础和JUC的部分</code></li>
<li>编程方面的个人理解</li>
</ul>
<p>今天是除夕，先祝各位新年快乐!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="关于画一个句号--基于2022年终总结的反思与分享"><a class="header" href="#关于画一个句号--基于2022年终总结的反思与分享">关于画一个句号--基于2022年终总结的反思与分享</a></h1>
<p><em>没有平台鼓风造势，今年各大平台没有涌现出一批总结，非常清爽</em></p>
<p>正如同人发明了抽屉，将杂物进行整理、丢弃、收纳，才能对空间进行更合理地使用。我们也需要对知识、过往经历进行整理、丢弃、收纳，才能对大脑进行更合理地使用。</p>
<blockquote>
<p>这个人需要一个句号，你可以帮他画一个 -- 《天道》</p>
</blockquote>
<p>在电视剧天道中，丁元英说了这样一句话，指导芮小丹让罪犯彻底放下了执念。而对于人生中的一个年轮，无论它充斥几多成功与失败，夹杂几许悲欢或离合，都值得为它画一个阶段性的句号，
它需要庄严肃穆的态度，它需要严谨全面的视角。</p>
<p>画上句号，是对过去做一次整理、丢弃、收纳，是在自己竭尽全力反思后卸下精神的枷锁，为谱写新的篇章做好准备。认清目标，轻装简行。</p>
<p>经过多次审视，通过这一篇文章将我认为能对读者起到帮助的内容分享出来。</p>
<h2 id="我的个人总结"><a class="header" href="#我的个人总结">我的个人总结</a></h2>
<h3 id="工作方面"><a class="header" href="#工作方面">工作方面</a></h3>
<p>过去的一年，工作中的详细情况不适合与诸位分享。除去常规的APP编写维护工作外，我也结合工作内容在其他方向上做了一些扩展。</p>
<ul>
<li>实战了MVI架构，并将心得进行了分享</li>
<li>对物联网通讯协议进行浅层次的调研学习</li>
<li>结合"遥控器" 项目，对socket、蓝牙、WiFi等通信方面，Android事件底层机制等，进行了更深入的学习</li>
<li>结合"日志工具"，对加密进行了复习，实战了Compose和Compose-Desktop</li>
<li>对uni-app框架进行了浅层调研，反编译SDK简单阅读源码，和以往自研的h5-bridge进行了对比，开发了几个自研插件</li>
<li>潜伏后端写了写接口，对诸多优秀的框架展开源码学习，基于已掌握的反射知识和APT知识，造了点轮子，让后端见识了Android不仅卷还真TM会卷不是瞎卷</li>
</ul>
<p>总的来说，整体工作丰富多彩，至少有30%的时间不在拧业务螺丝。但个人回看时仍觉有所不足，部分工作并未留下详尽的脑图，未曾凝练为结构化的知识信息。</p>
<h3 id="自我学习与总结输出"><a class="header" href="#自我学习与总结输出">自我学习与总结输出</a></h3>
<p>去年年初计划全年写完Java多线程系列，以及其他零散的分享，预计12-15篇原创。</p>
<ul>
<li>多线程系列没有全部完成</li>
<li>实现了文章总数目标</li>
</ul>
<p>订计划时，希望通过写博客实现以下目标：</p>
<ul>
<li>锻炼驾驭不同风格的写作能力</li>
<li>提升结构化表达能力</li>
<li>提升绘图能力</li>
<li>总结、温习、继续学习知识</li>
<li>提升个人影响力</li>
</ul>
<p>通过刻意试探与反思多篇文章的数据，现在看来 "提升个人影响力" 这一目标倒大可不必存在。它太过于限制分享的内容且过于功利，以至于影响到撰文时的心态。</p>
<p>今年也会继续写下去，保底一个月出一篇，而心态转变后，文章内容和语言将不再刻意深沉。恰如标题，产出的目标都是 "画一个句号" ，将脑海中的知识挪挪地。</p>
<h3 id="文娱与生活"><a class="header" href="#文娱与生活">文娱与生活</a></h3>
<p>有事没事的陪老婆打打游戏，没遇到啥想看的新剧，周末不想起床的时候刷刷风筝之类的老剧。没去看啥电影，同样也没出去玩，逢年过节回去陪陪长辈。平淡无奇的生活。</p>
<p>因为某些原因，和老婆一起养的猫被送走了，少了很多麻烦与乐趣。</p>
<p>其他时间还是以读书为主，闲书（小说）读了不少，好书也读了不少，唯独技术类书籍没读几行，后续会写一些杂篇和大家分享分享。</p>
<p>说起读书想起来一件事情，去年读到别人的年终总结，里面提到一个目标：读完一本金庸著作。请恕我直言，当时我很不厚道的笑了。目前回头看时，制定并实现这一目标并无不妥。</p>
<p>时间固然宝贵，但我们并不能将所有的时间都用来学习技术，文武之道一张一弛，金庸的武侠世界中也有诸多人生哲理，金庸的文笔更数上乘。</p>
<p><strong>总体来说，Work-Life-Balance还算可以，但对家人的陪伴并不够。这一点需要在今年好好改进</strong></p>
<p>另外，在家里人强烈要求下，买了辆车，回老家倒是方便了很多，并且不出意外地养成了 "眼观六路，嘴骂八方" 的被动技能</p>
<blockquote>
<p>说了很多，最终汇总为一句：通过各种手段，我和自己达成了和解，阶段性地摆脱了焦虑。至于能维持多久，需要交给时间去校验。</p>
</blockquote>
<h2 id="工作总结与个人总结不同您需要一个更适合的思考框架"><a class="header" href="#工作总结与个人总结不同您需要一个更适合的思考框架">工作总结与个人总结不同，您需要一个更适合的思考框架</a></h2>
<p>絮叨了很多，我们开始谈一些真正能用到的。</p>
<p>我尚不敢指导各位如何去做工作总结，但我相信下面这些内容会给您一些启发。</p>
<blockquote>
<p>一定要意识到，工作总结和个人性质的总结是不同的！在目的性、思考框架上是完全两码事。</p>
</blockquote>
<p>我相信有不少读者朋友是这样进行工作总结的：</p>
<ul>
<li>细数全年做了哪些事情</li>
<li>做的结果如何</li>
<li>寻找一些亮点（自认为很厉害的、很有挑战的事情）</li>
<li>横向比较以及来年如何做出更好的成绩</li>
</ul>
<p>如果是个人性质的总结，这样搞没有问题，毕竟你大多数时间不为别人而活，想一想干了啥，是否是自己想做的事情，怎么能做得更好，这套思维逻辑没有问题。</p>
<p>但工作总结不一样，名义上你为自己挣钱，但实际上是为别人工作，无论是KPI或者OKR的考核机制，背后都是公司和领导层的价值导向。
你需要思考公司提倡的价值导向，并且哪些目标的实现对公司意味着价值转换，以此展开思考：哪些工作是服务于该目标的，这些要重点写。</p>
<p>但不可否认，在有些公司中，努力搬砖就能创造大多数价值，这对技术创新者而言并不友好，但人总要为自己的选择承担后果。
简而言之，并不是你做的不好，而是公司不提倡，在这些公司这是一条死路。</p>
<p>即便你的技术创新能够带来极大地便利，让开发成本降低不少，<strong>但这并不能缓解中高层和老板的焦虑</strong>。</p>
<p>看到员工在加班创造价值会缓解老板的焦虑，哪怕付出水电费；看到手下人在加班，能够缓解管理人员的另一种焦虑。</p>
<p><em>具体的内容我不点破，您自行观察和思考</em></p>
<p><strong>早日认清这一点很重要。</strong></p>
<p>伴随着总结的还有一件事情，即绩效评定。这又是一件有门道的事情。</p>
<p>我希望每一位打工人都能受到公平公正和过程公开的对待，但很遗憾这是奢望。</p>
<p>大多数公司的绩效考核都是过程不公开的，而大多数人收到不符合预期的绩效反馈时，总是在努力反驳，希望推倒这种非公平非公正。</p>
<p>其实大可不必！你几乎无法改变既定的事情。</p>
<p>但请注意，绩效考核以及其沟通环节是一个难得的机会，您拥有一个官方认可的场合去试探您的直属和间接领导。</p>
<p>前面我们提到，考核本身是公司价值导向的体现。正如同有一千个读者就有一千个哈姆雷特。老板们和董事会们制定了公司的发展策略和近几年的核心价值，在不同层次落实时难免会发生偏差。</p>
<p>您拥有一个冠冕堂皇的理由让直属、间接领导解释为何得到这样的评分，哪些地方做的不到位，来年如何做出 "好成绩"，没有人会拒绝这样的戏台。</p>
<p>相信只要您留心，就一定能发现</p>
<ul>
<li>领导是否藏有私心</li>
<li>自己对价值导向的理解是否有误</li>
</ul>
<p>而这些信息对您做出选择至关重要，借用最近随着高启强大火的孙子兵法：</p>
<blockquote>
<p>兵者,国之大事,死生之地,存亡之道,不可不察也。故经之以五事,校之以计,而索其情:一曰道,二曰天,三曰地,四曰将,五曰法 -- 计篇</p>
</blockquote>
<p>这件事情往小了说是一两个月薪资的奖金问题，往大了说是未来一两年的工作安排和未来几年的职业规划。</p>
<ul>
<li>道：意志统一，上下一心，如果高层的想法，中层的想法，基层的想法，您的想法，如果有偏差，要注意衡量了。</li>
<li>天：天时，公司资金流是否充裕，大环境好不好很重要！</li>
<li>地：地利，工作中的氛围，合作者如果很不配合，一个人很难成事，主管和你不对付就更难了。</li>
<li>将：您的直接主管和间接上级，如果他们不够体恤下属，不能传达正确的价值导向，做不到赏罚分明，工作中夹杂过多个人诉求，如果您不愿意成为他们的狗腿子，那也不会有好结果。</li>
<li>法：指组织结构，责权划分，人员编制，管理制度，资源保障，物资调配。在绩效考核时，只要留心，一定可以观察到。</li>
</ul>
<h2 id="兼听则明偏听则暗"><a class="header" href="#兼听则明偏听则暗">兼听则明，偏听则暗</a></h2>
<blockquote>
<p>监听则明，偏听则暗</p>
<p>原文出自《资治通鉴》，典故为唐太宗与魏征问答，最早出处 《管子》君臣篇</p>
</blockquote>
<ul>
<li>我所说的，您也未必要全盘接受，大可和信得过的朋友们商讨一二</li>
<li>别人对你的评价，没必要全盘接受，但不能完全不听，客观地对照审视。例如绩效考评中上级对你的评价、同事对你的评价，是从他们自身的利益出发的还是从你个人利益出发的，多听一些，自见端倪。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="突如其来的秋季反思"><a class="header" href="#突如其来的秋季反思">突如其来的秋季反思</a></h1>
<p>反思来的很突然，人随运走，兴由事发。</p>
<p>一切很突然，一切又有迹可循。</p>
<p>五月份时，Boss让我停掉一切研发事项，开始统筹变更管理；九月初，我从研发转为项目管理；</p>
<p><em>通俗来说，某些原因导致的医疗器械中的DMR变化，这些变化及其追溯即所谓变更管理</em></p>
<p>巨变之下，回顾了近两年的历程，所思所想，记于下文。</p>
<h2 id="养性与养气"><a class="header" href="#养性与养气">养性与养气</a></h2>
<blockquote>
<p>20年冬季，身体不适，去看中医。诊断脉弦数，热邪亢盛，肝风内动之象。开了些药，听了一堆医嘱。</p>
<p>在狂奔的途中撞上了墙，一个踉跄，转身后，竟看到了歇斯底里的自己。</p>
</blockquote>
<p>那时，我突然意识到，我在工作中走了歪路，并且已产生了很多不好的影响。用时下的词描述为 "极度精神内耗"</p>
<blockquote>
<p>理想的书籍是智慧的钥匙 -- 托尔斯泰</p>
</blockquote>
<p>与其这样内耗，不如先把个人技术提升的事情先放一放，将业余时间用来读一读书。于是买了一本想读很久的书《管子》。</p>
<p>我仍然记得，小学的苏教版课本上，有一句：<code>仓廪实则知礼节，衣食足则知荣辱</code> 语出 《管子-牧民》，老师给我们讲了管仲帮助齐桓公称霸的历史，并诵读了部分章句，并告诫我们以后有机会一定要读一读这部鸿篇巨著。</p>
<p>买这本书的理由很片面：找一本感兴趣又难读的书来磨性子。先秦文章，词句远比唐宋时期晦涩。理念振聋发聩，章句浩然磅礴，对我而言是不二之选。</p>
<blockquote>
<p>读这本书的过程中，我开始思考公司的管理，团队的做事方式。并且真正理解一个道理：“不要陷在自己的世界中钻牛角尖，要去和高人探讨，如果不能和真人讨论，就去读高人的书籍”。</p>
</blockquote>
<p>从这时起，开始了养性、养气。</p>
<p><em>作者按：方法上不必强求一致，如果读者诸君能够旁证自身，发现也应该做出自我调整，养性、养气，那么本章节就真正触达有缘人了</em></p>
<blockquote>
<p>中庸中提到： 天命之谓性，率性之谓道，修道之谓教。喜怒哀乐之未发谓之中，发而皆中节谓之和。中也者，天下之大本也；和也者，天下之达道也。致中和，天地位焉，万物育焉。</p>
</blockquote>
<p>通俗地讲，养性就是控制情绪，适度地释放，有节制，达到很平和的状态。而养气是养浩然气，知善恶辩是非明黑白，不可一味和稀泥。</p>
<blockquote>
<p>居天下之广居，立天下之正位，行天下之大道；得志与民由之，不得志独行其道；富贵不能淫，贫贱不能移，威武不能屈，此之谓大丈夫。 -- 孟子 滕文公</p>
</blockquote>
<h2 id="价值证明的陷阱"><a class="header" href="#价值证明的陷阱">价值证明的陷阱</a></h2>
<p>再后来，我入职了新公司。此时我一直在思考一个问题：</p>
<blockquote>
<p>如果在工作中花了很多心血和精力，但如何体现出价值 -- 价值证明问题</p>
</blockquote>
<p>可能在大部分公司，都有这样的不利因素：需要打工人自己举证自己的价值</p>
<p>一旦陷入到这样的怪圈中，永远是吃亏的。</p>
<blockquote>
<p>你如何证明自己本职工作做得很出色？</p>
<p>你如何证明你做了本质工作之外的内容，并对公司产生了价值？</p>
<p>你如何证明……</p>
</blockquote>
<p>上面的BOSS无非是想用这种方式逼底层人内卷罢了，只要你去想了，你就输了。</p>
<blockquote>
<p>公司的核心是商业化,不要奢求他人能管理好贪欲</p>
</blockquote>
<h2 id="目标契合与捆绑"><a class="header" href="#目标契合与捆绑">目标契合与捆绑</a></h2>
<p>而解法也不难，让上级无法否认你的价值即可！如果你所在的公司，上级很轻易就可以否定别人的价值，那么就可以考虑换工作了。</p>
<p>可以将目标分成两部分：</p>
<ul>
<li>一部分是明面上的，紧扣上级的考核点，对齐公司的核心价值，如果公司的核心价值很低，那么也可以考虑换工作了。</li>
<li>另一部分是私下里的，用于个人成长。时下难以在一家公司干到退休，人总要成长。这部分目标是朝下一个职位的模板对齐的
<ul>
<li>能融合进当前工作的，就将其打造为超预期</li>
<li>不能融合的，就需要付出个人时间了</li>
</ul>
</li>
</ul>
<p>以这种方式切入，上级难以否定你所创造的价值（否则是自我否定），公司也难以否定全员价值。与此同时，自己也可以借机成长（达成自我目标）。不可否认，这一方式可以避免自己浪费精力，好钢永远用在刀刃上。</p>
<p>日常需要留意：</p>
<ul>
<li>商业画布，但一般难以接触，甚至没有明确</li>
<li>业务布局、产品规划，用于分清主次</li>
<li>市场分析、一般也难以接触，留心Boss们的分享</li>
<li>各种大会，先听出基调和逻辑，用正说反说折中说去拆解话术，还原真实想法</li>
</ul>
<h2 id="结语-14"><a class="header" href="#结语-14">结语</a></h2>
<p>近半年，也常和朋友聊中年危机之类的话题，时常感慨万千，虽然还有几年才到年纪，但总要先做好准备。</p>
<p>这次的思考比较随性，并未仔细提炼主题并围绕行文，个人观点大体如下：</p>
<ul>
<li>大部分公司管理者认为程序员是"生产工具"，并且利用各种方式让人成为高产的工具</li>
<li>我们需要认识到这一点，并打破这一点。关键在于形成自我核心价值观、逻辑体系自洽。就可以免疫PUA等手段，并且不露于形色</li>
<li>读书、读好书是一种有效方式</li>
<li>规避自我证明价值这类陷阱</li>
<li>用"目标契合与捆绑" 这一方式，在工作中不浪费精力</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2023年总结-寻找到源于内心深处的无穷力量"><a class="header" href="#2023年总结-寻找到源于内心深处的无穷力量">2023年总结 寻找到源于内心深处的无穷力量</a></h1>
<p>今天是跨年夜，将前段时间的思考记录于下。今年的关键词是 "改变" 与 "求索"，最值得分享的事情是寻找到源于内心深处的无穷力量。</p>
<h2 id="从一个有局限的观点出发---人是万物的尺度"><a class="header" href="#从一个有局限的观点出发---人是万物的尺度">从一个有局限的观点出发 - "人是万物的尺度"</a></h2>
<blockquote>
<p>人是万物的尺度 -- 普罗泰戈拉</p>
</blockquote>
<p><em>这一观点曾受到苏格拉底、柏拉图和亚里士多德的批评，并且在很长时间内受到质疑。黑格尔从认识史发展的角度，肯定这个命题体现了思维的能动性。</em></p>
<p><em>这个命题集中代表了普罗泰戈拉的<strong>相对主义</strong>和<strong>怀疑主义</strong>的<strong>错误观点</strong>，有<strong>主观唯心主义</strong>的因素，但是它触及到主观与客观的关系问题，表明了人类认识的进步。</em></p>
<p>谈及此命题，并非想和读者诸君讨论哲学，只是想表达以下观点：</p>
<blockquote>
<p><strong>即便是身处21世纪，大部分人仍会因尚未客观认清事物，而陷入主观唯心主义。在大部分的事项与活动中人的主观性远大于客观</strong></p>
</blockquote>
<p>在事项与活动中，总会不自觉的以人为中心，无论是理解事项、传递信息、互相协作，评价...</p>
<h2 id="为何寻找这种力量"><a class="header" href="#为何寻找这种力量">为何寻找这种力量</a></h2>
<p>人生无法保持风平浪静，工作和生活中会遇到各种问题，即便能力再强，也难免会囿于困境。</p>
<p>前段时间读了不少他人的年终总结，同时回顾了自己近10年的历程，</p>
<p>在学校，因交叉学科，有医学专业课和计算机方向专业课，在学习之余帮老师打杂并自己段炼编程
在第一家公司，适应学校和职场的差别，从带领同学一同完成项目转变到主导完成安卓软件开发项目
在第二家公司，运用Practical Problem Solving的理念整治充满异味的代码，尝试作为scrum master并探索技术领导力
在第三家公司，完成更具挑战的技术调研和项目开发，并转变至医疗器材类项目管理</p>
<p>一路走来，山高路远，道阻且长，凡心所向，行之将至，应叹人生多幸，未曾行差踏错，然此去蓬莱路远，万丈迷津难渡，须有一点星火，燃起万丈燎原。</p>
<p>所幸者，这种力量点燃了意志，让我敢于直面困难，直至挣断枷锁打破樊笼</p>
<p>我在 <a href="https://juejin.cn/post/7285373518837383223">突如其来的秋季反思</a> 中曾提到，要让个人目标与工作目标相契合，在完成工作的同时实现自我提升。</p>
<p>而实际上，当实现了工作目标后，再使用一定的时间进行关联性延伸，会更容易获得质变。</p>
<p>这种力量帮助我打破了樊笼，并促使我进行关联性延伸方面摸鱼，提升了个人能力并反映为业务能力的提升，进一步获得更多摸鱼时间。</p>
<h2 id="这种力量是什么"><a class="header" href="#这种力量是什么">这种力量是什么</a></h2>
<p>虽然我能感受到那一点星火，但仍难以具体描述它，仅在追寻的过程中，摸到蛛丝马迹。</p>
<ul>
<li>在陷于迷惘中时，它是 "从书中学，向高人问，在事上练"；</li>
<li>在闭上双眼冥想坐于暗室时，它是 "不自欺，要践行仁义礼智信，温良恭俭让"；</li>
<li>在止不不前时，它是 "道虽弥，不行不至"；</li>
<li>在事情难以入手时 ，它是 "天下难事，必成于易，天下大事，必作于细"</li>
<li>...</li>
</ul>
<p>大体可以描述为 "心志"，但这种描述是虚无缥缈的。</p>
<p>提到心志，大多会想到《孟子》：</p>
<blockquote>
<p>天将降大任于斯人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为，所以动心忍性，增益其所不能</p>
</blockquote>
<p>这句话要倒着理解：人生来是白纸，当熬炼过心志，打磨好筋骨，能够忍受身体饥饿、穷困潦倒、事不遂意，这样都无法击溃他时，他会心性成熟能力提升，才有可能接住大任。</p>
<h2 id="将这种力量作用于人的改变"><a class="header" href="#将这种力量作用于人的改变">将这种力量作用于人的改变</a></h2>
<p>将这种力量作用于自身，终究会引起自身的改变。</p>
<p>如前文所言，人习惯将自我作为万物的尺度，在事项与活动中，无论其他参与者自身是否发生改变，这种力量的辐射会逐步改变参与者对你的看法。</p>
<p>这种改变如烈阳照于雪山，可卸下偏见的枷锁，推倒困住你的樊笼。</p>
<h2 id="结尾-明年的规划"><a class="header" href="#结尾-明年的规划">结尾-明年的规划</a></h2>
<ul>
<li>重塑阅读 - "阅读"事物、阅读人心、阅读书籍</li>
<li>重塑表达 - 和不同的人，有不同的表达方式，系统性的反思</li>
<li>将节约出的时间用于保持对技术的热情</li>
<li>给家人更多的陪伴</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2024年年中思考推倒樊笼重新出发"><a class="header" href="#2024年年中思考推倒樊笼重新出发">2024年年中思考，推倒樊笼重新出发</a></h1>
<h2 id="近况"><a class="header" href="#近况">近况</a></h2>
<p>上一次更新，是在5个月前，这段时间我没有写下一段文字，而是努力让内心重归平静。</p>
<p>这半年中历经不少磨难，保胎、再保胎、早产、NICU、去医院次数比回家多，一路艰辛不足为外人道。</p>
<p>有读者在后台私信我进行交流，同时也好奇断更的原因，实情是是内心太乱，无法开展有效的内容整理进而输出文章。</p>
<p>刚将宝宝哄睡，偷闲做一些思考。</p>
<h2 id="跨年夜立下的目标"><a class="header" href="#跨年夜立下的目标">跨年夜立下的目标</a></h2>
<p>当时我给自己立下了四个目标：</p>
<ul>
<li>重塑阅读 - "阅读"事物、阅读人心、阅读书籍</li>
<li>重塑表达 - 和不同的人，有不同的表达方式，系统性的反思</li>
<li>将节约出的时间用于保持对技术的热情</li>
<li>给家人更多的陪伴</li>
</ul>
<p>此时已近年中，可适时回顾一番。</p>
<h3 id="重塑阅读"><a class="header" href="#重塑阅读">重塑阅读</a></h3>
<p>本意是想锻炼以更系统更复杂的方式对事物、人心进行观察，继而再回顾书籍中的内容。</p>
<p>此事的进展约30%，下一步行动：回顾《认知觉醒》，总结思考目前的做法是否系统化，评估是否有益，进而决定是否固化方法论形成习惯。</p>
<h3 id="重塑表达"><a class="header" href="#重塑表达">重塑表达</a></h3>
<p>此事的进展约10%，下一步行动：速读《结构化表达》，回顾《金字塔原理》，有意识性的锻炼表达方式，以提升沟通效率。</p>
<p>这一条我带有很强的功利性，目标是减少不必要的沟通时间消耗。</p>
<h3 id="技术热情"><a class="header" href="#技术热情">技术热情</a></h3>
<p>此事的进展约0。空余热情而无暇顾之。</p>
<h3 id="给家人更多的陪伴"><a class="header" href="#给家人更多的陪伴">给家人更多的陪伴</a></h3>
<p>谈及此事，心中多有愧疚与不安，论心论迹都愧对妻儿，给到她们的实在太少，这也坚定了我做出选择的决心。</p>
<h2 id="困境"><a class="header" href="#困境">困境</a></h2>
<p>上一篇年终总结中也提到：</p>
<blockquote>
<p><strong>即便是身处21世纪，大部分人仍会因尚未客观认清事物，而陷入主观唯心主义。在大部分的事项与活动中人的主观性远大于客观</strong></p>
</blockquote>
<p>在事项与活动中，总会不自觉的以人为中心，无论是理解事项、传递信息、互相协作，评价...</p>
<p>目前我也陷在这一困境中，高管层忽略了客观事实、不顾团队的认知负荷，大谈特谈价值观和个人方法论，不免以其昏昏使人昭昭。</p>
<p>家人、同事都曾劝过我，以我目前所处的角色，大不了把责任心放一边，犯不着逆势而为。</p>
<p>然而终有8个字刻在心中 "生命相托、健康所系", 这8个字立在一处小楼之上，墙上布满了爬山虎，从铁门进入后，只能拾阶而下，入眼均是大体老师……</p>
<blockquote>
<p>彼黍离离，彼稷之实。行迈靡靡，中心如噎。知我者，谓我心忧; 不知我者，谓我何求?</p>
</blockquote>
<p>君子有所为，有所不为。不以善小而不为，不以恶小而为之。</p>
<p>庄子人世间有语：</p>
<blockquote>
<p>知其无可奈何而安之若命</p>
</blockquote>
<p>既然付出了各种努力也无法改变，公司自有其命运。</p>
<blockquote>
<p>天行有常,不为尧存,不为桀亡。应之以治则吉,应之以乱则凶。强本而节用,则天不能贫,养备而动时,则天下不能病;修道而不贰,则天不能祸。</p>
</blockquote>
<p>当下能做的，只有从自身出发，应之以治，强本节用，养备动时。</p>
<h2 id="关于认知负荷"><a class="header" href="#关于认知负荷">关于认知负荷</a></h2>
<p>认知负载是指：<strong>在特定时间内，工作记忆中的信息负荷</strong>。</p>
<p>对于个人而言，认知负载就是 <strong>大脑需要同时处理的信息量</strong> 。 拓展到团队层面时，认知负载是 <strong>团队在执行任务时所承担的信息处理总量</strong> 。</p>
<p>团队的认知负载并不等于团队成员各自认知负载的累加。团队协作过程中产生的交流、同步、协调等活动，都会带来额外的认知负载。</p>
<p><strong>团队的认知负载是影响研发效能的重要因素</strong>。</p>
<p>有时，即使团队的认知负荷总量合理，也未必是较理想的情况，因为团队成员之间知识和技能的差异，会影响到认知负载在团队内部的分配。</p>
<p>观察角度可以多样化，一般可以从 "任务执行情况"、"团队氛围"、"个人状态" 三点入手。</p>
<h3 id="任务执行情况"><a class="header" href="#任务执行情况">任务执行情况</a></h3>
<p>团队在面对新需求时，响应速度明显变慢，对变更的适应能力下降，出现更多交付物质量问题，需要更多的返工和修复，这是认知过载的典型信号。</p>
<p>团队投入了更多的时间和精力，但产出的绩效却在下降，说明认知资源已经难以支撑高质量高效率的工作。</p>
<h3 id="团队氛围"><a class="header" href="#团队氛围">团队氛围</a></h3>
<ul>
<li>团队成员之间的沟通变得低效和困难，产生更多的误解和冲突，知识共享和协作的意愿下降</li>
<li>整个团队的创新能力和解决问题的能力下降，团队士气低落，抱怨和消极情绪在蔓延</li>
</ul>
<p>此时团队认知压力已经达到高负荷甚至超负荷。自然而然的，<strong>成员往往会降低对他人和整体的关注，转而专注应对自己的工作压力</strong>。</p>
<h3 id="个人状态"><a class="header" href="#个人状态">个人状态</a></h3>
<p>团队成员普遍感到疲惫和倦怠，对工作失去热情和主动性，工作与生活难以平衡，出现失眠、健康问题等身心状况，这往往是认知过载的结果。</p>
<p>当个人长期处于高认知负荷状态，既要应对本职工作，又要参与大量协调和沟通，还要不断学习新知识，就很容易产生持续的压力感，陷入职业倦怠。</p>
<h2 id="关于前路"><a class="header" href="#关于前路">关于前路</a></h2>
<p>无论你是否愿意承认，当今社会无法让所有人都不面临生存问题，无法让所有人的物质需求都被满足，继而解放人类转向精神需求。</p>
<p>拥抱技术已经让我们在前十年领先了好几步，就不要因为陷入技术某方向的深坑，受困后再埋怨社会不公。</p>
<p>技术能力的底层支持是学习能力和应用能力，及时调整方向。学习是使个人保持锐化的过程，永远要承受孤独之苦。</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="note"><a class="header" href="#note">Note</a></h3>
<p>读书笔记</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="读书笔记简约至上--交互式设计四策略"><a class="header" href="#读书笔记简约至上--交互式设计四策略">读书笔记：《简约至上--交互式设计四策略》</a></h1>
<h2 id="前言-31"><a class="header" href="#前言-31">前言</a></h2>
<p>近来整理资料时，发现了以前留下的宝藏。这本书是2016年时一位从事 <code>产品经理</code> 职业的朋友推荐给我的，当时读完后大呼过瘾，并做了摘要。</p>
<p>作为开发人员，工作中必然要和产品经理以及设计的同事打交道，而往往因为 <code>不够专业</code> ，导致沟通效果欠佳，明明目的是让大家都专注于一个目标，最后却沟通不愉快、还要被扣上不合作的帽子。
当然，我的目的并非是让大家成为 <code>产品、UI、体验设计</code> 领域的专业人才，而是通过摘要快速判断 <strong>自己是否需要精读这本书</strong> ，<strong>并且从中学习到领域概念，在沟通中把握Keypoint并提升沟通效率</strong> 。</p>
<h2 id="摘要"><a class="header" href="#摘要">摘要</a></h2>
<blockquote>
<p>《简约至上》是英国的交互设计师 Giles Colborne 写的一本 <strong>小书</strong> ，说小是因为书很薄而且每篇文章都很短，<strong>但字字精彩</strong> 。
书的内容和排版就是简约设计非常好的案例。</p>
</blockquote>
<p>以下是我读后觉得很棒一些摘要，与大家分享。</p>
<p>简化交互设计的四种策略：</p>
<ul>
<li><code>删除</code> -- 去除所有不必要的功能，直到减到不能再减</li>
<li><code>组织</code> -- 按照有意义的标准将功能划分成组</li>
<li><code>隐藏</code> -- 把那些不是最重要的功能安排在不显眼的地方，避免分散用户的注意力</li>
<li><code>转移</code> -- 将高级功能转移动另一个地方，转移复杂性</li>
</ul>
<p>另外十点:</p>
<ol>
<li><strong>简单</strong> 就是感觉在 <strong>掌控一切</strong> 。</li>
<li><strong>要方案，不是流程</strong>。如果一个小的变化导致了复杂的流程，就应该退一步去寻找更好地解决方案。</li>
<li>选择有限，用户反而更喜欢。因为过多的选择会让用户无所适从。</li>
<li>删除多余文字的三大好处：
<ol>
<li>重要的内容"水落石出"</li>
<li>消除了分析满屏内容的麻烦</li>
<li>读者会对自己看到了什么更有自信</li>
</ol>
</li>
<li>复杂性是相对的，对于用户擅长的事情，往往就变得简单。</li>
<li>创建简单用户体验的秘诀就在于把复杂性转移到正确的地方，让用户每时每刻都能感受到简单之美。</li>
<li>简单的体验应该为用户留出足够空间，让他们能够想象到当前正在做的事情同样也是自己生活的一部分。</li>
<li>对一个产品的认识大致可以分为三个层次：
<ol>
<li>可信的环境(故事中的时间和地点）</li>
<li>可信的角色（谁和为什么）</li>
<li>流畅的细节（什么和怎么样）</li>
</ol>
</li>
<li>不要匆忙着手设计。理解核心问题需要时间。</li>
<li>想吸引大众，必须要关注主流。专家想要的功能往往会吓倒主流用户。</li>
</ol>
<p>提到简单，可以把用户分为 <strong>三种类型</strong> 。</p>
<blockquote>
<p>第一类是 <strong>专家型用户</strong></p>
</blockquote>
<p>他们愿意探索你的产品或服务，并且会给你提出各种改进建议。他们希望看到为他们量身定做的前所未有的技术。
即便拿到的是一个从未见过的产品，他们也会摆出专家的态度。换句话说，他们舍得花时间研究新产品，探索产品的新功能。</p>
<p>如果你是造手机的，他们就是那些想要浏览手机的文件系统，哪儿都动一动的人。</p>
<p><strong>不过这类用户总体上占少数</strong>。</p>
<blockquote>
<p>第二类是 <strong>随意型用户</strong></p>
</blockquote>
<p>他们可能使用过类似的产品或服务。他们有兴趣使用更高级更复杂的产品，但却 <strong>不愿意接触</strong> 全新的东西——要想让他们认可新功能，那么新功能必须足够简单。</p>
<p>比如说，他们可能会对更先进的手机感兴趣，但是必须保证能够轻松地导入他们宝贵的联系人。</p>
<p><strong>这一类用户比你想象的少</strong> ，而且他们的学习意愿不强烈。</p>
<blockquote>
<p>第三类是 <strong>主流用户（最大的用户群体）</strong></p>
</blockquote>
<p>他们自己不会因为你的技术而使用你的产品，使用你的产品的目的是完成某项任务。</p>
<p>他们会掌握一些重要功能的使用方法，但永远不会产生学会所有功能的想法。</p>
<p>这些人的口头禅就是："我的手机只要能打电话、能发信息就行了。"</p>
<p><strong>大多数人都属于这一类</strong>。</p>
<p>你可能会天真的认为，一段时间以后，其中一类人就会升级为另一类人。 但这几乎是不可能发生的。即使一个产品用了很多年，用户类型的标签也是不会变的。</p>
<p>举例来说，有一大群使用微软的Excel软件长达5年的用户，其中有一些人可能已经知道了某些设置和选项的作用，有一些人会掌握一些高级技巧，能够通过它们为自己提供便利，而剩下的一大部分人则只会对金额一栏求和。</p>
<h2 id="帮助理解"><a class="header" href="#帮助理解">帮助理解</a></h2>
<p><em>据我回忆，本章节是我第一次读该书时得到的一份读后感，可能来自那位PM朋友，时间太久，记忆已经模糊，但从内容侧重点推测不是我的手笔</em></p>
<p>首先对于书的内容和排版设计都符合 <strong>"简约"</strong> 的设计：一面文字、一面图片，条理清晰，取例于生活之中，阅读起来不枯燥又易懂，让用户觉得简单快乐。作者的理论和实践结合得很完美，不得不说：这书你值得拥有！</p>
<p>看完这本书，觉得简单的设计是如此的美好。对简单的含义也有了更深刻地理解。总结如下几点：</p>
<h3 id="一简单的理解"><a class="header" href="#一简单的理解">一、简单的理解</a></h3>
<p><strong>简单是有对象的</strong></p>
<blockquote>
<p>《设计之下》书中说"简单其实最复杂的设计"。</p>
</blockquote>
<p>这句话说明简单是有对象，对于用户来说某个操作很简单，但是对于背后的工程师为了这个操作要付出很多。</p>
<p>简单体现在 <code>流程短</code> ，<code>选择少</code>，<code>操作简单思考少</code>，<code>视觉清晰</code> ，<code>自然人性</code>，<code>场景贴近生活</code> 等方面，<strong>但是不能拒绝复杂</strong> ，复杂在合适的位置也是简单的用户体验。</p>
<p>有些简单看起来很简单，但是实际在具体的场景中运用时却是复杂的。比如说明书，看起来很简单，实际上用户不会看，他们只想拿起来就用。</p>
<h3 id="二要到用户现场体验参观才能更好地理解用户使用场景"><a class="header" href="#二要到用户现场体验参观才能更好地理解用户使用场景">二、要到用户现场体验参观，才能更好地理解用户使用场景</a></h3>
<p>要做好用户体验，必须要到用户的使用现场去，才能知道用户喜欢怎么用，会出现什么干扰因素，简化用户体验时，会影响那些环节，造成什么样的后果。</p>
<h3 id="三用户分为专家型随意型主流用户三种"><a class="header" href="#三用户分为专家型随意型主流用户三种">三、用户分为：专家型、随意型、主流用户三种</a></h3>
<ul>
<li>专家型的用户是愿意探索你的产品和服务，希望达到高深的体验；</li>
<li>随意型的用户是有兴趣使用更高级更复杂的产品却不愿意接触全新的东西，所以新功能必须简单；</li>
<li>主流用户是为了完成某项任务，比如"我的手机，只要能打电话，发信息就行"。</li>
</ul>
<p><strong>应该忽略专家型，为主流用户设计，因为专家型想要的功能会吓跑用户</strong>。</p>
<h3 id="四设计简单需要关注用户的行为和行动用户体验需要用故事讲出来"><a class="header" href="#四设计简单需要关注用户的行为和行动用户体验需要用故事讲出来">四、设计简单需要关注用户的行为和行动，用户体验需要用故事讲出来</a></h3>
<p>应该关注用户在做什么，而不是过多描述自己的解决方案。</p>
<p>把他们的行为和行动描述出来，尽可能详细，特别是干扰处和自然反应。</p>
<p>用户体验是场景再现，是简短而美好的故事。比如某一天在街上匆忙地遇到了高圆圆女神，快速拿出摄像机，然后分享至社交平台上，这个场景包含着环境，角色，情节等完整故事，是可信的，
那么 我们设计摄像机的时候，摄像机上面的按钮一定少而且精准，否则还在摸索的时候女神就走了。</p>
<h3 id="五增加功能不一定让用户体验更加简单"><a class="header" href="#五增加功能不一定让用户体验更加简单">五、增加功能不一定让用户体验更加简单</a></h3>
<p>用户的意见要听，<strong>但不能盲从</strong> 。</p>
<p><em>在3年前我们团队就吃过这样的亏</em></p>
<p>功能过多反而会分散用户的注意力，降低主流用户的满意度，从而对长期的盈利能力损害。功能过多，只会做广而做不深，"泛而不精"。</p>
<p>用户的需求会很多，满足所有的功能只会使产品臃肿，这是不可能的。所以满足用户，我们退而求次，专注于目标客户的需求，让他们满意就可以了。记得马化腾说过：我们不能为了1%需求去伤害了99%的用户的体验，取舍的用户需求很重要。</p>
<h3 id="六如果小的变化导致复杂的流程就应该退一步寻找更好地解决方案"><a class="header" href="#六如果小的变化导致复杂的流程就应该退一步寻找更好地解决方案">六、如果小的变化导致复杂的流程，就应该退一步寻找更好地解决方案</a></h3>
<p>如果设计只盯住流程简单化，那么很有可能创造更多的功能去处理出现的各种异常情况问题和细节，那么这个时候我们就应该退一步问自己：我设计这个的目的是什 么？有没有其他的解决方案。用户在使用过程中觉得简单就是掌控一切 ，如果他们在流程中还要去想：然后呢的问题，就说明这样的简单不可行。同时不能为了追求设计的完美，而牺牲速度和简单。</p>
<h3 id="七分清用户和产品之间的任务界限让用户拥有主动控制权"><a class="header" href="#七分清用户和产品之间的任务界限让用户拥有主动控制权">七、分清用户和产品之间的任务界限，让用户拥有主动控制权</a></h3>
<p>在 <code>产品功能设计</code> 的过程中，很容易对用户产生过多或者不必要的要求，这就 <strong>增加了用户的工作量</strong>。</p>
<p>又或者，产品设计中有"霸道"甚至是"强硬"的态度表现，强迫甚至威胁用户做出一些操作，对于用户来说，这些都是很不愉快的体验。</p>
<p>在产品设计中，我们需要首先分清用户和产品之间的任务界限，在帮助用户完成任务的目标下，尽量减少和简化用户的操作，让用能更快捷更愉快地完成任务。</p>
<p>在用户完成任务的过程中，产品设计者需要明白用户才是主角，应该让用户拥有控制权。产品是 <strong>帮助用户完成任务的</strong> ，而不能凌驾于用户之上，让用户有强迫感和威胁感。</p>
<h3 id="八不要为了简单而拒绝复杂而应该把复杂性放在合适的地方"><a class="header" href="#八不要为了简单而拒绝复杂而应该把复杂性放在合适的地方">八、不要为了简单而拒绝复杂，而应该把复杂性放在合适的地方</a></h3>
<p>在 <strong>简约式的设计</strong> 中，有时候为了一个简单的设计需要较为复杂的实现过程，虽然没有副作用或者附加风险，但也要谨慎。</p>
<p>复杂的过程永远应该处于隐蔽的状态，不能暴露在用户的面前，那样会让用户感到困惑。</p>
<p>产品作为支持者和协助者的角色，很多操作都应该放在"后台"，呈献给用户的应该是一个美好的结果，而不是过程。</p>
<p><strong>为用户而设计</strong> ，让用户感到愉悦，很多时候都会涉及到复杂的实现过程，但不必一一呈现在用户面前，以炫耀或者展示自己的功劳。</p>
<p>产品的 <strong>简单而美好的使用体验</strong> 必然包含 <strong>优秀而复杂的实现</strong>，用户自然会有考虑，也会很感激。为了简单化的设计，复杂是值得的，但是要记得把复杂放在合适的地方。</p>
<h3 id="九不要匆忙着手设计理解核心问题需要时间"><a class="header" href="#九不要匆忙着手设计理解核心问题需要时间">九、不要匆忙着手设计，理解核心问题需要时间</a></h3>
<p>轶</p>
<p><em>作者按：从技术角度看，该法则依旧适用，先理解问题</em></p>
<h3 id="十简约的四大方法删除组织隐藏和转移"><a class="header" href="#十简约的四大方法删除组织隐藏和转移">十、简约的四大方法：删除，组织，隐藏和转移</a></h3>
<p>删除不必要的，组织要提供的，隐藏非核心的，转移复杂的。不能为了简单过度删除，比如自行车过度删除成独轮车，你会骑吗？这样的简单主流用户是不会接受的，也就是说这样的简单是失败且不可取的。</p>
<h2 id="后记-3"><a class="header" href="#后记-3">后记</a></h2>
<p>昨天我又走马观花的读了一遍，依旧有很多收获，如果没有记错，这是第三次阅读了。</p>
<p>相比于摘要，原书内容要更加精彩！</p>
<p>熟练掌握知识后，必然掌握砍需求之刀！</p>
<p>如有条件，还请支持正版（第二版已发布）！以下内容为第一版，仅供学习使用，不要肆意分享 <a href="https://pan.baidu.com/s/109aWYGnoBnRHFo3SLV_YzQ">链接</a> 提取码: c13f</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="杂谈"><a class="header" href="#杂谈">杂谈</a></h1>
<p>姑妄言之</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="杂篇一"><a class="header" href="#杂篇一">杂篇（一）</a></h1>
<h2 id="开篇词"><a class="header" href="#开篇词">开篇词</a></h2>
<p>我本是红尘一俗客，没有那文人酸腐气。</p>
<p>曾几何时，梳理收藏夹，发现了很久前收藏的一位前端大佬的个人博客：<a href="https://imnerd.org/">怡红院落</a> ，因为领域不同，之前一直没有拜读过他的文章。 我尚且无法判断怡红公子购买的域名中，"imnerd" 是指 "书呆子"
还是 "电脑迷"，他在文中这样介绍自己：</p>
<blockquote>
<p>嗯，平凡，普通的不能在普通的一个地球人，从初中到大学都没出方圆百里的老挫男；</p>
<p>喜欢上网，是个极度恋家的宅男+网虫。喜欢计算机技术，但自己没本事，啥也不会；</p>
<p>网络让我认识了好多人， 比我大的，比我小的，男的，女的，还有好多动物。</p>
<p>喜欢朦胧的细雨，爱上烟雨的江南，形式作风拖拖拉拉，是个十足的懒散蛋，行事低调，主要原因是胆小怕事，没有勇气。</p>
<p>属于内在美没有，外在美全无的那种人， 在社会的大河中漂流， 希望平平淡淡的过完这一生。</p>
<p>一座小房，有工资，还有一台电脑，就够了。</p>
<p>出自：<a href="https://imnerd.org/about.html">关于|怡红院落</a></p>
</blockquote>
<p>但他的文章中，除了技术博文外，还有说走就走的旅行、发自内心的影评。</p>
<p>这让我相信了："愿你出走半生，归来仍是少年" 所言非虚。所以，在技术相关的绝对理性内容之外，我开辟了这一隅，留给自己的感性。</p>
<h2 id="务必让自己慢下来"><a class="header" href="#务必让自己慢下来">务必让自己慢下来</a></h2>
<p>杨绛在百岁感言中写道：</p>
<blockquote>
<p>我们曾如此渴望命运的波澜,到最后才发现:人生最曼妙的风景,竟是内心的淡定与从容</p>
</blockquote>
<p>我也曾于古文中探索，君子如玉是何种风采；怎样的内涵，才能支撑起内心深处的淡定与从容。</p>
<p>曾经我以为，能够让一个技术人员做到淡定从容的是渊博的知识与见识，就如同："家中有粮，心里不慌"。</p>
<p>但没过多久我就陷入了迷茫，即便我的专业知识、技能、业务知识已经能够完全掌控 "编程工作" 时，依旧会有一些事情，让我无名火起。</p>
<p>要知道，世间有很多的的压力 <strong>迫使你往前跑</strong> ，世间有很多种声音在尝试暗示和欺骗你："只要你有能力能够掌控这些事情，你就能..."，以此让你 <strong>跑的更快</strong> 。</p>
<p>当你跑的足够快的时候，你就再也没有机会去观察自己了，顺其自然的，你也不会有机会发现自己的问题并修正。失去了雕琢自身的可能，自然不会锻炼出内心的淡定与从容。</p>
<p>因此，一定要让自己先慢下来，至少先意识到要慢下来，通过观察自身，去尝试发现问题。</p>
<p>淡定是对事物的反应的一种理智表现，而做到从容要更加困难，往往需要在认知领域达到很高的成就，它不仅是心理活动，在行动上也表现一致。这让我联想到了一个影视人物：天道中的丁元英。</p>
<h2 id="那些有趣的玩具们"><a class="header" href="#那些有趣的玩具们">那些有趣的玩具们</a></h2>
<p>小时候收到过一个玩具，一个普通的魔方，虽然它在漫长的岁月里早已损坏。嗯，就像这样的小玩意</p>
<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d4103e0414940e69c5585a232ba9655~tplv-k3u1fbpfcp-watermark.image?" width="162" />
<p>它很容易被打乱，并且难以靠运气还原它:</p>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51cc4120c86f46399059a5fe1fe40b04~tplv-k3u1fbpfcp-watermark.image?" width="162" />
<p>即便是最基本的还原方式，也需要遵循步骤，</p>
<p>先还原一层：</p>
<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d10e23b35934b12bbadc07c3d050274~tplv-k3u1fbpfcp-watermark.image?" width="162" />
<p>再还原一层：</p>
<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8961fc310fb9404fbb814b9a2f6e175f~tplv-k3u1fbpfcp-watermark.image?" width="162" />
<p>调整第三层：</p>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ba506c369974f08aac0f2bc9a0b5cbd~tplv-k3u1fbpfcp-watermark.image?" width="162" />
<p>最后再小心的完成它</p>
<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d4103e0414940e69c5585a232ba9655~tplv-k3u1fbpfcp-watermark.image?" width="162" />
<p>整个过程就像下图这样，即便它的组合非常的多，你也只需要记住解决问题的KeyPoint：</p>
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aedd2a0a96dd46bdadc28bf19ec91901~tplv-k3u1fbpfcp-watermark.image?" width="162" />
<p>有时候，同样的问题，随着观测的角度不一致，也会让你慌乱：</p>
<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b60086648e74a6ab761432354e10886~tplv-k3u1fbpfcp-watermark.image?" width="162" />
<p>请淡定一点，其实它们没有本质的差别</p>
<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86e1369769814be6bb30c23a956bebfc~tplv-k3u1fbpfcp-watermark.image?" width="162" />
<p>随着年龄的增长，我们会碰到更大的麻烦：</p>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bac5ef6816ba4e6eb89516dfd73dd5d8~tplv-k3u1fbpfcp-watermark.image?" width="162" />
<p>甚至为了追寻刺激，自己寻找更大的麻烦：</p>
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fed222860f5b4481aa6f4625867c3c85~tplv-k3u1fbpfcp-watermark.image?" width="162" />
<p>但仍请保持乐观</p>
<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8304b527c7944901bb142da4aa3db5d6~tplv-k3u1fbpfcp-watermark.image?" width="162" />
<p>问题也有可能会变得更加简单，但处理问题的步骤与经验同样可以复用</p>
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7ec15d8d92848f184fc26a6d6f0b99c~tplv-k3u1fbpfcp-watermark.image?" width="162" />
<p>有时候，除了角度不同，问题面也会有变化：</p>
<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/abc9d924be4a422791ade72e99d50b83~tplv-k3u1fbpfcp-watermark.image?" width="162" />
<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c978e684b4a4fd08849232c0a53a308~tplv-k3u1fbpfcp-watermark.image?" width="162" />
<p>他们时刻在提醒我，具体问题具体分析，过去的成绩只能代表过去，权威并不能在所有问题下保持权威。</p>
<p>大多数人将这一行为称为收集，部分人称之为"积累与成长"</p>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/15860a9335bd424796a1936e7fe9183c~tplv-k3u1fbpfcp-watermark.image?" width="162" />
<h2 id="找准目标"><a class="header" href="#找准目标">找准目标</a></h2>
<p>我们需要清晰地意识到正确的目标才能玩转这些玩具，人生中的各种事情也是如此。</p>
<p>正如同兵家所言："故善战者，立于不败之地，而不失敌之败也。是故胜兵先胜而后求战，败兵先战而后求胜。"，如此方能做到从容。</p>
<p>将问题放大到人生路上，找准目标并非一件简单的事情，它牵涉到人生观、世界观、价值观，绝大多数情况下，我们无法判断已经认准的目标是对是错，甚至它们本身就没有对错之分！</p>
<p>前段时间，阅读到一篇对于 "高级程序员与普通程序员差别" 的讨论帖，截取核心内容如下，相信各位同行会有所感悟。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/557ff08585c64231a4f6515e4da2550e~tplv-k3u1fbpfcp-watermark.image?" alt="different_coder.png" /></p>
<p>大多数时候，我们都在做一些 <strong>"功利"</strong> 的事情，如同沿着如下图的技能树去扩展技能</p>
<p><em>注意，这里功利是一个中性词</em></p>
<img width=300 src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f3b27705d1e645abb9dfe0b301e624f0~tplv-k3u1fbpfcp-watermark.image?"/>
<p>图片来自 <a href="https://github.com/skydoves/android-developer-roadmap">skydoves/android-developer-roadmap</a></p>
<p>值得肯定的是，做此类功利的事情可以提升能力和看问题的深度，但难以提升广度。</p>
<p>现实生活中的问题也没有编程那么纯粹；能够拥有一位智者充当人生导师亦是极其罕见的机遇；所以找准目标是一件有挑战的事情，<strong>可能 "阅读经典书籍" 是一项有帮助的行为</strong>。</p>
<h2 id="关于读书"><a class="header" href="#关于读书">关于读书</a></h2>
<p>这是一个比较严肃的事情，我并不打算这样轻易地展开讨论下去。</p>
<p>读书分两种，功利的和非功利的；功利性的读书在合适场景下可以很快得到利益反馈，而非功利性的读书往往带给人思维上的质变。</p>
<h2 id="不再拘泥认可"><a class="header" href="#不再拘泥认可">不再拘泥认可</a></h2>
<blockquote>
<p>我们曾如此期盼外界的认可,到最后才知道:世界是自己的,与他人毫无关系。 -- 杨绛</p>
</blockquote>
<p>一般来说，知音体博主的小作文不会引用这一句，故一部分人只知道前一句。</p>
<p>我也曾执着于 <strong>"证明自己"</strong> ，<strong>"赢得认可"</strong> ，换来的往往是 "君子可以欺之以方"，在我读过《老子》《管子》，之后便释怀了。</p>
<p>从事脑力附加劳动的人，往往执着于获取他人的认可，但他人的认可是不仅仅取决于自身能力，亦取决于他人的素养、知识与道德。所以我认为，技术人需要的底线是尊重，可以不被认可，但不能不被尊重。</p>
<blockquote>
<p>圣人被褐而怀玉</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="杂篇二---认识并战胜焦虑"><a class="header" href="#杂篇二---认识并战胜焦虑">杂篇（二）-- 认识并战胜焦虑</a></h1>
<p>人生天地之间，若白驹之过隙，忽然而已矣。上一篇杂篇后，已是冬去春来。其实时间并未加快脚步，改变的是我对人生的态度。</p>
<p>有句俗语："急得像热锅上的蚂蚁"，蚂蚁感受到了将来的危险，但又没有改变现状的能力，处于焦虑之中，时间变得难熬。因此我并未像这只蚂蚁一般处于焦虑之中。</p>
<p>但在一年半前，我尚处于焦虑之中，正如您所想，焦虑来源于俗称的35岁危机。在心理学中，焦虑起于你认识到风险，并在一步步走向风险但无计可施。
一方面，疫情原因导致全球经济不景气，互联网行业也遭遇冷冬；另一方面，有一帮辛苦谋生的人，拼尽全力向我们贩卖焦虑。</p>
<p>从哲学上看，焦虑并非全无益处，但终究是弊大于利，以列子的虚无寂灭之法去无视焦虑，并非是上上之选。</p>
<h2 id="人生三境"><a class="header" href="#人生三境">人生三境</a></h2>
<p>前段时间，了解到一本小说《穆斯林的葬礼》，尚未全部读完，但其中的一段话已烙印在脑海之中，讲的是人生追求的三种境界。</p>
<blockquote>
<p>人们要做好一件事，大都是从向往开始，如登高望远，对那遥遥可见的风景，充满无限的憧憬，这便是第一境。</p>
<p>继而为之痴迷，苦苦追求，虽山重水复、万险千难也在所不惜，这便是第二境。</p>
<p>许多人就在这第二境中停顿了，退却了，或者倒下了，吃尽跋涉之苦，却未曾尝到攀登之乐，因为他没有达到那风光无限的第三境。</p>
<p>难就难在第三境，妙就妙在第三境，那是艰苦跋涉之后的突然发现，是长期积累之后的妙手偶得，是废纸三千之后的神来之笔。</p>
</blockquote>
<p>哲学中提到，量变引起质变，这三境也是如此，达到第三境需要一次质变，而从第二境的不断积累到最终的质变，需要一次跃迁。
正如同道家中的悟道和佛家中的开慧，不仅仅需要大量积累，<strong>还需要体悟思考</strong>。</p>
<h2 id="认清形式"><a class="header" href="#认清形式">认清形式</a></h2>
<p>我很喜欢梁晓声的这句话：</p>
<blockquote>
<p>岁月的列车不为谁停下，命运的站台，悲欢离合都是刹那，谁也无法阻止时光的脚步。
我们终将在岁月中老去，没有必要忧心忡忡，也没有必要烦恼不已，三千繁华，弹指刹那，多年之后一捧黄沙。
如此一来，就没必要纠结。生命就是一次有去无回的旅程，一路上每个人都有属于自己的独特风景。
无论你是否愿意是否接受，都是在命运的裹挟下一路前行。</p>
</blockquote>
<p>平心而论，我和诸位读者，大抵都是从事互联网IT行业。诚然，想吃这碗饭具有一定的技术门槛，但能在普罗大众中获得一份较高的薪资，本质上是享受互联网蓬勃发展的红利，技术和努力固然重要，但并不起决定性作用。这就是"命运的裹挟"。</p>
<p>但任何行业的发展都会陷入瓶颈，互联网行业也不例外。如果说目前取得的成功是因为登上了一部快捷的列车，而它又快要到达终点，我们是时候想想，下车后该选择哪一部列车呢？</p>
<p>在人生追求的三重境界中，我们要选对第一境中向往的目标。</p>
<h2 id="反复地理性地全面的思考总结"><a class="header" href="#反复地理性地全面的思考总结">反复地、理性地、全面的思考总结</a></h2>
<p>论语中记载了，曾子每天都思考三件事情：</p>
<blockquote>
<p>曾子曰：“吾日三省吾身：为人谋而不忠乎？与朋友交而不信乎？传不习乎？”</p>
</blockquote>
<p>我们对于事物的认知，总是在进步的，每一次反思，都有可能有新的收获，这也是曾子能德学兼备的原因。</p>
<p>可能诸位读者中的绝大部分都会时常反思，诸如技术实现方案，工作事物的处理，人际关系、家庭事物等等。一般而言，我们能够做到：</p>
<ul>
<li>从自身的角度出发，分析思考</li>
<li>从事物的角度出发，分析思考</li>
</ul>
<p>但我们很少能做到：站在他人的视角分析思考。注意，这并不是单纯的换位思考！</p>
<p>例如，吃完饭后把锅碗全收拾了，我们可能会从自身角度出发，认为自己和别人相比，更顾家、体贴；从事物出发，觉得总要有人干掉，最后吃完的收拾掉就行了。
但您是否站在您爱人的角度、小孩的角度思考过，他们怎么看待您去收拾锅碗这件事情，您是否能正确无误的看穿他们的想法呢？</p>
<p>又例如加班，我相信大家都讨厌加班，并且能从 "自身发展"、"项目健康度"、"加班的法律支持"等分析出一大堆内容，但您是否从其他人的视角分析过 "如何看待你在加班"。</p>
<p>如同收拾锅碗，小孩可能认为你抢走了他挣零花钱的机会，爱人可能担心你洗的不干净。对于您的加班行为，上级可能担心你的项目失控，您的老板可能担心你们在浪费水电毫无产出。</p>
<p>各种可能都有，而真正重要的是您在不停锻炼自己观察他人心理活动的能力，并且通过各种客观事物验证。当您驾驭了这种能力后，您会减少很多烦恼，您不会再焦虑我要付出多少努力才能得到认可。</p>
<h2 id="建立坚固的科学的价值观体系"><a class="header" href="#建立坚固的科学的价值观体系">建立坚固的、科学的价值观体系</a></h2>
<p>你在凝视深渊，深渊也在凝视你。</p>
<p>当您尝试从他人视角思考时，您需要先了解他人的价值观并自我带入，这样才能做出更加准确的分析。
<strong>而这一行为是危险的</strong>，您可能不知不觉中接受了他人的价值观并对自身价值观形成颠覆，俗称被洗脑！甚至有些人会主动尝试为您洗脑！</p>
<p>所以您需要先武装自己，而读书是一个安全且有效的方式。</p>
<p>例如，您一定会在企业中接触到一些词，如艰苦卓绝、奋斗、共赢、牺牲；您一定能遇到一些人，他们在宣讲这些内容时甚至可以契合社会主义核心价值观，您隐约发觉不对而又找不到理论依据！为此苦恼！</p>
<p>大约小半年前，我拜读了穆勒的《功利主义》并和同事进行了分享，对价值观进行了一次武装。</p>
<p>通过阅读，吸收大家公认的科学的价值观、哲学思想，您也可以领略到坐在哲学家思想家的肩膀上看普通人表演的心境。</p>
<p>当然，我们也可以读一些闲书，例如我过年期间消闲，就翻看了一本老爽文小说《雪鹰领主》，但即便是这类爽文小说，也体现了：</p>
<ul>
<li>人要按照自己的本心，尽力而为，心境才能通透</li>
<li>灵魂都是向往自由的，不应当强行束缚奴役</li>
<li>追求自己喜爱的东西，才能发挥出最大的力量而不遇瓶颈</li>
<li>强者要为弱者出头，弱者会认可帮助他们的人，弱者虽弱，但人心一致，力量积蓄起来远超强者</li>
</ul>
<p>而大部头相比闲书，信息更凝聚，理论更深刻，研究者众多。</p>
<h2 id="正视焦虑"><a class="header" href="#正视焦虑">正视焦虑</a></h2>
<p>黑格尔哲学体系中说存在即合理，您出现焦虑也必然有其滋生的客观原因，不要尝试忽视它，而应当客观的剖解并解决问题！</p>
<p>上个月阅读了一本心理学基础书目：《自卑与超越》，对于培养小孩子也有很大帮助，有兴趣的读者可以搜索一读，绝对不亏。</p>
<p>如果您比其他人更容易焦虑，可能存在自卑情结，但只需要正视它并科学的应对，反而有可能获得更大的收获。</p>
<h2 id="末-1"><a class="header" href="#末-1">末</a></h2>
<p>部分读者可能在沸点上留意到了，我最近身体出了点毛病，折腾的够呛，为了保障安全，甚至农药这类游戏都戒了。</p>
<p>把节奏放缓之后，陪老婆逛了逛西园寺撸猫，看窗外大爷在花园里下棋下一天... 发现这日子是怎么过都能过的，只要能力驾驭的住，过的节奏慢一点反而不会错过风景。</p>
<p>最后分享罗翔老师经常分享的话：</p>
<blockquote>
<p>知道和做到之间存在巨大的鸿沟</p>
<p>对于自己无法改变的，要保持乐观；对于自己能够改变的，要保持谨慎。</p>
</blockquote>
<p>如果无法改变客观环境，那不妨调整心态，有计划性的提升自我能力，如果能力也无法提升了，那就回头看看，是否只需要放宽心态。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="向钱看你需要想明白企业在为什么而付钱"><a class="header" href="#向钱看你需要想明白企业在为什么而付钱">向钱看，你需要想明白企业在为什么而付钱</a></h1>
<h2 id="写在开始前"><a class="header" href="#写在开始前">写在开始前</a></h2>
<p>在7月，花了约三周的时间，换了一份新工作。</p>
<p>上句话不到20个字，背后的千言万语，不愿在本篇提及，个人的思考过程和结论，酌情提取后，夹杂在以后得文章中。</p>
<p>从4月至7月，我一直在思考几个问题：</p>
<ul>
<li>企业应当如何管理人才</li>
<li>怎样执行绩效考核管理，才能公平公正且令人信服</li>
</ul>
<p>目的之一，是反向迎合以获得更高地评价。目的之二，是思考如何做好管理。最底层的目的，大方且粗鄙地讲，<strong>就是怎么挣更多的钱，工作需要实现挣钱的目标，这是底层刚需</strong>，"实现社会价值"、"获得认同感"等等都往边上靠。</p>
<p>这两个问题宏大、复杂，那不妨简单点，于是我读了一本关于<strong>如何发钱</strong>的书。</p>
<p>这本书的主要受众群体是HR和企业管理者：</p>
<ul>
<li>它是一本诠释、推销理念的书，因此其表达技巧和行文思路值得学习借鉴</li>
<li>它包含大量案例解读和实操指导，这些对于研发工作者价值不大，感兴趣的读者可阅读原本</li>
</ul>
<p>摘记整理如下。</p>
<blockquote>
<p>作者按：我一向认为，判断问题是否值得思考以及思考求索的过程要比别人给出的答案重要。</p>
</blockquote>
<h2 id="摘记"><a class="header" href="#摘记">摘记</a></h2>
<p>《薪酬设计实战：激发人才活力的薪酬体系设计》-  孙科柳，李曼，贺鹏著</p>
<p>全书一共有个九个章节：</p>
<ol>
<li>薪酬战略</li>
<li>薪酬策略</li>
<li>人力经营</li>
<li>薪酬水平</li>
<li>薪酬结构</li>
<li>岗位定薪</li>
<li>动态调整</li>
<li>薪酬优化</li>
<li>薪酬管理</li>
</ol>
<p>前4个章节偏重于理念，后5个章节偏重于实践</p>
<h2 id="薪酬战略"><a class="header" href="#薪酬战略">薪酬战略</a></h2>
<p>内容结构：</p>
<ul>
<li>
<p>薪酬与薪酬战略</p>
<ul>
<li>薪酬的定义、内涵与发展</li>
<li>薪酬管理在人力资源管理中的位置</li>
<li>薪酬战略的典型实践</li>
</ul>
</li>
<li>
<p>薪酬战略要与企业战略目标保持一致</p>
<ul>
<li>薪酬体系为企业战略服务</li>
<li>薪酬体系要随着企业战略进行动态调整</li>
<li>不匹配的薪酬战略影响企业战略目标的实现</li>
</ul>
</li>
<li>
<p>贯彻付薪理念，强化企业核心价值观</p>
<ul>
<li>基于企业战略明确企业的付薪要素</li>
<li>付薪理念是制定薪酬体系的前提</li>
<li>贯彻企业的付薪理念，传递企业的核心价值观</li>
</ul>
</li>
<li>
<p>构建有特色的薪酬体系，激发人才活力</p>
<ul>
<li>良好的薪酬体系是吸引人才的有力保障</li>
<li>业绩与能力并重，激励员工提升能力</li>
<li>薪酬导向高回报率人才，激发人才活力</li>
</ul>
</li>
</ul>
<p>重点摘要：</p>
<blockquote>
<p>企业战略是指企业先定位好自己在市场中的位置，然后明确未来的目标是什么、实现目标的路径是什么，以及与行业竞争对手相比存在哪些差异。</p>
<p>战略解决的事方向、目标以及路径问题。</p>
<p>薪酬体系作为企业人力资源体系的重要组成部分，向员工传达了企业中什么是有价值的，进而牵引员工的努力和行为聚焦到战略目标实现上。</p>
</blockquote>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left"><strong>企业发展阶段</strong></th><th style="text-align: left"><strong>初创期</strong></th><th style="text-align: left"><strong>快速成长期</strong></th><th style="text-align: left"><strong>成熟稳定期</strong></th><th style="text-align: left"><strong>衰退期</strong></th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>企业战略</strong></td><td style="text-align: left">探索商业模式，获得盈利</td><td style="text-align: left">快速增长；扩大市场规模</td><td style="text-align: left">持续稳定增长；提升盈利空间</td><td style="text-align: left">削减成本；控制衰退</td></tr>
<tr><td style="text-align: left"><strong>薪酬体系</strong></td><td style="text-align: left">加大浮动薪酬比例；对原创团队给予长期激励</td><td style="text-align: left">通过有竞争力的薪酬水平；逐步完善薪酬管理机制</td><td style="text-align: left">统一薪酬体系；更加注重内部平衡；加强人力资源机制建设</td><td style="text-align: left">节约/控制人力成本保留部分核心人员</td></tr>
</tbody></table>
</div>
<blockquote>
<p>人力资源可分为三类：</p>
<ol>
<li>奉献者（贡献大于回报）</li>
<li>打工者（贡献等于回报）</li>
<li>偷懒者（贡献小于回报）</li>
</ol>
<p>当奉献者老是吃亏，他就会反思，对自己的行为做出怀疑，进而减少自己的贡献，使贡献与低层次回报相等，他就会变成打工者，同样，打工者也会向偷懒者转变</p>
</blockquote>
<blockquote>
<p>付薪要素是指企业的激励导向，表示的是企业为“什么”支付薪酬。常见的付薪要素有4种：</p>
<ol>
<li>为绩效付薪 -- 员工为企业创造的业绩所支付的薪酬</li>
<li>为岗位付薪 -- 以岗位价值的大小作为整个薪酬体系的核心要素，岗位价值的大小直接决定了该岗位薪酬的高低</li>
<li>为能力付薪 -- 能力既包含学历、职业资质、经验以及工龄等，也包含专业技能、沟通能力和忠诚度等</li>
<li>为市场付薪 -- 企业根据市场薪酬水平来确定岗位的薪酬水平，以确保薪酬的市场竞争力</li>
</ol>
</blockquote>
<h2 id="薪酬策略"><a class="header" href="#薪酬策略">薪酬策略</a></h2>
<p><strong>内容结构</strong>：</p>
<ul>
<li>
<p>薪酬策略是薪酬体系设计的基本导向</p>
<ul>
<li>薪酬策略是薪酬体系设计的指导思想</li>
<li>薪酬策略需要体现企业的文化特征</li>
<li>薪酬策略要与企业的组织架构相匹配</li>
</ul>
</li>
<li>
<p>构建有外部竞争力的薪酬体系，提升薪酬吸引力</p>
<ul>
<li>薪酬水平要体现企业经营战略</li>
<li>市场对标，定位企业的薪酬水平</li>
<li>薪酬水平要向核心人才倾斜</li>
</ul>
</li>
<li>
<p>规范薪酬结构，分类分级设计薪酬结构</p>
<ul>
<li>配合全面的人才管理，分类分级规划薪酬结构</li>
<li>优化固浮比，合理确定浮动薪酬占比</li>
<li>融合岗位要求与个人能力，开展宽带薪酬设计</li>
</ul>
</li>
<li>
<p>设计差异化的激励机制</p>
<ul>
<li>贡献完全可量化的岗位，采取个人提成制</li>
<li>注重团队协作，运用项目分享制</li>
<li>业绩贡献难以量化，采用目标奖金制</li>
</ul>
</li>
<li>
<p>典型的绩效薪酬策略</p>
<ul>
<li>减人增效加薪，激励员工位企业创造更大价值</li>
<li>推行团队分享制，多劳多得</li>
<li>通过合伙人制，实现组织利益与风险共担</li>
</ul>
</li>
</ul>
<p><strong>重点摘要：</strong></p>
<blockquote>
<p>薪酬策略体现为企业对薪酬管理运行的目标、任务以及手段的选择，包括薪酬成本与预算控制策略、薪酬水平策略和薪酬结构策略等</p>
</blockquote>
<p>-- 通过公司当前薪酬水平、结构设计等，可以推断它在行业内以及该行业的情况，与实际情况对比，可以考量“行业态势”、“公司态势”、“管理层策略” by Leobert</p>
<blockquote>
<p>不同行业、不同类型的企业所反映的文化是不同的，而它们的文化属性对薪酬策略的制定会有潜移默化的影响。</p>
</blockquote>
<blockquote>
<p>当企业文化位平均主义时，员工的薪酬构成中固定部分应该占较大的比例</p>
<p>对业绩导向的企业文化，薪酬构成中固定部分应该占较小的比例，绩效工资和奖金等浮动部分应该占较比例；</p>
</blockquote>
<blockquote>
<p>常见的薪酬水平策略主要有4种：</p>
<ol>
<li>领先型薪酬水平策略；75分位以上</li>
<li>跟型型薪酬水平策略；市场50分位</li>
<li>滞后型薪酬水平策略；25分位</li>
<li>混合型薪酬水平策略；根据职位类型员工类型分别制定</li>
</ol>
</blockquote>
<p>-- 综合考量市场情况，公司业绩进而判断公司管理者水平 by Leobert</p>
<h2 id="人力经营"><a class="header" href="#人力经营">人力经营</a></h2>
<p><strong>内容结构：</strong></p>
<ul>
<li>
<p>依据企业经营目标，编制“三定”计划</p>
<ul>
<li>三定计划是薪酬预算编制的依据</li>
<li>基于企业经营目标，完善岗位设置</li>
<li>根据岗位设置，科学合理定编</li>
</ul>
</li>
<li>
<p>科学经营人力资源，提升企业竞争力</p>
<ul>
<li>正确认识人力成本，避免陷入认知误区</li>
<li>科学分析人力成本，实现更好的成本控制</li>
<li>做好人力成本分析，发挥人力经营杠杆作用</li>
</ul>
</li>
<li>
<p>做好薪酬预算管理，把钱花在刀刃上</p>
<ul>
<li>薪酬是经营成本，需要进行预算与控制</li>
<li>薪酬预算的目标与方法</li>
<li>薪酬预算的管控与调整</li>
</ul>
</li>
<li>
<p>优化薪酬总额决定机制，提升人才活力</p>
<ul>
<li>建立薪酬总额与业绩联动机制，促进价值创造</li>
<li>做好薪酬递延支付，以丰补歉</li>
<li>薪酬增量导向核心岗位与骨干，体现价值导向</li>
</ul>
</li>
<li>
<p>做好人效分析，为人效提升指明方向</p>
<ul>
<li>人效是人力经营的导向</li>
<li>甄选关键人效指标，全面评价人力经营效率</li>
<li>开展人效分析，实现人效提升</li>
</ul>
</li>
</ul>
<p><strong>重点摘要：</strong></p>
<blockquote>
<p>三定：定岗、定编、定员；</p>
</blockquote>
<blockquote>
<p>薪酬作为一种经营成本，也是需要与其他成本一起进行总体预算与控制的。也就是说，企业给员工发放的薪酬总额应该计算清楚并有所管控</p>
</blockquote>
<blockquote>
<p>企业应该基于以下原则来建立薪酬总额与业绩挂钩的联动机制：</p>
<ol>
<li>以业绩为中心，量入为出。薪酬总额应依据企业的经营业绩来确定，量入为出</li>
<li>“两低于”原则。薪酬总额的增长幅度要低于企业销售收入的增长幅度；员工实际平均薪酬水平的增长幅度要低于人均销售收入的增长幅度</li>
<li>绩效回报原则。员工个人薪酬的增长率，要基于市场上相应岗位的价位、员工个人的贡献来确定。</li>
<li>谨慎增长原则。薪酬总额的增长在某种程度上具有刚性。</li>
</ol>
</blockquote>
<p>-- 不谋全局者不足谋一域,不谋万世者不足谋一时</p>
<blockquote>
<p>人效，简单来说，就是人力资源的投入产出比。</p>
</blockquote>
<p>-- 团队扩大可能会降低人效，挑活，不是可耻的事情。by leobert</p>
<h2 id="薪酬水平"><a class="header" href="#薪酬水平">薪酬水平</a></h2>
<p><strong>内容结构：</strong></p>
<ul>
<li>
<p>知己知彼，开展薪酬调查</p>
<ul>
<li>调查薪酬，为设计薪酬水平提供指导</li>
<li>有目的地收集薪酬信息，全面了解市场薪酬水平</li>
<li>有针对性地处理与分析数据，最大限度地保障准确性</li>
</ul>
</li>
<li>
<p>合理确定薪酬水平，强化外部竞争力</p>
<ul>
<li>对标分析，确定现有薪酬的市场水平</li>
<li>对照企业战略，明确薪酬水平的市场定位</li>
<li>定期维护薪酬水平，确保薪酬外部竞争力</li>
</ul>
</li>
<li>
<p>分类对标，吸引和保留优秀人才</p>
<ul>
<li>为不同职位分类设定不同的薪酬水平</li>
<li>基于岗位特点差异化设计薪酬水平</li>
<li>员工创造的价值不同，薪酬水平不同</li>
</ul>
</li>
<li>
<p>保持薪酬外部竞争力的同时，兼顾内部公平性</p>
<ul>
<li>薪酬外部竞争力和内部公平性的关系</li>
<li>薪酬外部竞争力优先</li>
<li>薪酬外部竞争力与内部公平性兼顾</li>
</ul>
</li>
</ul>
<p><strong>重点摘要</strong>：</p>
<blockquote>
<p>当员工认为自己的薪酬水平与所创造的价值不相符时，就会降低工作的积极性，进而降低对企业薪酬体系的满意度。</p>
</blockquote>
<blockquote>
<p>当企业构建起外部竞争力和内部公平性兼具的薪酬体系时，不仅能提升企业对优秀人才的吸引力，还能改善员工对薪酬公平性的感知度，激发他们的奋斗动力，持续为企业创造价值，最终实现员工和企业共赢</p>
</blockquote>
<blockquote>
<p>"公平、公正、平等的管理原则"、“与工作投入相匹配的薪酬回报” 是评价雇主是否是理想雇主最重要的两个原则。</p>
</blockquote>
<h2 id="薪酬结构"><a class="header" href="#薪酬结构">薪酬结构</a></h2>
<ul>
<li>
<p>差异化薪酬构成，引导员工聚焦到价值创造的关键点上</p>
<ul>
<li>明确薪酬总体结构，导向企业经营目标</li>
<li>差异化设计不同职类的薪酬构成</li>
<li>针对不同类型的员工，设计不同的薪酬构成</li>
</ul>
</li>
<li>
<p>针对薪酬构成要素，明确关键设计点</p>
<ul>
<li>基于岗位特点设计基本工资，保障员工的基本生活</li>
<li>将绩效奖金与绩效结果花狗，强化激励作用</li>
<li>从员工需求角度设计福利，增强员工的归属感</li>
</ul>
</li>
<li>
<p>合理搭配固定和浮动薪酬，确保“劳有所得，绩有所得”</p>
<ul>
<li>分级设定薪酬固浮比，保障薪酬的激励性</li>
<li>基于岗位特点，设定适用的薪酬固浮比</li>
<li>设计内部二次竞争机制，牵引价值创造</li>
</ul>
</li>
<li>
<p>适时优化薪酬结构，激活组织</p>
<ul>
<li>围绕经营管理导向，优化薪酬构成要素</li>
<li>加大浮动薪酬比例，拉大差距</li>
<li>改变薪酬等级，增加薪酬管理的灵活性</li>
</ul>
</li>
</ul>
<p>重点摘要：</p>
<blockquote>
<p>薪酬作为企业给员工劳动回报的一部分，通常是工资、奖金、福利等多种要素的组合。</p>
<p>由基本工资、福利、津贴、短期激励、中长期激励等构成。</p>
</blockquote>
<blockquote>
<p>薪酬激励既要关注员工的获得感，也要关注企业的人工成本可控性。</p>
</blockquote>
<blockquote>
<p>在设定薪酬固浮比时，通常应遵循如下原则：</p>
<ol>
<li>越高层级员工的浮动薪酬占比越高</li>
<li>越靠近客户的岗位浮动薪酬占比越高</li>
</ol>
</blockquote>
<blockquote>
<p>企业通常从两个维度来分析岗位特点：</p>
<ol>
<li>岗位绩效对组织绩效的影响程度。高则应使用高弹性模式的薪酬构成策略，低则应当采用稳定模式</li>
<li>岗位弹性。岗位弹性是指任职者的能力、能动性对岗位绩效的影响程度。高则应使用高弹性模式的薪酬构成策略，低则应当采用稳定模式</li>
</ol>
<p>处于24象限使用调和模式</p>
</blockquote>
<h2 id="岗位定薪"><a class="header" href="#岗位定薪">岗位定薪</a></h2>
<ul>
<li>
<p>岗位分析是设计公平合理的薪酬体系的前提</p>
<ul>
<li>岗位分析是岗位价值评估的基础</li>
<li>选择岗位分析方法，收集并分析信息</li>
<li>进行岗位描述，完善岗位说明书</li>
</ul>
</li>
<li>
<p>岗位价值评估为薪酬设计奠定合理的基础</p>
<ul>
<li>用“尺子”来评估岗位的相对价值</li>
<li>结合企业实际需要，选择合适的尺子</li>
<li>科学处理评估数据，确保评估结果的有效性</li>
</ul>
</li>
<li>
<p>依据岗位价值评估结果，导出职位等级体系</p>
<ul>
<li>梳理岗位层级，形成清晰的岗位架构</li>
<li>形成岗位价值等级表，明确岗位相对价值</li>
<li>建立职位等级体系</li>
</ul>
</li>
<li>
<p>实行宽带薪酬，提升新年抽的灵活性和激励性</p>
<ul>
<li>基于岗位价值评估设定薪级数，适配成长通道</li>
<li>确定具有市场竞争力的中点值，保证薪酬对优秀人才的激励性</li>
<li>设计合理薪酬带宽，保障薪资增长合理性</li>
</ul>
</li>
<li>
<p>导出薪级薪档表，强化薪酬应用灵活度</p>
<ul>
<li>明确岗位的价值产出弹性，确保薪酬的内部公平性</li>
<li>保持薪酬等级适度重叠，激发员工的活力</li>
<li>科学设置薪档数量，为新老员工预留晋升空间</li>
</ul>
</li>
<li>
<p>人岗匹配，以岗定薪，套改测算</p>
<ul>
<li>以岗定薪，基于薪级薪档表确定员工薪级薪档</li>
<li>处理好套改特殊情况，提升员工与薪酬的匹配度</li>
<li>套改测算分析，确保薪酬体系平稳落地</li>
</ul>
</li>
</ul>
<blockquote>
<p>开展岗位分析，能明确岗位的基本职责、任职资格等关键付薪要素，进而确保在岗位价值评估的过程中反映岗位的真实价值。</p>
<p>解决的是 “某一岗位应该干什么” 和 “该用什么样的人来干最合适” 这两个核心问题</p>
</blockquote>
<p>-- 对应的，员工可以反向分析，评估自身的工作情况、绩效以及职业规划 by leobert </p>
<blockquote>
<p>岗位分析需要收集的信息主要有：</p>
<ol>
<li>岗位基本信息。岗位名称、所属部门、岗位定员、直接上级、直接下级。</li>
<li>岗位工作内容及工作关系。主要指岗位的工作范围和主要内容，岗位的具体职责以及与部门内其他岗位之间的关系</li>
<li>岗位工作环境。工作地点与环境等信息</li>
<li>岗位任职资格。年龄、性别、学历、知识、经验、能力以及职业素养等</li>
</ol>
</blockquote>
<p>-- 可反向评估公司的管理是否健全；若成为管理者，这也是基本要素 -- by leobert</p>
<h2 id="动态调整"><a class="header" href="#动态调整">动态调整</a></h2>
<ul>
<li>
<p>正确理解薪酬的动态调整</p>
<ul>
<li>薪酬调整要小步、年年有</li>
<li>薪酬调整依据要明确，确保公平公正</li>
<li>差异化薪酬调整，打破平均主义</li>
</ul>
</li>
<li>
<p>适时调整薪酬，适应市场水平</p>
<ul>
<li>保持薪酬总体增长，降低员工离职率</li>
<li>岗位变动晋升调薪，激励员工做出更大贡献</li>
<li>关键岗位调薪，保障岗位薪酬竞争力</li>
</ul>
</li>
<li>
<p>绩效考核结果与调薪融合应用</p>
<ul>
<li>基于绩效等级矩阵确定调薪幅度</li>
<li>导向绩效考核结果优秀的人才</li>
<li>绩效考核结果差的员工降薪降级</li>
</ul>
</li>
<li>
<p>围绕人力经营目标，把握薪酬调整时机</p>
<ul>
<li>把握薪酬调整时机，发挥良好的激励作用</li>
<li>在人力经营范围内，对薪酬调整幅度进行管控</li>
</ul>
</li>
</ul>
<blockquote>
<p>人才不会因为钱多而永远满意，但是肯定会因为钱少而对企业产生不满意情绪。</p>
</blockquote>
<h2 id="薪酬优化"><a class="header" href="#薪酬优化">薪酬优化</a></h2>
<ul>
<li>
<p>全面开展薪酬诊断，有针对性地优化薪酬体系</p>
<ul>
<li>开展薪酬诊断，了解薪酬体系的合理性</li>
<li>切忌头痛医头脚痛医脚</li>
<li>量化薪酬诊断分析，科学指引薪酬决策</li>
</ul>
</li>
<li>
<p>分析薪酬构成，推动实现内部平衡</p>
<ul>
<li>寻求薪酬的保障和激励功能的平衡点</li>
<li>深入剖析薪酬构成情况</li>
<li>多维度开展薪酬效益分析</li>
</ul>
</li>
<li>
<p>对比薪酬竞争力，提升薪酬吸引力</p>
<ul>
<li>薪酬竞争力是吸引和保留人才的关键</li>
<li>明确企业薪酬定位，选定市场标杆</li>
<li>全方位对比薪酬水平，指明薪酬吸引力提升方向</li>
</ul>
</li>
<li>
<p>明确影响内部公平性的原因，提升员工的归属感</p>
<ul>
<li>开展薪酬内部公平性分析，提升员工归属感</li>
<li>分类分级对比，为薪酬结构差异化设计提供依据</li>
<li>提炼影响薪酬内部公平性的原因，奠定公平分配的基础</li>
</ul>
</li>
</ul>
<p>案例分析和实操指导为主，略</p>
<h2 id="薪酬管理"><a class="header" href="#薪酬管理">薪酬管理</a></h2>
<ul>
<li>
<p>薪酬管理需要良好的制度保证</p>
<ul>
<li>建立清晰明确的薪酬政策</li>
<li>从薪酬保密到薪酬公开</li>
<li>健全薪酬核算和支付机制</li>
</ul>
</li>
<li>
<p>明确薪酬管理权责，实现薪酬统一管理</p>
<ul>
<li>建立薪酬管理部门，统筹薪酬管理</li>
<li>直接主管和HR负责人的薪酬管理职责</li>
<li>规范薪酬激励审批流程和权限管理</li>
</ul>
</li>
<li>
<p>建立有效的薪酬沟通机制</p>
<ul>
<li>良好的薪酬沟通是薪酬体系落地的保障</li>
<li>及时开展薪酬沟通，确保薪酬管理有序推进</li>
<li>薪酬沟通需要各方协同配合</li>
</ul>
</li>
<li>
<p>关注薪酬变革风险，减轻变革阻力</p>
<ul>
<li>薪酬变革要循序渐进，谋定而后动</li>
<li>缓解抵制情绪，减轻变革阻力</li>
<li>把握变革中的关键要素，降低变革风险</li>
</ul>
</li>
</ul>
<p>案例分析和实操指导为主，略。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="半成熟的思考"><a class="header" href="#半成熟的思考">半成熟的思考</a></h1>
<p>往往以一个问题为引，展开各种思考，但未输出阶段性成果，姑且定义为质变前的量变</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="好玩系列--当spi-和-设计模式依赖注入发生碰撞可以擦出怎样的火花"><a class="header" href="#好玩系列--当spi-和-设计模式依赖注入发生碰撞可以擦出怎样的火花">好玩系列 | 当SPI 和 设计模式、依赖注入发生碰撞，可以擦出怎样的火花</a></h1>
<h2 id="前言-32"><a class="header" href="#前言-32">前言</a></h2>
<p>前段时间阅读到一篇文章，关于Service-Provider-Interface机制（SPI机制），在评论区看到一条评论：</p>
<blockquote>
<p>spi实现类是不是只能是空构造函数？</p>
</blockquote>
<p>后续我又回味了一下，这个问题可以引出很多有趣的内容，决定系统性的思考并分享讨论一番。</p>
<p><em><strong>作者按：有时候思考未必能获得令人振奋的完美答案，但这种思考是触发质变的积累</strong></em></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c22ee10a621947f3a38cca27ed01f96d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1080&amp;h=1779&amp;s=547534&amp;e=png&amp;b=191919" alt="img_2.png" /></p>
<p>因为讨论内容的scope比较广，而我的行文思路比较跳跃，为尽可能避免阅读时乏力，读者诸君可参考以下导图：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4024864ea70a42009e204e87f6849c0c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2678&amp;h=1982&amp;s=507388&amp;e=png&amp;b=fffdfd" alt="guideline.png" /></p>
<p><a href="https://github.com/leobert-lan/SPIDemo.git">文中涉及的代码可于本仓库获取</a></p>
<h2 id="spi机制简介"><a class="header" href="#spi机制简介">SPI机制简介</a></h2>
<blockquote>
<p>Service provider interface (SPI) is an API intended to be implemented or extended by a third party.
It can be used to enable framework extension and replaceable components.</p>
</blockquote>
<p>Service provider interface 是能被第三方继承或者实现的API，可以用作框架扩张或者可变组件</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ccd604bf8f9420fa838180d20e74e03~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1994&amp;h=1312&amp;s=134731&amp;e=png&amp;b=ffffff" alt="spi.png" /></p>
<p>不难理解，核心需要：</p>
<ul>
<li>预先定义服务接口，即SPI接口</li>
<li>由提供服务的模块自行实现SPI接口，并在Meta info中注册</li>
<li>提供服务的模块由某种机制被加载，<em>例如编译时、运行时，一般使用编译时，运行时将涉及插件化等</em></li>
<li>发现并加载服务实现</li>
</ul>
<h3 id="demo-1"><a class="header" href="#demo-1">Demo</a></h3>
<p>定义以下module，依赖关系如下：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b71444f404e34b2cb19b2152d4cb4a35~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=262&amp;h=96&amp;s=9730&amp;e=png&amp;b=3c3f41" alt="img.png" /></p>
<ul>
<li>api 用于接口和模型类定义</li>
<li>host 为主工程
<ul>
<li>编码时，依赖api</li>
<li>编译时，依赖api 和 服务提供模块</li>
</ul>
</li>
<li>module-a 一个服务提供模块，依赖api</li>
</ul>
<p><em>方便起见，不再定义多个服务提供模块，实现类均置于module-a中，读者应当能够理解，host通过编译时确定服务提供模块，是一种"可变组件"的实现方式</em></p>
<blockquote>
<ol>
<li>在api中定义接口：</li>
</ol>
</blockquote>
<pre><code class="language-kotlin">interface DemoApi {
    fun doSth(): String
}
</code></pre>
<blockquote>
<ol start="2">
<li>在module-a中定义实现类</li>
</ol>
</blockquote>
<pre><code class="language-kotlin">@AutoService(DemoApi::class)
class ModuleADemoApiImpl : DemoApi {
    companion object {
        const val NAME = "ModuleADemoApiImpl"
    }

    override fun doSth(): String {
        return "the result by $NAME"
    }
}
</code></pre>
<p>注意，还需要在Meta info中进行注册，手工操作比较麻烦，直接借助Google的AutoService。</p>
<p><em>注意，Demo中图方便使用Kotlin，因此需使用kapt，如果日常习惯使用ksp，Zacsweers提供了AutoService的ksp版，并需要处理打包资源目录</em></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dadfed12df4c412891d6cc4cb685f21c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=516&amp;h=219&amp;s=23449&amp;e=png&amp;b=4e4b40" alt="img_1.png" /></p>
<p>内容如下：</p>
<pre><code>osp.leobert.android.module.a.ModuleADemoApiImpl
</code></pre>
<p>模块加载即为声明dependency并编译，略去。</p>
<blockquote>
<p>使用</p>
</blockquote>
<pre><code class="language-kotlin">fun directLoadDemo() {

    val loader = ServiceLoader.load(DemoApi::class.java)
    val iterator = loader.iterator()
    var hasNext = false
    do {
        try {
            hasNext = iterator.hasNext()
            if (hasNext) {
                iterator.next().let {
                    println("find a impl of DemoApi, doSth:")
                    println(it.doSth())
                    println()
                }
            }
        } catch (e: Throwable) {
            println("thr: " + e.message)
        }
    } while (hasNext)

    println("finish directLoadDemo\r\n")
}
</code></pre>
<p>运行将在控制台观测到：</p>
<pre><code>find a impl of DemoApi, doSth:
the result by ModuleADemoApiImpl
</code></pre>
<h2 id="面向问题"><a class="header" href="#面向问题">面向问题</a></h2>
<p>上文已废诸多笔墨，演示了SPI的使用，让我们重新回到问题：</p>
<blockquote>
<p>使用SPI时，SPI实现类是不是必须要无参构造函数?</p>
</blockquote>
<p>不难理解，这需要从服务加载过程寻找答案。接下来我们分析下 <code>ServiceLoader</code> 中关于服务加载的核心代码。</p>
<h3 id="原因分析-serviceloader核心代码"><a class="header" href="#原因分析-serviceloader核心代码">原因分析-ServiceLoader核心代码</a></h3>
<blockquote>
<p>作者按：为什么要写这一段？</p>
<p>SPI是一种机制，既然是机制，就可以有多种实现手段，这里是Java中提供的一种手段！</p>
<p>阅读了解这一手段的实现可以帮助理解机制，并且能举一反三地联想到其他手段.唯有自行阅读才能有最深地体会！</p>
</blockquote>
<p>读者应当留意到，服务发现和服务加载的核心是ServiceLoader，答案也在其中。</p>
<p><em>作者按：可能大部分读者都是Android开发者，我挑选android.jar中的代码。注意，JDK中不同版本的源码不一致；Android发展历程中可能也发生过演变，未寻找证据</em></p>
<p>我们先关注两个核心方法：</p>
<ul>
<li><code>static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service)</code></li>
<li><code>Iterator&lt;S&gt; iterator()</code></li>
</ul>
<pre><code class="language-java">class ServiceLoader {
    private LazyIterator lookupIterator;

    public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service) {
        ClassLoader cl = Thread.currentThread().getContextClassLoader();
        return ServiceLoader.load(service, cl);
    }

    public Iterator&lt;S&gt; iterator() {
        return new Iterator&lt;S&gt;() {
            Iterator&lt;Map.Entry&lt;String, S&gt;&gt; knownProviders = providers.entrySet().iterator();

            public boolean hasNext() {
                if (knownProviders.hasNext())
                    return true;
                return lookupIterator.hasNext();
            }

            public S next() {
                if (knownProviders.hasNext())
                    return knownProviders.next().getValue();
                return lookupIterator.next();
            }

            public void remove() {
                throw new UnsupportedOperationException();
            }
        };
    }
}
</code></pre>
<p>很明显，服务发现和服务加载过程中需要利用 <code>ClassLoader</code>，<em>相关知识不再展开，此处可引发大量黑科技联想</em></p>
<p><code>knownProviders</code> 是已加载实例的池，不是重点，重点是 <code>lookupIterator</code></p>
<p>这部分代码略长，核心点在于：</p>
<ul>
<li>基于 <code>ClassLoader</code> 加载指定的Resource，即 <code>META-INF/services/{接口类名}</code>，还记得AutoService生成的文件吗？</li>
<li>解析内容获得类名</li>
<li>通过反射加载类</li>
<li>调用 <code>Class#newInstance()</code> 获得实例</li>
</ul>
<blockquote>
<p><code>Class#newInstance()</code> 制约了服务实现类必须要有无参构造函数。</p>
</blockquote>
<p>代码如下，泛读体会即可</p>
<pre><code class="language-java">private class LazyIterator implements Iterator&lt;S&gt; {

    Class&lt;S&gt; service;
    ClassLoader loader;
    Enumeration&lt;URL&gt; configs = null;
    Iterator&lt;String&gt; pending = null;
    String nextName = null;

    private LazyIterator(Class&lt;S&gt; service, ClassLoader loader) {
        this.service = service;
        this.loader = loader;
    }

    private boolean hasNextService() {
        if (nextName != null) {
            return true;
        }
        if (configs == null) {
            try {
                String fullName = PREFIX + service.getName();
                if (loader == null)
                    configs = ClassLoader.getSystemResources(fullName);
                else
                    configs = loader.getResources(fullName);
            } catch (IOException x) {
                fail(service, "Error locating configuration files", x);
            }
        }
        while ((pending == null) || !pending.hasNext()) {
            if (!configs.hasMoreElements()) {
                return false;
            }
            pending = parse(service, configs.nextElement());
        }
        nextName = pending.next();
        return true;
    }

    private S nextService() {
        if (!hasNextService())
            throw new NoSuchElementException();
        String cn = nextName;
        nextName = null;
        Class&lt;?&gt; c = null;
        try {
            c = Class.forName(cn, false, loader);
        } catch (ClassNotFoundException x) {
            fail(service, "Provider " + cn + " not found", x);
        }
        if (!service.isAssignableFrom(c)) {
            ClassCastException cce = new ClassCastException(service.getCanonicalName() + " is not assignable from " + c.getCanonicalName());
            fail(service, "Provider " + cn + " not a subtype", cce);
        }
        try {
            S p = service.cast(c.newInstance());
            providers.put(cn, p);
            return p;
        } catch (Throwable x) {
            fail(service, "Provider " + cn + " could not be instantiated", x);
        }
        throw new Error();          // This cannot happen
    }

    public boolean hasNext() {
        return hasNextService();
    }

    public S next() {
        return nextService();
    }

    public void remove() {
        throw new UnsupportedOperationException();
    }
}
</code></pre>
<h3 id="解决方案-1"><a class="header" href="#解决方案-1">解决方案</a></h3>
<p>严格来说，如果项目中：</p>
<ul>
<li>有<strong>严谨且健壮且全面</strong> 的 对象生命周期管理，并且与对象实例化时间无关联</li>
<li>通过其他途径，不依靠构造器做依赖注入</li>
</ul>
<p>那么将可消灭源头问题，即：没有使用有参构造器的必要。但现实比较骨感，这种假设过于理想化，并且会对编码习惯带来很多冲击。</p>
<p>如果非要使用含参构造器，有以下思路：</p>
<ul>
<li>暗度陈仓，不直接提供服务实现，而是基于SPI机制和现有实现，提供一个新服务，该服务满足"创建、获取特定服务"的需求，<strong>将实例的创建过程与获取过程分离</strong>
。通俗地讲，定义的Interface为目标api-Interface的Factory或者Builder</li>
<li>力大砖飞，自实现SPI机制，通俗地讲，即自定义ServiceLoader</li>
</ul>
<h2 id="与设计模式碰撞"><a class="header" href="#与设计模式碰撞">与设计模式碰撞</a></h2>
<p>换个角度看待问题，使用 <code>ServiceLoader</code> 时，其同时实现了：</p>
<ul>
<li>服务发现</li>
<li>服务加载（实例化）</li>
</ul>
<p>问题在于，实例化方式不满足服务提供者期望，而服务使用者关心点在于发现服务并使用服务，此时则不难想到设计模式。</p>
<p>如Factory模块，其创建对象时，无需对使用者暴露创建的逻辑。</p>
<h3 id="使用factory模式"><a class="header" href="#使用factory模式">使用Factory模式</a></h3>
<p>此时，SPI接口不再是原服务接口，而是原服务接口的Factory</p>
<h4 id="demo-2"><a class="header" href="#demo-2">Demo</a></h4>
<pre><code class="language-kotlin">interface DemoApiFactory {
    fun create(): DemoApi
}
</code></pre>
<p>模块提供Factory实现</p>
<pre><code class="language-kotlin">class SomeOp {
    fun execute(): String {
        return "[result of SomeOp $this]"
    }
}

//@AutoService(DemoApi::class)
class ModuleADemoApiImpl2(val someOp: SomeOp) : DemoApi {
    companion object {
        const val NAME = "ModuleADemoApiImpl2"
    }

    override fun doSth(): String {
        return "${someOp.execute()} - the result by $NAME"
    }

    @AutoService(DemoApiFactory::class)
    class Factory : DemoApiFactory {
        override fun create(): DemoApi {
            return ModuleADemoApiImpl2(SomeOp())
        }
    }
}
</code></pre>
<p>使用</p>
<pre><code class="language-kotlin">fun useFactoryDemo() {
    val loader = ServiceLoader.load(DemoApiFactory::class.java)
    val iterator = loader.iterator()
    var hasNext = false
    do {
        try {
            hasNext = iterator.hasNext()
            if (hasNext) {
                iterator.next().create().let {
                    println("find a impl of DemoApi, doSth:")
                    println(it.doSth())
                    println()
                }
            }
        } catch (e: Throwable) {
            println("thr: " + e.message)
        }
    } while (hasNext)

    println("finish useFactoryDemo\r\n")
}
</code></pre>
<pre><code>find a impl of DemoApi, doSth:
[result of SomeOp osp.leobert.android.module.a.SomeOp@26ba2a48]
 - the result by ModuleADemoApiImpl2

finish useFactoryDemo
</code></pre>
<h4 id="问题-1"><a class="header" href="#问题-1">问题</a></h4>
<p>读者诸君不难理解，Demo中的情况模拟的非常简单,而实际情况往往比较复杂，例如：获取构造器所需的参数往往比较复杂，可能来自不同模块</p>
<p>此时可与Builder模式相结合，<em>如果Builder已存在有参构造函数，在不修改的情况下，可继续套用Factory</em>。</p>
<h3 id="使用builder模式"><a class="header" href="#使用builder模式">使用Builder模式</a></h3>
<pre><code class="language-kotlin">interface DemoApi {

    fun doSth(): String

    interface Builder {

        var foo: Foo

        fun build(): DemoApi

        interface Factory {
            fun create(): Builder
        }
    }
}

class Foo {
    val createdAt = Throwable().stackTrace[1].toString()
}
</code></pre>
<blockquote>
<p>模拟一个服务实现类，需要的参数分别由当前模块和宿主模块提供，因而使用Builder将过程分离</p>
</blockquote>
<pre><code class="language-kotlin">//@AutoService(DemoApi::class)
class ModuleADemoApiImpl3(val someOp: SomeOp, val needProvideByHost: Foo) : DemoApi {
    companion object {
        const val NAME = "ModuleADemoApiImpl3"
    }

    override fun doSth(): String {
        return "${someOp.execute()} ,param2 create at${needProvideByHost.createdAt} - the result by $NAME"
    }
    class Builder(val someOp: SomeOp) : DemoApi.Builder {
        override lateinit var foo: Foo
        override fun build(): DemoApi {
            return ModuleADemoApiImpl3(someOp, foo)
        }

        @AutoService(DemoApi.Builder.Factory::class)
        class Factory : DemoApi.Builder.Factory {
            override fun create(): DemoApi.Builder {
                //the logic to get SomeOp instance,it may be complex
                val someOp = SomeOp()
                return Builder(someOp)
            }
        }
    }
}
</code></pre>
<p>使用：</p>
<pre><code class="language-kotlin">
fun useBuilderDemo() {
    val loader = ServiceLoader.load(DemoApi.Builder.Factory::class.java)
    val iterator = loader.iterator()
    var hasNext = false
    do {
        try {
            hasNext = iterator.hasNext()
            if (hasNext) {
                iterator.next().create().let {
                    it.foo = Foo()
                    it.build()
                }.let {
                    println("find a impl of DemoApi, doSth:")
                    println(it.doSth())
                    println()
                }
            }
        } catch (e: Throwable) {
            println("thr: " + e.message)
        }
    } while (hasNext)

    println("finish useBuilderDemo\r\n")
}
</code></pre>
<p>结果如下：</p>
<pre><code>find a impl of DemoApi, doSth:
[result of SomeOp osp.leobert.android.module.a.SomeOp@180bc464] ,
param2 create at osp.leobert.android.host.MyClassKt.useBuilderDemo(MyClass.kt:75)
 - the result by ModuleADemoApiImpl3

finish useBuilderDemo
</code></pre>
<blockquote>
<p>然即便如此，实际项目中，依旧会有诸多麻烦。依赖获取或依赖注入，永远会面临极端复杂的情况。我们模拟的情况永远比不上实际情况复杂。</p>
<p>读者诸君应当能够理解，当面临极端复杂的情况时，例如参数来自3个甚至更多模块时，即便利用设计模式仍能解决问题，但其设计和理解成本已然极高！</p>
</blockquote>
<h3 id="与依赖注入碰撞"><a class="header" href="#与依赖注入碰撞">与依赖注入碰撞</a></h3>
<p>虽然从广义上看，SPI机制也是一种特定场景下的DI实现，本章节暂不无限扩展，仅在下个章节中留下开端。</p>
<p>当与依赖注入的手段相碰撞时，可考虑两个方向：</p>
<ul>
<li>服务模块内部使用依赖注入，考量SPI(ServiceLoader)是否可无缝衔接模块内DI</li>
<li>力大砖飞，自实现SPI机制，通俗地讲，即自定义ServiceLoader，并在其中无缝衔接DI</li>
</ul>
<h4 id="与dagger2兼容性探寻"><a class="header" href="#与dagger2兼容性探寻">与Dagger2兼容性探寻</a></h4>
<blockquote>
<p>首先可以明确一点：<code>@AutoService</code> 必须注解于非抽象类上，所以，假如ServiceLoader可以和Dagger2生成的代码兼容，也需要手动注册 <em>（或者自扩展Dagger2的编译，对生成类添加标记）</em></p>
<p>其次，不难通过思考得出结论：ServiceLoader 直接加载 Dagger2 的生成类，将会破坏Dagger2对依赖的生命周期管理。即便模仿 <code>Anvil</code>（类似Hilt）进行一系列自定义扩展，也无法降低设计难度，不再展开讨论。</p>
</blockquote>
<p>因此，可靠的实现思路为：SPI接口实现类依赖 <code>DaggerComponent</code> ，并据此进入Dagger的世界获取到目标对象实例。伪代码如下：</p>
<pre><code class="language-kotlin">class ApiFactoryImpl : ApiFactory {
    fun create(foo: Foo): Api {
        return DaggerComponent.create().provideApi(foo)
    }
}
</code></pre>
<p><em>注意，伪代码仅示意，实际编写时仍需要考虑Component的生命周期控制，以避免产生潜在BUG</em></p>
<p>很显然，由宿主模块提供的依赖使用 <code>@Assisted</code> 注解标记，其他依赖通过 <code>Dagger2</code> 进行管理</p>
<p>重新定义SPI接口：</p>
<pre><code class="language-kotlin">interface DemoApiFactory2 {
    fun create(foo: Foo): DemoApi
}
</code></pre>
<p>服务模块内部使用 DI：</p>
<pre><code class="language-kotlin">class ModuleADemoApiImpl4
@AssistedInject constructor(
    val someOp: SomeOp,
    @Assisted val needProvideByHost: Foo
) : DemoApi {

    companion object {
        const val NAME = "ModuleADemoApiImpl4"
    }

    override fun doSth(): String {
        return "${someOp.execute()} ,param2 create at${needProvideByHost.createdAt} - the result by $NAME"
    }

    @AutoService(DemoApiFactory2::class)
    class SpiFactory : DemoApiFactory2 {
        //注意，仅示例代码，实际使用时需严格遵循Component的生命周期需求获取实例
        private val factory by lazy {
            DaggerAppComponent.create().provideFactory()
        }

        override fun create(foo: Foo): DemoApi {
            return factory.create(foo)
        }
    }

    @AssistedFactory
    abstract class Factory {
        abstract fun create(@Assisted needProvideByHost: Foo): ModuleADemoApiImpl4
    }
}
</code></pre>
<p>DI部分的代码忽略，详见仓库代码。</p>
<p>这个思路可以解决采用多种设计模式带来的编码复杂度问题。</p>
<blockquote>
<p>那么，是否得到了银弹呢？答案是否定的！SPI机制的设计是"轻量级"的，当按照这一思路，完美解决依赖注入和依赖管理难点时（显然它需要拥有一种聚合能力方可解决问题），简单推理即可以发现：</p>
<p>即便不使用SPI机制，也可以基于此时的DI框架的聚合能力，实现：enable framework extension and replaceable components 的目标</p>
<p>代价是每个framework extension 都被一个特定的三方DI框架所捆绑，这显然不是好主意！</p>
<p><em><strong>作者按：可能我这样表述很不便于理解，读者诸君可以从SpringBoot的相关知识进行横向对比理解：</strong></em></p>
<p>在SpringBoot中有 <code>spring.factories</code>,它可以在不侵入代码的情况下，使用第三方Jar包中的Bean，它的实现与JDK中SPI机制实现基本类似，
但SpringBoot本身就蕴含IOC容器，只要使用SpringBoot生态则意味着接受了它的DI，因此可无视DI框架捆绑</p>
</blockquote>
<h2 id="自定义serviceloader"><a class="header" href="#自定义serviceloader">自定义ServiceLoader</a></h2>
<p>读到此处的读者诸君，我们将进行这次思考中最关键的一步！我们已经收集到诸多思路的弊端，如果自定义ServiceLoader实现SPI机制，最佳实践应当如何？</p>
<p><strong>正如我前文所言，这里仅仅只有开端，没有最终答案，只有一些思路提供参考</strong>：</p>
<ul>
<li>1.服务发现部分:
<ul>
<li>结合注册清单、反射手段等，应当获得是否有实现类</li>
</ul>
</li>
<li>2.服务加载部分：
<ul>
<li>结合注册清单、反射手段等，应当获得实现类的构建途径和所需依赖</li>
</ul>
</li>
</ul>
<p>ServiceLoader中处理第一点时，将所有的注册类反射遍历，利用类型推断实现目标。处理第二点时，直接反射无参构造器，致使存在一定限制。</p>
<p>因此，在设计时可以考虑：</p>
<ul>
<li>注册清单中可以获知服务实现类的实例化路径</li>
<li>注册清单中可以获知服务实现类实例化时需要的依赖信息</li>
<li>将ServiceLoader设计为轻量级的IOC容器，撇去读写生命周期管理，仅提供有限的依赖获取途径</li>
</ul>
<p>例如：注册清单内容可以设计为：</p>
<p><code>{Interface/abstract class}:{Implement Class}#construcor({Param Type1},{Param Type2})</code></p>
<pre><code class="language-kotlin">osp.leobert.android.api.DemoApi:osp.leobert.android.module.a.ModuleADemoApiImpl4#ModuleADemoApiImpl4(osp.leobert.android.module.a.SomeOp,osp.leobert.android.api.Foo)

//方便阅读，进行换行：
osp.leobert.android.api.DemoApi:
    osp.leobert.android.module.a.ModuleADemoApiImpl4#
        ModuleADemoApiImpl4(
          osp.leobert.android.module.a.SomeOp,
          osp.leobert.android.api.Foo
        )
</code></pre>
<h2 id="结语-15"><a class="header" href="#结语-15">结语</a></h2>
<p>最近写文章时，有一些苦恼：对于单纯的知识点，不太愿意动笔；而容易发散的知识，发散出去又难以收束。</p>
<p>最近也在思考，希冀寻找到源于内心深处的无穷力量，解开束缚精神的枷锁，照亮前行的道路。</p>
<p>前段时间读到一句话，分享给读者诸君：</p>
<blockquote>
<p>there are three pillars in life: health, time, and money. At any given moment, most people have at most two. If you're fortunate enough to have all three, you make the most of it while you can.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="系列说明"><a class="header" href="#系列说明">系列说明</a></h1>
<ul>
<li><a href="info/./about_view_series.html">关于View系列</a></li>
<li><a href="info/./about_sansi_series.html">关于三思系列</a></li>
<li><a href="info/./about_haowan_series.html">关于好玩系列</a></li>
<li><a href="info/./about_wengu_series.html">关于温故系列</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="关于view系列"><a class="header" href="#关于view系列">关于View系列</a></h1>
<p>其实想写这个系列很久了，这两年多次撰写了草稿，但又全部放弃。</p>
<ul>
<li>一来，是对大纲内容不满意</li>
<li>二来，是对撰写的目的产生质疑</li>
</ul>
<p>有一个问题一直思考了多年：</p>
<blockquote>
<p>为什么View体系从Android出现就有，到现在这么多年，还是不断的有分析的文章出现？</p>
</blockquote>
<p>按照黑格尔的观点:</p>
<blockquote>
<p>Was vernünftig ist , das ist wirklich ,</p>
<p>und was wirklich ist , das ist vernünftig</p>
</blockquote>
<blockquote>
<p>凡是合乎理性的东西都是现实的；凡是现实的东西都是合乎理性的。</p>
<p>有一个常见的译文叫："存在即合理"</p>
</blockquote>
<p>思考之后，个人认为，有以下几点：</p>
<ul>
<li>View体系的内容实在 <code>太大、太深</code> ，没有人能够做到用几篇文章让 <code>不同知识层面</code> 的读者们都理解
<ul>
<li>几乎每一位写相关内容的博主，都曾是其他相关内容文章的读者。</li>
<li>结合多方资料学习总结后，出现了更高的认知，<code>新事物比旧事物更加"合乎理性"</code>。</li>
</ul>
</li>
<li>与其说分享知识，不如说 <code>自我总结、记录</code></li>
</ul>
<h2 id="为什么之前抛弃了草稿"><a class="header" href="#为什么之前抛弃了草稿">为什么之前抛弃了草稿</a></h2>
<ul>
<li>内容总是偏向于 <code>总结</code>，那么在写它的时候，知识已经被个人掌握，写不写，是一个形式。</li>
<li>不从至少高一层的水平写文章时，写出的内容往往不易于阅读</li>
<li>不能够激发读者思考的内容，更容易被灭亡，自己总结的，总会比别人总结的看着舒服</li>
</ul>
<h2 id="为什么又开始撰写"><a class="header" href="#为什么又开始撰写">为什么又开始撰写</a></h2>
<p>一个长假期，做了很多思考。回想了之前想要撰写的内容，再思考了自己学习View体系的全过程。想明白了一件事情：</p>
<p>值得分享的是对 <code>View的认知体系</code>。</p>
<p>前面提到，View体系太大太深，对它的学习也不是阅读几篇文章的事情，
而同读者一道，对该 <code>知识体系</code> 建立 <code>相对完整的认知</code>。这才是 <code>最有意义</code>，<code>最有价值</code> 的事情。</p>
<p>通俗的讲，<code>认识</code> View体系的 <code>全貌</code>，知道每一块内容 <code>解决什么问题</code>，再从这个基础上，<code>挖掘细节</code>。
即，这是 <code>学习的指导手册</code> ，而不是被学习的内容。</p>
<h2 id="为什么放入三思系列中"><a class="header" href="#为什么放入三思系列中">为什么放入三思系列中</a></h2>
<p>对这部分内容的 <code>认知过程</code>，是和三思系列一致的，其 <code>目的</code>，也是和三思系列一致。下定决心要开始撰写时，
是打算 <code>挑重点</code> 写三思系列，转念一想，与其写的零碎，写的看的都不过瘾，<code>索性做全套</code>。</p>
<h2 id="系列大纲"><a class="header" href="#系列大纲">系列大纲</a></h2>
<ul>
<li><a href="info/../Android/View/%E4%B8%89%E6%80%9D%E7%B3%BB%E5%88%97%EF%BC%9AView%E4%BD%93%E7%B3%BB%E8%AE%A4%E7%9F%A5(%E4%B8%80)%EF%BC%8C%E5%86%85%E5%AE%B9%E6%98%AF%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E8%A2%AB%E5%B1%95%E7%8E%B0%E5%87%BA%E6%9D%A5%E7%9A%84--%E8%A7%86%E8%A7%89%E5%91%88%E7%8E%B0%E6%A6%82%E8%A7%88.html">三思系列：View体系认知(一)，视觉呈现概览</a></li>
<li>三思系列：View体系认知(二)，用户交互概览</li>
<li>三思系列：View体系认知(三)，滑动的本质</li>
<li>三思系列：View体系认知(四)，Canvas绘制总结 -- <em>这一篇可能不写，从认知体系上，一段话就能说清楚它存在的目的，其他都是总结</em></li>
<li>三思系列：View体系认知(五)，自定义View的意义和实践</li>
<li><a href="info/../Android/View/%E4%B8%89%E6%80%9D%E7%B3%BB%E5%88%97%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%87%AA%E5%AE%9A%E4%B9%89View.html">三思系列：为什么自定义View</a></li>
</ul>
<p>目前先定下这些内容。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="关于三思系列"><a class="header" href="#关于三思系列">关于三思系列</a></h1>
<p>这里的三思不是论语中提到的三思：</p>
<blockquote>
<p>季文子三思而后行。子闻之，曰：“再，斯可矣。</p>
</blockquote>
<p>而是</p>
<blockquote>
<p>思危;思退;思变</p>
</blockquote>
<p>从技术角度上，一个事情确定了方向，只要把各种危险都避开，持续走下去，一定会成功，这就是要<strong>思危</strong>；
不要站在风尖浪口，这样会看不清危险。如果已经站上去了，要<strong>思退</strong>；
危险是否会被察觉，依赖于我们的眼力，提升自己的高度，以<strong>增加观测事物的角度</strong>和<strong>洞察力</strong>，才能规避更多的危险，我们的眼力、站的高度、对问题的理解、观测问题的角度等发生了变化，这是<strong>思变</strong>。</p>
<p>三思系列着重于:<strong>问题分析</strong>、<strong>技术积累</strong>、<strong>视野拓展</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="关于好玩系列"><a class="header" href="#关于好玩系列">关于好玩系列</a></h1>
<p>平时工作中或者阅读其他大佬的博文时，偶尔会灵光一闪，想到一些好玩的事情，如探究一个挺有意思的问题、一种挺有意思的解决方案等等。</p>
<p><strong>这些事情，如果不加以记录的话，实在有点可惜。</strong></p>
<p>大多数情况下，本系列的产出尚不能直接作为商业实施方案(<em>多半还需要再加入一定的工作</em>)，但对于个人提升应当会有较大的助力。</p>
<p>最重要的：这件事情一定要好玩！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="关于温故系列"><a class="header" href="#关于温故系列">关于温故系列</a></h1>
<blockquote>
<p>《论语》有云：温故而知新，可以为师矣。</p>
</blockquote>
<p>窃以为:</p>
<ul>
<li>人在记忆存储上不如机器，学过的东西会忘</li>
<li>人的阅历和认知能力会涨</li>
</ul>
<p>温故而知新有四解：</p>
<ul>
<li>一曰温习故学，领悟新知 -- 治学</li>
<li>二曰"温故" <code>及</code> "知新" -- 治学</li>
<li>三曰阅历无恒常，温习旧闻可获新知 -- 治学</li>
<li>四曰拥顾旧闻而推未知之能；因词句出于论语-为政，更多是表达 "以史为鉴，避免犯错" -- 治国治政</li>
</ul>
<p>我整理温故系列，不是 <code>新瓶装旧酒</code>，是为了在 <code>阅历增长</code>时，总结旧闻，以 <code>期获</code> 新知。撰写成文，一方面是<code>自我总结</code>，成为 <code>下一次温故</code> 的材料；
另一方面，试图与读者 <code>产生共鸣</code> ，以期获得读者的旧闻新知</p>
<p>值得一提，这个系列和 <code>三思系列</code> 还是有一定区别的：</p>
<blockquote>
<p>三思系列目的在于 <code>思危、思退、思变</code>，通过一定深度的挖掘，发现危险、避免危险；寻找退路；探寻更好的方案。</p>
</blockquote>
<p>当然，三思系列如果是挖掘 <code>非新兴</code> 的知识体系，就会和温故系列很像</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
