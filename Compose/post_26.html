<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Jetpack Compose | 控件篇（一） -- Text、TextField、Button - leobert&#x27;s blog</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">目录</li><li class="chapter-item expanded "><a href="../Android/index.html"><strong aria-hidden="true">1.</strong> Android</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/View/index.html"><strong aria-hidden="true">1.1.</strong> View</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/View/post_1.html"><strong aria-hidden="true">1.1.1.</strong> 好玩系列：优雅的处理ButterKnife和KAE被废弃</a></li><li class="chapter-item expanded "><a href="../Android/View/post_6.html"><strong aria-hidden="true">1.1.2.</strong> 三思系列：View体系认知(一)，内容是如何正确被展现出来的--视觉呈现概览</a></li><li class="chapter-item expanded "><a href="../Android/View/post_7.html"><strong aria-hidden="true">1.1.3.</strong> 三思系列：为什么自定义View</a></li><li class="chapter-item expanded "><a href="../Android/Idea/post_9.html"><strong aria-hidden="true">1.1.4.</strong> 三思系列："声明式UI"和"命令式UI"，你的理解可能是错的</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/Drawable/index.html"><strong aria-hidden="true">1.2.</strong> Drawable</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/Drawable/post_2.html"><strong aria-hidden="true">1.2.1.</strong> 三思系列：重新认识Drawable</a></li><li class="chapter-item expanded "><a href="../Android/Drawable/post_4.html"><strong aria-hidden="true">1.2.2.</strong> 好玩系列：拥有它，XML文件少一半--更方便的处理View背景</a></li><li class="chapter-item expanded "><a href="../Android/Drawable/post_47.html"><strong aria-hidden="true">1.2.3.</strong> 迟来的续集--Drawable+Animator，将优雅进行到底</a></li><li class="chapter-item expanded "><a href="../Android/Drawable/post_49.html"><strong aria-hidden="true">1.2.4.</strong> 好玩系列：让ImageSpan动起来</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/Mechanism/Message/index.html"><strong aria-hidden="true">1.3.</strong> 消息机制</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/Mechanism/Message/post_8.html"><strong aria-hidden="true">1.3.1.</strong> 三思系列：Android的消息机制，一文吃透</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/Idea/post_14/index.html"><strong aria-hidden="true">1.4.</strong> 兼容</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/Idea/post_14.html"><strong aria-hidden="true">1.4.1.</strong> 好玩系列：让项目中的相册支持Heif格式图片</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/Glide/index.html"><strong aria-hidden="true">1.5.</strong> Glide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/Glide/post_15.html"><strong aria-hidden="true">1.5.1.</strong> 三思系列：Glide 4.X全方位认知 -- 模块职责概览</a></li><li class="chapter-item expanded "><a href="../Android/Glide/post_16.html"><strong aria-hidden="true">1.5.2.</strong> 三思系列：Glide 4.X加载过程一文掌握 | Glide（二）</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/KSP/index.html"><strong aria-hidden="true">1.6.</strong> KSP</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/KSP/post_24.html"><strong aria-hidden="true">1.6.1.</strong> 好玩系列 | 拥抱Kotlin Symbol Processing(KSP),项目实战</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/Base/index.html"><strong aria-hidden="true">1.7.</strong> 基础</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/Base/post_35.html"><strong aria-hidden="true">1.7.1.</strong> 孔乙己：你可知道页面和弹窗“通信“的方式有四种？</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/SysApp/index.html"><strong aria-hidden="true">1.8.</strong> 系统APP</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/SysApp/post_52.html"><strong aria-hidden="true">1.8.1.</strong> 使用日历丰富产品的用户体验</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/DI/index.html"><strong aria-hidden="true">1.9.</strong> Part4-依赖注入部分</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/DI/post_53.html"><strong aria-hidden="true">1.9.1.</strong> Hilt进阶--一文吃透Hilt自定义与跨壁垒</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../Compose/index.html"><strong aria-hidden="true">2.</strong> Jetpack Compose</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Compose/post_21.html"><strong aria-hidden="true">2.1.</strong> Jetpack Compose | 一文理解神奇的Modifier</a></li><li class="chapter-item expanded "><a href="../Compose/post_26.html" class="active"><strong aria-hidden="true">2.2.</strong> Jetpack Compose | 控件篇（一） -- Text、TextField、Button</a></li><li class="chapter-item expanded "><a href="../Compose/post_27.html"><strong aria-hidden="true">2.3.</strong> Jetpack Compose | 控件篇（二） -- Icon，Image</a></li><li class="chapter-item expanded "><a href="../Compose/post_28.html"><strong aria-hidden="true">2.4.</strong> Jetpack Compose | 控件篇（三） -- Switch、CheckBox、RadioButton</a></li><li class="chapter-item expanded "><a href="../Compose/post_29.html"><strong aria-hidden="true">2.5.</strong> Jetpack Compose | 控件篇（四）-- Box、Row、Column</a></li><li class="chapter-item expanded "><a href="../Compose/post_30.html"><strong aria-hidden="true">2.6.</strong> Jetpack Compose | 控件篇（五）-- Spacer、LazyRow、LazyColumn & 让Column可滑动</a></li></ol></li><li class="chapter-item expanded "><a href="../MultiThreading/index.html"><strong aria-hidden="true">3.</strong> Java多线程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../MultiThreading/post_33.html"><strong aria-hidden="true">3.1.</strong> 总纲</a></li><li class="chapter-item expanded "><a href="../MultiThreading/post_37.html"><strong aria-hidden="true">3.2.</strong> Java基础--图解JVM内存模型和JVM线程模型</a></li><li class="chapter-item expanded "><a href="../MultiThreading/post_38.html"><strong aria-hidden="true">3.3.</strong> Java多线程系列--掌控面试，一文吃透Synchronized锁</a></li><li class="chapter-item expanded "><a href="../MultiThreading/post_39.html"><strong aria-hidden="true">3.4.</strong> Java多线程基础--线程生命周期与线程协作详解</a></li><li class="chapter-item expanded "><a href="../MultiThreading/post_42.html"><strong aria-hidden="true">3.5.</strong> Java多线程基础--线程的创建与线程池管理</a></li><li class="chapter-item expanded "><a href="../MultiThreading/post_46.html"><strong aria-hidden="true">3.6.</strong> Java多线程系列--掌握Future，轻松获取异步任务结果</a></li><li class="chapter-item expanded "><a href="../MultiThreading/post_50.html"><strong aria-hidden="true">3.7.</strong> Java多线程系列--Fork&Join框架，分治的艺术</a></li><li class="chapter-item expanded "><a href="../MultiThreading/post_54.html"><strong aria-hidden="true">3.8.</strong> Java多线程系列--掌握CompletableFuture，驾驭异步编程</a></li></ol></li><li class="chapter-item expanded "><a href="../IO/index.html"><strong aria-hidden="true">4.</strong> Java IO系列</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../IO/post_55.html"><strong aria-hidden="true">4.1.</strong> Java IO 系列总纲</a></li><li class="chapter-item expanded "><a href="../IO/post_56.html"><strong aria-hidden="true">4.2.</strong> Java IO系列 | 经典 IO</a></li><li class="chapter-item expanded "><a href="../IO/post_57.html"><strong aria-hidden="true">4.3.</strong> Java IO 系列 | NIO-1.0一文速览</a></li><li class="chapter-item expanded "><a href="../IO/post_58.html"><strong aria-hidden="true">4.4.</strong> Java IO系列 | NIO-1.0拾遗、NIO-2.0 & 零拷贝必吹的牛皮</a></li><li class="chapter-item expanded "><a href="../IO/post_59.html"><strong aria-hidden="true">4.5.</strong> IO系列 | 一文掌握OKHTTP中的OKIO为什么这么OK</a></li></ol></li><li class="chapter-item expanded "><a href="../Gradle/index.html"><strong aria-hidden="true">5.</strong> Gradle</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Gradle/Modularization/post_18.html"><strong aria-hidden="true">5.1.</strong> 组件化：三思系列：组件化场景下module依赖优雅实践方案</a></li><li class="chapter-item expanded "><a href="../Gradle/Publish/post_17.html"><strong aria-hidden="true">5.2.</strong> MavenCentral发布：迁移到MavenCentral--再不行动起来，你的托管的library就没了</a></li><li class="chapter-item expanded "><a href="../Gradle/post_22.html"><strong aria-hidden="true">5.3.</strong> Gradle | 依赖管理最佳实践</a></li></ol></li><li class="chapter-item expanded "><a href="../Groovy/index.html"><strong aria-hidden="true">6.</strong> Groovy</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Groovy/why_write_groovy.html"><strong aria-hidden="true">6.1.</strong> 为什么撰写这个系列</a></li><li class="chapter-item expanded "><a href="../Groovy/post_23.html"><strong aria-hidden="true">6.2.</strong> Groovy：MOP一文打尽</a></li></ol></li><li class="chapter-item expanded "><a href="../Review/index.html"><strong aria-hidden="true">7.</strong> Review</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Review/post_10.html"><strong aria-hidden="true">7.1.</strong> 造完了这个轮子--Mocker，却让我感到很羞愧|项目复盘</a></li><li class="chapter-item expanded "><a href="../Review/post_40.html"><strong aria-hidden="true">7.2.</strong> 三思系列：前人用GreenDao留下的坑，全线被扣了绩效</a></li><li class="chapter-item expanded "><a href="../Review/post_44.html"><strong aria-hidden="true">7.3.</strong> 谈一谈在两个商业项目中使用MVI架构后的感悟</a></li><li class="chapter-item expanded "><a href="../Review/post_45.html"><strong aria-hidden="true">7.4.</strong> Review | 这三个坑你遇到了吗？</a></li></ol></li><li class="chapter-item expanded "><a href="../repo/index.html"><strong aria-hidden="true">8.</strong> 个人项目</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../repo/DaVinCi.html"><strong aria-hidden="true">8.1.</strong> DaVinCi,取代XML编写Shape或ColorStateList的方案</a></li><li class="chapter-item expanded "><a href="../Android/Idea/post_32.html"><strong aria-hidden="true">8.2.</strong> 好玩系列：白嫖一个优雅的类图生成工具</a></li><li class="chapter-item expanded "><a href="../Speculative/post_43.html"><strong aria-hidden="true">8.3.</strong> 初体验：动手搭建"小清新式"局域网文档系统</a></li><li class="chapter-item expanded "><a href="../repo/post_48.html"><strong aria-hidden="true">8.4.</strong> 研究良久，终于发现了他代码写的快且bug少的原因</a></li><li class="chapter-item expanded "><a href="../Speculative/post_61.html"><strong aria-hidden="true">8.5.</strong> 好玩系列 | 如果后端让你用SSE接收多次返回，那我们改造Retrofit吧</a></li></ol></li><li class="chapter-item expanded "><a href="../Review/DataStructure/index.html"><strong aria-hidden="true">9.</strong> 数据结构</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Review/DataStructure/post_11.html"><strong aria-hidden="true">9.1.</strong> 温故：线性表</a></li><li class="chapter-item expanded "><a href="../Review/DataStructure/post_12.html"><strong aria-hidden="true">9.2.</strong> 温故：栈</a></li><li class="chapter-item expanded "><a href="../Review/DataStructure/post_13.html"><strong aria-hidden="true">9.3.</strong> 温故：队列</a></li></ol></li><li class="chapter-item expanded "><a href="../Review/README2.html"><strong aria-hidden="true">10.</strong> 年终总结&计划</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Review/post_36.html"><strong aria-hidden="true">10.1.</strong> 2021年终总结</a></li><li class="chapter-item expanded "><a href="../Review/post_51.html"><strong aria-hidden="true">10.2.</strong> 关于画一个句号--基于2022年终总结的反思与分享</a></li><li class="chapter-item expanded "><a href="../Review/post_60.html"><strong aria-hidden="true">10.3.</strong> 突如其来的秋季反思</a></li><li class="chapter-item expanded "><a href="../Review/post_63.html"><strong aria-hidden="true">10.4.</strong> 2023年总结 寻找到源于内心深处的无穷力量</a></li><li class="chapter-item expanded "><a href="../Review/post_64.html"><strong aria-hidden="true">10.5.</strong> 2024年中思考，推倒樊笼重新出发</a></li></ol></li><li class="chapter-item expanded "><a href="../Note/index.html"><strong aria-hidden="true">11.</strong> 读书笔记</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Note/post_41.html"><strong aria-hidden="true">11.1.</strong> 读书笔记：《简约至上--交互式设计四策略》</a></li><li class="chapter-item expanded "><a href="../Talk/talk_4_2024-08.html"><strong aria-hidden="true">11.2.</strong> 读书笔记 - 《团队管理》精华摘要</a></li></ol></li><li class="chapter-item expanded "><a href="../Talk/index.html"><strong aria-hidden="true">12.</strong> 杂谈</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Talk/talk_1.html"><strong aria-hidden="true">12.1.</strong> 杂谈1-2022-11</a></li><li class="chapter-item expanded "><a href="../Talk/talk_2_2023-03.html"><strong aria-hidden="true">12.2.</strong> 杂篇（二）-- 认识并战胜焦虑</a></li><li class="chapter-item expanded "><a href="../Talk/talk_3_2024-08.html"><strong aria-hidden="true">12.3.</strong> 杂谈（三）-- 向钱看，你需要想明白企业在为什么而付钱</a></li></ol></li><li class="chapter-item expanded "><a href="../Thought/index.html"><strong aria-hidden="true">13.</strong> 半成熟的思考</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Thought/post_62.html"><strong aria-hidden="true">13.1.</strong> 好玩系列 | 当SPI 和 设计模式、依赖注入发生碰撞，可以擦出怎样的火花</a></li></ol></li><li class="chapter-item expanded "><a href="../info/index.html"><strong aria-hidden="true">14.</strong> 系列说明</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../info/about_view_series.html"><strong aria-hidden="true">14.1.</strong> 关于View系列</a></li><li class="chapter-item expanded "><a href="../info/about_sansi_series.html"><strong aria-hidden="true">14.2.</strong> 关于三思系列</a></li><li class="chapter-item expanded "><a href="../info/about_haowan_series.html"><strong aria-hidden="true">14.3.</strong> 关于好玩系列</a></li><li class="chapter-item expanded "><a href="../info/about_wengu_series.html"><strong aria-hidden="true">14.4.</strong> 关于温故系列</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">leobert&#x27;s blog</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>#Jetpack Compose | 控件篇（一） -- Text、TextField、Button</p>
<p>这一篇，我们一起学习 Jetpack Compose 中的部分控件 -- <code>Text、TextField、Button</code>，掌握其使用方式和特性。</p>
<p><em>文中代码均基于 1.0.1版本</em></p>
<p><em>如无特殊说明，下文中的 <code>Compose</code> 均指代 <code>Jetpack compose</code></em></p>
<h2 id="小互动"><a class="header" href="#小互动">小互动</a></h2>
<p>上一篇文章：<a href="https://juejin.cn/post/6994359593375629326">Compose | 一文理解神奇的Modifier </a> 在郭婶的号上有读者评论到不知道Compose从何学起，
无从下手，这里简单的谈一谈我的看法：</p>
<ul>
<li>Compose 以及 Jetpack Compose 对于Android从业人员而言确实是一门 <code>全新的技术</code></li>
<li>目前才兴起，还没有达到一个辉煌的阶段</li>
</ul>
<p>在此背景下，开始学习研究Compose 都可以算的上 <code>先行者</code>，而且这门技术还做不到诸如："一年内全面替代老技术"、"不掌握就找不到工作" 这种程度。</p>
<p>那么按部就班的学习它就行了，没有时间上的紧迫感。而学习一样东西，有这样几个阶段：</p>
<ul>
<li>掌握如何使用</li>
<li>掌握实现细节，逐渐理解其本质</li>
<li>从其本质出发，利用对程序的理解，优化使用方式甚至优化这门技术</li>
</ul>
<p>显然，我们现在要做的就是：</p>
<ul>
<li>先结合官方资料以及源码，先掌握如何使用：<code>它解决哪些问题，怎么使用它解决问题</code></li>
<li>鉴于部分读者已经有一定的基础，对类似技术有了一定的理解，在此过程中就可以提前阅读该技术的实现细节，尝试理解其本质。或者再掌握了使用方式后再开始。</li>
<li>再之后的道路就很清晰了</li>
</ul>
<p>下面我们进入今天的正文。</p>
<h2 id="text"><a class="header" href="#text">Text</a></h2>
<p>在Android中，有 <code>TextView</code> 这一控件，用于展示文本，Compose中对应的是 <code>Text</code>。</p>
<p>先看源码：</p>
<pre><code class="language-kotlin">fun Text(
    text: String,
    modifier: Modifier = Modifier,
    color: Color = Color.Unspecified,
    fontSize: TextUnit = TextUnit.Unspecified,
    fontStyle: FontStyle? = null,
    fontWeight: FontWeight? = null,
    fontFamily: FontFamily? = null,
    letterSpacing: TextUnit = TextUnit.Unspecified,
    textDecoration: TextDecoration? = null,
    textAlign: TextAlign? = null,
    lineHeight: TextUnit = TextUnit.Unspecified,
    overflow: TextOverflow = TextOverflow.Clip,
    softWrap: Boolean = true,
    maxLines: Int = Int.MAX_VALUE,
    onTextLayout: (TextLayoutResult) -&gt; Unit = {},
    style: TextStyle = LocalTextStyle.current
)
</code></pre>
<pre><code class="language-kotlin">fun Text(
    text: AnnotatedString,
    modifier: Modifier = Modifier,
    color: Color = Color.Unspecified,
    fontSize: TextUnit = TextUnit.Unspecified,
    fontStyle: FontStyle? = null,
    fontWeight: FontWeight? = null,
    fontFamily: FontFamily? = null,
    letterSpacing: TextUnit = TextUnit.Unspecified,
    textDecoration: TextDecoration? = null,
    textAlign: TextAlign? = null,
    lineHeight: TextUnit = TextUnit.Unspecified,
    overflow: TextOverflow = TextOverflow.Clip,
    softWrap: Boolean = true,
    maxLines: Int = Int.MAX_VALUE,
    inlineContent: Map&lt;String, InlineTextContent&gt; = mapOf(),
    onTextLayout: (TextLayoutResult) -&gt; Unit = {},
    style: TextStyle = LocalTextStyle.current
)
</code></pre>
<p>这两个方法原型的唯一差别就是形参 <code>text</code> 的类型，AnnotatedString 类似于Android中的 SpannableString, 可以标记各类效果。</p>
<p><strong>其实阅读源码后可以发现，Text 基于 BasicText 实现，应用了样式</strong>。</p>
<pre><code class="language-kotlin">val textColor = color.takeOrElse {
    style.color.takeOrElse {
        LocalContentColor.current.copy(alpha = LocalContentAlpha.current)
    }
}
val mergedStyle = style.merge(
    TextStyle(
        color = textColor,
        fontSize = fontSize,
        fontWeight = fontWeight,
        textAlign = textAlign,
        lineHeight = lineHeight,
        fontFamily = fontFamily,
        textDecoration = textDecoration,
        fontStyle = fontStyle,
        letterSpacing = letterSpacing
    )
)
BasicText(
    text,
    modifier,
    mergedStyle,
    onTextLayout,
    overflow,
    softWrap,
    maxLines,
    inlineContent
)
</code></pre>
<p>参数含义：（翻译自API文档）</p>
<ul>
<li>text - 要显示的内容</li>
<li>modifier - 需要应用的修饰器.</li>
<li>color - 文字色. 如果是 <code>Color.Unspecified</code>, 同时 style 没有配饰颜色, 将会使用 <code>LocalContentColor</code>.</li>
<li>fontSize - 字号. See TextStyle.fontSize.</li>
<li>fontStyle - 文字样式，例如斜体，See TextStyle.fontStyle.</li>
<li>fontWeight - 字重，例如加粗.</li>
<li>fontFamily - 字体系列. See TextStyle.fontFamily.</li>
<li>letterSpacing - 字间距. See TextStyle.letterSpacing.</li>
<li>textDecoration - 文字装饰效果，例如下划线. See TextStyle.textDecoration.</li>
<li>textAlign - 文字段落对齐方式. See TextStyle.textAlign.</li>
<li>lineHeight - 行高. See TextStyle.lineHeight.</li>
<li>overflow - 溢出时的处理方案，所谓溢出即文本框显示不下这么多文字.</li>
<li>softWrap - 是否应用换行符. 如果不应用，则一行写完，<code>overflow</code> 、<code>TextAlign</code> 无效.</li>
<li>maxLines - 最大行数，必须大于0.</li>
<li>inlineContent - 占位的替代信息匹配</li>
<li>onTextLayout - 绘制文字计算布局时的回调</li>
<li>style - 样式，例如： color, font, line height 等.</li>
</ul>
<p><em><a href="https://github.com/leobert-lan/ComposeWorkShop">WorkShop</a> 中按照这些参数编写了一些样例代码，效果如下，因过度图片压缩导致有锯齿感，非Compose问题</em></p>
<p><img src="./post_26/text_demo.webp" alt="text_demo" /></p>
<p><em>考虑到阅读体验，代码请移步WorkShop</em></p>
<h2 id="textfield"><a class="header" href="#textfield">TextField</a></h2>
<p>Android中有 <code>EditText</code> 控件，用于接收 <code>用户的文本输入</code>，Compose中为 <code>TextField</code></p>
<p>和 <code>TextField</code> 类似的还有 <code>OutlinedTextField</code>，使用上和 <code>TextField</code> 一致，多一个描边外框效果</p>
<p>方法原型：</p>
<pre><code class="language-kotlin">fun TextField(
    value: String,
    onValueChange: (String) -&gt; Unit,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    readOnly: Boolean = false,
    textStyle: TextStyle = LocalTextStyle.current,
    label: @Composable (() -&gt; Unit)? = null,
    placeholder: @Composable (() -&gt; Unit)? = null,
    leadingIcon: @Composable (() -&gt; Unit)? = null,
    trailingIcon: @Composable (() -&gt; Unit)? = null,
    isError: Boolean = false,
    visualTransformation: VisualTransformation = VisualTransformation.None,
    keyboardOptions: KeyboardOptions = KeyboardOptions.Default,
    keyboardActions: KeyboardActions = KeyboardActions(),
    singleLine: Boolean = false,
    maxLines: Int = Int.MAX_VALUE,
    interactionSource: MutableInteractionSource = remember { MutableInteractionSource() },
    shape: Shape =
        MaterialTheme.shapes.small.copy(bottomEnd = ZeroCornerSize, bottomStart = ZeroCornerSize),
    colors: TextFieldColors = TextFieldDefaults.textFieldColors()
)
</code></pre>
<pre><code class="language-kotlin">fun TextField(
    value: TextFieldValue,
    onValueChange: (TextFieldValue) -&gt; Unit,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    readOnly: Boolean = false,
    textStyle: TextStyle = LocalTextStyle.current,
    label: @Composable (() -&gt; Unit)? = null,
    placeholder: @Composable (() -&gt; Unit)? = null,
    leadingIcon: @Composable (() -&gt; Unit)? = null,
    trailingIcon: @Composable (() -&gt; Unit)? = null,
    isError: Boolean = false,
    visualTransformation: VisualTransformation = VisualTransformation.None,
    keyboardOptions: KeyboardOptions = KeyboardOptions.Default,
    keyboardActions: KeyboardActions = KeyboardActions(),
    singleLine: Boolean = false,
    maxLines: Int = Int.MAX_VALUE,
    interactionSource: MutableInteractionSource = remember { MutableInteractionSource() },
    shape: Shape =
        MaterialTheme.shapes.small.copy(bottomEnd = ZeroCornerSize, bottomStart = ZeroCornerSize),
    colors: TextFieldColors = TextFieldDefaults.textFieldColors()
)
</code></pre>
<p>很巧，和Text类似，除了value 和 onValueChange 的类型不一致，其他均一致。</p>
<p>简单追溯代码后可以发现：</p>
<ul>
<li>和Android不一致，它并没有依赖Text的实现，而Android中 Edittext 继承自 TextView</li>
<li>TextField 同样是结合 <code>较为通用的设计</code> 组合而成的一个控件，并不仅仅只有文字相关部分</li>
</ul>
<p><em>本篇注重于学习如何使用，故而略去源码部分</em></p>
<p>参数含义：</p>
<p>value: TextFieldValue
输入框中要显示的文本，包含了输入框编辑状态的信息，这个功能很强大，可以用来更新文本，光标等，然后还可以从其他位置直接观察到这些值的变化。也就是相当于双向绑定的意思；</p>
<ul>
<li>value: 显示的文本</li>
<li>onValueChange: 更新后的回调</li>
<li>modifier:修饰器</li>
<li>enabled:是否可用，如果为false，将不可选中，不可输入，呈现出禁用状态</li>
<li>readOnly:是否只读，如果是true，则不可编辑，但是可以选中，可以触发复制</li>
<li>textStyle: 文字样式，<em>前文中Text的诸多参数亦用于构建TextStyle</em></li>
<li>label: 显示在文本字段内的可选标签，未获得焦点时呈现</li>
<li>placeholder: 获得焦点时的默认呈现 <em>类似Tint的效果</em></li>
<li>leadingIcon: 输入框前部的图标；</li>
<li>trailingIcon: 输入框后部的图标；</li>
<li>isError: 输入内容是否错误，如果为true，则label，Icon等会相应的展示错误的显示状态；</li>
<li>visualTransformation: 内容显示转变，例如输入密码时可以变成特定效果</li>
<li>keyboardOptions: 软件键盘选项</li>
<li>keyboardActions: ImeAction</li>
<li>singleLine: 是否单行输入</li>
<li>maxLines:最大行数，需要≥1。如果将singleLine设置为true，则将忽略此参数，</li>
<li>interactionSource: <em>目前的知识体系暂不深入</em></li>
<li>shape: 输入框的形状</li>
<li>colors: 各种状态下的颜色 <em>类似Android的ColorStateList</em></li>
</ul>
<h3 id="效果演示"><a class="header" href="#效果演示">效果演示</a></h3>
<pre><code class="language-kotlin">TextField(
    value = "文字",
    onValueChange = {
        
    }
)
</code></pre>
<p>如果我们测试这样一段代码，会发现无论输入什么，显示内容都不会改变。Compose 需要我们在外部维护状态</p>
<p>一个有效的输入框代码示例：</p>
<pre><code class="language-kotlin">var text by rememberSaveable { mutableStateOf("文字") }
TextField(
    value = text,
    onValueChange = {
        text = it
    }
)
</code></pre>
<p><em>如果读者仔细的观察一下，会发现这里的value 依旧对应 String 类型！这里充分利用了Delegate的特性！！</em></p>
<p>接下来，我们尝试一下几个有趣的属性。</p>
<blockquote>
<p>而下述的一些简单属性，相信读者已经心中有数，就不在WorkShop中演示了：</p>
<ul>
<li>modifier</li>
<li>enabled</li>
<li>readOnly</li>
<li>textStyle</li>
<li>visualTransformation</li>
<li>singleLine</li>
<li>maxLines</li>
<li>shape</li>
<li>colors</li>
</ul>
</blockquote>
<h3 id="label--placeholder"><a class="header" href="#label--placeholder">label &amp; placeholder</a></h3>
<pre><code class="language-kotlin">var text by rememberSaveable { mutableStateOf("") }
TextField(
    value = text,
    onValueChange = { text = it },
    label = { Text("Label") },
    placeholder = { Text("PlaceHolder") }
)
</code></pre>
<p>未获得焦点时，显示label：<em>这里输入的是啥</em>，获取焦点后，label缩小，如果没有初始值，则显示PlaceHolder，否则初始文字
PlaceHolder：<em>输入示例</em></p>
<p><em>效果在章节末呈现</em></p>
<h3 id="leadingicontrailingicon"><a class="header" href="#leadingicontrailingicon">leadingIcon&amp;trailingIcon</a></h3>
<pre><code class="language-kotlin">var text by rememberSaveable { mutableStateOf("") }

TextField(
    value = text,
    onValueChange = { text = it },
    placeholder = { Text("PlaceHolder") },
    leadingIcon = { Icon(Icons.Filled.Favorite, contentDescription = "Favorite") },
    trailingIcon = { Icon(Icons.Filled.Clear, contentDescription = "Clear",modifier = Modifier.clickable {
        text = ""
    }) }
)
</code></pre>
<blockquote>
<p>如果在Android原生SDK下，做法可以是：</p>
<ul>
<li>完全自定义View -- 完全通过继承</li>
<li>继承ViewGroup或者特定ViewGroup，内部通过组合控件方式 <em>反射xml布局或者代码构建</em> 实现逻辑 -- 继承 + 组合</li>
<li>定义类，内部通过组合控件方式 <em>反射xml布局或者代码构建</em> 实现逻辑 -- 组合</li>
</ul>
<p>每种做法都有自身的优势和劣势，<strong>但代码量都会很多</strong></p>
<p>这个例子下我们还无法去讨论 <code>组合与继承的优劣对比</code> ，但代码量的感性对比非常明显</p>
</blockquote>
<h3 id="iserror--keyboardactions--输入校验"><a class="header" href="#iserror--keyboardactions--输入校验">isError &amp; keyboardActions &amp; 输入校验</a></h3>
<pre><code class="language-kotlin">var text by rememberSaveable { mutableStateOf("") }
var isError by rememberSaveable { mutableStateOf(false) }

fun validate(text: String) {
    isError = text.count() &lt; 5
}

TextField(
    value = text,
    onValueChange = {
        text = it
        isError = false
    },
    singleLine = true,
    label = { Text(if (isError) "Email*" else "Email") },
    isError = isError,
    keyboardActions = KeyboardActions { validate(text) },
    modifier = Modifier.semantics {
        // Provide localized description of the error
        if (isError) {
            Toast.makeText(this@P26TextFieldSample,"输入错误",Toast.LENGTH_SHORT).show()
        }
    }
)
</code></pre>
<p>代码含义清晰明了</p>
<h3 id="上述例子的效果"><a class="header" href="#上述例子的效果">上述例子的效果</a></h3>
<p><img src="./post_26/text_field_demo.webp" alt="text_field_demo" /></p>
<p>读者可以clone项目后自行体验</p>
<blockquote>
<p>相信有读者已经在思考Compose是如何实现 <code>双向绑定</code> 的了，按照我们的学习计划，这将在后续的文章中展开。</p>
</blockquote>
<h2 id="button"><a class="header" href="#button">Button</a></h2>
<p>相信看到这里，有读者已经在思考一个问题了：</p>
<blockquote>
<p>Modifier 中有点击相关的内容，为什么还需要有Button呢？它真的是一个视图控件吗？还是一个特定的、带有点击效果的样式组合？</p>
</blockquote>
<p>其实 <code>Button</code> 在人机交互中，是一个类似 <code>隐喻</code> 的存在，指代点击可触发特定行为的交互区，在设计发展中，
逐渐形成了一些约定：</p>
<ul>
<li><strong>可触发和不可触发的状态要可识别</strong></li>
<li><strong>从其所在环境中可以被轻易地识别出来</strong></li>
<li><strong>点击或者按压要有视觉反馈效果</strong></li>
</ul>
<p>所以样式上是一个不可忽略的侧重点。但是也要客观的承认一点：<code>中式UI和欧美UI确实不是一个风格</code>，所以多数情况下我们会修改掉默认效果。</p>
<p>看一下方法原型：</p>
<pre><code class="language-kotlin">fun Button(
    onClick: () -&gt; Unit,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    interactionSource: MutableInteractionSource = remember { MutableInteractionSource() },
    elevation: ButtonElevation? = ButtonDefaults.elevation(),
    shape: Shape = MaterialTheme.shapes.small,
    border: BorderStroke? = null,
    colors: ButtonColors = ButtonDefaults.buttonColors(),
    contentPadding: PaddingValues = ButtonDefaults.ContentPadding,
    content: RowScope.() -&gt; Unit
): @Composable Unit
</code></pre>
<ul>
<li>onClick: 点击事件回调</li>
<li>modifier: 修饰器</li>
<li>enabled:是否可点击触发</li>
<li>interactionSource:</li>
<li>elevation: z轴投影效果</li>
<li>shape: button和投影的形状</li>
<li>border: 描边</li>
<li>colors: 背景色、内容色、各个状态配色</li>
<li>contentPadding: 容器和内容的间距</li>
<li>content: 内容</li>
</ul>
<h3 id="代码示例"><a class="header" href="#代码示例">代码示例</a></h3>
<p>一个最简单的文字按钮：</p>
<pre><code class="language-kotlin">Button(
    onClick = {
        toast("onClick")
    },
    modifier = Modifier.clickable {
        toast("Modifier.onClick")
    }
) {
    Text(
        text = "Button",
    )
}
</code></pre>
<p>显然，点击生效的是 <code>onClick</code> 的回调函数。</p>
<p><em>在 <strong>后面的效果图</strong> 或者 <strong>运行WorkShop后</strong> 可发现，这个文字Button已经运用了许多样式</em></p>
<p><em>Button的样式部分，读者可自行编码探索实践一二，可以很轻易的和Android原生内容对应上，不再展开。</em></p>
<p>前文的方法原型中，<code>content: RowScope.() -&gt; Unit</code> 显然可以包含更多的东西。<em>Row 的布局特性会在后续文章展开</em></p>
<p>例如：</p>
<pre><code class="language-kotlin">Button(
    onClick = {
        toast("onClick")
    }
) {
    Icon(
        Icons.Filled.Favorite,
        contentDescription = "Favorite"
    )
    Text(
        text = "Button",
    )
}
</code></pre>
<p>可以在文字左边放置一个 <code>Favorite</code> 图标</p>
<h3 id="结合样式的衍生物"><a class="header" href="#结合样式的衍生物">结合样式的衍生物</a></h3>
<p>而Compose中，还有一些内容，代表着Button的操作含义，但有更特殊的样式含义，例如：</p>
<ul>
<li>OutlinedButton：有边线的Button, 但非实质的，<em>借用Android原生的内容比喻：有Stroke效果，无Solid效果</em></li>
<li>IconButton：显示一个Icon的button <em>但编码上未强制约束</em></li>
<li>IconToggleButton：两个状态图标的icon，相互切换，<em>例如：收藏、取消收藏</em>，表现含义上有别于 <code>Switch</code>，表现类似无文字的 <code>CheckBox</code></li>
</ul>
<h4 id="outlinedbutton"><a class="header" href="#outlinedbutton">OutlinedButton</a></h4>
<pre><code class="language-kotlin">fun OutlinedButton(
    onClick: () -&gt; Unit,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    interactionSource: MutableInteractionSource = remember { MutableInteractionSource() },
    elevation: ButtonElevation? = null,
    shape: Shape = MaterialTheme.shapes.small,
    border: BorderStroke? = ButtonDefaults.outlinedBorder,
    colors: ButtonColors = ButtonDefaults.outlinedButtonColors(),
    contentPadding: PaddingValues = ButtonDefaults.ContentPadding,
    content: @Composable RowScope.() -&gt; Unit
)
</code></pre>
<p>和Button参数含义一致</p>
<h4 id="iconbutton"><a class="header" href="#iconbutton">IconButton</a></h4>
<pre><code class="language-kotlin">fun IconButton(
    onClick: () -&gt; Unit,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    interactionSource: MutableInteractionSource = remember { MutableInteractionSource() },
    content: @Composable () -&gt; Unit
)
</code></pre>
<p><em>参数含义参考Button</em></p>
<p>适用场景如返回键、关闭按钮等</p>
<p>示例：</p>
<pre><code class="language-kotlin">IconButton(
    onClick = {
        toast("onClick")
    },
) {
    Icon(
        imageVector = Icons.Filled.Favorite,
        contentDescription = "Favorite"
    )
}
</code></pre>
<h4 id="icontogglebutton"><a class="header" href="#icontogglebutton">IconToggleButton</a></h4>
<pre><code class="language-kotlin">fun IconToggleButton(
    checked: Boolean,
    onCheckedChange: (Boolean) -&gt; Unit,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    interactionSource: MutableInteractionSource = remember { MutableInteractionSource() },
    content: @Composable () -&gt; Unit
) 
</code></pre>
<ul>
<li>checked：默认状态</li>
<li>onCheckedChange：状态变化后的回调</li>
</ul>
<p>适用场景如：收藏、取消收藏等</p>
<p>示例：</p>
<pre><code class="language-kotlin">val checkedState = remember { mutableStateOf(true) }

IconToggleButton(
    checked = checkedState.value,
    onCheckedChange = {
        checkedState.value = it
    },
) {
    Icon(
        imageVector = Icons.Filled.Favorite,
        contentDescription = "Favorite",
        tint = if (checkedState.value) {
            Color.Red
        } else {
            Color.Gray
        }
    )
}
</code></pre>
<p>上述所有内容的效果：
<img src="./post_26/button_demo.webp" alt="button_demo" /></p>
<h2 id="结语"><a class="header" href="#结语">结语</a></h2>
<p>在本篇文章中，我们一起学习了Compose的部分基础内容，这些内容学起来也比较枯燥，但适应了Compose之后，学习这些基础内容就会越来越快。</p>
<p>读者可以结合 <a href="https://github.com/leobert-lan/ComposeWorkShop">WorkShop</a> 实践一波，加深印象！</p>
<p>我们下一篇见。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../Compose/post_21.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../Compose/post_27.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../Compose/post_21.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../Compose/post_27.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
