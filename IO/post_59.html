<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>IO系列 | 一文掌握OKHTTP中的OKIO为什么这么OK - leobert&#x27;s blog</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">目录</li><li class="chapter-item expanded "><a href="../Android/index.html"><strong aria-hidden="true">1.</strong> Android</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/View/index.html"><strong aria-hidden="true">1.1.</strong> View</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/View/post_1.html"><strong aria-hidden="true">1.1.1.</strong> 好玩系列：优雅的处理ButterKnife和KAE被废弃</a></li><li class="chapter-item expanded "><a href="../Android/View/post_6.html"><strong aria-hidden="true">1.1.2.</strong> 三思系列：View体系认知(一)，内容是如何正确被展现出来的--视觉呈现概览</a></li><li class="chapter-item expanded "><a href="../Android/View/post_7.html"><strong aria-hidden="true">1.1.3.</strong> 三思系列：为什么自定义View</a></li><li class="chapter-item expanded "><a href="../Android/Idea/post_9.html"><strong aria-hidden="true">1.1.4.</strong> 三思系列："声明式UI"和"命令式UI"，你的理解可能是错的</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/Drawable/index.html"><strong aria-hidden="true">1.2.</strong> Drawable</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/Drawable/post_2.html"><strong aria-hidden="true">1.2.1.</strong> 三思系列：重新认识Drawable</a></li><li class="chapter-item expanded "><a href="../Android/Drawable/post_4.html"><strong aria-hidden="true">1.2.2.</strong> 好玩系列：拥有它，XML文件少一半--更方便的处理View背景</a></li><li class="chapter-item expanded "><a href="../Android/Drawable/post_47.html"><strong aria-hidden="true">1.2.3.</strong> 迟来的续集--Drawable+Animator，将优雅进行到底</a></li><li class="chapter-item expanded "><a href="../Android/Drawable/post_49.html"><strong aria-hidden="true">1.2.4.</strong> 好玩系列：让ImageSpan动起来</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/Mechanism/Message/index.html"><strong aria-hidden="true">1.3.</strong> 消息机制</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/Mechanism/Message/post_8.html"><strong aria-hidden="true">1.3.1.</strong> 三思系列：Android的消息机制，一文吃透</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/Idea/post_14/index.html"><strong aria-hidden="true">1.4.</strong> 兼容</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/Idea/post_14.html"><strong aria-hidden="true">1.4.1.</strong> 好玩系列：让项目中的相册支持Heif格式图片</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/Glide/index.html"><strong aria-hidden="true">1.5.</strong> Glide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/Glide/post_15.html"><strong aria-hidden="true">1.5.1.</strong> 三思系列：Glide 4.X全方位认知 -- 模块职责概览</a></li><li class="chapter-item expanded "><a href="../Android/Glide/post_16.html"><strong aria-hidden="true">1.5.2.</strong> 三思系列：Glide 4.X加载过程一文掌握 | Glide（二）</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/KSP/index.html"><strong aria-hidden="true">1.6.</strong> KSP</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/KSP/post_24.html"><strong aria-hidden="true">1.6.1.</strong> 好玩系列 | 拥抱Kotlin Symbol Processing(KSP),项目实战</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/Base/index.html"><strong aria-hidden="true">1.7.</strong> 基础</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/Base/post_35.html"><strong aria-hidden="true">1.7.1.</strong> 孔乙己：你可知道页面和弹窗“通信“的方式有四种？</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/SysApp/index.html"><strong aria-hidden="true">1.8.</strong> 系统APP</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/SysApp/post_52.html"><strong aria-hidden="true">1.8.1.</strong> 使用日历丰富产品的用户体验</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/DI/index.html"><strong aria-hidden="true">1.9.</strong> Part4-依赖注入部分</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/DI/post_53.html"><strong aria-hidden="true">1.9.1.</strong> Hilt进阶--一文吃透Hilt自定义与跨壁垒</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../Compose/index.html"><strong aria-hidden="true">2.</strong> Jetpack Compose</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Compose/post_21.html"><strong aria-hidden="true">2.1.</strong> Jetpack Compose | 一文理解神奇的Modifier</a></li><li class="chapter-item expanded "><a href="../Compose/post_26.html"><strong aria-hidden="true">2.2.</strong> Jetpack Compose | 控件篇（一） -- Text、TextField、Button</a></li><li class="chapter-item expanded "><a href="../Compose/post_27.html"><strong aria-hidden="true">2.3.</strong> Jetpack Compose | 控件篇（二） -- Icon，Image</a></li><li class="chapter-item expanded "><a href="../Compose/post_28.html"><strong aria-hidden="true">2.4.</strong> Jetpack Compose | 控件篇（三） -- Switch、CheckBox、RadioButton</a></li><li class="chapter-item expanded "><a href="../Compose/post_29.html"><strong aria-hidden="true">2.5.</strong> Jetpack Compose | 控件篇（四）-- Box、Row、Column</a></li><li class="chapter-item expanded "><a href="../Compose/post_30.html"><strong aria-hidden="true">2.6.</strong> Jetpack Compose | 控件篇（五）-- Spacer、LazyRow、LazyColumn & 让Column可滑动</a></li></ol></li><li class="chapter-item expanded "><a href="../MultiThreading/index.html"><strong aria-hidden="true">3.</strong> Java多线程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../MultiThreading/post_33.html"><strong aria-hidden="true">3.1.</strong> 总纲</a></li><li class="chapter-item expanded "><a href="../MultiThreading/post_37.html"><strong aria-hidden="true">3.2.</strong> Java基础--图解JVM内存模型和JVM线程模型</a></li><li class="chapter-item expanded "><a href="../MultiThreading/post_38.html"><strong aria-hidden="true">3.3.</strong> Java多线程系列--掌控面试，一文吃透Synchronized锁</a></li><li class="chapter-item expanded "><a href="../MultiThreading/post_39.html"><strong aria-hidden="true">3.4.</strong> Java多线程基础--线程生命周期与线程协作详解</a></li><li class="chapter-item expanded "><a href="../MultiThreading/post_42.html"><strong aria-hidden="true">3.5.</strong> Java多线程基础--线程的创建与线程池管理</a></li><li class="chapter-item expanded "><a href="../MultiThreading/post_46.html"><strong aria-hidden="true">3.6.</strong> Java多线程系列--掌握Future，轻松获取异步任务结果</a></li><li class="chapter-item expanded "><a href="../MultiThreading/post_50.html"><strong aria-hidden="true">3.7.</strong> Java多线程系列--Fork&Join框架，分治的艺术</a></li><li class="chapter-item expanded "><a href="../MultiThreading/post_54.html"><strong aria-hidden="true">3.8.</strong> Java多线程系列--掌握CompletableFuture，驾驭异步编程</a></li></ol></li><li class="chapter-item expanded "><a href="../IO/index.html"><strong aria-hidden="true">4.</strong> Java IO系列</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../IO/post_55.html"><strong aria-hidden="true">4.1.</strong> Java IO 系列总纲</a></li><li class="chapter-item expanded "><a href="../IO/post_56.html"><strong aria-hidden="true">4.2.</strong> Java IO系列 | 经典 IO</a></li><li class="chapter-item expanded "><a href="../IO/post_57.html"><strong aria-hidden="true">4.3.</strong> Java IO 系列 | NIO-1.0一文速览</a></li><li class="chapter-item expanded "><a href="../IO/post_58.html"><strong aria-hidden="true">4.4.</strong> Java IO系列 | NIO-1.0拾遗、NIO-2.0 & 零拷贝必吹的牛皮</a></li><li class="chapter-item expanded "><a href="../IO/post_59.html" class="active"><strong aria-hidden="true">4.5.</strong> IO系列 | 一文掌握OKHTTP中的OKIO为什么这么OK</a></li></ol></li><li class="chapter-item expanded "><a href="../Gradle/index.html"><strong aria-hidden="true">5.</strong> Gradle</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Gradle/Modularization/post_18.html"><strong aria-hidden="true">5.1.</strong> 组件化：三思系列：组件化场景下module依赖优雅实践方案</a></li><li class="chapter-item expanded "><a href="../Gradle/Publish/post_17.html"><strong aria-hidden="true">5.2.</strong> MavenCentral发布：迁移到MavenCentral--再不行动起来，你的托管的library就没了</a></li><li class="chapter-item expanded "><a href="../Gradle/post_22.html"><strong aria-hidden="true">5.3.</strong> Gradle | 依赖管理最佳实践</a></li></ol></li><li class="chapter-item expanded "><a href="../Groovy/index.html"><strong aria-hidden="true">6.</strong> Groovy</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Groovy/why_write_groovy.html"><strong aria-hidden="true">6.1.</strong> 为什么撰写这个系列</a></li><li class="chapter-item expanded "><a href="../Groovy/post_23.html"><strong aria-hidden="true">6.2.</strong> Groovy：MOP一文打尽</a></li></ol></li><li class="chapter-item expanded "><a href="../Review/index.html"><strong aria-hidden="true">7.</strong> Review</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Review/post_10.html"><strong aria-hidden="true">7.1.</strong> 造完了这个轮子--Mocker，却让我感到很羞愧|项目复盘</a></li><li class="chapter-item expanded "><a href="../Review/post_40.html"><strong aria-hidden="true">7.2.</strong> 三思系列：前人用GreenDao留下的坑，全线被扣了绩效</a></li><li class="chapter-item expanded "><a href="../Review/post_44.html"><strong aria-hidden="true">7.3.</strong> 谈一谈在两个商业项目中使用MVI架构后的感悟</a></li><li class="chapter-item expanded "><a href="../Review/post_45.html"><strong aria-hidden="true">7.4.</strong> Review | 这三个坑你遇到了吗？</a></li></ol></li><li class="chapter-item expanded "><a href="../repo/index.html"><strong aria-hidden="true">8.</strong> 个人项目</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../repo/DaVinCi.html"><strong aria-hidden="true">8.1.</strong> DaVinCi,取代XML编写Shape或ColorStateList的方案</a></li><li class="chapter-item expanded "><a href="../Android/Idea/post_32.html"><strong aria-hidden="true">8.2.</strong> 好玩系列：白嫖一个优雅的类图生成工具</a></li><li class="chapter-item expanded "><a href="../Speculative/post_43.html"><strong aria-hidden="true">8.3.</strong> 初体验：动手搭建"小清新式"局域网文档系统</a></li><li class="chapter-item expanded "><a href="../repo/post_48.html"><strong aria-hidden="true">8.4.</strong> 研究良久，终于发现了他代码写的快且bug少的原因</a></li><li class="chapter-item expanded "><a href="../Speculative/post_61.html"><strong aria-hidden="true">8.5.</strong> 好玩系列 | 如果后端让你用SSE接收多次返回，那我们改造Retrofit吧</a></li></ol></li><li class="chapter-item expanded "><a href="../Review/DataStructure/index.html"><strong aria-hidden="true">9.</strong> 数据结构</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Review/DataStructure/post_11.html"><strong aria-hidden="true">9.1.</strong> 温故：线性表</a></li><li class="chapter-item expanded "><a href="../Review/DataStructure/post_12.html"><strong aria-hidden="true">9.2.</strong> 温故：栈</a></li><li class="chapter-item expanded "><a href="../Review/DataStructure/post_13.html"><strong aria-hidden="true">9.3.</strong> 温故：队列</a></li></ol></li><li class="chapter-item expanded "><a href="../Review/README2.html"><strong aria-hidden="true">10.</strong> 年终总结&计划</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Review/post_36.html"><strong aria-hidden="true">10.1.</strong> 2021年终总结</a></li><li class="chapter-item expanded "><a href="../Review/post_51.html"><strong aria-hidden="true">10.2.</strong> 关于画一个句号--基于2022年终总结的反思与分享</a></li><li class="chapter-item expanded "><a href="../Review/post_60.html"><strong aria-hidden="true">10.3.</strong> 突如其来的秋季反思</a></li><li class="chapter-item expanded "><a href="../Review/post_63.html"><strong aria-hidden="true">10.4.</strong> 2023年总结 寻找到源于内心深处的无穷力量</a></li><li class="chapter-item expanded "><a href="../Review/post_64.html"><strong aria-hidden="true">10.5.</strong> 2024年中思考，推倒樊笼重新出发</a></li></ol></li><li class="chapter-item expanded "><a href="../Note/index.html"><strong aria-hidden="true">11.</strong> 读书笔记</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Note/post_41.html"><strong aria-hidden="true">11.1.</strong> 读书笔记：《简约至上--交互式设计四策略》</a></li><li class="chapter-item expanded "><a href="../Talk/talk_4_2024-08.html"><strong aria-hidden="true">11.2.</strong> 读书笔记 - 《团队管理》精华摘要</a></li></ol></li><li class="chapter-item expanded "><a href="../Talk/index.html"><strong aria-hidden="true">12.</strong> 杂谈</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Talk/talk_1.html"><strong aria-hidden="true">12.1.</strong> 杂谈1-2022-11</a></li><li class="chapter-item expanded "><a href="../Talk/talk_2_2023-03.html"><strong aria-hidden="true">12.2.</strong> 杂篇（二）-- 认识并战胜焦虑</a></li><li class="chapter-item expanded "><a href="../Talk/talk_3_2024-08.html"><strong aria-hidden="true">12.3.</strong> 杂谈（三）-- 向钱看，你需要想明白企业在为什么而付钱</a></li></ol></li><li class="chapter-item expanded "><a href="../Thought/index.html"><strong aria-hidden="true">13.</strong> 半成熟的思考</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Thought/post_62.html"><strong aria-hidden="true">13.1.</strong> 好玩系列 | 当SPI 和 设计模式、依赖注入发生碰撞，可以擦出怎样的火花</a></li></ol></li><li class="chapter-item expanded "><a href="../info/index.html"><strong aria-hidden="true">14.</strong> 系列说明</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../info/about_view_series.html"><strong aria-hidden="true">14.1.</strong> 关于View系列</a></li><li class="chapter-item expanded "><a href="../info/about_sansi_series.html"><strong aria-hidden="true">14.2.</strong> 关于三思系列</a></li><li class="chapter-item expanded "><a href="../info/about_haowan_series.html"><strong aria-hidden="true">14.3.</strong> 关于好玩系列</a></li><li class="chapter-item expanded "><a href="../info/about_wengu_series.html"><strong aria-hidden="true">14.4.</strong> 关于温故系列</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">leobert&#x27;s blog</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="io系列--一文掌握okhttp中的okio为什么这么ok"><a class="header" href="#io系列--一文掌握okhttp中的okio为什么这么ok">IO系列 | 一文掌握OKHTTP中的OKIO为什么这么OK</a></h1>
<h2 id="前言"><a class="header" href="#前言">前言</a></h2>
<p>本篇是 <a href="https://juejin.cn/post/7231540022595141693">IO系列</a>
的第4篇，前三篇文章中，我们已经对JAVA经典IO设计、JAVA－NIO内容、操作系统IO架构基础概念、Zero－Copy做了较为系统的回顾。</p>
<p>而绝大部分Android应用中都会涉及到网络模块，<code>Retrofit</code>、<code>Okhttp</code> 几乎是必用的框架， <code>Okio</code> 作为 <code>Okhttp</code> 中的重要模块，原先用于处理网络模块中的IO问题，随着其项目发展，Okio也开始面向其他问题。</p>
<p>这一篇，我们一同对OKIO做一次系统的梳理，搞明白OKIO为什么OK，做到在面试中自如的吹牛批、在日常工作中灵活使用。</p>
<p><em>编者按：面试吹牛批需要把握尺度，避免远超岗位预期，导致浪费时间</em></p>
<p>因文章篇幅较长，可结合内容导图阅读：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2d1c33d42e24465ba66782ec42e6aa2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1682&amp;h=1466&amp;e=png&amp;b=3c3c3c" alt="okio.png" /></p>
<h2 id="okio的主旨与架构"><a class="header" href="#okio的主旨与架构">okio的主旨与架构</a></h2>
<p>在OKIO项目的 wiki 中，对其主旨有如下介绍：</p>
<blockquote>
<p>Okio is a library that complements java.io and java.nio to make it much easier to access, store, and process your data. It started as a component of OkHttp, the capable HTTP client included in Android. It’s well-exercised and ready to solve new problems.</p>
</blockquote>
<p>简单直译为中文如下：</p>
<blockquote>
<p>Okio是一个类库，对 <code>java.io</code> 和 <code>java.nio</code> 进行了补充，使得访问、存储和处理数据变得更加容易。它最初是OkHttp的一个组件，OkHttp是安卓中的一个功能强大的HTTP客户端。它非常健壮，可以解决新问题。</p>
</blockquote>
<p>简言之：为了更简单的访问、存储、处理数据,基于 <code>java.io</code> 和 <code>java.nio</code> 进行了功能补充</p>
<p>wiki中，简单介绍了设计中的几个重点角色：</p>
<ul>
<li>ByteStrings and Buffers</li>
<li>Sources and Sinks</li>
</ul>
<p>分层架构中相对扁平、简单：在应用和Java IO 之间增加了一层，即OKIO本身，包含 <code>数据封装</code> 、 <code>输入输出</code> 、 <code>超时机制</code></p>
<p>体现在类图上还是比较复杂的：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fedeb0bc77f2443489e62d72e907db32~tplv-k3u1fbpfcp-watermark.image?" alt="图片.png" /></p>
<p>在库内部，<code>ByteStrings</code> 的使用不多，对 <code>Buffer</code> 数据包装后为上层应用服务，单独拎出。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae6e6dcdbd4e4666b063727b186228ac~tplv-k3u1fbpfcp-watermark.image?" alt="KtsampleOkioDiagramReport2.png" /></p>
<p>信息噪声比较多，去掉功能装饰的实现类后较为精简：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2a3eb53e0844ec8a0116ed6eaa9b380~tplv-k3u1fbpfcp-watermark.image?" alt="KtsampleOkioDiagramReport.png" /></p>
<h2 id="与java的输入输出的对比"><a class="header" href="#与java的输入输出的对比">与Java的输入输出的对比</a></h2>
<p>Java经典IO中的输入输出定义为Stream，在 <a href="https://juejin.cn/post/7231804508082159675">系列文章</a> 中进行了介绍。<em>字符流类似，图略</em></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b37be911d88b4b97a3fa12dc1cc0cb8c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="" /></p>
<p>在JDK的IO框架中，使用装饰模式建立了规模庞大、功能丰富的输入输出流。从OKIO的主旨出发，不难理解其设计者希望类库尽可能简单、易扩展、内建部分功能足够完善。因此，OKIO会适当的另起炉灶，不会全面的使用JDK中的Stream。</p>
<p>OKIO中使用了自定义的输入、输出，即 <code>Source</code> 和 <code>Sink</code> ，注意淡黄色、淡粉色部分：</p>
<blockquote>
<p>Sink 在计算机领域有特定含义：指程序或者线程，可以接收数据，并且可以处理或者发送这些数据</p>
</blockquote>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2a3eb53e0844ec8a0116ed6eaa9b380~tplv-k3u1fbpfcp-watermark.image?" alt="KtsampleOkioDiagramReport.png" /></p>
<h3 id="差异点"><a class="header" href="#差异点">差异点</a></h3>
<p>在wiki中提到如下内容：</p>
<blockquote>
<p>An elegant part of the java.io design is how streams can be layered for transformations like encryption and compression. Okio includes its own stream types called Source and Sink that work like InputStream and OutputStream, but with some key differences:</p>
<ul>
<li>Timeouts.</li>
<li>Easy to implement.</li>
<li>Easy to use.</li>
<li>No artificial distinction between byte streams and char streams.</li>
<li>Easy to test.</li>
</ul>
</blockquote>
<p>简单翻译下， Java IO的设计中有一处非常优雅：可以调整流的分层包装以实现加密、压缩等转换。OKIO包含自有的流类型 <code>Source</code>、<code>Sink</code>，与Java的 <code>InputStream </code>、 <code>OutputStream</code>
功能类似，但是有几点关键的不同：</p>
<ul>
<li>超时机制</li>
<li>更容易实现</li>
<li>更容易使用</li>
<li>字节流、字符流之间没有人为的差异</li>
<li>更容易测试</li>
</ul>
<p><strong>从输入方面看</strong>：</p>
<p>在JDK中，<code>InputStream</code> 使用多种层（以及复合层）处理种类繁多的各类数据</p>
<ul>
<li><code>DataInputStream</code> 用于处理基础数据类型</li>
<li><code>BufferedInputStream</code> 处理缓冲</li>
<li><code>InputStreamReader</code> 处理文本字符串</li>
</ul>
<p>而OKIO在这些层之上建立了 <code>BufferedSource</code>，Source避免了一些无法实现 <code>available()</code> 方法的困境, 转而由调用者指定它们需要的byte个数</p>
<p>在实现一个Source时，不必操心 <code>read()</code> 方法，它难以有效实现且需从257种值中返回一个 ，<em>注：null &amp; [0x00，0xFF]</em></p>
<p><strong>从输出方面看</strong>：</p>
<p>类似的，在JDK中 <code>OutputStream</code> 使用多种层（以及复合层）处理种类繁多的各类数据，而Sink也非常容易采用分层设计</p>
<h3 id="相同点"><a class="header" href="#相同点">相同点</a></h3>
<ul>
<li><code>Source</code> 、 <code>Sink</code> 的功能与 <code>InputStream</code> 、 <code>OutputStream</code> 、 <code>Reader</code> 、 <code>Writer</code> 相同</li>
<li>使用时可以通过装饰追加功能</li>
</ul>
<p>对于功能相同，wiki中提到如下内容：</p>
<blockquote>
<p>Sources and sinks interoperate with InputStream and OutputStream. You can view any Source as an InputStream, and you can view any InputStream as a Source. Similarly for Sink and OutputStream.</p>
</blockquote>
<p>下文的Source、Sink详解中，解析他们与IOStream 为何 “等价”、如何“互操作”</p>
<h2 id="sourcesink-详解"><a class="header" href="#sourcesink-详解">Source、Sink 详解</a></h2>
<h3 id="source-体系"><a class="header" href="#source-体系">Source 体系</a></h3>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55d27ea70bc94f1db95aa190a2b1a567~tplv-k3u1fbpfcp-watermark.image?" alt="KtsampleOkio-sourceDiagramReport.png" /></p>
<p>抛开功能类（压缩、哈希、加密、装饰等），主要关注：</p>
<ul>
<li>Source</li>
<li>BufferedSource</li>
<li>Buffer</li>
<li>RealBufferedSource</li>
</ul>
<p>Source的定义中规中矩：</p>
<pre><code>interface Source : Closeable {

  @Throws(IOException::class)
  fun read(sink: Buffer, byteCount: Long): Long

  fun timeout(): Timeout

  @Throws(IOException::class)
  override fun close()
}
</code></pre>
<p>其中的 <code>timeout</code> 将在下文超时机制章节中展开。</p>
<p>BufferedSource接口约定使用 <code>Buffer</code> 承接实际数据，并且定义了一系列方便使用的接口，如：</p>
<ul>
<li>读取Int</li>
<li>读取Short</li>
<li>读取字符串</li>
<li>内容选择 等，不做罗列</li>
</ul>
<p><code>RealBufferedSource</code> 实现了 <code>BufferedSource</code> 接口，从本质上可以认为是 <code>Buffer</code> 类的代理，增加了边界校验</p>
<p><code>Buffer</code> 实现了 <code>BufferedSource </code> 接口，包含 <strong>读</strong> 的具体实现</p>
<h3 id="sink-体系"><a class="header" href="#sink-体系">Sink 体系</a></h3>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f80924dedbd412894570f28664e99ca~tplv-k3u1fbpfcp-watermark.image?" alt="KtsampleOkio-sinkDiagramReport.png" /></p>
<p>抛开功能类（压缩、哈希、加密、装饰等），主要关注：</p>
<ul>
<li>Sink</li>
<li>BufferedSink</li>
<li>Buffer</li>
<li>RealBufferedSink</li>
</ul>
<pre><code>interface Sink : Closeable {
  @Throws(IOException::class)
  fun write(source: Buffer, byteCount: Long)

  @Throws(IOException::class)
  fun flush()

  fun timeout(): Timeout

  @Throws(IOException::class)
  override fun close()
}
</code></pre>
<p>同样，Sink接口的定义也中规中矩。</p>
<p>类似的，<code>BufferedSink</code> 接口继承了 <code>Sink</code> 接口，约定了使用 <code>Buffer</code> 承接实际数据, <code>RealBufferedSink</code> 是具体实现，从本质上是 <code>Buffer</code> 作为 <code>Sink</code>
时的代理，进行了边界校验。</p>
<p><code>Buffer</code> 实现了 <code>BufferedSink </code> 接口，包含 <strong>写</strong> 的具体实现</p>
<h3 id="sourcesink与io-stream的互操作"><a class="header" href="#sourcesink与io-stream的互操作">Source、Sink与I/O-Stream的互操作</a></h3>
<p><em>作者按：请仔细思考一下 <code>互操作</code> ，其本质是：<strong>使用一种实例对象的API去操作另一种对象实例的API</strong>, 请留意直接操作和间接操作，国内程序员更习惯使用 “转”、“转换” ，着眼点是从一种实例对象获得另一种实例对象。</em>
<em>从转换角度思考时，容易陷入误区，枚举出没必要地转换情况、忽略掉必要的间接转换。</em></p>
<p>首先明确一点：<strong>在基于I/O-Stream进行读写时，InputStreamSource、 OutputStreamSink 是 I/O-Stream的读写代理； I/O-Stream 是 InputStreamSource、
OutputStreamSink 的读写委托。</strong></p>
<p>依靠转换API：</p>
<pre><code>fun InputStream.source(): Source = InputStreamSource(this, Timeout())
fun OutputStream.sink(): Sink = OutputStreamSink(this, Timeout())
</code></pre>
<p>排除此 <strong>“基本情况1”</strong> ，还有一种 <strong>基本情况2</strong> ，即我们希望使用I/O-Stream的API去实质操作OKIO。不难想象，此时必然存在用OKIO实现的定制业务，即数据的实质处理，OKIO选择了 <code>BufferedSink</code>
和 <code>BufferedSource</code> 而非 <code>Sink</code> 、 <code>Source</code>，此时 <code>BufferedSink</code> 和 <code>BufferedSource</code> 是 I/O-Stream 的业务委托。</p>
<p>API如下：</p>
<pre><code>interface BufferedSink : Sink, WritableByteChannel {
   //... ignore

  /** Returns an output stream that writes to this sink. */
  fun outputStream(): OutputStream
}
</code></pre>
<pre><code>interface BufferedSource : Source, ReadableByteChannel {
  //... ignore

  /** Returns an input stream that reads from this source. */
  fun inputStream(): InputStream
}
</code></pre>
<h4 id="更复杂的情况----基于基本情况加各类业务的组合"><a class="header" href="#更复杂的情况----基于基本情况加各类业务的组合">更复杂的情况 -- 基于基本情况加各类业务的组合</a></h4>
<p>排除掉这些基本情况，还需要需要互操作时，意味着存在两套模块，一套使用Okio的Source、Sink，一套使用Java的InputStream、OutputStream。假定使用Sink、Source的模块为A，使用I/O-Stream的模块为B。</p>
<p>以写为例，进行分析，有两种可能：</p>
<ul>
<li>操作模块A，数据从A流向B，进而写入 (一般来说，B存在业务定制，否则是基本情况1)</li>
<li>操作模块B，数据从B流向A，进而写入（A最终使用了基本情况1，此情况属于基本情况2的复杂版）</li>
</ul>
<h5 id="1-数据从a流向b进而写入"><a class="header" href="#1-数据从a流向b进而写入">1. 数据从A流向B，进而写入</a></h5>
<p>关注A模块的数据出口，A模块可能的设计</p>
<ul>
<li>A1:接受一个Sink实例，或者接受一些参数构建Sink实例</li>
<li>A2:对外提供一个Source实例，由外界自行消费 -- <em>这种设计思路比较奇葩</em></li>
<li>接受回调函数，提供实际数据 -- 不属于实际讨论范畴，忽略</li>
</ul>
<p>关注B模块的数据入口，B模块可能的设计</p>
<ul>
<li>B1:接受一个InputStream实例，或者接受一些参数构建InputStream实例，消费其数据 -- <em>这种设计思路比较奇葩</em></li>
<li>B2:对外提供一个OutputStream实例，由外界控制实际写</li>
<li>暴露使用ByteArray等写入API -- 不属于实际讨论范畴，忽略</li>
</ul>
<h6 id="a1b1-情况的伪代码"><a class="header" href="#a1b1-情况的伪代码">A1+B1 情况的伪代码</a></h6>
<blockquote>
<p>A1:接受一个Sink实例，或者接受一些参数构建Sink实例</p>
<p>B1:接受一个InputStream实例，或者接受一些参数构建InputStream实例，消费其数据</p>
</blockquote>
<pre><code class="language-kotlin">class Client {
    fun demo() {
        //使用Sink、Source的模块A
        val moduleA = A()

        //使用I/O-Stream的模块B
        val moduleB = B()

        val buffer = Buffer()

        //设置模块A的数据出口
        moduleA.setSink(buffer)
        //设置模块B的数据入口
        moduleB.setInputStream(buffer.inputStream())

        //假定最终写入file：
        moduleB.setOutputFile(File("/target.txt"))

        //调用模块A开始写入
        moduleA.write("some thing")
    }
}
</code></pre>
<p>值得注意的是，需要在Buffer区的数据被消费后，进行清理，以避免内存占用越来越多，而因为B模块的奇葩设计，往往带入多线程问题，编程难度较大</p>
<h6 id="a1b2-情况的伪代码"><a class="header" href="#a1b2-情况的伪代码">A1+B2 情况的伪代码</a></h6>
<blockquote>
<p>A1:接受一个Sink实例，或者接受一些参数构建Sink实例</p>
<p>B2:对外提供一个OutputStream实例，由外界控制实际写</p>
</blockquote>
<pre><code class="language-kotlin">class Client {
    fun demo() {
        //使用Sink、Source的模块A
        val moduleA = A()

        //使用I/O-Stream的模块B 
        val moduleB = B()
        //假定其写入方式为：moduleB.writer().write("xxx")， moduleB.writer()获得OutputStream实例
        //假定最终写入file：
        moduleB.setOutputFile(File("/target.txt"))

        //使用B的入口，套接到模块A的数据出口
        moduleA.setSink(moduleB.writer().sink())

        //调用模块A开始写入
        moduleA.write("some thing")
    }
}
</code></pre>
<h6 id="a2b1-情况的伪代码"><a class="header" href="#a2b1-情况的伪代码">A2+B1 情况的伪代码</a></h6>
<blockquote>
<p>A2:对外提供一个Source实例，由外界自行消费</p>
<p>B1:接受一个InputStream实例，或者接受一些参数构建InputStream实例，消费其数据</p>
</blockquote>
<pre><code class="language-kotlin">class Client {
    fun demo() {
        //使用Sink、Source的模块A
        val moduleA = A()

        //使用I/O-Stream的模块B 
        val moduleB = B()
        //假定最终写入file：
        moduleB.setOutputFile(File("/target.txt"))

        //此情况需要moduleA.getSource() 提供 BufferedSource实例，
        //如果实现了Sink而并未实现BufferedSource, 需要模块提供者自己考虑接口系统的转换
        moduleB.setInputStream(moduleA.getSource().inputStream())

        //调用模块A开始写入
        moduleA.write("some thing")
    }
}
</code></pre>
<h6 id="a2b2-情况的伪代码"><a class="header" href="#a2b2-情况的伪代码">A2+B2 情况的伪代码</a></h6>
<blockquote>
<p>A2:对外提供一个Source实例，由外界自行消费</p>
<p>B2:对外提供一个OutputStream实例，由外界控制实际写</p>
</blockquote>
<pre><code class="language-kotlin">class Client {
    fun demo() {
        //使用Sink、Source的模块A
        val moduleA = A()

        //使用I/O-Stream的模块B 
        val moduleB = B()
        //假定最终写入file：
        moduleB.setOutputFile(File("/target.txt"))

        val resultFromA = moduleA.getSource()

        val buffer = Buffer()
        while (resultFromA.read(buffer, count) != -1) {
            buffer.writeTo(moduleB.writer())
            buffer.clear()
        }

        //调用模块A开始写入
        moduleA.write("some thing")
    }
}
</code></pre>
<h5 id="2-数据从b流向a进而写入"><a class="header" href="#2-数据从b流向a进而写入">2. 数据从B流向A，进而写入</a></h5>
<p>关注A模块的数据入口，A模块可能的设计</p>
<ul>
<li>A1:接受一个Source实例，或者接受一些参数构建Source实例 -- <em>这种设计思路比较奇葩，在主动拥抱复杂</em></li>
<li>A2:对外提供一个Sink实例，由外界自行控制写入</li>
<li>暴露使用ByteArray等写入API -- 不属于实际讨论范畴，忽略</li>
</ul>
<p>关注B模块的数据出口，B模块可能的设计</p>
<ul>
<li>B1:接受一个OutputStream实例，或者接受一些参数构建OutputStream实例</li>
<li>B2:对外提供一个InputStream实例，由外界自行消费数据 -- <em>这种设计思路比较奇葩</em></li>
<li>接受回调函数，提供实际数据 -- 不属于实际讨论范畴，忽略</li>
</ul>
<p><em>简单归纳伪代码如下</em></p>
<pre><code>//A1 + B1 同样会有内存释放、多线程编程难度问题
val buffer = Buffer()
moduleA.setSource(buffer)
moduleB.setWriter(buffer.outputStream())

//A1 + B2
// moduleB.getResult() 返回InputStream实例
moduleA.setSource(moduleB.getResult().source())

//A2 + B1
moduleB.setWriter(moduleA.getSink().outputStream())

//A2 + B2
val resultFromB:InputStream = moduleB.getResult()
val buffer = ByteArray(1024)
while ((len = in.read(buffer))!=-1) {
    moduleA.sink().write(buffer,0,len)
}

</code></pre>
<p>很显然，OKIO提供的转化方式，能够满足正常的设计，而剩余的奇葩设计，自然需要设计者自行处理内存、多线程问题。</p>
<p><strong>而读的例子也是类似的，考虑到篇幅已经很长，读者诸君可以自行梳理。</strong></p>
<p><strong>在读和写都能够完成两套系统的互操作时，即可随心随意地构建出更加复杂的层叠layer，亦不再展开</strong></p>
<h2 id="buffer-详解"><a class="header" href="#buffer-详解">Buffer 详解</a></h2>
<p>顾名思义，OKIO 中的 Buffer 是特意设计的缓冲区。它在 <code>数据处理</code> 和 <code>数据读写</code> 之间进行缓冲</p>
<p><code>class Buffer : BufferedSource, BufferedSink, Cloneable, ByteChannel</code></p>
<p>它的设计意图可以概括为三个方面，这三方面并不孤立互斥：</p>
<ul>
<li>内存中的读写缓冲区</li>
<li>更方便的API</li>
<li>和 Java IO 互操作</li>
</ul>
<blockquote>
<p>更方便的API：系列文章中提到过，数据的实质内容可以编码成ByteArray，Buffer提供了更方便的编解码</p>
</blockquote>
<blockquote>
<p>和 Java IO 互操作：除了上文中已经提及的内容，还包含 <code>readFrom(input: InputStream)</code> , <code>fun writeTo(out: OutputStream, byteCount: Long = size)</code> 等API，这些也可以算为更方便的API</p>
<p>Buffer实现了ByteChannel接口，可以适应NIO的设计体系，当然此时它又是内存中的读写缓冲区</p>
</blockquote>
<p>API方面，读者诸君可自行研读代码，内容比较简单。让我们将精力放在 <code>缓冲区</code> 上，看一看它的实现原理。</p>
<h3 id="核心实现"><a class="header" href="#核心实现">核心实现</a></h3>
<p>移除掉干扰代码后, 可以发现它的重点为 <code> head: Segment</code> ，代码简单扫一眼有个印象即可：</p>
<pre><code>class Buffer : /*BufferedSource, BufferedSink,*/ Cloneable, ByteChannel {
  internal var head: Segment? = null

  var size: Long = 0L
    internal set

  @Throws(EOFException::class)
  override fun readByte(): Byte = commonReadByte()
  //和下面的read类似，仅作为Source的API示例

  @Throws(IOException::class)
  override fun read(sink: ByteBuffer): Int {
    val s = head ?: return -1

    val toCopy = minOf(sink.remaining(), s.limit - s.pos)
    sink.put(s.data, s.pos, toCopy)

    s.pos += toCopy
    size -= toCopy.toLong()

    if (s.pos == s.limit) {
      head = s.pop()
      SegmentPool.recycle(s)
    }

    return toCopy
  }

  override fun write(source: ByteArray): Buffer = commonWrite(source)
  //也用到了writableSegment(1)，可类比下面的write代码，仅留作Sink的API示例

  @Throws(IOException::class)
  override fun write(source: ByteBuffer): Int {
    val byteCount = source.remaining()
    var remaining = byteCount
    while (remaining &gt; 0) {
      val tail = writableSegment(1)

      val toCopy = minOf(remaining, Segment.SIZE - tail.limit)
      source.get(tail.data, tail.limit, toCopy)

      remaining -= toCopy
      tail.limit += toCopy
    }

    size += byteCount.toLong()
    return byteCount
  }
}

</code></pre>
<p>而Segment是什么呢？是一个链表数据结构：</p>
<pre><code>internal class Segment {
  @JvmField val data: ByteArray
  @JvmField var pos: Int = 0
  @JvmField var limit: Int = 0
  @JvmField var shared: Boolean = false
  @JvmField var owner: Boolean = false
  @JvmField var next: Segment? = null
  @JvmField var prev: Segment? = null
  
  //ignore
}
</code></pre>
<p>包含了三种内容：</p>
<ul>
<li>实际数据 data</li>
<li>标记 pos+limit和读写有关，shared、owner和数据保护有关</li>
<li>上下游节点，链表的本质</li>
</ul>
<p>而 <code>SegmentPool</code> 是很典型的池化设计，毕竟 <code>ByteArray</code> 需要分配内存空间，使用池化可以很好地减少无效内存管理（频繁分配回收）</p>
<p>不难得出总结：</p>
<ul>
<li><code>Segment</code> 是实现了方便使用的API的ByteArray链表</li>
<li><code>Buffer</code> 是使用 <code>Segment</code> 包装而成的数据缓冲区，实现了方便使用的API，实现了和JAVA IO间的互操作</li>
<li><code>Buffer</code> 既可以作为上游 <code>Source</code> 角色，也可以作为下游 <code>Sink</code> 角色</li>
<li>在设计 <code>Buffer</code> 和 <code>Segment</code> 时，结合了日常使用场景进行了特定优化，例如通过转移、分享数据而非拷贝实质数据</li>
</ul>
<h2 id="bytestring-概述"><a class="header" href="#bytestring-概述">ByteString 概述</a></h2>
<p>在Okio中，ByteString也是一个重要的、方便使用的设计，但比Buffer简单的多。</p>
<p><em>它的命名也非常有趣，计算机领域中，String一词对应字符串，它本身拥有一个更宽泛的含义就是“一串”。 在不足够严谨的讨论场景下，我们可以认为 <code>String</code>
就是指定了编码的CharArray或ByteArray。而CharSequence又太过于抽象，设计者似乎仅希望将一些特定的具体情况进行封装，因此制造了ByteString。</em></p>
<pre><code>open class ByteString
internal actual constructor(
  internal actual val data: ByteArray,
) : Serializable, Comparable&lt;ByteString&gt; {}
</code></pre>
<p>_
作者按：我在开发一些蓝牙应用时，数据传输层和应用协议层有一些特定的数据操作，例如：信息摘要计算、CRC校验、AES加解密、Hex-String转换用作日志输出。在很多年前才接触Android时，使用HttpUrlConnection，对body也有类似的处理。属实枯燥繁琐_</p>
<p>它是一个内容不可变byte序列，这一点可以通过观测API发现，它并不提供修改内容的相关API。但它封装了一系列好用的API，例如：</p>
<ul>
<li>utf8(): String</li>
<li>string(charset: Charset)</li>
<li>fun base64()</li>
<li>fun md5() = digest("MD5")</li>
<li>fun sha1() = digest("SHA-1")</li>
<li>digest(algorithm: String): ByteString 等等</li>
</ul>
<p>相比于定义与使用Utility类，代码可读性更强。</p>
<p><strong>值得注意</strong> ：虽然它在设计意图上是内容不可变的，但注意它的构造函数，它只保留了引用，并没有对内容进行拷贝，这意味实质内容可以在外部篡改</p>
<p>它实现了 <code>Comparable</code> 接口，值得一提的是，它按照无符号数大小进行 “字典序” 比对。</p>
<ul>
<li>"字典序" 比对，即按照从头到尾的顺序，依次比对，脑补一下英文词典。</li>
<li>Byte使用8bit表示，0xFF（补码）如果视作符号数为255，排在0x00后面，如果视作有符号数，则为-1，排在0x00前面</li>
</ul>
<h2 id="超时机制"><a class="header" href="#超时机制">超时机制</a></h2>
<p>简单思考一下，你的BOSS是如何按照Deadline来检查你的工作的。</p>
<p>如果你没有提前告知已完成，</p>
<ul>
<li>最理想的BOSS会在到期时查你</li>
<li>宽松一点的BOSS会在Deadline当天或提前一天过问一下，到点再查一下</li>
<li>焦虑一点的BOSS会频繁一点</li>
<li>有毛病的BOSS会一天到晚盯着你</li>
</ul>
<p>显然，需要先约定一个超时的信息：</p>
<pre><code>class Timeout {
  private var hasDeadline = false
  private var deadlineNanoTime = 0L
  private var timeoutNanos = 0L
}
</code></pre>
<p>假定有一项具体工作，当你和BOSS约定好时间，他会记录这一信息，得到一个<code>timeout</code>，<em>当然，并非所有事情都会有Deadline</em></p>
<p>此时，你去执行这一事项：</p>
<pre><code>timeout.withTimeout {
	//具体的事项
}
</code></pre>
<p>而你的BOSS，则会根据是否有真实Deadline，决定是否记录到他的检查单上。</p>
<p>很显然，你的BOSS需要跟踪的事项进度比较多，他按照到期时间先后顺序对检查单内容进行整理，这样他就省事了，他只需要盯着第一个到期时间进行追踪即可。</p>
<p>当发现超时时，他会将这一项移除，调整他的检查单，并通报此项已经超时...</p>
<p>不难想象，如果他的检查单上没有追踪项，他不会给自己来一个遥遥无期的休假，否则有后续事项没被跟踪，他就惨了，但一直盯着有没有新事项产生会很累，所以他每两小时就会看一下，是否有事项需要写入检查单。即便写入检查单时此事已经延期，但一个2小时内就会到Deadline的事情，稍微拖延了一会去追查，也没啥毛病。</p>
<p>将BOSS的这部分工作写成代码如下：</p>
<details>
<pre><code class="language-kotlin">internal fun awaitTimeout(): AsyncTimeout? {
    // Get the next eligible node.
    val node = head!!.next

    // The queue is empty. Wait until either something is enqueued or the idle timeout elapses.
    if (node == null) {
        val startNanos = System.nanoTime()
        condition.await(IDLE_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS)
        return if (head!!.next == null &amp;&amp; System.nanoTime() - startNanos &gt;= IDLE_TIMEOUT_NANOS) {
            head // The idle timeout elapsed.
        } else {
            null // The situation has changed.
        }
    }

    var waitNanos = node.remainingNanos(System.nanoTime())

    // The head of the queue hasn't timed out yet. Await that.
    if (waitNanos &gt; 0) {
        condition.await(waitNanos, TimeUnit.NANOSECONDS)
        return null
    }

    // The head of the queue has timed out. Remove it.
    head!!.next = node.next
    node.next = null
    return node
}

private class Watchdog internal constructor() : Thread("Okio Watchdog") {
    init {
        isDaemon = true
    }

    override fun run() {
        while (true) {
            try {
                var timedOut: AsyncTimeout? = null
                AsyncTimeout.lock.withLock {
                    timedOut = awaitTimeout()

                    // The queue is completely empty. Let this thread exit and let another watchdog thread
                    // get created on the next call to scheduleTimeout().
                    if (timedOut === head) {
                        head = null
                        return
                    }
                }

                // Close the timed out node, if one was found.
                timedOut?.timedOut()
            } catch (ignored: InterruptedException) {
            }
        }
    }
}
</code></pre>
</details>
<p>再回到你这边，如果你的工作完成了，你去会找BOSS汇报工作，让他处理检查单：</p>
<pre><code class="language-kotlin">inline fun &lt;T&gt; withTimeout(block: () -&gt; T): T {
    var throwOnTimeout = false
    enter()
    try {
        val result = block()
        throwOnTimeout = true
        return result
    } catch (e: IOException) {
        throw if (!exit()) e else `access$newTimeoutException`(e)
    } finally {
        // 找BOSS汇报工作，让他处理检查单
        val timedOut = exit()
        if (timedOut &amp;&amp; throwOnTimeout) throw `access$newTimeoutException`(null)
    }
}
</code></pre>
<p>此时轮到BOSS来处理，如果这个事项并没有真实Deadline，他并不会额外做什么。否则他会重新维护检查单内容，但如果没有在检查单中发现这一项，则说明该项在之前通报过已经超时。</p>
<pre><code class="language-kotlin">fun exit(): Boolean {
    return cancelScheduledTimeout(this)
}

private fun cancelScheduledTimeout(node: AsyncTimeout): Boolean {
    AsyncTimeout.lock.withLock {
        if (!node.inQueue) return false
        node.inQueue = false

        // Remove the node from the linked list.
        var prev = head
        while (prev != null) {
            if (prev.next === node) {
                prev.next = node.next
                node.next = null
                return false
            }
            prev = prev.next
        }

        // The node wasn't found in the linked list: it must have timed out!
        return true
    }
}
</code></pre>
<p>我们通过一个故事演示了一种异步的超时检测机制，在Okio中，对应了 <code>AsyncTimeout</code> 。当然，实际场景中还有一些更复杂的，例如两个事项合并。</p>
<p>甚至，我们可以直接借用此机制：</p>
<p>演示代码：</p>
<details>
<pre><code class="language-kotlin">class Job&lt;T&gt;(
    val block: () -&gt; T,
    private val onTimeout: ((afterResult: Boolean, result: T?) -&gt; Boolean)? = null
) {
    @Volatile
    private var timeout = false

    @Volatile
    private var timeoutHandled = false

    @Volatile
    private var execFinished = false

    fun exec(): T = block().also { result -&gt;
        execFinished = true
        if (timeout &amp;&amp; !timeoutHandled) {
            onTimeout?.let {
                timeoutHandled = it(true, result)
            }
        }
    }

    fun timeout() {
        if (execFinished) return

        timeout = true
        onTimeout?.let {
            timeoutHandled = it(false, null)
        }
    }
}

class JobsAsyncTimeout&lt;T&gt;(private val job: Job&lt;T&gt;) : AsyncTimeout() {
    override fun timedOut() {
        job.timeout()
    }
    override fun timeout(timeout: Long, unit: TimeUnit): JobsAsyncTimeout&lt;T&gt; {
        super.timeout(timeout, unit)
        return this
    }

    fun delegate(): () -&gt; T {
        return {
            withTimeout {
                job.exec()
            }
        }
    }
}


fun &lt;T&gt; (() -&gt; T).timeoutJob(
    timeout: Long,
    timeUnit: TimeUnit,
    onTimeout: ((afterResult: Boolean, result: T?) -&gt; Boolean)? = null
): () -&gt; T {
    return JobsAsyncTimeout(Job(block = this, onTimeout = onTimeout))
        .timeout(timeout = timeout, unit = timeUnit)
        .delegate()
}
</code></pre>
</details>
<p>以一个效率低下的递归计算斐波那契数列进行演示(如果你的机器性能异常的好，可以适当调大入参)：</p>
<p>Demo 代码 :</p>
<details>
<pre><code class="language-kotlin">class Demo {
    @Test
    fun testTimeOut() {
        val fib30 = {
            fibonacci(30)
        }.timeoutJob(1, TimeUnit.NANOSECONDS) { afterResult, result -&gt;
            if (!afterResult) {
                // 如果是可以打断的操作，执行打断；除非你仍然想要结果,这样使用超时机制是很牵强的
                println("on timeout, callback before result, you should interrupt the job")
                // 返回true则意味着已经消费
                false
            } else {
                //如果 afterResult 为false时，已经返回true，则不会有此轮回调
                //除非你真的需要结果

                println("on timeout, callback after result, $result")
                //返回true则意味着已经消费
                false
            }
        }

        //超时是会抛出InterruptedIOException
        assertThrows(InterruptedIOException::class.java) {
            println("fib100-&gt; ${fib30()}")
        }
    }

    @Throws(Exception::class)
    fun fibonacci(n: Int): Long {
        when {
            n &lt; 0 -&gt; throw Exception("n为非法值！")
            else -&gt; return when (n) {
                0 -&gt; 0
                1 -&gt; 1
                else -&gt; fibonacci(n - 1) + fibonacci(n - 2)
            }
        }
    }
}
</code></pre>
</details>
<h2 id="结语"><a class="header" href="#结语">结语</a></h2>
<p>至此，IO系列告一段落。</p>
<p>按照惯例，再絮叨几句。在去年放缓节奏后，读了一些书、想了一些事、观了一些人。近期于《孟子》中得一句：</p>
<blockquote>
<p>或劳心，或劳力；劳心者治人，劳力者治于人；治于人者食人，治人者食于人：天下之通义</p>
</blockquote>
<p>下个系列还在构思斟酌中，下个月再见。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../IO/post_58.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../Gradle/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../IO/post_58.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../Gradle/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
