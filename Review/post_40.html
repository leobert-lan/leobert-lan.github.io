<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>三思系列：前人用GreenDao留下的坑，全线被扣了绩效 - leobert&#x27;s blog</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">目录</li><li class="chapter-item expanded "><a href="../Android/index.html"><strong aria-hidden="true">1.</strong> Android</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/View/index.html"><strong aria-hidden="true">1.1.</strong> View</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/View/post_1.html"><strong aria-hidden="true">1.1.1.</strong> 好玩系列：优雅的处理ButterKnife和KAE被废弃</a></li><li class="chapter-item expanded "><a href="../Android/View/post_6.html"><strong aria-hidden="true">1.1.2.</strong> 三思系列：View体系认知(一)，内容是如何正确被展现出来的--视觉呈现概览</a></li><li class="chapter-item expanded "><a href="../Android/View/post_7.html"><strong aria-hidden="true">1.1.3.</strong> 三思系列：为什么自定义View</a></li><li class="chapter-item expanded "><a href="../Android/Idea/post_9.html"><strong aria-hidden="true">1.1.4.</strong> 三思系列："声明式UI"和"命令式UI"，你的理解可能是错的</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/Drawable/index.html"><strong aria-hidden="true">1.2.</strong> Drawable</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/Drawable/post_2.html"><strong aria-hidden="true">1.2.1.</strong> 三思系列：重新认识Drawable</a></li><li class="chapter-item expanded "><a href="../Android/Drawable/post_4.html"><strong aria-hidden="true">1.2.2.</strong> 好玩系列：拥有它，XML文件少一半--更方便的处理View背景</a></li><li class="chapter-item expanded "><a href="../Android/Drawable/post_47.html"><strong aria-hidden="true">1.2.3.</strong> 迟来的续集--Drawable+Animator，将优雅进行到底</a></li><li class="chapter-item expanded "><a href="../Android/Drawable/post_49.html"><strong aria-hidden="true">1.2.4.</strong> 好玩系列：让ImageSpan动起来</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/Mechanism/Message/index.html"><strong aria-hidden="true">1.3.</strong> 消息机制</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/Mechanism/Message/post_8.html"><strong aria-hidden="true">1.3.1.</strong> 三思系列：Android的消息机制，一文吃透</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/Idea/post_14/index.html"><strong aria-hidden="true">1.4.</strong> 兼容</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/Idea/post_14.html"><strong aria-hidden="true">1.4.1.</strong> 好玩系列：让项目中的相册支持Heif格式图片</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/Glide/index.html"><strong aria-hidden="true">1.5.</strong> Glide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/Glide/post_15.html"><strong aria-hidden="true">1.5.1.</strong> 三思系列：Glide 4.X全方位认知 -- 模块职责概览</a></li><li class="chapter-item expanded "><a href="../Android/Glide/post_16.html"><strong aria-hidden="true">1.5.2.</strong> 三思系列：Glide 4.X加载过程一文掌握 | Glide（二）</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/KSP/index.html"><strong aria-hidden="true">1.6.</strong> KSP</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/KSP/post_24.html"><strong aria-hidden="true">1.6.1.</strong> 好玩系列 | 拥抱Kotlin Symbol Processing(KSP),项目实战</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/Base/index.html"><strong aria-hidden="true">1.7.</strong> 基础</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/Base/post_35.html"><strong aria-hidden="true">1.7.1.</strong> 孔乙己：你可知道页面和弹窗“通信“的方式有四种？</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/SysApp/index.html"><strong aria-hidden="true">1.8.</strong> 系统APP</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/SysApp/post_52.html"><strong aria-hidden="true">1.8.1.</strong> 使用日历丰富产品的用户体验</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/DI/index.html"><strong aria-hidden="true">1.9.</strong> Part4-依赖注入部分</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/DI/post_53.html"><strong aria-hidden="true">1.9.1.</strong> Hilt进阶--一文吃透Hilt自定义与跨壁垒</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../Compose/index.html"><strong aria-hidden="true">2.</strong> Jetpack Compose</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Compose/post_21.html"><strong aria-hidden="true">2.1.</strong> Jetpack Compose | 一文理解神奇的Modifier</a></li><li class="chapter-item expanded "><a href="../Compose/post_26.html"><strong aria-hidden="true">2.2.</strong> Jetpack Compose | 控件篇（一） -- Text、TextField、Button</a></li><li class="chapter-item expanded "><a href="../Compose/post_27.html"><strong aria-hidden="true">2.3.</strong> Jetpack Compose | 控件篇（二） -- Icon，Image</a></li><li class="chapter-item expanded "><a href="../Compose/post_28.html"><strong aria-hidden="true">2.4.</strong> Jetpack Compose | 控件篇（三） -- Switch、CheckBox、RadioButton</a></li><li class="chapter-item expanded "><a href="../Compose/post_29.html"><strong aria-hidden="true">2.5.</strong> Jetpack Compose | 控件篇（四）-- Box、Row、Column</a></li><li class="chapter-item expanded "><a href="../Compose/post_30.html"><strong aria-hidden="true">2.6.</strong> Jetpack Compose | 控件篇（五）-- Spacer、LazyRow、LazyColumn & 让Column可滑动</a></li></ol></li><li class="chapter-item expanded "><a href="../MultiThreading/index.html"><strong aria-hidden="true">3.</strong> Java多线程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../MultiThreading/post_33.html"><strong aria-hidden="true">3.1.</strong> 总纲</a></li><li class="chapter-item expanded "><a href="../MultiThreading/post_37.html"><strong aria-hidden="true">3.2.</strong> Java基础--图解JVM内存模型和JVM线程模型</a></li><li class="chapter-item expanded "><a href="../MultiThreading/post_38.html"><strong aria-hidden="true">3.3.</strong> Java多线程系列--掌控面试，一文吃透Synchronized锁</a></li><li class="chapter-item expanded "><a href="../MultiThreading/post_39.html"><strong aria-hidden="true">3.4.</strong> Java多线程基础--线程生命周期与线程协作详解</a></li><li class="chapter-item expanded "><a href="../MultiThreading/post_42.html"><strong aria-hidden="true">3.5.</strong> Java多线程基础--线程的创建与线程池管理</a></li><li class="chapter-item expanded "><a href="../MultiThreading/post_46.html"><strong aria-hidden="true">3.6.</strong> Java多线程系列--掌握Future，轻松获取异步任务结果</a></li><li class="chapter-item expanded "><a href="../MultiThreading/post_50.html"><strong aria-hidden="true">3.7.</strong> Java多线程系列--Fork&Join框架，分治的艺术</a></li><li class="chapter-item expanded "><a href="../MultiThreading/post_54.html"><strong aria-hidden="true">3.8.</strong> Java多线程系列--掌握CompletableFuture，驾驭异步编程</a></li></ol></li><li class="chapter-item expanded "><a href="../IO/index.html"><strong aria-hidden="true">4.</strong> Java IO系列</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../IO/post_55.html"><strong aria-hidden="true">4.1.</strong> Java IO 系列总纲</a></li><li class="chapter-item expanded "><a href="../IO/post_56.html"><strong aria-hidden="true">4.2.</strong> Java IO系列 | 经典 IO</a></li><li class="chapter-item expanded "><a href="../IO/post_57.html"><strong aria-hidden="true">4.3.</strong> Java IO 系列 | NIO-1.0一文速览</a></li><li class="chapter-item expanded "><a href="../IO/post_58.html"><strong aria-hidden="true">4.4.</strong> Java IO系列 | NIO-1.0拾遗、NIO-2.0 & 零拷贝必吹的牛皮</a></li><li class="chapter-item expanded "><a href="../IO/post_59.html"><strong aria-hidden="true">4.5.</strong> IO系列 | 一文掌握OKHTTP中的OKIO为什么这么OK</a></li></ol></li><li class="chapter-item expanded "><a href="../Gradle/index.html"><strong aria-hidden="true">5.</strong> Gradle</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Gradle/Modularization/post_18.html"><strong aria-hidden="true">5.1.</strong> 组件化：三思系列：组件化场景下module依赖优雅实践方案</a></li><li class="chapter-item expanded "><a href="../Gradle/Publish/post_17.html"><strong aria-hidden="true">5.2.</strong> MavenCentral发布：迁移到MavenCentral--再不行动起来，你的托管的library就没了</a></li><li class="chapter-item expanded "><a href="../Gradle/post_22.html"><strong aria-hidden="true">5.3.</strong> Gradle | 依赖管理最佳实践</a></li></ol></li><li class="chapter-item expanded "><a href="../Groovy/index.html"><strong aria-hidden="true">6.</strong> Groovy</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Groovy/why_write_groovy.html"><strong aria-hidden="true">6.1.</strong> 为什么撰写这个系列</a></li><li class="chapter-item expanded "><a href="../Groovy/post_23.html"><strong aria-hidden="true">6.2.</strong> Groovy：MOP一文打尽</a></li></ol></li><li class="chapter-item expanded "><a href="../Review/index.html"><strong aria-hidden="true">7.</strong> Review</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Review/post_10.html"><strong aria-hidden="true">7.1.</strong> 造完了这个轮子--Mocker，却让我感到很羞愧|项目复盘</a></li><li class="chapter-item expanded "><a href="../Review/post_40.html" class="active"><strong aria-hidden="true">7.2.</strong> 三思系列：前人用GreenDao留下的坑，全线被扣了绩效</a></li><li class="chapter-item expanded "><a href="../Review/post_44.html"><strong aria-hidden="true">7.3.</strong> 谈一谈在两个商业项目中使用MVI架构后的感悟</a></li><li class="chapter-item expanded "><a href="../Review/post_45.html"><strong aria-hidden="true">7.4.</strong> Review | 这三个坑你遇到了吗？</a></li></ol></li><li class="chapter-item expanded "><a href="../repo/index.html"><strong aria-hidden="true">8.</strong> 个人项目</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../repo/DaVinCi.html"><strong aria-hidden="true">8.1.</strong> DaVinCi,取代XML编写Shape或ColorStateList的方案</a></li><li class="chapter-item expanded "><a href="../Android/Idea/post_32.html"><strong aria-hidden="true">8.2.</strong> 好玩系列：白嫖一个优雅的类图生成工具</a></li><li class="chapter-item expanded "><a href="../Speculative/post_43.html"><strong aria-hidden="true">8.3.</strong> 初体验：动手搭建"小清新式"局域网文档系统</a></li><li class="chapter-item expanded "><a href="../repo/post_48.html"><strong aria-hidden="true">8.4.</strong> 研究良久，终于发现了他代码写的快且bug少的原因</a></li><li class="chapter-item expanded "><a href="../Speculative/post_61.html"><strong aria-hidden="true">8.5.</strong> 好玩系列 | 如果后端让你用SSE接收多次返回，那我们改造Retrofit吧</a></li></ol></li><li class="chapter-item expanded "><a href="../Review/DataStructure/index.html"><strong aria-hidden="true">9.</strong> 数据结构</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Review/DataStructure/post_11.html"><strong aria-hidden="true">9.1.</strong> 温故：线性表</a></li><li class="chapter-item expanded "><a href="../Review/DataStructure/post_12.html"><strong aria-hidden="true">9.2.</strong> 温故：栈</a></li><li class="chapter-item expanded "><a href="../Review/DataStructure/post_13.html"><strong aria-hidden="true">9.3.</strong> 温故：队列</a></li></ol></li><li class="chapter-item expanded "><a href="../Review/README2.html"><strong aria-hidden="true">10.</strong> 年终总结&计划</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Review/post_36.html"><strong aria-hidden="true">10.1.</strong> 2021年终总结</a></li><li class="chapter-item expanded "><a href="../Review/post_51.html"><strong aria-hidden="true">10.2.</strong> 关于画一个句号--基于2022年终总结的反思与分享</a></li><li class="chapter-item expanded "><a href="../Review/post_60.html"><strong aria-hidden="true">10.3.</strong> 突如其来的秋季反思</a></li><li class="chapter-item expanded "><a href="../Review/post_63.html"><strong aria-hidden="true">10.4.</strong> 2023年总结 寻找到源于内心深处的无穷力量</a></li><li class="chapter-item expanded "><a href="../Review/post_64.html"><strong aria-hidden="true">10.5.</strong> 2024年中思考，推倒樊笼重新出发</a></li></ol></li><li class="chapter-item expanded "><a href="../Note/index.html"><strong aria-hidden="true">11.</strong> 读书笔记</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Note/post_41.html"><strong aria-hidden="true">11.1.</strong> 读书笔记：《简约至上--交互式设计四策略》</a></li><li class="chapter-item expanded "><a href="../Talk/talk_4_2024-08.html"><strong aria-hidden="true">11.2.</strong> 读书笔记 - 《团队管理》精华摘要</a></li></ol></li><li class="chapter-item expanded "><a href="../Talk/index.html"><strong aria-hidden="true">12.</strong> 杂谈</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Talk/talk_1.html"><strong aria-hidden="true">12.1.</strong> 杂谈1-2022-11</a></li><li class="chapter-item expanded "><a href="../Talk/talk_2_2023-03.html"><strong aria-hidden="true">12.2.</strong> 杂篇（二）-- 认识并战胜焦虑</a></li><li class="chapter-item expanded "><a href="../Talk/talk_3_2024-08.html"><strong aria-hidden="true">12.3.</strong> 杂谈（三）-- 向钱看，你需要想明白企业在为什么而付钱</a></li></ol></li><li class="chapter-item expanded "><a href="../Thought/index.html"><strong aria-hidden="true">13.</strong> 半成熟的思考</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Thought/post_62.html"><strong aria-hidden="true">13.1.</strong> 好玩系列 | 当SPI 和 设计模式、依赖注入发生碰撞，可以擦出怎样的火花</a></li></ol></li><li class="chapter-item expanded "><a href="../info/index.html"><strong aria-hidden="true">14.</strong> 系列说明</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../info/about_view_series.html"><strong aria-hidden="true">14.1.</strong> 关于View系列</a></li><li class="chapter-item expanded "><a href="../info/about_sansi_series.html"><strong aria-hidden="true">14.2.</strong> 关于三思系列</a></li><li class="chapter-item expanded "><a href="../info/about_haowan_series.html"><strong aria-hidden="true">14.3.</strong> 关于好玩系列</a></li><li class="chapter-item expanded "><a href="../info/about_wengu_series.html"><strong aria-hidden="true">14.4.</strong> 关于温故系列</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">leobert&#x27;s blog</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="三思系列前人用greendao留下的坑全线被扣了绩效"><a class="header" href="#三思系列前人用greendao留下的坑全线被扣了绩效">三思系列：前人用GreenDao留下的坑，全线被扣了绩效</a></h1>
<h2 id="前言"><a class="header" href="#前言">前言</a></h2>
<p>本篇文章，您将从一个GreenDao使用的事故开始，围观事故现场，并获得问题分析结论。跟随作者再次巩固GreenDao的整体设计，并实践 <code>APT</code> 、 <code>Gradle Plugin</code> 两种方案，通过不断地总结、对比和深度反思扫荡盲区，将知识融会贯通！</p>
<blockquote>
<p>创作三思系列是我学习、总结、反思的一种方式，着重于:<strong>问题分析</strong>、<strong>技术积累</strong>、<strong>视野拓展</strong>。<a href="https://leobert-lan.github.io/info/about_sansi_series.html">了解三思系列</a></p>
</blockquote>
<p>去年年末，出了一个可大可小的事故，<strong>导致开发、测试一条线都被扣了绩效</strong>。</p>
<p>背景是这样的：</p>
<ul>
<li>项目的部分业务数据存储于 <strong>本地数据库</strong></li>
<li>数据库业务使用了ORM框架--GreenDao</li>
<li>采用了类似 <a href="https://github.com/yuweiguocn/GreenDaoUpgradeHelper">GreenDaoUpgradeHelper</a> 的方案处理 "数据库版本升级"</li>
</ul>
<p>然而，最终事故发生在调用 <strong>Migration</strong> 时，<strong>遗漏了Dao</strong>，如果读者对这类 <strong>粗犷的</strong> 升级方案有所了解，一定猜到了最终结果：<strong>表数据丢失！！！</strong></p>
<p>很显然，导致最终结果的原因是多元的：</p>
<ul>
<li>前人采用的数据库升级方案就很危险</li>
<li>特殊渠道包的更新频次低、时间跨度长，测试覆盖粒度不够细（仅回归主功能、增量实现、从主包同步的bug修改和优化）导致一直未发现问题</li>
<li>轻易地相信了一个老项目，没有对基建部分进行详细的review</li>
<li>...</li>
</ul>
<p><em>作者按：可大可小的原因--性质比较恶劣的研发测试流程问题；值得庆幸的是这部分数据不会影响使用正确性，且发生在特殊用途的增量包中，影响范围很小，通过日志分析可回滚弥补。</em></p>
<p>显然，诸位亲爱的读者点进来，除了围观事故现场，还想看点别的！那自然不能辜负读者厚爱，本篇会同读者一起做一些有趣的事情。</p>
<h2 id="前人的使用方式概览"><a class="header" href="#前人的使用方式概览">前人的使用方式概览</a></h2>
<p><em>在真正开始之前，我们还需要耐心地看一下前人的使用方式</em>，<strong>此乃前车之鉴，如果你的项目中也有类似的用法，可能需要尽早地、仔细地Review一遍</strong>。</p>
<ul>
<li>正常的导包、应用plugin -- 没问题</li>
<li>gradle配置 <code>GreendaoOptions</code> -- 没问题， <em>targetGenDir配置到了常规sourceSet中，增加一些代码提交和merge conflict 问题不大</em></li>
<li>用注解标识Entity -- 参数都是默认的，问题不大，<strong>没有隐藏的大坑</strong></li>
<li>自实现了 <code>DaoMaster.OpenHelper</code> -- 没问题</li>
<li>自定义了数据库升级的helper，类似前文提到的GreenDaoUpgradeHelper -- 坑比较大：
<ul>
<li>性能问题</li>
<li>临时表名产生的制约</li>
<li><strong>人工维护传入的dao -- 直接导致的事故</strong></li>
</ul>
</li>
</ul>
<p>可能大多数项目的使用方式都是类似的，那么有三大问题丞待解决：</p>
<ul>
<li>需要人工维护升级的dao参数 -- 人的记性差，容易遗漏。不符合GreenDaoUpgradeHelper 等工具的设计初衷，<em>即不需要人工维护升级细节</em></li>
<li>restore时的效率问题</li>
<li>临时表名无形中产生的制约</li>
</ul>
<p><strong>限于篇幅，本篇只解决第一个问题，点出第二个问题，分析第三个问题。</strong></p>
<h3 id="greendao-如何进入升级降级"><a class="header" href="#greendao-如何进入升级降级">GreenDao 如何进入升级（降级）</a></h3>
<p>我们知道： Sqlite 存在有 <code>PRAGMA</code> 命令，可以在 SQLite 环境内控制各种环境变量和状态标志。而数据库的版本信息存储为 环境变量 <code>user_version</code></p>
<p>通过以下sql进行查询和设置：</p>
<pre><code class="language-roomsql">#查询
PRAGMA user_version;

#设置
PRAGMA user_version = {version}
</code></pre>
<p>而GreenDao配置的schemaVersion：</p>
<pre><code class="language-groovy">greendao {
    schemaVersion 1000
}
</code></pre>
<p>将通过gradle-task：<code>greendao</code> 写入生成的 <code>DaoMaster</code> 中,并作为 <code>SQLiteOpenHelper</code> 的 <code>version</code> 参数，与数据库的 <code>user_version</code>
比对后，判断是否需要进行创建、升级、降级。</p>
<pre><code class="language-java">public class DaoMaster extends AbstractDaoMaster {
    public static final int SCHEMA_VERSION = 1000;
    //...


    public static abstract class OpenHelper extends DatabaseOpenHelper {
        public OpenHelper(Context context, String name) {
            super(context, name, SCHEMA_VERSION);
        }

        public OpenHelper(Context context, String name, CursorFactory factory) {
            super(context, name, factory, SCHEMA_VERSION);
        }
        //...
    }
}
</code></pre>
<p>节选 <code>SQLiteOpenHelper</code> 一段代码如下：</p>
<pre><code>db.beginTransaction();
try {
    if (version == 0) {
        onCreate(db);
    } else {
        if (version &gt; mNewVersion) {
            onDowngrade(db, version, mNewVersion);
        } else {
            onUpgrade(db, version, mNewVersion);
        }
    }
    db.setVersion(mNewVersion);
    db.setTransactionSuccessful();
} finally {
    db.endTransaction();
}
</code></pre>
<p>您一定注意到：此处已经开启了数据库事务，如果将升级任务置于额外的线程执行，也存在风险！<strong>做好设计，减少甚至杜绝表结构变更</strong> 是最佳实践！</p>
<h3 id="升级helper概览"><a class="header" href="#升级helper概览">升级Helper概览</a></h3>
<p>几乎所有可以搜索到的工具，均以以下流程作为实现方案：</p>
<p><img src="./post_40/img_1.png" alt="" /></p>
<p>表名关系：诸如 <code>临时表名 = {原表名}+"_TEMP"</code></p>
<p><em>作者按：为了方便，下文以 <code>tempTableName</code> 指代临时表名，<code>oTableName</code> 指代Entity对应的表名</em></p>
<p><strong>1.创建临时表</strong></p>
<ul>
<li>删除临时表 <code>DROP TABLE IF EXISTS {tempTableName}</code> -- 看似没有毛病，但如果存在业务设计的临库临表，就被误删除了</li>
<li>创建临时表 <code>CREATE TEMPORARY TABLE {tempTableName} AS SELECT * FROM {oTableName}</code></li>
</ul>
<p>比较奇怪的是：为何不:</p>
<ol>
<li>先判断临时表名是否存在，如存在则抛错，</li>
<li>然后再判断新增表是否会和临时表重名，如果存在则抛错，</li>
<li>继而在同一数据库内使用 <code>ALTER TABLE {oTableName} RENAME TO {tempTableName}</code> 修改表名</li>
</ol>
<blockquote>
<p><em>作者按：此处仅为一个设想，是Sqlite支持的SQL，但并未在Android项目中实践验证以及推理可能出现的问题。</em></p>
<p><em>可以预见的是：即便增加校验，也无法避免用户绕开GreenDao进行数据库操作所带来的隐性冲突可能。</em></p>
<p><em>GreenDaoUpgradeHelper在新的临时数据库中处理临时表，作者公司项目中的代码在原数据库中处理</em></p>
</blockquote>
<p><strong>2.调用DaoMaster删除表</strong></p>
<p>逻辑借用了GreenDao生成的代码，细节忽略</p>
<p><strong>3.调用DaoMaster生成表</strong></p>
<p>逻辑借用了GreenDao生成的代码，细节忽略</p>
<p><strong>4.restore数据</strong>
根据 <code>tempTableName</code> 和 <code>oTableName</code> 两张表的结构，构建SQL，迁移数据，细节忽略</p>
<h3 id="小结"><a class="header" href="#小结">小结</a></h3>
<p>至此，我们已经完成了问题2、3的基本分析：</p>
<blockquote>
<ol>
<li>人工维护需要升级的dao</li>
<li>restore时的效率问题 -- <strong>不需要升级的表也进行了I/O，不需要变更的字段也进行了I/O</strong></li>
<li>临时表名无形中产生的制约 -- <strong>同库情况下产生制约，创建无冲突的临库则无影响，但会增加I/O</strong></li>
</ol>
</blockquote>
<p>显而易见：问题2、3可以通过 "健壮的、可靠的数据库设计以降低升级数据库的需求"、"更加细致、高效的升级SQL" 加以解决。</p>
<p><em>作者按：虽然前文为它们花费了较长的篇幅，但它们不是这篇文章的主角，以后时间充裕的话，我会考虑造一个更好用、高效的轮子</em></p>
<p>而问题1的原因更加明显：GreenDao 并没有设计相关功能 <strong>用以提供需要升级的DAO信息</strong> 。而从数据库升级的算法流程分析，<strong>需要的DAO信息为全部的DAO类集合即可</strong></p>
<blockquote>
<p>经过前文大篇幅的分析，我们已经完成了第一次扣题：思危 -- 发现、分析危险。</p>
<p>如果有读者已经很不幸地处于危险之中，则需要开始思退。</p>
</blockquote>
<h2 id="两种可行的额外技术手段"><a class="header" href="#两种可行的额外技术手段">两种可行的额外技术手段</a></h2>
<p>此时让我们退一步，冷静地思考下：为什么先前的开发人员选择了 <strong>人工维护DAO类的Collection</strong> 呢？</p>
<p>诚然，GreenDao 没有帮助开发者维护 <strong>需要升级的表信息</strong> ，这种小事也没有必要提issue；</p>
<p>进一步思考：GreenDao将升级都交由开发者自行维护，Entity也由开发者自行创建，更没有理由提供这一信息；</p>
<p>更进一步思考：GreenDao还存在着 <strong>高级用法</strong> ，此时表可以交由开发者创建、维护。当自由度提升，没有 <strong>可靠的机制</strong> 帮助GreenDao判断开发者需要哪些信息；</p>
<p><strong>终极思考：是否GreenDao提供了，但开发者没注意到？</strong></p>
<p>但不用担心，我们自己动手，依旧可以丰衣足食，<em>虽然方案的出发点本身存在不合理之处</em>。</p>
<h3 id="方案1注解处理技术"><a class="header" href="#方案1注解处理技术">方案1：注解处理技术</a></h3>
<p>GreenDao使用 <code>@Entity</code> 对实体类进行注解，例如：</p>
<pre><code class="language-java">
@Entity(indexes = {
        @Index(value = "text, date DESC", unique = true)
})
public class Note {
    @Id
    private Long id;

    @NotNull
    private String text;
    private String comment;
    private java.util.Date date;

    @Convert(converter = NoteTypeConverter.class, columnType = String.class)
    private NoteType type;
}
</code></pre>
<p>依据 <code>@Entity</code> 注解，通过APT机制，我们可以很轻易的收集Entity对应的 <code>AbstractDao</code> 类信息</p>
<p><em>作者按：APT stands for Annotation Processing Tool. Sun shipped an API for APT in JDK 1.5, which can be viewed
at <a href="https://docs.oracle.com/javase/1.5.0/docs/guide/apt/mirror/index.html">一个你不愿意打开，打开了也不乐意看的网站😂</a></em></p>
<h3 id="方案2greendao插件"><a class="header" href="#方案2greendao插件">方案2：GreenDao插件</a></h3>
<p>众所周知，GreenDao通过Gradle Plugin完成了：</p>
<ul>
<li>Entity 发现</li>
<li>Entity 中表字段关系、索引、约束分析，源码级代码插桩</li>
<li>Dao 生成</li>
<li>DaoMaster生成</li>
</ul>
<p>如果我们可以 "入侵" 这一系列的流程，显然也可以达成目标，毕竟，生成的DaoMaster类头注释了：<strong>knows all DAOs.</strong></p>
<pre><code class="language-java">/**
 * Master of DAO (schema version 1000): knows all DAOs.
 */
public class DaoMaster extends AbstractDaoMaster {
    //...
}
</code></pre>
<h2 id="小时牛刀--注解处理"><a class="header" href="#小时牛刀--注解处理">小时牛刀--注解处理</a></h2>
<p>先简单回顾一下Entity注解的源码：</p>
<pre><code class="language-java">
/**
 * Annotation for entities
 * greenDAO only persist objects of classes which are marked with this annotation
 */
@Retention(RetentionPolicy.SOURCE)
@Target(ElementType.TYPE)
public @interface Entity {

    /**
     * Specifies the name on the DB side (e.g. table name) this entity maps to. By default, the name is based on the entities class name.
     */
    String nameInDb() default "";

    /**
     * Indexes for the entity.
     * &lt;p/&gt;
     * Note: To create a single-column index consider using {@link Index} on the property itself
     */
    Index[] indexes() default {};

    /**
     * Advanced flag to disable table creation in the database (when set to false). This can be used to create partial
     * entities, which may use only a sub set of properties. Be aware however that greenDAO does not sync multiple
     * entities, e.g. in caches.
     */
    boolean createInDb() default true;

    /**
     * Specifies schema name for the entity: greenDAO can generate independent sets of classes for each schema.
     * Entities which belong to different schemas should &lt;strong&gt;not&lt;/strong&gt; have relations.
     */
    String schema() default "default";

    /**
     * Whether update/delete/refresh methods should be generated.
     * If entity has defined {@link ToMany} or {@link ToOne} relations, then it is active independently from this value
     */
    boolean active() default false;

    /**
     * Whether an all properties constructor should be generated. A no-args constructor is always required.
     */
    boolean generateConstructors() default true;

    /**
     * Whether getters and setters for properties should be generated if missing.
     */
    boolean generateGettersSetters() default true;

    /**
     * Define a protobuf class of this entity to create an additional, special DAO for.
     */
    Class protobuf() default void.class;

}
</code></pre>
<p>作用在 <code>TYPE</code> 上，保存至源码级别，显然没有限制。</p>
<p>剩下来的工作非常简单：</p>
<ul>
<li>实现 <code>AbstractProcessor</code> 并完成SPI注册，进入到AnnotationProcessor流程</li>
<li>通过获取 <code>Entity</code> 注解类对应的 <code>TypeElement</code> ，判断项目是否正确配置</li>
<li>获取被注解的类，收集必要的信息</li>
<li>可选项1：甄别是否会出现临时表表名冲突，<em>编译期抛错优于运行期</em></li>
<li>可选项2：排除Kotlin类等干扰项，<em>GreenDao仅支持Java</em></li>
<li>生成代码</li>
</ul>
<p><em>具体代码可参考 <a href="https://github.com/leobert-lan/GreenDaoCollector">GreenDaoCollector</a> 中的 greendao-collector 部分</em></p>
<p><em>作者按：相信诸位读者对APT都有一定程度的掌握，如果掌握程度还不够熟练，在有时间条件的基础下，可以结合本案例展开一次练习</em></p>
<h3 id="额外的风险"><a class="header" href="#额外的风险">额外的风险</a></h3>
<p><em>看至此处，您一定已经对 <code>可选项2：排除Kotlin类等干扰项，GreenDao仅支持Java</code> 这句话进行了思考，并对我将 <code>Entity</code> 注解的源码全文粘贴于上这一 <code>水字数</code>
的行为表示了鄙夷。</em></p>
<p>但是请注意：</p>
<ul>
<li>GreenDaoCollector 没有考虑注解中 <code> boolean createInDb() default true;</code> 等方法</li>
<li>GreenDao存在一些限制，例如不支持Kotlin，GreenDaoCollector 采用了一个取巧的方案来甄别排除不支持的类</li>
<li>越精密的机器越容易出现故障，对于复杂的机制也是如此</li>
</ul>
<p><em>作者按：这一取巧的方案为：使用GreenDao时一般会为Entity生成相应的构造函数和Getter、Setter，追加的构造函数代码会被 <code>@Generated</code> 注解，基于此排除不支持的类，但请注意这一行为可以被关闭而造成误判。</em></p>
<p>很显然，该方案将承受巨大的风险，<strong>它仿刻了GreenDao的结果，但采用了不同的机制</strong> ，出现问题的机率会大增！</p>
<h2 id="渐入佳境--插件魔改"><a class="header" href="#渐入佳境--插件魔改">渐入佳境--插件魔改</a></h2>
<blockquote>
<p>莫非命也，顺受其正，是故知命者不立乎岩墙之下。尽其道而死者，正命也；桎梏死者，非正命也。</p>
<p>防祸于先而不致于后伤情。知而慎行，君子不立于危墙之下，焉可等闲视之</p>
<p>-- 《孟子》</p>
</blockquote>
<p>此时我们已经充分意识到第一个方案的风险，让我们来思考第二个方案，并做出对比。</p>
<p>您一定知道：GreenDao plugin 提供了两个 Gradle Task：</p>
<ul>
<li>greendaoPrepare</li>
<li>greendao</li>
</ul>
<p><em>作者按：GreenDao的插件并未开源，我们选择尊重GreenDao的团队，文中不讨论通过反编译才能得到的信息</em></p>
<h3 id="窥一斑而见全豹--分析其设计"><a class="header" href="#窥一斑而见全豹--分析其设计">窥一斑而见全豹--分析其设计</a></h3>
<p>如果您先前了解过Gradle Plugin，那一定知道Gradle的Task均有其输入和输出。</p>
<p>而顾名思义，<code>greendaoPrepare</code> 一定是一个准备工作，将它的输出做为 <code>greendao</code> Task的输入，</p>
<p>结合 GreenDaoCollector 项目中的sample可以获知，其输出为：</p>
<pre><code>// 相对路径：build/cache/greendao-candidates.list

1649475279008
{略去}/GreenDaoCollector/app/src/main/java/osp/leobert/android/gdc/entity/JavaDemoEntity.java
{略去}/GreenDaoCollector/app/src/main/java/osp/leobert/android/gdc/entity/JavaDemoEntityTemp.java
</code></pre>
<p>并且您一定注意到了，<code>JavaDemoEntityTemp</code> 已经被全文注释</p>
<p>从结果来看， <code>greendaoPrepare</code> 一定不是 <strong>基于编译或者基于AST</strong> 的方案，它必然是一个从源码文件中 <strong>快速筛选</strong> 可能存在Entity的方案，用以减少 <code>greendao</code> Task
的性能开销，可以很轻易的推断出 <strong>通过字符串匹配</strong> 实现这一功能。</p>
<p>言归正传，您一定知道：gradle借助pom文件实现library依赖管理，通过greendao plugin 的pom文件可知： 插件依赖 <code>greendao-code-modifier</code>。</p>
<p><code>greendao-code-modifier</code> 同样未开源，通过pom文件分析其依赖：</p>
<ul>
<li><a href="https://github.com/greenrobot/greenDAO">greendao-api</a> 开源，greendao中的注解和基础interface</li>
<li><a href="https://github.com/greenrobot/greenDAO">greendao-generator</a> 开源，生成源码部分</li>
<li>greenrobot-jdt，Repackaged version of JDT</li>
<li><a href="https://github.com/greenrobot/essentials">essentials</a> ， 开源，用于计算Hash</li>
</ul>
<p><em>作者按：相关的pom文件，可以于MavenCentral中检索，或者查看gradle/maven
的本地cache，或者在 <a href="https://github.com/leobert-lan/GreenDaoCollector">GreenDaoCollector 的files目录中</a> 查阅。考虑到阅读体验，重要部分摘录附于文末</em></p>
<p>至此，我们得出结论：</p>
<blockquote>
<p>通过 greendaoPrepare 任务，基于源码内容做字符串检索，快速筛选出可能是Entity的源码，信息输出到文件：greendao-candidates.list</p>
<p>读取greendao-candidates.list 文件内容，基于jdt分析其源码语法树（AST）</p>
<p>基于AST和注解解析Entity、主键、索引、约束、关联等</p>
<p>调用greendao-generator生成源码</p>
</blockquote>
<p><em>作者按：<a href="http://www.eclipse.org/jdt/">JDT</a> 是eclipse为Java提供的一组工具，可以实现APT、支持Java editing等</em></p>
<p>如果您对Intellij中 <strong>与Java、Kotlin源码相关</strong> 的插件开发有一定的了解，对其早期使用的 <code>lombok-ast</code> 和后来使用的 <code>uast</code> 一定不会感到陌生，JDT也是类似的工具。</p>
<p>言归正传，我们只需要改变 <code>greendao-generator</code> 生成代码的实现即可实现需求！</p>
<p>阅读 <code>greendao-generator</code> 源码后，您将获悉：它因为 <strong>业务非常复杂</strong> 而使用<a href="https://freemarker.apache.org/">FreeMaker</a>作为模板引擎生成源码。</p>
<p><strong>难道要使用字节码技术，直接修改加载模板处的源码，增加新的模板</strong>，这么轻易就放大招了吗？</p>
<h3 id="大象无形--利用加载机制做文章"><a class="header" href="#大象无形--利用加载机制做文章">大象无形--利用加载机制做文章</a></h3>
<p>可以发现，greenDao对FreeMaker的初始化代码如下：</p>
<pre><code class="language-java">public class DaoGenerator {
    private Configuration getConfiguration(String probingTemplate) throws IOException {
        Configuration config = new Configuration(Configuration.VERSION_2_3_29);
        config.setClassForTemplateLoading(getClass(), "/");
    }
}
</code></pre>
<p>简单查看源码：</p>
<pre><code>public void setClassForTemplateLoading(Class resourceLoaderClass, String basePackagePath) {
    setTemplateLoader(new ClassTemplateLoader(resourceLoaderClass, basePackagePath));
}

/**
 * A {@link TemplateLoader} that can load templates from the "classpath". Naturally, it can load from jar files, or from
 * anywhere where Java can load classes from. Internally, it uses {@link Class#getResource(String)} or
 * {@link ClassLoader#getResource(String)} to load templates.
 */
public class ClassTemplateLoader extends URLTemplateLoader {
//ignore 看类注释
}
</code></pre>
<p>如果您了解 <code>Class.getResource(String name)</code> 方法，并且对打包有了解，则可以得出结论：</p>
<blockquote>
<p>关键点在于 <code>ClassLoader#getResource</code> 并且存在 <code>Parent-delegate</code> 机制。</p>
<p><strong>只需要在plugin中增加同名模板，在plugin被运行时，该模板将被先加载</strong>。</p>
</blockquote>
<p><em>作者按：此处不再展开，否则十篇文章也写不完。</em></p>
<p><strong>实现目标只需要两步</strong>：</p>
<ul>
<li>新建插件，通过继承或者使用组合，直接使用GreenDao插件逻辑，<em>选用组合,因为无法继承</em></li>
<li>新增同名模板，并增加相关逻辑用以生成代码，<em>最终选用dao-master模板</em></li>
</ul>
<p>重点代码如下： <em>具体代码可参考 <a href="https://github.com/leobert-lan/GreenDaoCollector">GreenDaoCollector</a> 中的 greendao-plugin-wrapper 部分</em></p>
<pre><code class="language-Kotlin">//插件
class GreenDaoPluginWrapper : Plugin&lt;Project&gt; {
    private val wrapper: Plugin&lt;Project&gt; = Greendao3GradlePlugin()
    override fun apply(project: Project) {
        wrapper.apply(project)
    }
}
</code></pre>
<pre><code>//模板
/**
* Master of DAO (schema version ${schema.version?c}): knows all DAOs.
*/
public class ${schema.prefix}DaoMaster extends AbstractDaoMaster{
  public static final int SCHEMA_VERSION=${schema.version?c};
  
  // all dao need to create in db, do not modify, created by leobert
  public static final List&lt;Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;&gt;allDao=new java.util.ArrayList();
  
      static {
  &lt;#list schema.entities as entity&gt;
  &lt;#if!entity.skipCreationInDb&gt;
          allDao.add(${entity.classNameDao}.class);
  &lt;/#if&gt;
  &lt;/#list&gt;
      }
          
      //其他略
}
</code></pre>
<p>读者应该还记得前文的 <code>Entity</code> 注解以及我提到的只言片语，开发者可以自行创建数据库，或者从某处获得数据库直接使用，那么可以通过 <code>boolean createInDb()</code> 等配置 令GreenDao忽略表的创建与删除。</p>
<p>示例模板中通过 <code>&lt;#if!entity.skipCreationInDb&gt;</code> 的判断，排除了无需GreenDao协助建表的DAO。但请务必留心，<strong>数据库表升级永远是业务级别的工作</strong>，框架和工具再好，也需要 <strong>根据实际业务进行调整</strong>
！</p>
<p>应用插件后效果如下：</p>
<pre><code class="language-java">// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.

/**
 * Master of DAO (schema version 1): knows all DAOs.
 */
public class DaoMaster extends AbstractDaoMaster {
    public static final int SCHEMA_VERSION = 1;

    // all dao need to create in db, do not modify, created by leobert
    public static final List&lt;Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;&gt; allDao = new java.util.ArrayList();

    static {
        allDao.add(JavaDemoEntityDao.class);
    }

    /** Creates underlying database table using DAOs. */
    public static void createAllTables(Database db, boolean ifNotExists) {
        JavaDemoEntityDao.createTable(db, ifNotExists);
    }

    /** Drops underlying database table using DAOs. */
    public static void dropAllTables(Database db, boolean ifExists) {
        JavaDemoEntityDao.dropTable(db, ifExists);
    }
    //其他略
}
</code></pre>
<h3 id="与方案1对比"><a class="header" href="#与方案1对比">与方案1对比</a></h3>
<p>显而易见，方案2借用了greendao的插件业务逻辑，除了在模板中增加少许内容，再无其他，无论风险性还是简易性均优于方案1。</p>
<p>模板中基于 <code>&lt;#if!entity.skipCreationInDb&gt;</code> 判断，收集的dao信息与 <code>createAllTables、dropAllTables</code> 中保持一致！当然，亦可以移除判断，收集所有的dao ，**
需结合业务做出选择**。</p>
<p>不具备编译时临时表名冲突检测功能。</p>
<h2 id="前车之鉴--大彻大悟一个错误犯两次"><a class="header" href="#前车之鉴--大彻大悟一个错误犯两次">前车之鉴--大彻大悟,一个错误犯两次</a></h2>
<blockquote>
<p>前车已覆，后未知更，何觉时？</p>
<p>-- 《荀子·成相》</p>
</blockquote>
<p>这句话讲的是成语前车之鉴，让我们回顾一下：</p>
<p><strong>导致问题的原因：</strong></p>
<ul>
<li>前人采用的数据库升级方案就很危险</li>
<li>特殊渠道包的更新频次低、时间跨度长，测试覆盖粒度不够细，导致一直未发现问题</li>
<li><strong>轻易地相信了一个老项目，没有对基建部分进行详细的review</strong></li>
<li>...</li>
</ul>
<p><strong>升级方案丞待解决的问题：</strong></p>
<ul>
<li>需要人工维护升级的dao参数，容易遗漏，存在风险</li>
<li>restore时的效率问题</li>
<li>临时表名无形中产生的制约</li>
</ul>
<p><strong>采用的手段</strong></p>
<p>使用了 <code>APT</code> 和 <code>包装插件替换模板</code> 两种技术手段，为一个 <strong>非最佳的数据库表升级方案</strong> 解决了 <strong>需要人工维护参数</strong> 的问题。</p>
<p>显而易见，最佳的实践方案应当为：</p>
<blockquote>
<p>替换一套健壮、高效的数据库升级方案: 自动收集需要升级的表 -- 排除无效迁移工作提升效率、使用自动化替代人工规避人的错误。同时满足 <strong>可测性</strong></p>
</blockquote>
<p>那么立足当下，<strong>方案1、2就是最佳实践了吗</strong>？请重读下面这两句话：</p>
<ul>
<li><strong>轻易地相信了一个老项目，没有对基建部分进行详细的review</strong></li>
<li>Master of DAO (schema version 1000): knows all DAOs.</li>
</ul>
<p>同一个错误又犯了一次: <strong>我们轻易地否定了一个老项目，没有对它的代码进行详细的review</strong></p>
<pre><code class="language-kotlin">val allDao: List&lt;Class&lt;AbstractDao&lt;*, *&gt;&gt;&gt; = DaoMaster(
    SQLiteDatabase.create(null)
).newSession().allDaos.map {
    it.javaClass
}.toCollection(arrayListOf())
</code></pre>
<p><code>DaoMaster</code> 的模板中，为其构造函数实现了所有Dao的注册，无论是否创建表，它们都会被汇总到
<code>Map&lt;Class&lt;?&gt;, AbstractDao&lt;?, ?&gt;&gt; AbstractDaoSession#entityToDao</code> 中。</p>
<p>但您需要始终牢记，这是在为一个非最佳方案服务，一旦使用了更好的方案，这一方式将不再适用！</p>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<p>本篇，我们从一个事故开始，展开了问题分析，并提出技术方案，实现方案并进行了知识巩固，通过不断地总结、对比和深度反思扫荡盲区！</p>
<p>如果单纯的服务于解决问题，这篇博客将不会存在，区区10行代码即可。但三思系列是学习、总结、反思的一种方式，着重于:<strong>问题分析</strong>、<strong>技术积累</strong>、<strong>视野拓展</strong> ，看完这一篇，我相信你收获的内容 <strong>远远超过</strong> 一个bug的解法。</p>
<h2 id="附"><a class="header" href="#附">附</a></h2>
<h3 id="项目源码"><a class="header" href="#项目源码">项目源码</a></h3>
<p><a href="https://github.com/greenrobot/greenDAO">GreenDao</a></p>
<p>作为数据库版本升级方案示例的： <a href="https://github.com/yuweiguocn/GreenDaoUpgradeHelper">GreenDaoUpgradeHelper</a></p>
<p>Sample代码，APT, Plugin 及部分资料均开源 ：<a href="https://github.com/leobert-lan/GreenDaoCollector">GreenDaoCollector</a></p>
<h3 id="pom文件摘要"><a class="header" href="#pom文件摘要">pom文件摘要</a></h3>
<pre><code class="language-xml">&lt;!--greendao-gradle-plugin-3.3.0.pom--&gt;
&lt;groupId&gt;org.greenrobot&lt;/groupId&gt;
&lt;artifactId&gt;greendao-gradle-plugin&lt;/artifactId&gt;
&lt;version&gt;3.3.0&lt;/version&gt;
&lt;name&gt;greenDAO Gradle Plugin&lt;/name&gt;
&lt;description&gt;Gradle Plugin for greenDAO, the light and fast ORM for Android&lt;/description&gt;
&lt;url&gt;https://github.com/greenrobot/greenDAO&lt;/url&gt;
    &lt;!--  略--&gt;
&lt;dependencies&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.greenrobot&lt;/groupId&gt;
    &lt;artifactId&gt;greendao-code-modifier&lt;/artifactId&gt;
    &lt;version&gt;3.3.0&lt;/version&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
&lt;!--    略--&gt;
&lt;/dependencies&gt;


    &lt;!--greendao-code-modifier-3.3.0.pom--&gt;
&lt;groupId&gt;org.greenrobot&lt;/groupId&gt;
&lt;artifactId&gt;greendao-code-modifier&lt;/artifactId&gt;
&lt;version&gt;3.3.0&lt;/version&gt;
&lt;name&gt;greenDAO Code Modifier&lt;/name&gt;
&lt;description&gt;Code modifier for greenDAO, the light and fast ORM for Android&lt;/description&gt;
&lt;url&gt;https://github.com/greenrobot/greenDAO&lt;/url&gt;
    &lt;!--  略--&gt;
&lt;dependencies&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.greenrobot&lt;/groupId&gt;
    &lt;artifactId&gt;greendao-api&lt;/artifactId&gt;
    &lt;version&gt;3.3.0&lt;/version&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.greenrobot&lt;/groupId&gt;
    &lt;artifactId&gt;greendao-generator&lt;/artifactId&gt;
    &lt;version&gt;3.3.0&lt;/version&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.greenrobot&lt;/groupId&gt;
    &lt;artifactId&gt;greenrobot-jdt&lt;/artifactId&gt;
    &lt;version&gt;3.20.0&lt;/version&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.greenrobot&lt;/groupId&gt;
    &lt;artifactId&gt;essentials&lt;/artifactId&gt;
    &lt;version&gt;3.0.0-RC1&lt;/version&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
&lt;!--  略--&gt;
&lt;/dependencies&gt;
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../Review/post_10.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../Review/post_44.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../Review/post_10.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../Review/post_44.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
