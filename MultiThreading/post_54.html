<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Java多线程系列--掌握CompletableFuture，驾驭异步编程 - leobert&#x27;s blog</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">目录</li><li class="chapter-item expanded "><a href="../Android/index.html"><strong aria-hidden="true">1.</strong> Android</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/View/index.html"><strong aria-hidden="true">1.1.</strong> View</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/View/post_1.html"><strong aria-hidden="true">1.1.1.</strong> 好玩系列：优雅的处理ButterKnife和KAE被废弃</a></li><li class="chapter-item expanded "><a href="../Android/View/post_6.html"><strong aria-hidden="true">1.1.2.</strong> 三思系列：View体系认知(一)，内容是如何正确被展现出来的--视觉呈现概览</a></li><li class="chapter-item expanded "><a href="../Android/View/post_7.html"><strong aria-hidden="true">1.1.3.</strong> 三思系列：为什么自定义View</a></li><li class="chapter-item expanded "><a href="../Android/Idea/post_9.html"><strong aria-hidden="true">1.1.4.</strong> 三思系列："声明式UI"和"命令式UI"，你的理解可能是错的</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/Drawable/index.html"><strong aria-hidden="true">1.2.</strong> Drawable</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/Drawable/post_2.html"><strong aria-hidden="true">1.2.1.</strong> 三思系列：重新认识Drawable</a></li><li class="chapter-item expanded "><a href="../Android/Drawable/post_4.html"><strong aria-hidden="true">1.2.2.</strong> 好玩系列：拥有它，XML文件少一半--更方便的处理View背景</a></li><li class="chapter-item expanded "><a href="../Android/Drawable/post_47.html"><strong aria-hidden="true">1.2.3.</strong> 迟来的续集--Drawable+Animator，将优雅进行到底</a></li><li class="chapter-item expanded "><a href="../Android/Drawable/post_49.html"><strong aria-hidden="true">1.2.4.</strong> 好玩系列：让ImageSpan动起来</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/Mechanism/Message/index.html"><strong aria-hidden="true">1.3.</strong> 消息机制</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/Mechanism/Message/post_8.html"><strong aria-hidden="true">1.3.1.</strong> 三思系列：Android的消息机制，一文吃透</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/Idea/post_14/index.html"><strong aria-hidden="true">1.4.</strong> 兼容</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/Idea/post_14.html"><strong aria-hidden="true">1.4.1.</strong> 好玩系列：让项目中的相册支持Heif格式图片</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/Glide/index.html"><strong aria-hidden="true">1.5.</strong> Glide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/Glide/post_15.html"><strong aria-hidden="true">1.5.1.</strong> 三思系列：Glide 4.X全方位认知 -- 模块职责概览</a></li><li class="chapter-item expanded "><a href="../Android/Glide/post_16.html"><strong aria-hidden="true">1.5.2.</strong> 三思系列：Glide 4.X加载过程一文掌握 | Glide（二）</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/KSP/index.html"><strong aria-hidden="true">1.6.</strong> KSP</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/KSP/post_24.html"><strong aria-hidden="true">1.6.1.</strong> 好玩系列 | 拥抱Kotlin Symbol Processing(KSP),项目实战</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/Base/index.html"><strong aria-hidden="true">1.7.</strong> 基础</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/Base/post_35.html"><strong aria-hidden="true">1.7.1.</strong> 孔乙己：你可知道页面和弹窗“通信“的方式有四种？</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/SysApp/index.html"><strong aria-hidden="true">1.8.</strong> 系统APP</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/SysApp/post_52.html"><strong aria-hidden="true">1.8.1.</strong> 使用日历丰富产品的用户体验</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/DI/index.html"><strong aria-hidden="true">1.9.</strong> Part4-依赖注入部分</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/DI/post_53.html"><strong aria-hidden="true">1.9.1.</strong> Hilt进阶--一文吃透Hilt自定义与跨壁垒</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../Compose/index.html"><strong aria-hidden="true">2.</strong> Jetpack Compose</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Compose/post_21.html"><strong aria-hidden="true">2.1.</strong> Jetpack Compose | 一文理解神奇的Modifier</a></li><li class="chapter-item expanded "><a href="../Compose/post_26.html"><strong aria-hidden="true">2.2.</strong> Jetpack Compose | 控件篇（一） -- Text、TextField、Button</a></li><li class="chapter-item expanded "><a href="../Compose/post_27.html"><strong aria-hidden="true">2.3.</strong> Jetpack Compose | 控件篇（二） -- Icon，Image</a></li><li class="chapter-item expanded "><a href="../Compose/post_28.html"><strong aria-hidden="true">2.4.</strong> Jetpack Compose | 控件篇（三） -- Switch、CheckBox、RadioButton</a></li><li class="chapter-item expanded "><a href="../Compose/post_29.html"><strong aria-hidden="true">2.5.</strong> Jetpack Compose | 控件篇（四）-- Box、Row、Column</a></li><li class="chapter-item expanded "><a href="../Compose/post_30.html"><strong aria-hidden="true">2.6.</strong> Jetpack Compose | 控件篇（五）-- Spacer、LazyRow、LazyColumn & 让Column可滑动</a></li></ol></li><li class="chapter-item expanded "><a href="../MultiThreading/index.html"><strong aria-hidden="true">3.</strong> Java多线程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../MultiThreading/post_33.html"><strong aria-hidden="true">3.1.</strong> 总纲</a></li><li class="chapter-item expanded "><a href="../MultiThreading/post_37.html"><strong aria-hidden="true">3.2.</strong> Java基础--图解JVM内存模型和JVM线程模型</a></li><li class="chapter-item expanded "><a href="../MultiThreading/post_38.html"><strong aria-hidden="true">3.3.</strong> Java多线程系列--掌控面试，一文吃透Synchronized锁</a></li><li class="chapter-item expanded "><a href="../MultiThreading/post_39.html"><strong aria-hidden="true">3.4.</strong> Java多线程基础--线程生命周期与线程协作详解</a></li><li class="chapter-item expanded "><a href="../MultiThreading/post_42.html"><strong aria-hidden="true">3.5.</strong> Java多线程基础--线程的创建与线程池管理</a></li><li class="chapter-item expanded "><a href="../MultiThreading/post_46.html"><strong aria-hidden="true">3.6.</strong> Java多线程系列--掌握Future，轻松获取异步任务结果</a></li><li class="chapter-item expanded "><a href="../MultiThreading/post_50.html"><strong aria-hidden="true">3.7.</strong> Java多线程系列--Fork&Join框架，分治的艺术</a></li><li class="chapter-item expanded "><a href="../MultiThreading/post_54.html" class="active"><strong aria-hidden="true">3.8.</strong> Java多线程系列--掌握CompletableFuture，驾驭异步编程</a></li></ol></li><li class="chapter-item expanded "><a href="../IO/index.html"><strong aria-hidden="true">4.</strong> Java IO系列</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../IO/post_55.html"><strong aria-hidden="true">4.1.</strong> Java IO 系列总纲</a></li><li class="chapter-item expanded "><a href="../IO/post_56.html"><strong aria-hidden="true">4.2.</strong> Java IO系列 | 经典 IO</a></li><li class="chapter-item expanded "><a href="../IO/post_57.html"><strong aria-hidden="true">4.3.</strong> Java IO 系列 | NIO-1.0一文速览</a></li><li class="chapter-item expanded "><a href="../IO/post_58.html"><strong aria-hidden="true">4.4.</strong> Java IO系列 | NIO-1.0拾遗、NIO-2.0 & 零拷贝必吹的牛皮</a></li><li class="chapter-item expanded "><a href="../IO/post_59.html"><strong aria-hidden="true">4.5.</strong> IO系列 | 一文掌握OKHTTP中的OKIO为什么这么OK</a></li></ol></li><li class="chapter-item expanded "><a href="../Gradle/index.html"><strong aria-hidden="true">5.</strong> Gradle</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Gradle/Modularization/post_18.html"><strong aria-hidden="true">5.1.</strong> 组件化：三思系列：组件化场景下module依赖优雅实践方案</a></li><li class="chapter-item expanded "><a href="../Gradle/Publish/post_17.html"><strong aria-hidden="true">5.2.</strong> MavenCentral发布：迁移到MavenCentral--再不行动起来，你的托管的library就没了</a></li><li class="chapter-item expanded "><a href="../Gradle/post_22.html"><strong aria-hidden="true">5.3.</strong> Gradle | 依赖管理最佳实践</a></li></ol></li><li class="chapter-item expanded "><a href="../Groovy/index.html"><strong aria-hidden="true">6.</strong> Groovy</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Groovy/why_write_groovy.html"><strong aria-hidden="true">6.1.</strong> 为什么撰写这个系列</a></li><li class="chapter-item expanded "><a href="../Groovy/post_23.html"><strong aria-hidden="true">6.2.</strong> Groovy：MOP一文打尽</a></li></ol></li><li class="chapter-item expanded "><a href="../Review/index.html"><strong aria-hidden="true">7.</strong> Review</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Review/post_10.html"><strong aria-hidden="true">7.1.</strong> 造完了这个轮子--Mocker，却让我感到很羞愧|项目复盘</a></li><li class="chapter-item expanded "><a href="../Review/post_40.html"><strong aria-hidden="true">7.2.</strong> 三思系列：前人用GreenDao留下的坑，全线被扣了绩效</a></li><li class="chapter-item expanded "><a href="../Review/post_44.html"><strong aria-hidden="true">7.3.</strong> 谈一谈在两个商业项目中使用MVI架构后的感悟</a></li><li class="chapter-item expanded "><a href="../Review/post_45.html"><strong aria-hidden="true">7.4.</strong> Review | 这三个坑你遇到了吗？</a></li></ol></li><li class="chapter-item expanded "><a href="../repo/index.html"><strong aria-hidden="true">8.</strong> 个人项目</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../repo/DaVinCi.html"><strong aria-hidden="true">8.1.</strong> DaVinCi,取代XML编写Shape或ColorStateList的方案</a></li><li class="chapter-item expanded "><a href="../Android/Idea/post_32.html"><strong aria-hidden="true">8.2.</strong> 好玩系列：白嫖一个优雅的类图生成工具</a></li><li class="chapter-item expanded "><a href="../Speculative/post_43.html"><strong aria-hidden="true">8.3.</strong> 初体验：动手搭建"小清新式"局域网文档系统</a></li><li class="chapter-item expanded "><a href="../repo/post_48.html"><strong aria-hidden="true">8.4.</strong> 研究良久，终于发现了他代码写的快且bug少的原因</a></li><li class="chapter-item expanded "><a href="../Speculative/post_61.html"><strong aria-hidden="true">8.5.</strong> 好玩系列 | 如果后端让你用SSE接收多次返回，那我们改造Retrofit吧</a></li></ol></li><li class="chapter-item expanded "><a href="../Review/DataStructure/index.html"><strong aria-hidden="true">9.</strong> 数据结构</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Review/DataStructure/post_11.html"><strong aria-hidden="true">9.1.</strong> 温故：线性表</a></li><li class="chapter-item expanded "><a href="../Review/DataStructure/post_12.html"><strong aria-hidden="true">9.2.</strong> 温故：栈</a></li><li class="chapter-item expanded "><a href="../Review/DataStructure/post_13.html"><strong aria-hidden="true">9.3.</strong> 温故：队列</a></li></ol></li><li class="chapter-item expanded "><a href="../Review/README2.html"><strong aria-hidden="true">10.</strong> 年终总结&计划</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Review/post_36.html"><strong aria-hidden="true">10.1.</strong> 2021年终总结</a></li><li class="chapter-item expanded "><a href="../Review/post_51.html"><strong aria-hidden="true">10.2.</strong> 关于画一个句号--基于2022年终总结的反思与分享</a></li><li class="chapter-item expanded "><a href="../Review/post_60.html"><strong aria-hidden="true">10.3.</strong> 突如其来的秋季反思</a></li><li class="chapter-item expanded "><a href="../Review/post_63.html"><strong aria-hidden="true">10.4.</strong> 2023年总结 寻找到源于内心深处的无穷力量</a></li><li class="chapter-item expanded "><a href="../Review/post_64.html"><strong aria-hidden="true">10.5.</strong> 2024年中思考，推倒樊笼重新出发</a></li></ol></li><li class="chapter-item expanded "><a href="../Note/index.html"><strong aria-hidden="true">11.</strong> 读书笔记</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Note/post_41.html"><strong aria-hidden="true">11.1.</strong> 读书笔记：《简约至上--交互式设计四策略》</a></li></ol></li><li class="chapter-item expanded "><a href="../Talk/index.html"><strong aria-hidden="true">12.</strong> 杂谈</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Talk/talk_1.html"><strong aria-hidden="true">12.1.</strong> 杂谈1-2022-11</a></li><li class="chapter-item expanded "><a href="../Talk/talk_2_2023-03.html"><strong aria-hidden="true">12.2.</strong> 杂篇（二）-- 认识并战胜焦虑</a></li><li class="chapter-item expanded "><a href="../Talk/talk_3_2024-08.html"><strong aria-hidden="true">12.3.</strong> 杂谈（三）-- 向钱看，你需要想明白企业在为什么而付钱</a></li></ol></li><li class="chapter-item expanded "><a href="../Thought/index.html"><strong aria-hidden="true">13.</strong> 半成熟的思考</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Thought/post_62.html"><strong aria-hidden="true">13.1.</strong> 好玩系列 | 当SPI 和 设计模式、依赖注入发生碰撞，可以擦出怎样的火花</a></li></ol></li><li class="chapter-item expanded "><a href="../info/index.html"><strong aria-hidden="true">14.</strong> 系列说明</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../info/about_view_series.html"><strong aria-hidden="true">14.1.</strong> 关于View系列</a></li><li class="chapter-item expanded "><a href="../info/about_sansi_series.html"><strong aria-hidden="true">14.2.</strong> 关于三思系列</a></li><li class="chapter-item expanded "><a href="../info/about_haowan_series.html"><strong aria-hidden="true">14.3.</strong> 关于好玩系列</a></li><li class="chapter-item expanded "><a href="../info/about_wengu_series.html"><strong aria-hidden="true">14.4.</strong> 关于温故系列</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">leobert&#x27;s blog</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="java多线程系列--掌握completablefuture驾驭异步编程"><a class="header" href="#java多线程系列--掌握completablefuture驾驭异步编程">Java多线程系列--掌握CompletableFuture，驾驭异步编程</a></h1>
<h2 id="前言"><a class="header" href="#前言">前言</a></h2>
<p>本文隶属于我归纳整理的Android知识体系的第四部分，属于 <code>异步</code> 部分的多线程内容</p>
<p>您可以通过访问 <a href="https://leobert-lan.github.io/MultiThreading/post_33.html">总纲</a> 阅读系列内的其他文章。</p>
<img width="600" alt="desc" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d229ce6c3a5d4e52985f24fd489f4943~tplv-k3u1fbpfcp-watermark.image?"/>
<p><em>作者按：草稿进行了几次大改，移除了Demo部分、源码解析部分、设计原理部分。结合实际工作经验，"掌握API能熟练使用、能无障碍阅读相关框架源码" 已基本够用。</em></p>
<p>读者可结合下面的导图进行快速的知识自查</p>
<img width="800" alt="desc" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d39c0a5a14540a787f6cc95706d62ce~tplv-k3u1fbpfcp-watermark.image?"/>
<h2 id="一个美好的期望"><a class="header" href="#一个美好的期望">一个美好的期望</a></h2>
<p>通常情况下，我们希望代码的执行顺序和代码的组织顺序一致，即代码表述了同步执行的程序，这样可以减少很多思考。</p>
<p>而 <strong>阅读异步的程序代码，需要在脑海中建立事件流</strong>，当程序业务复杂时，将挑战人的记忆力和空间想象力，<strong>并非所有人都擅长在脑海中构建并分析异步事件流模型</strong>。</p>
<blockquote>
<p>所以，我们期望拥有一个非常友好的框架，能够让我们方便地进行异步编程，并且在框架内部设计有线程同步、异常处理机制。</p>
<p>并且，基于该框架编写的代码具有很高的可读、可理解性。</p>
</blockquote>
<p>而Future基本无法满足这一期望。</p>
<h2 id="future的不足与completablefuture的来源"><a class="header" href="#future的不足与completablefuture的来源">Future的不足与CompletableFuture的来源</a></h2>
<h3 id="future的不足"><a class="header" href="#future的不足">Future的不足</a></h3>
<blockquote>
<p>在先前的系列文章中，我们已经回顾了Future类的设计，在绝大多数场景下，我们选择使用多线程，是为了 <strong>充分利用机器性能</strong> 以及 <strong>避免用户交互线程出现长时间阻塞</strong> 以致影响体验。</p>
<p>所以我们将耗时的、会引起长时间阻塞的任务分离到其他线程执行，并在 <strong>合适时机</strong> 进行线程同步，于主线程（一般负责用户交互处理、界面渲染）中处理结果。</p>
</blockquote>
<p><em>详见拙作 <a href="https://leobert-lan.github.io/MultiThreading/post_46.html">掌握Future，轻松获取异步任务结果</a>
、<a href="https://juejin.cn/post/7147552484213719076">掘金链接</a></em></p>
<p><code>Future</code> 于 Java 1.5版本引入，它类似于 <code>异步处理的结果占位符</code> ， 提供了两个方法获取结果：</p>
<ul>
<li><code>get()</code>, 调用线程进入阻塞直至得到结果或者异常。</li>
<li><code>get(long timeout, TimeUnit unit)</code>, 调用线程将仅在指定时间 timeout 内等待结果或者异常，如果超时未获得结果就会抛出 TimeoutException 异常。</li>
</ul>
<p><code>Future</code> 可以实现 <code>Runnable</code> 或 <code>Callable</code> 接口来定义任务，一定程度上满足 <code>使用框架进行异步编程</code> 的期望，但通过整体源码可知它存在如下 <strong>3个问题</strong> ：</p>
<ul>
<li>调用 <code>get()</code> 方法会一直阻塞直到获取结果、异常，无法在任务完成时获得 "通知" ，无法附加回调函数</li>
<li>不具备链式调用和结果聚合处理能力，当我们想链接多个 <code>Future</code> 共同完成一件任务时，<strong>没有框架级的处理，只能编写业务级逻辑</strong>，合并结果，并小心的处理同步</li>
<li>需要单独编写异常处理代码</li>
</ul>
<p><em>使用 <code>get(long timeout, TimeUnit unit)</code> 和 <code>isDone()</code> 判断，确实可以缓解问题1，但这需要结合业务单独设计（调优），存在大量的不确定性。不再展开</em></p>
<p>Java 8中引入 <code>CompletableFuture</code> 来解决 <code>Future</code> 的不足。</p>
<h3 id="completablefuture来源"><a class="header" href="#completablefuture来源">CompletableFuture来源</a></h3>
<p><code>CompletableFuture</code> 的设计灵感来自于 <code>Google Guava</code> 库的 <code>ListenableFuture</code> 类，它实现了 <code>Future接口</code> 和 <code>CompletionStage接口</code> ，
并且新增一系列API，支持Java 8的 <code>lambda特性</code>，通过回调利用非阻塞方法，提升了异步编程模型。</p>
<img width="600" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0affb25beff4ac7bff9d5a28576ff12~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?"/>
<p>它解决了Future的不足，允许我们在非主线程中运行任务，并向启动线程 <em>(一般是主线程)</em> 通知 <code>任务完成</code> 或 <code>任务失败</code>，编写异步的、非阻塞的程序。</p>
<h2 id="使用completablefuture"><a class="header" href="#使用completablefuture">使用CompletableFuture</a></h2>
<h3 id="最简方式获取实例"><a class="header" href="#最简方式获取实例">最简方式获取实例</a></h3>
<p>使用 <code>CompletableFuture.completedFuture(U value)</code> 可以获取一个 <code>执行状态已经完成</code> 的 <code>CompletableFuture</code> 对象。</p>
<p><em>这可以用于快速改造旧程序，并进行逐步过渡</em></p>
<pre><code class="language-java">class Demo {
    @Test
    public void testSimpleCompletableFuture() {
        CompletableFuture&lt;String&gt; completableFuture =
                CompletableFuture.completedFuture("testSimpleCompletableFuture");

        assertTrue(completableFuture.isDone());
        try {
            assertEquals("testSimpleCompletableFuture", completableFuture.get());
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<h3 id="改造线程同步部分"><a class="header" href="#改造线程同步部分">改造线程同步部分</a></h3>
<p><em>部分老旧程序已经建立了多线程业务模型，我们可以使用 <code>CompletableFuture</code> 改造其中的线程同步部分，但暂不改造数据传递。</em></p>
<p>使用 <code>runAsync()</code> 方法，该方法接收一个 <code>Runnable</code> 类型的参数返回 <code>CompletableFuture&lt;Void&gt;</code>:</p>
<pre><code class="language-java">//并不改变原项目中数据传递的部分、或者不关心结果数据，仅进行同步
class Demo {
    @Test
    public void testCompletableFutureRunAsync() {
        AtomicInteger variable = new AtomicInteger(0);
        CompletableFuture&lt;Void&gt; runAsync = CompletableFuture.runAsync(() -&gt; process(variable));
        runAsync.join();
        assertEquals(1, variable.get());
    }

    public void process(AtomicInteger variable) {
        System.out.println(Thread.currentThread() + " Process...");
        variable.set(1);
    }
}
</code></pre>
<h3 id="进一步改造结果数据传递"><a class="header" href="#进一步改造结果数据传递">进一步改造结果数据传递</a></h3>
<p>当我们关心异步任务的结果数据、或者改造原 <strong>多线程业务模型</strong> 的 <strong>数据传递方式</strong> 时，可以使用 <code>supplyAsync()</code> 方法，该方法接收一个 <code>Supplier&lt;T&gt;</code>
接口类型的参数，它实现了任务的逻辑，方法返回 <code>CompletableFuture&lt;T&gt;</code> 实例。</p>
<pre><code class="language-java">class Demo {
    @Test
    public void testCompletableFutureSupplyAsync() {
        CompletableFuture&lt;String&gt; supplyAsync =
                CompletableFuture.supplyAsync(this::process);
        try {
            // Blocking 
            assertEquals("testCompletableFutureSupplyAsync", supplyAsync.get());
        } catch (ExecutionException | InterruptedException e) {
            e.printStackTrace();
        }
    }

    public String process() {
        return "testCompletableFutureSupplyAsync";
    }
}
</code></pre>
<h3 id="指定执行线程池"><a class="header" href="#指定执行线程池">指定执行线程池</a></h3>
<p>"获取用于执行任务的线程" 类似 Java 8 中的 <code>parallelStream</code>， <code>CompletableFuture</code> 默认从全局
<code>ForkJoinPool.commonPool()</code> 获取线程，用于执行任务。同时也提供了指定线程池的方式用于获取线程执行任务，您可以使用API中具有 <code>Executor</code> 参数的重载方法。</p>
<pre><code class="language-java">class Demo {
    @Test
    public void testCompletableFutureSupplyAsyncWithExecutor() {
        ExecutorService newFixedThreadPool =
                Executors.newFixedThreadPool(2);
        CompletableFuture&lt;String&gt; supplyAsync = CompletableFuture.supplyAsync(this::process,
                newFixedThreadPool);
        try {
            // Blocking 
            assertEquals("testCompletableFutureSupplyAsyncWithExecutor", supplyAsync.get());
        } catch (ExecutionException | InterruptedException e) {
            e.printStackTrace();
        }
    }

    public String process() {
        return "testCompletableFutureSupplyAsyncWithExecutor";
    }
}
</code></pre>
<p><code>CompletableFuture</code> 中有众多API，方法命名中含有 <code>Async</code> 的API可使用线程池。</p>
<p><em>截至此处，以上使用方式均与 <code>Future</code> 类似，接下来演示 <code>CompletableFuture</code> 的不同</em></p>
<h3 id="回调链式调用"><a class="header" href="#回调链式调用">回调&amp;链式调用</a></h3>
<p><code>CompletableFuture</code> 的 <code>get()</code>API是阻塞式获取结果，<code>CompletableFuture</code> 提供了</p>
<ul>
<li><code>thenApply</code></li>
<li><code>thenAccept</code></li>
<li><code>thenRun</code></li>
</ul>
<p>等API来避免阻塞式获取，并且可添加 <code>任务完成</code> 后的回调。这几个方法的使用场景如下：</p>
<ul>
<li><code>&lt;U&gt; CompletableFuture&lt;U&gt; thenApply(Function&lt;? super T,? extends U&gt; fn)</code> 收到结果后，可以进行转化</li>
<li><code>CompletableFuture&lt;Void&gt; thenAccept(Consumer&lt;? super T&gt; action)</code> 收到结果后，对其进行消费</li>
<li><code>CompletableFuture&lt;Void&gt; thenRun(Runnable action)</code> 收到结果后，执行回调，无法消费结果只能消费 <strong>这一事件</strong></li>
</ul>
<p><em>API较为简单，不再代码演示</em></p>
<p>显然，通过链式调用可以组装多个执行过程。</p>
<blockquote>
<p>有读者可能会疑惑：<code>Function</code> 和 <code>Consumer</code> 也可以进行链式组装，是否存在冗余呢？</p>
</blockquote>
<p>两种的链式调用特性确实存在重叠，您可以自行选择用法，但 <code>thenRun</code> 只能采用 <code>CompletableFuture</code>的链式调用。</p>
<p>另外，前面提到，我们可以指定线程池执行任务，对于这三组API，同样有相同的特性，通过 <code>thenXXXXAsync</code> 指定线程池，这是 <code>Function</code> 和 <code>Consumer</code> 的链式组装所无法完成的。</p>
<pre><code class="language-java">class Demo {
    @Test
    public void testCompletableFutureApplyAsync() {
        ExecutorService newFixedThreadPool = Executors.newFixedThreadPool(2);
        ScheduledExecutorService newSingleThreadScheduledExecutor = Executors.newSingleThreadScheduledExecutor();
        // 从线程池 newFixedThreadPool 获取线程执行任务 
        CompletableFuture&lt;Double&gt; completableFuture =
                CompletableFuture.supplyAsync(() -&gt; 1D, newFixedThreadPool)
                        .thenApplyAsync(d -&gt; d + 1D, newSingleThreadScheduledExecutor)
                        .thenApplyAsync(d -&gt; d + 2D);
        Double result = completableFuture.join();
        assertEquals(4D, result);
    }

}
</code></pre>
<h3 id="聚合多个completablefuture"><a class="header" href="#聚合多个completablefuture">聚合多个CompletableFuture</a></h3>
<p>通过 <code>聚合</code> 多个 <code>CompletableFuture</code>，可以组成更 <code>复杂</code> 的业务流，可以达到精细地控制粒度、聚焦单个节点的业务。</p>
<p><em>注意：操作符并不能完全的控制 <code>CompletableFuture</code> 任务执行的时机，您需要谨慎的选择 <code>CompletableFuture</code> 的创建时机</em></p>
<h4 id="thencomposethencomposeasync"><a class="header" href="#thencomposethencomposeasync">thenCompose、thenComposeAsync</a></h4>
<p><code>compose</code> 原意为 <code>组成</code>， 通过多个 <code>CompletableFuture</code> 构建异步流。</p>
<p>在操作的 <code>CompletableFuture</code> 获得结果时，将另一个 <code>CompletableFuture</code> <code>compose</code> 到异步流中，compose的过程中，可以根据操作的 <code>CompletableFuture</code> 的结果编写逻辑。</p>
<p>与 <code>thenApply</code> 相比，<code>thenCompose</code> 返回逻辑中提供的 <code>CompletableFuture</code> 而 <code>thenApply</code> 返回框架内处理的新实例。</p>
<p><em>注意，这一特性在使用 <code>FP编程范式</code>进行编码时，会显得非常灵活，一定程度上提升了函数的复用性</em></p>
<p><em>API含义直观，不再进行代码演示</em></p>
<h4 id="thencombinethencombineasync"><a class="header" href="#thencombinethencombineasync">thenCombine、thenCombineAsync</a></h4>
<p><code>thenCombine</code> 可以用于合并多个 <strong>独立任务</strong> 的处理结果。</p>
<blockquote>
<p><em>注意： <code>thenCompose</code> 进行聚合时，下游可以使用上游的结果，在业务需求上一般表现为依赖上一步结果，而非两者相互独立。</em></p>
</blockquote>
<p>例如，产品希望在博客详情页同时展示 "博客的详情" 和 "作者主要信息" ，以避免内容区抖动或割裂的骨架占位。这两者 <strong>可以独立获取时</strong> ，则可以使用 <code>thenCombine</code> 系列API，分别获取，并合并结果。</p>
<p><code>combine</code> 的特点是 被合并的两个 <code>CompletableFuture</code> 可以并发，等两者都获得结果后进行合并。</p>
<p>但它依旧存在使用上的不便捷，合并超过2个 <code>CompletableFuture</code> 时，显得不够灵活。可以使用
<code>static CompletableFuture&lt;Void&gt; allOf(CompletableFuture&lt;?&gt;... cfs)</code> API。</p>
<p><code>allOf</code> 创建了 <code>CompletableFuture&lt;Void&gt;</code>，并不会帮助我们合并结果，所以需要自行编写业务代码合并，故存在 <code>Side Effects</code>。</p>
<h4 id="runafterbothrunafterbothasyncrunaftereitherrunaftereitherasync"><a class="header" href="#runafterbothrunafterbothasyncrunaftereitherrunaftereitherasync">runAfterBoth、runAfterBothAsync;runAfterEither、runAfterEitherAsync</a></h4>
<ul>
<li><code>runAfterBoth</code> 系列API在两个 <code>CompletableFuture</code> 都获得结果后执行回调</li>
<li><code>runAfterEither</code> 系列API在两个 <code>CompletableFuture</code> 任意一个获得结果后执行回调</li>
</ul>
<p>通过API，不难理解它们需要使用者自行处理结果</p>
<ul>
<li><code>CompletableFuture&lt;Void&gt; runAfterBoth(CompletionStage&lt;?&gt; other, Runnable action)</code>;</li>
<li><code>CompletableFuture&lt;Void&gt; runAfterEither(CompletionStage&lt;?&gt; other, Runnable action)</code></li>
</ul>
<p>同样可以增加编码灵活性，不再赘述。</p>
<h4 id="applytoeitherapplytoeitherasyncaccepteitheraccepteitherasyncthenacceptboththenacceptbothasync"><a class="header" href="#applytoeitherapplytoeitherasyncaccepteitheraccepteitherasyncthenacceptboththenacceptbothasync">applyToEither、applyToEitherAsync；acceptEither、acceptEitherAsync;thenAcceptBoth、thenAcceptBothAsync</a></h4>
<ul>
<li><code>applyToEither</code> 系列API表现如 <code>thenApply</code> 和 <code>Either</code> 的组合，两个同类型的 <code>CompletableFuture</code> 任意一个获得结果后，可消费该结果并进行改变，类似 thenApply</li>
<li><code>acceptEither</code> 系列API表现如 <code>thenAccept</code> 和 <code>Either</code> 的组合，两个同类型的 <code>CompletableFuture</code> 任意一个获得结果后，可消费该结果，类似 thenAccept</li>
<li><code>thenAcceptBoth</code> 系列API表现如 <code>thenCombine</code>，但返回 <code>CompletableFuture&lt;Void&gt;</code></li>
</ul>
<p>同样可以增加编码灵活性，不再赘述</p>
<h3 id="结果处理"><a class="header" href="#结果处理">结果处理</a></h3>
<p>使用回调处理结果有两种API，注意，除了正常获得结果外还可能获得异常，而这两组API簇差异体现在对 <code>异常</code> 的处理中。</p>
<p><code>&lt;U&gt; CompletableFuture&lt;U&gt; handle(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn)</code>
<code>CompletableFuture&lt;T&gt; whenComplete(BiConsumer&lt;? super T, ? super Throwable&gt; action)</code></p>
<p><code>handle</code> 使用 <code>BiFunction</code>，无论是正常结果还是异常情况，均视作可被逻辑接受，消费后转化</p>
<p>而 <code>whenComplete</code> 使用 <code>BiConsumer</code>，仅可消费但不能转化，异常情况被视作不可被逻辑接受，仍会抛出。</p>
<p>举个例子，进行网络编程时会遇到 <code>Exception</code>, 如果业务设计中使用的模型实体包含了 <code>正常结果</code>、<code>异常</code> 两种情况：</p>
<pre><code class="language-kotlin">open class Result&lt;T&gt;(val t: T?) {
    open val isThr: Boolean = false
}

class FailResult&lt;T&gt;(val tr: Throwable) : Result&lt;T&gt;(null) {
    override val isThr: Boolean = true
}
</code></pre>
<p>则适合使用 <code>handle</code> API在底层处理。否则需要额外的异常处理，<em>可依据项目的设计选择处理方式，一般在依据FP范式设计的程序中，倾向于使用handle，避免增加side effect。</em></p>
<h3 id="异常处理"><a class="header" href="#异常处理">异常处理</a></h3>
<p>在多线程背景下，异常处理并不容易。它不仅仅是使用 <code>try-catch</code> 捕获异常，还包含程序异步流中，节点出现异常时流的业务走向。</p>
<p>在 <code>CompletableFuture</code> 中，节点出现异常将跳过后续节点，进入异常处理。</p>
<p>_如果您不希望某个节点抛出异常导致后续流程中断，则可在节点的处理中捕获并包装为结果、或者对子 CompletableFuture 节点采用 <code>handle</code>、<code>exceptionally</code> API转换异常 _</p>
<p>除前文提到的 <code>handle</code> <code>whenComplete</code>，<code>CompletableFuture</code> 中还提供了 <code>exceptionally</code> API用于处理异常</p>
<p><code>CompletableFuture&lt;T&gt; exceptionally(Function&lt;Throwable, ? extends T&gt; fn)</code></p>
<p>从表现结果看，它类似于 <code>handle</code> API中对异常的处理，将异常转换为目标结果的一种特定情形。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../MultiThreading/post_50.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../IO/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../MultiThreading/post_50.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../IO/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
