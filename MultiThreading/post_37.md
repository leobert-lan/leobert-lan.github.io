# Java基础--图解JVM内存模型和JVM线程模型

## 前言

各位亲爱的读者朋友，我正在创作 `Java多线程系列` 文章，严格的说，**JVM内存模型的知识并不隶属于Java多线程范畴**，但在讨论多线程的过程中，会涉及到相关概念，考虑到它作为 `面经常客`，故单独成篇进行知识梳理。

*在面经渲染的焦虑之下，我尽量让这部分知识整理的好记，虽然我并不认为正经面试会考察这些，又不开发JDK，帮助各位克服焦虑！*

在本篇中，将JVM内存模型以及JVM线程模型的关键知识，形成凝练的图、辅以文字，同读者一起回顾并掌握这些知识。

*作者按：我不是太喜欢抄书的人，本篇将以我记住的知识为主，如有谬误，还请读者在评论区不吝指出*

> 了解系列以及总纲：[Java多线程系列](todo)

先来看一张 **较为完整** 的图：

![](./post_37/jvm_memory_structure.png)

*作者按：图片源自亿图图示的模板*

再右侧再补充GC部分后，就比较完整了。今天的文章中，类加载部分略去，GC部分略去。

*作者按：读者朋友们还是应当将这两部分吃透的，如果面试遇到，可以顺着图展开作答*

**图中的 `Java栈` 又称为 `Java虚拟机栈` 、 `虚拟机栈` 、 `JVM栈` 等； `本地栈` 即 `本地方法栈`** 

## JVM内存模型

从上图中，我们将运行时数据区剥出来，形成下图，即JVM内存模型 _(内存区域)_：

![](./post_37/jvm_memory.png)

**在JVM1.8中，图中的 `方法区` 为 `元数据区`**

> 在多线程背景下，我们应个景：
> 
> * 堆和方法区是 **线程共享** 的
> * 虚拟机栈、本地方法栈、程序计数器是 **线程隔离** 的

下面展开谈一谈这五个区域的作用。

*以Java虚拟机规范为界，不讨论具体实现*


### 方法区（JVM1.8为元数据区）

方法区的作用为：存放虚拟机加载的：类型信息，域（Field）信息，方法（Method）信息，常量，静态变量，即时编译器编译后的代码缓存

值得注意的是，无法申请到内存时，将抛出 `OutOfMemoryError`

方法区中存在运行时常量池，字面量、符号引用等存放入其中。

在Hotspot的演变过程中：

* JDK6及之前：方法区存在永久代，保存有静态变量
* JDK7：进行去永久代工作，虽然还保留着，但静态常量池，如字符串常量池，已经移动到堆中
* JDK8：移除永久代，类型信息、域（Field）信息、方法（Method）信息存放在元数据区；字符串常量池、静态变量存放在堆区

*作者按：不同的虚拟机实现细节我也没有研究过，感兴趣的读者可以自行研究，如有靠谱文章希望分享下*

### 虚拟机栈

虚拟机栈中保存了 **每一次** `方法调用` 的信息。

每个Java线程创建时，都会创建对应的 `虚拟机栈` ，每一次方法调用，都会往栈中压入一个 `栈帧`。如下图：

![](./post_37/stack_frame.png)

而栈帧中，包含：

* 局部变量表：保存函数 *（即方法）* 的局部变量
* 操作数栈：保存计算过程中的结果，即临时变量
* 动态链接：指向方法区的运行时常量池。字节码中的 `方法调用指令` 以常量池中指向方法的 `符号引用` 为参数。
* 方法的返回地址

### 本地方法栈

和虚拟机栈功能上类似，它管理了native方法的一些执行细节，而虚拟机栈管理的是Java方法的执行细节。

### 程序计数器

程序计数器记录线程执行的字节码行号，*如果当前线程正在运行native方法则为空*。也有称之为 `PC寄存器`

字节码解释器在工作时，通过改变计数器的值来选取下一跳需要执行的字节码指令，`分支` 、 `循环` 、
`跳转` 、 `异常处理` 、`线程恢复` 等基本功能都需要依赖计数器来完成。

> Java虚拟机的多线程实现方式：通过 **轮流切换并分配处理器执行时间** 实现

所以，在任意确定的时间点，一个处理器只会处理一个线程中的指令。为了正确地处理 **线程切换后的任务恢复** ，每一个线程都具有自身的程序计数器

### 堆

堆提供了类实例和数组的内存，可以按如下方式划分：

* 新生代 *亦可称之年轻代、New Generation*
    * Eden区
    * Survivor 区 *S0和S1中存在互相移动，一些文章中的from、to是指移动上的逻辑关系*
        * S0
        * S1
* 老年代 *Old Generation*

如下图所示：

![](./post_37/jvm_heap.png)

划分和对象创建与GC有关，

* 新生成的对象在Eden区
* 触发 Minor GC后，还 "幸存" 的对象移动到S0
* 再次触发Minor GC后，S0和Eden 中存活的对象被移动到S1中，S0清空
* 每次移动时，自动递增计数器，超过默认值时 *（印象中是16）*，移动到老年代，如果Eden中没有足够内存分配，也将直接在老年代中分配内存
* 老年代中依靠Major GC


### 小总结

将上文的知识点进行一定的汇总后，我们可以得到一个新的图：

![](./post_37/JVM_1_8.jpg)

*图片来自亿图图示模板，再次不用画图了😂*


## JVM线程模型

https://www.cnblogs.com/kaleidoscope/p/9598140.html





