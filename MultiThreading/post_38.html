<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Java多线程系列--掌控面试，一文吃透Synchronized锁 - leobert&#x27;s blog</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">目录</li><li class="chapter-item expanded "><a href="../Android/index.html"><strong aria-hidden="true">1.</strong> Android</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/View/index.html"><strong aria-hidden="true">1.1.</strong> View</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/View/post_1.html"><strong aria-hidden="true">1.1.1.</strong> 好玩系列：优雅的处理ButterKnife和KAE被废弃</a></li><li class="chapter-item expanded "><a href="../Android/View/post_6.html"><strong aria-hidden="true">1.1.2.</strong> 三思系列：View体系认知(一)，内容是如何正确被展现出来的--视觉呈现概览</a></li><li class="chapter-item expanded "><a href="../Android/View/post_7.html"><strong aria-hidden="true">1.1.3.</strong> 三思系列：为什么自定义View</a></li><li class="chapter-item expanded "><a href="../Android/Idea/post_9.html"><strong aria-hidden="true">1.1.4.</strong> 三思系列："声明式UI"和"命令式UI"，你的理解可能是错的</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/Drawable/index.html"><strong aria-hidden="true">1.2.</strong> Drawable</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/Drawable/post_2.html"><strong aria-hidden="true">1.2.1.</strong> 三思系列：重新认识Drawable</a></li><li class="chapter-item expanded "><a href="../Android/Drawable/post_4.html"><strong aria-hidden="true">1.2.2.</strong> 好玩系列：拥有它，XML文件少一半--更方便的处理View背景</a></li><li class="chapter-item expanded "><a href="../Android/Drawable/post_47.html"><strong aria-hidden="true">1.2.3.</strong> 迟来的续集--Drawable+Animator，将优雅进行到底</a></li><li class="chapter-item expanded "><a href="../Android/Drawable/post_49.html"><strong aria-hidden="true">1.2.4.</strong> 好玩系列：让ImageSpan动起来</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/Mechanism/Message/index.html"><strong aria-hidden="true">1.3.</strong> 消息机制</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/Mechanism/Message/post_8.html"><strong aria-hidden="true">1.3.1.</strong> 三思系列：Android的消息机制，一文吃透</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/Idea/post_14/index.html"><strong aria-hidden="true">1.4.</strong> 兼容</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/Idea/post_14.html"><strong aria-hidden="true">1.4.1.</strong> 好玩系列：让项目中的相册支持Heif格式图片</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/Glide/index.html"><strong aria-hidden="true">1.5.</strong> Glide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/Glide/post_15.html"><strong aria-hidden="true">1.5.1.</strong> 三思系列：Glide 4.X全方位认知 -- 模块职责概览</a></li><li class="chapter-item expanded "><a href="../Android/Glide/post_16.html"><strong aria-hidden="true">1.5.2.</strong> 三思系列：Glide 4.X加载过程一文掌握 | Glide（二）</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/KSP/index.html"><strong aria-hidden="true">1.6.</strong> KSP</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/KSP/post_24.html"><strong aria-hidden="true">1.6.1.</strong> 好玩系列 | 拥抱Kotlin Symbol Processing(KSP),项目实战</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/Base/index.html"><strong aria-hidden="true">1.7.</strong> 基础</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/Base/post_35.html"><strong aria-hidden="true">1.7.1.</strong> 孔乙己：你可知道页面和弹窗“通信“的方式有四种？</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/SysApp/index.html"><strong aria-hidden="true">1.8.</strong> 系统APP</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/SysApp/post_52.html"><strong aria-hidden="true">1.8.1.</strong> 使用日历丰富产品的用户体验</a></li></ol></li><li class="chapter-item expanded "><a href="../Android/DI/index.html"><strong aria-hidden="true">1.9.</strong> Part4-依赖注入部分</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Android/DI/post_53.html"><strong aria-hidden="true">1.9.1.</strong> Hilt进阶--一文吃透Hilt自定义与跨壁垒</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../Compose/index.html"><strong aria-hidden="true">2.</strong> Jetpack Compose</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Compose/post_21.html"><strong aria-hidden="true">2.1.</strong> Jetpack Compose | 一文理解神奇的Modifier</a></li><li class="chapter-item expanded "><a href="../Compose/post_26.html"><strong aria-hidden="true">2.2.</strong> Jetpack Compose | 控件篇（一） -- Text、TextField、Button</a></li><li class="chapter-item expanded "><a href="../Compose/post_27.html"><strong aria-hidden="true">2.3.</strong> Jetpack Compose | 控件篇（二） -- Icon，Image</a></li><li class="chapter-item expanded "><a href="../Compose/post_28.html"><strong aria-hidden="true">2.4.</strong> Jetpack Compose | 控件篇（三） -- Switch、CheckBox、RadioButton</a></li><li class="chapter-item expanded "><a href="../Compose/post_29.html"><strong aria-hidden="true">2.5.</strong> Jetpack Compose | 控件篇（四）-- Box、Row、Column</a></li><li class="chapter-item expanded "><a href="../Compose/post_30.html"><strong aria-hidden="true">2.6.</strong> Jetpack Compose | 控件篇（五）-- Spacer、LazyRow、LazyColumn & 让Column可滑动</a></li></ol></li><li class="chapter-item expanded "><a href="../MultiThreading/index.html"><strong aria-hidden="true">3.</strong> Java多线程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../MultiThreading/post_33.html"><strong aria-hidden="true">3.1.</strong> 总纲</a></li><li class="chapter-item expanded "><a href="../MultiThreading/post_37.html"><strong aria-hidden="true">3.2.</strong> Java基础--图解JVM内存模型和JVM线程模型</a></li><li class="chapter-item expanded "><a href="../MultiThreading/post_38.html" class="active"><strong aria-hidden="true">3.3.</strong> Java多线程系列--掌控面试，一文吃透Synchronized锁</a></li><li class="chapter-item expanded "><a href="../MultiThreading/post_39.html"><strong aria-hidden="true">3.4.</strong> Java多线程基础--线程生命周期与线程协作详解</a></li><li class="chapter-item expanded "><a href="../MultiThreading/post_42.html"><strong aria-hidden="true">3.5.</strong> Java多线程基础--线程的创建与线程池管理</a></li><li class="chapter-item expanded "><a href="../MultiThreading/post_46.html"><strong aria-hidden="true">3.6.</strong> Java多线程系列--掌握Future，轻松获取异步任务结果</a></li><li class="chapter-item expanded "><a href="../MultiThreading/post_50.html"><strong aria-hidden="true">3.7.</strong> Java多线程系列--Fork&Join框架，分治的艺术</a></li><li class="chapter-item expanded "><a href="../MultiThreading/post_54.html"><strong aria-hidden="true">3.8.</strong> Java多线程系列--掌握CompletableFuture，驾驭异步编程</a></li></ol></li><li class="chapter-item expanded "><a href="../IO/index.html"><strong aria-hidden="true">4.</strong> Java IO系列</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../IO/post_55.html"><strong aria-hidden="true">4.1.</strong> Java IO 系列总纲</a></li><li class="chapter-item expanded "><a href="../IO/post_56.html"><strong aria-hidden="true">4.2.</strong> Java IO系列 | 经典 IO</a></li><li class="chapter-item expanded "><a href="../IO/post_57.html"><strong aria-hidden="true">4.3.</strong> Java IO 系列 | NIO-1.0一文速览</a></li><li class="chapter-item expanded "><a href="../IO/post_58.html"><strong aria-hidden="true">4.4.</strong> Java IO系列 | NIO-1.0拾遗、NIO-2.0 & 零拷贝必吹的牛皮</a></li><li class="chapter-item expanded "><a href="../IO/post_59.html"><strong aria-hidden="true">4.5.</strong> IO系列 | 一文掌握OKHTTP中的OKIO为什么这么OK</a></li></ol></li><li class="chapter-item expanded "><a href="../Gradle/index.html"><strong aria-hidden="true">5.</strong> Gradle</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Gradle/Modularization/post_18.html"><strong aria-hidden="true">5.1.</strong> 组件化：三思系列：组件化场景下module依赖优雅实践方案</a></li><li class="chapter-item expanded "><a href="../Gradle/Publish/post_17.html"><strong aria-hidden="true">5.2.</strong> MavenCentral发布：迁移到MavenCentral--再不行动起来，你的托管的library就没了</a></li><li class="chapter-item expanded "><a href="../Gradle/post_22.html"><strong aria-hidden="true">5.3.</strong> Gradle | 依赖管理最佳实践</a></li></ol></li><li class="chapter-item expanded "><a href="../Groovy/index.html"><strong aria-hidden="true">6.</strong> Groovy</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Groovy/why_write_groovy.html"><strong aria-hidden="true">6.1.</strong> 为什么撰写这个系列</a></li><li class="chapter-item expanded "><a href="../Groovy/post_23.html"><strong aria-hidden="true">6.2.</strong> Groovy：MOP一文打尽</a></li></ol></li><li class="chapter-item expanded "><a href="../Review/index.html"><strong aria-hidden="true">7.</strong> Review</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Review/post_10.html"><strong aria-hidden="true">7.1.</strong> 造完了这个轮子--Mocker，却让我感到很羞愧|项目复盘</a></li><li class="chapter-item expanded "><a href="../Review/post_40.html"><strong aria-hidden="true">7.2.</strong> 三思系列：前人用GreenDao留下的坑，全线被扣了绩效</a></li><li class="chapter-item expanded "><a href="../Review/post_44.html"><strong aria-hidden="true">7.3.</strong> 谈一谈在两个商业项目中使用MVI架构后的感悟</a></li><li class="chapter-item expanded "><a href="../Review/post_45.html"><strong aria-hidden="true">7.4.</strong> Review | 这三个坑你遇到了吗？</a></li></ol></li><li class="chapter-item expanded "><a href="../repo/index.html"><strong aria-hidden="true">8.</strong> 个人项目</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../repo/DaVinCi.html"><strong aria-hidden="true">8.1.</strong> DaVinCi,取代XML编写Shape或ColorStateList的方案</a></li><li class="chapter-item expanded "><a href="../Android/Idea/post_32.html"><strong aria-hidden="true">8.2.</strong> 好玩系列：白嫖一个优雅的类图生成工具</a></li><li class="chapter-item expanded "><a href="../Speculative/post_43.html"><strong aria-hidden="true">8.3.</strong> 初体验：动手搭建"小清新式"局域网文档系统</a></li><li class="chapter-item expanded "><a href="../repo/post_48.html"><strong aria-hidden="true">8.4.</strong> 研究良久，终于发现了他代码写的快且bug少的原因</a></li><li class="chapter-item expanded "><a href="../Speculative/post_61.html"><strong aria-hidden="true">8.5.</strong> 好玩系列 | 如果后端让你用SSE接收多次返回，那我们改造Retrofit吧</a></li></ol></li><li class="chapter-item expanded "><a href="../Review/DataStructure/index.html"><strong aria-hidden="true">9.</strong> 数据结构</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Review/DataStructure/post_11.html"><strong aria-hidden="true">9.1.</strong> 温故：线性表</a></li><li class="chapter-item expanded "><a href="../Review/DataStructure/post_12.html"><strong aria-hidden="true">9.2.</strong> 温故：栈</a></li><li class="chapter-item expanded "><a href="../Review/DataStructure/post_13.html"><strong aria-hidden="true">9.3.</strong> 温故：队列</a></li></ol></li><li class="chapter-item expanded "><a href="../Review/README2.html"><strong aria-hidden="true">10.</strong> 年终总结&计划</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Review/post_36.html"><strong aria-hidden="true">10.1.</strong> 2021年终总结</a></li><li class="chapter-item expanded "><a href="../Review/post_51.html"><strong aria-hidden="true">10.2.</strong> 关于画一个句号--基于2022年终总结的反思与分享</a></li><li class="chapter-item expanded "><a href="../Review/post_60.html"><strong aria-hidden="true">10.3.</strong> 突如其来的秋季反思</a></li><li class="chapter-item expanded "><a href="../Review/post_63.html"><strong aria-hidden="true">10.4.</strong> 2023年总结 寻找到源于内心深处的无穷力量</a></li><li class="chapter-item expanded "><a href="../Review/post_64.html"><strong aria-hidden="true">10.5.</strong> 2024年中思考，推倒樊笼重新出发</a></li></ol></li><li class="chapter-item expanded "><a href="../Note/index.html"><strong aria-hidden="true">11.</strong> 读书笔记</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Note/post_41.html"><strong aria-hidden="true">11.1.</strong> 读书笔记：《简约至上--交互式设计四策略》</a></li><li class="chapter-item expanded "><a href="../Talk/talk_4_2024-08.html"><strong aria-hidden="true">11.2.</strong> 读书笔记 - 《团队管理》精华摘要</a></li></ol></li><li class="chapter-item expanded "><a href="../Talk/index.html"><strong aria-hidden="true">12.</strong> 杂谈</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Talk/talk_1.html"><strong aria-hidden="true">12.1.</strong> 杂谈1-2022-11</a></li><li class="chapter-item expanded "><a href="../Talk/talk_2_2023-03.html"><strong aria-hidden="true">12.2.</strong> 杂篇（二）-- 认识并战胜焦虑</a></li><li class="chapter-item expanded "><a href="../Talk/talk_3_2024-08.html"><strong aria-hidden="true">12.3.</strong> 杂谈（三）-- 向钱看，你需要想明白企业在为什么而付钱</a></li></ol></li><li class="chapter-item expanded "><a href="../Thought/index.html"><strong aria-hidden="true">13.</strong> 半成熟的思考</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Thought/post_62.html"><strong aria-hidden="true">13.1.</strong> 好玩系列 | 当SPI 和 设计模式、依赖注入发生碰撞，可以擦出怎样的火花</a></li></ol></li><li class="chapter-item expanded "><a href="../info/index.html"><strong aria-hidden="true">14.</strong> 系列说明</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../info/about_view_series.html"><strong aria-hidden="true">14.1.</strong> 关于View系列</a></li><li class="chapter-item expanded "><a href="../info/about_sansi_series.html"><strong aria-hidden="true">14.2.</strong> 关于三思系列</a></li><li class="chapter-item expanded "><a href="../info/about_haowan_series.html"><strong aria-hidden="true">14.3.</strong> 关于好玩系列</a></li><li class="chapter-item expanded "><a href="../info/about_wengu_series.html"><strong aria-hidden="true">14.4.</strong> 关于温故系列</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">leobert&#x27;s blog</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="java多线程系列--掌控面试一文吃透synchronized锁"><a class="header" href="#java多线程系列--掌控面试一文吃透synchronized锁">Java多线程系列--掌控面试，一文吃透Synchronized锁</a></h1>
<h2 id="前言"><a class="header" href="#前言">前言</a></h2>
<p>各位亲爱的读者朋友，我正在创作 <code>Java多线程系列</code> 文章，本篇我们将分析重点内容：<code>锁</code></p>
<p>锁是 <strong>面试中的常客</strong> ，也是多线程编码中 <strong>必不可少</strong> 的内容，无论是为了 <strong>"面试胜利"</strong> ，还是 <strong>"写出高质量的代码"</strong> ，我们都需要掌握它。</p>
<p><em>作者按：本篇按照自己有限的知识进行整理，如有谬误，还请读者在评论区不吝指出</em></p>
<blockquote>
<p>了解系列以及总纲：<a href="https://leobert-lan.github.io/MultiThreading/post_33.html">Java多线程系列</a></p>
</blockquote>
<p>本文篇幅较长，内容较为跳跃，可参考导图阅读：</p>
<p><img src="./post_38/guide.png" alt="" /></p>
<h2 id="前文拾遗----java对象结构"><a class="header" href="#前文拾遗----java对象结构">前文拾遗 -- JAVA对象结构</a></h2>
<p>先前已经发布过一篇系列文章：<a href="https://juejin.cn/post/7068941257074016263">克服焦虑--图解JVM内存模型和JVM线程模型</a></p>
<p>其中还有一处关键知识没有展开："Java对象包含哪些内容"，这部分内容和锁的实现有关，本篇将由此继续展开。</p>
<p>单刀直入，在HotSpot虚拟机中，一个对象实例可以被划分出三块信息：</p>
<ul>
<li>对象头 Header</li>
<li>实例数据 Instance Data，亦有称之对象体</li>
<li>对齐填充 Padding</li>
</ul>
<p>其中对齐填充可能存在，实例数据是供给 <code>应用程序逻辑</code> 使用的，存储了实例的字段信息。接下来重点探讨对象头。</p>
<h3 id="java对象头"><a class="header" href="#java对象头">Java对象头</a></h3>
<p>对象头部分的信息主要面向JVM，包含：</p>
<ul>
<li>Mark Word</li>
<li>kclass, 对象对应的类的元数据指针</li>
<li>array length ，仅数组对象才拥有</li>
</ul>
<p>整体划分如图所示：</p>
<p><img src="./post_38/jvm_header.jpeg" alt="" /></p>
<p><em>图片来自网络搜索，水印为Java帮帮</em></p>
<h4 id="mark-word"><a class="header" href="#mark-word">Mark Word</a></h4>
<p>Mark Word 用于存储对象运行时数据： <code>哈希</code>、<code>GC分代年龄</code>、<code>锁状态标志</code>、<code>线程持有的锁</code>、<code>偏向线程ID</code>、<code>偏向时间戳</code> 等。</p>
<p>查找 HotSpot中markOop的doc如下：</p>
<pre><code class="language-java">// The markOop describes the header of an object.
// Note that the mark is not a real oop but just a word.
// It is placed in the oop hierarchy for historical reasons.
//
// Bit-format of an object header (most significant first, big endian layout below):
//
//  32 bits:
//  --------
//  hash:25 ------------&gt;| age:4    biased_lock:1 lock:2 (normal object)
//  JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)
//  size:32 ------------------------------------------&gt;| (CMS free block)
//  PromotedObject*:29 ----------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)
//
//  64 bits:
//  --------
//  unused:25 hash:31 --&gt;| unused:1   age:4    biased_lock:1 lock:2 (normal object)
//  JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)
//  PromotedObject*:61 ---------------------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)
//  size:64 -----------------------------------------------------&gt;| (CMS free block)
//
//  unused:25 hash:31 --&gt;| cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; normal object)
//  JavaThread*:54 epoch:2 cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; biased object)
//  narrowOop:32 unused:24 cms_free:1 unused:4 promo_bits:3 -----&gt;| (COOPs &amp;&amp; CMS promoted object)
//  unused:21 size:35 --&gt;| cms_free:1 unused:7 ------------------&gt;| (COOPs &amp;&amp; CMS free block)
</code></pre>
<p><em>32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit，开启压缩后为32bit</em></p>
<p>梳理64位虚拟机五种状态下的对象头：</p>
<pre><code class="language-commandline">|------------------------------------------------------------------------------------------------------------------|
|                                     Object Header(128bits)                                                       |
|---------------------|--------------------------------------------------------------------------------------------|
|       State         |                                   Mark Word(64bits)               |  Klass Word(64bits)    |
|---------------------|--------------------------------------------------------------------------------------------|
|       Nomal         | unused:25|identity_hashcode:31|unused:1|age:4|biase_lock:1|lock:2 | OOP to metadata object |
|---------------------|--------------------------------------------------------------------------------------------|
|       Biased        | thread:54|      epoch:2       |unused:1|age:4|biase_lock:1|lock:2 | OOP to metadata object |
|---------------------|--------------------------------------------------------------------------------------------|
|  Lightweight Locked |                     ptr_to_lock_record:62                 |lock:2 | OOP to metadata object |
|---------------------|--------------------------------------------------------------------------------------------|
|  Heavyweight Locked |                    ptr_to_heavyweight_monitor:62          |lock:2 | OOP to metadata object |
|---------------------|--------------------------------------------------------------------------------------------|
|     Marked for GC   |                                                           |lock:2 | OOP to metadata object |
|---------------------|--------------------------------------------------------------------------------------------|
</code></pre>
<p><em>排版不方便的话看下图：</em></p>
<p><img src="./post_38/jvm_header_64.png" alt="" /></p>
<p>如果运行在 HotSpot openJdk VM 上，可以借助："org.openjdk.jol:jol-core:0.9" 打印对象头进行对照。</p>
<p><a href="https://blog.csdn.net/qdh186/article/details/96162413">五种状态下分析对象头的一份参考博客</a></p>
<p><em>作者按：此处的知识我们留一个印象即可，Android同学可能只能拿来吹牛</em></p>
<p>归纳后知识概要如图：</p>
<p><img src="./post_38/jvm_obj_structure.png" alt="" /></p>
<p><em>注：32位</em></p>
<h2 id="锁的常见概念分类"><a class="header" href="#锁的常见概念分类">锁的常见概念、分类</a></h2>
<p>我们平时会听到关于锁的各种概念名词，前文的表中，我们也看到了 <code>偏向锁</code> <code>轻量级锁</code> <code>重量级锁</code> 的身影，接下来简单聊一聊分类以及常见概念。</p>
<h3 id="乐观锁--悲观锁"><a class="header" href="#乐观锁--悲观锁">乐观锁 / 悲观锁</a></h3>
<p>乐观锁和悲观锁是一种相对的 <strong>态度</strong> 。在并发的背景下，访问临界区时 <strong>可能会</strong> 发生 "冲突"，不同的态度演变出不同的策略。</p>
<p><strong>悲观</strong> 地看，可以 <strong>认为冲突一定会发生</strong> ：访问临界区时，自身线程的写入行为一定会影响其他线程，自身线程的读取行为一定会受到其他线程的写入影响！ 所以 <strong>必须要进行锁保护</strong> ，通过 "独占"，"排他" 等特性，保障无冲突。
即：<strong>悲观地认为，不加锁的并发操作一定会出现冲突，必须加锁</strong></p>
<p><strong>乐观</strong> 地看，可以 <strong>认为发生冲突是场景限定的事件</strong> ：读不会有冲突，但写入存在冲突可能。所以 <strong>只有在写操作时，进行冲突检测，检测到冲突时操作就会失败，返回错误信息</strong></p>
<p>在Java中，悲观锁即各种实际的锁实现，而乐观锁即无锁编程，转为使用CAS算法。</p>
<h3 id="独享锁--共享锁"><a class="header" href="#独享锁--共享锁">独享锁 / 共享锁</a></h3>
<p>锁可以被访问者独享或者共享，直白地讲：独享锁在某一时间点，只能被一个线程获取，其它线程必须等待锁被持有者释放之后，才可能获取到锁，而共享锁可以被多个线程获取。</p>
<p>独享锁又称独占锁、排它锁。</p>
<p>显然，共享锁认为持有它的线程们在并发操作时并不会发生冲突。</p>
<h3 id="可重入锁--非可重入锁"><a class="header" href="#可重入锁--非可重入锁">可重入锁 / 非可重入锁</a></h3>
<p>从概念上看：一个线程在持有一个锁的时候，它内部能否再次（多次）申请该锁，如果可以则为可重入锁，否则为不可重入锁。</p>
<p>显然易见：<code>不可重入</code> 将大大增加 <code>死锁</code> 的机率。</p>
<p><em>作者按：但在线程的基础上实现类似协程的机制时，非可重入将具有重要意义。</em></p>
<h3 id="公平锁--非公平锁"><a class="header" href="#公平锁--非公平锁">公平锁 / 非公平锁</a></h3>
<p>锁需要通过竞争获取，公平 / 非公平指的是 是否按照"先来后到"获取锁。</p>
<p>如果按照申请顺序分配锁，则为公平锁，否则为非公平锁。</p>
<p>我们常用的Synchronized即非公平锁，Java的可重入锁（ReentrantLock）默认为非公平锁，但可以实例化为公平锁。</p>
<p>非公平锁的优点在于吞吐量比公平锁大。</p>
<h3 id="互斥锁读写锁"><a class="header" href="#互斥锁读写锁">互斥锁、读写锁</a></h3>
<p>独享锁、共享锁的具体实现，读写锁作为读模式时是共享锁。</p>
<p>Java中的 <code>ReentrantLock</code> 是互斥锁，<code>ReadWriteLock</code> 是读写锁实现。</p>
<h3 id="分段锁"><a class="header" href="#分段锁">分段锁</a></h3>
<p>分段锁并非是一种锁，而是一种提高效率的设计思路，将临界区进行划分，当某一块区域的写入并不影响其他区域的读取时，就可以采用分段的思路， 对写入区域加锁，读取其他区域则无需竞争锁从而提高效率，例如 <code>ConcurrentHashMap</code>
就采用了这一设计</p>
<h3 id="偏向锁--轻量级锁--重量级锁"><a class="header" href="#偏向锁--轻量级锁--重量级锁">偏向锁 / 轻量级锁 / 重量级锁</a></h3>
<p>专指 <code>synchronized</code> 的三种锁状态，并且关系到后文中的 <code>锁升级</code> 部分。</p>
<p>在前文中，我们花了很多篇幅梳理 <code>对象头</code> 中的 <code>Mark Word</code>，其中有三种状态：Biased，Lightweight Locked，Heavyweight Locked 于此对应。</p>
<ul>
<li>偏向锁状态：同步代码一直被同一线程访问时，该线程会自动获取锁，降低获取锁的代价。</li>
<li>轻量级锁状态：在偏向锁状态时，一旦另一线程竞争该锁，则升级为轻量级锁，竞争的线程通过 <code>有限的自旋</code> 尝试获取锁，如果锁的持有者在此过程中 <strong>释放了锁</strong> ， 并被该线程成功获取锁，则可以避免阻塞，减少线程切换，*
挂起和恢复线程是较为昂贵的*。</li>
<li>重量级锁状态：当线程完成了有限的自旋后依旧未能获得锁，将不得不进行阻塞以免空耗CPU，此时锁升级为重量级锁</li>
</ul>
<p>不难理解，按照Java的线程模型，<strong>仅多核CPU情况下，采用轻量级锁并利用自旋才有意义</strong>。如果是单核CPU，并不存在真正的时间意义上的线程并发，自旋时，持有锁的线程是挂起的，并无释放锁的可能</p>
<p><em>作者按：Java的线程模型可参见拙作：<a href="https://juejin.cn/post/7068941257074016263">克服焦虑--图解JVM内存模型和JVM线程模型</a></em></p>
<h3 id="自旋锁"><a class="header" href="#自旋锁">自旋锁</a></h3>
<p>基于CAS利用自旋去竞争锁实现同步的一种方式，如前文所言，发生竞争而产生自旋时，当前线程不会阻塞，所以不会直接导致系统调用，减少上下文切换的开销，
但如果一直竞争不到锁，将造成CPU空转，所谓的busy-waiting。对于计算密集型程序而言，可能会带来负面效果。</p>
<p>我们可以利用Atomic实现一个简单的 <code>可重入自旋锁</code></p>
<pre><code class="language-java">public class ReentrantSpinLock {
    private AtomicReference&lt;Thread&gt; cas = new AtomicReference&lt;Thread&gt;();
    private int count;

    public void lock() {
        Thread current = Thread.currentThread();
        if (current == cas.get()) {
            count++;
            return;
        }
        while (!cas.compareAndSet(null, current)) {
            // Do nothing
        }
    }

    public void unlock() {
        Thread cur = Thread.currentThread();
        if (cur == cas.get()) {
            if (count &gt; 0) {
                count--;
            } else {
                cas.compareAndSet(cur, null);
            }
        }
    }
}
</code></pre>
<p>很显然，这也是一个非公平锁、独享锁</p>
<h2 id="synchronized锁"><a class="header" href="#synchronized锁">Synchronized锁</a></h2>
<p><code>synchronized</code> 作为Java关键字，提供同步能力，其核心依赖于Java对象的对象头，当一个类对象被作为synchronized锁对象时，其即为 <code>Monitor</code>，JVM通过
<strong>进入、退出Monitor</strong> 来实现同步</p>
<pre><code class="language-java">class Foo {

    synchronized static foo() {
    }

    synchronized void bar() {
    }

    void baz() {
        synchronized (Foo.class) {
            //同步块
        }
    }
}
</code></pre>
<p>如上代码中展示了三种同步的方式：</p>
<ul>
<li><code>foo()</code> 中锁对应的Monitor为 <code>Foo.class</code></li>
<li><code>bar()</code> 中锁对应的Monitor为 Foo 的对象实例</li>
<li><code>baz()</code> 中的同步块可以用任意的对象作为Monitor，演示部分使用了 <code>Foo.class</code> 作为Monitor</li>
</ul>
<p>注意，Monitor的选取务必慎重，不仅仅要从 <code>同步</code> 的需求角度出发，避免性能损耗，也要注意锁无法正常生效的问题。例如：</p>
<p>我们模拟5个线程同时竞争一个数（初始值为6）并做 <code>--</code> 运算，读者是否认为它会按照 <code>5、4、3、2、1</code> 的顺序输出？</p>
<pre><code class="language-java">class Foo {

  Integer integer = 6;

  void minus() {
    synchronized (integer) {
      if (integer &gt; 0) {
        integer--;
      }
      System.out.println(Thread.currentThread().getId() + " -&gt; i:" + integer);
    }
  }

  static class MThread extends Thread {
    final Foo foo;
    final CountDownLatch latch;

    MThread(Foo foo, CountDownLatch latch) {
      this.foo = foo;
      this.latch = latch;
    }

    @Override
    public void run() {
      super.run();
      try {
        latch.await();
        foo.minus();
      } catch (InterruptedException e) {
        e.printStackTrace();
      }

    }
  }

  public static void main(String[] args) {
    Foo foo = new Foo();
    CountDownLatch latch = new CountDownLatch(1);

    for (int i = 0; i &lt; 5; i++) {
      new MThread(foo,latch).start();
    }
    latch.countDown();
    try {
      Thread.sleep(1000);
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
  }
}
</code></pre>
<p>多执行几次就会发现 <code>可能</code> 会像下面的结果，它并非是一个同步情况的结果，<em>如果想要更顺利的模拟问题的出现，增大线程数即可</em></p>
<pre><code class="language-java">&gt; Task :Foo.main()
13 -&gt; i:3
15 -&gt; i:4
12 -&gt; i:3
14 -&gt; i:1
11 -&gt; i:2
</code></pre>
<p>如果读者注意了lint，会注意到提示：Synchronization on a non-final field 'integer'</p>
<p>很显然，上面的代码并未采用正确的Monitor，在 <code>integer--</code> 的过程中，integer实例已经发生变化：</p>
<pre><code class="language-java">System.out.println(Thread.currentThread().getId() + 
        " -&gt; i:" + integer+","+System.identityHashCode(integer));
</code></pre>
<p>我们增加identityHashCode，并增大并发数量到10，输出如下：</p>
<pre><code class="language-java">13 -&gt; i:0,482590393
15 -&gt; i:1,1722967101
11 -&gt; i:3,1130778910
16 -&gt; i:0,482590393
17 -&gt; i:0,482590393
20 -&gt; i:0,482590393
12 -&gt; i:4,685260083
14 -&gt; i:2,1983109557
19 -&gt; i:0,482590393
18 -&gt; i:0,482590393
</code></pre>
<p>显然，<strong>锁了个寂寞</strong> 。<em>当然，该问题深入研究下去，读者可以一直挖到动态常量池，不再展开</em>。</p>
<p>所以，编码中一定要保持好习惯：<code>Monitor对象不可变</code>，无形中就避开了bug。</p>
<h3 id="锁升级"><a class="header" href="#锁升级">锁升级</a></h3>
<p>前文已经提到了锁的升级：</p>
<blockquote>
<p>偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁 , 锁的升级是单向的</p>
</blockquote>
<p>这其实是 <code>synchronized</code> 内部实现上对锁方式的优化</p>
<h4 id="转换原因"><a class="header" href="#转换原因">转换原因</a></h4>
<p>很显然，这一过程充分考虑各种锁的优点和缺点，在相应场景下以期获得最好的性能。</p>
<ul>
<li>偏向锁：没有自旋、没有系统调用，所以 <strong>消耗少性能高</strong> ，并且具有可重入特性，在 <code>同一线程执行同步代码</code> 场景下是最优选择，但它具有 <strong>撤销锁消耗高</strong> 的缺点。</li>
<li>轻量级锁：前面已经提到，用CAS取代了阻塞，在 <code>锁持有时间短</code> 的场景下是最优选择，可追求 <code>快速响应</code> ，但缺点是短时间内无法获取锁时，自旋消耗CPU资源。</li>
<li>重量级锁：具备 <code>大吞吐量</code> ，未竞争到锁的线程不会自旋消耗资源，适合 <code>锁占用时间长，吞吐量需求大</code> 的场景</li>
</ul>
<p>而从 <strong>偏向锁到轻量级锁</strong>，意味着多线程竞争，假定锁的持有时间不会太长，有限的自旋可以等到持有者释放锁，而当 <strong>轻量级锁升级到重量级锁</strong> ，意味着这一 <strong>假设不成立</strong> ，自旋只是在白白消耗，通过挂起和等待唤醒以提升吞吐量</p>
<h4 id="转换过程"><a class="header" href="#转换过程">转换过程</a></h4>
<p><img src="./post_38/Synchronization.gif" alt="" /></p>
<p>从OpenJdk的 <a href="%5Bhttps://wiki.openjdk.java.net/display/HotSpot/Synchronization">WIKI -- Synchronization</a> 可以得到这张图。</p>
<p>为广泛流传的下图的原版
<img src="./post_38/synchronized2.png" alt="" /></p>
<p>一图胜千言，图中表现的非常明确，读者可以结合WIKI内容自行理解，不再多做赘述。</p>
<p>经常在课程广告中出现的一张图如下,收藏不等于学会：</p>
<p><img src="./post_38/java_sync.jpg" alt="" /></p>
<p><em>图片水印Blog.Dreamtobe.cn</em></p>
<h2 id="一段很长的后记"><a class="header" href="#一段很长的后记">一段很长的后记</a></h2>
<p>在拟定系列大纲时，本篇的原名为：<code>Java多线程系列--掌控面试，一文吃透锁</code>，然而写至 <code>JDK中的Lock接口</code> 时，
后知后觉的意识到将 <strong>不得不深入源码</strong> 并且涉及到 <code>AQS</code>，AQS的内容在大纲中已有单篇计划，展开则篇幅过长不利于阅读，不展开则实在无内容可写。</p>
<p>原章节内容权且作为 <strong>开端</strong> 、 <strong>引子</strong> 留于文末：</p>
<h3 id="jdk中的lock接口"><a class="header" href="#jdk中的lock接口">JDK中的Lock接口</a></h3>
<p>在Jdk1.5之后，存在Lock接口：</p>
<pre><code class="language-java">public interface Lock {
    //获取锁
    void lock();

    //获取锁，如果线程阻塞状态（未获取到而进入阻塞）被中断则抛出异常
    void lockInterruptibly() throws InterruptedException;

    //尝试获取锁
    boolean tryLock();

    //在给定时间内尝试获取锁，
    boolean tryLock(long var1, TimeUnit var3) throws InterruptedException;

    void unlock();

    Condition newCondition();
}
</code></pre>
<p>前四个API均为获取锁的API，<code>unlock</code> 释放锁，通过Condition提供线程通信能力. <em>Condition将在以后的文章中展开</em></p>
<p>有别于语言关键字 <code>synchronized</code> , 在使用角度上，Lock将需要使用者自行获取锁、释放锁。在内部实现上，区别于 <code>Monitor模式</code> ，增加了更丰富的功能：</p>
<ul>
<li>支持 <code>锁的公平性</code></li>
<li>获取 <code>当前线程调用lock的次数</code></li>
<li>获取 <code>等待锁的线程数</code></li>
<li>查询 <code>是否存在线程等待获取该锁</code></li>
<li>查询 <code>指定的线程是否在等待获取该锁</code></li>
<li>查询 <code>当前线程是否持有该锁</code></li>
<li>判断 <code>锁是否已被持有</code></li>
<li>加锁时如果中断则不加锁，抛出异常</li>
<li><code>尝试获取锁</code> 的机制，如果锁未被其他线程持有则成功，否则返回失败，不会直接进入阻塞</li>
</ul>
<p>很显然，<strong>限于目标和篇幅，这篇文章不会再和诸位读者一同探索源码</strong>，写至此处，我意识到真的无法做到标题中说的："一篇文章吃透锁"。
JDK中还有锁实现，例如常用的：</p>
<ul>
<li>ReentrantLock</li>
<li>ReadWriteLock，一般使用实现类 <code>ReentrantReadWriteLock</code></li>
</ul>
<p><em>作者按：一旦开始深入，将势必谈及AQS，按照计划，这将于后续文章中展开，故本篇不再展开。望读者见谅</em></p>
<h3 id="真正的后记"><a class="header" href="#真正的后记">真正的后记</a></h3>
<p>这一篇又断断续续写了超过一周，期间我也一度怀疑，这个系列要不要继续下去，对于读者而言，买本书钻研可能是比看本系列更加实在的行为，<code>勘校后的知识准确性</code> 、 <code>文字的准确性</code> 、
<code>表达的结构性</code> 都更胜一筹，博客仅能靠碎片化特性占点便宜。</p>
<p>但一件事情坚定了我将它写下去的信念，我翻看了往年的博客，清晰的意识到：</p>
<ul>
<li>将脑海中的知识，整理后再做 <code>结构化的输出</code> ，可以牢靠地掌握这些知识，并且在任意时刻都可以完成流畅的表达</li>
<li>通过对比，清晰的看到自己的成长</li>
<li>文字功力可以通过锻炼得到长足提升</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../MultiThreading/post_37.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../MultiThreading/post_39.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../MultiThreading/post_37.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../MultiThreading/post_39.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
