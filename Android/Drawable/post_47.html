<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>迟来的续集--Drawable+Animator，将优雅进行到底 - leobert&#x27;s blog</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">目录</li><li class="chapter-item expanded "><a href="../../Android/index.html"><strong aria-hidden="true">1.</strong> Android</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Android/View/index.html"><strong aria-hidden="true">1.1.</strong> View</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Android/View/post_1.html"><strong aria-hidden="true">1.1.1.</strong> 好玩系列：优雅的处理ButterKnife和KAE被废弃</a></li><li class="chapter-item expanded "><a href="../../Android/View/post_6.html"><strong aria-hidden="true">1.1.2.</strong> 三思系列：View体系认知(一)，内容是如何正确被展现出来的--视觉呈现概览</a></li><li class="chapter-item expanded "><a href="../../Android/View/post_7.html"><strong aria-hidden="true">1.1.3.</strong> 三思系列：为什么自定义View</a></li><li class="chapter-item expanded "><a href="../../Android/Idea/post_9.html"><strong aria-hidden="true">1.1.4.</strong> 三思系列："声明式UI"和"命令式UI"，你的理解可能是错的</a></li></ol></li><li class="chapter-item expanded "><a href="../../Android/Drawable/index.html"><strong aria-hidden="true">1.2.</strong> Drawable</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Android/Drawable/post_2.html"><strong aria-hidden="true">1.2.1.</strong> 三思系列：重新认识Drawable</a></li><li class="chapter-item expanded "><a href="../../Android/Drawable/post_4.html"><strong aria-hidden="true">1.2.2.</strong> 好玩系列：拥有它，XML文件少一半--更方便的处理View背景</a></li><li class="chapter-item expanded "><a href="../../Android/Drawable/post_47.html" class="active"><strong aria-hidden="true">1.2.3.</strong> 迟来的续集--Drawable+Animator，将优雅进行到底</a></li><li class="chapter-item expanded "><a href="../../Android/Drawable/post_49.html"><strong aria-hidden="true">1.2.4.</strong> 好玩系列：让ImageSpan动起来</a></li></ol></li><li class="chapter-item expanded "><a href="../../Android/Mechanism/Message/index.html"><strong aria-hidden="true">1.3.</strong> 消息机制</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Android/Mechanism/Message/post_8.html"><strong aria-hidden="true">1.3.1.</strong> 三思系列：Android的消息机制，一文吃透</a></li></ol></li><li class="chapter-item expanded "><a href="../../Android/Idea/post_14/index.html"><strong aria-hidden="true">1.4.</strong> 兼容</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Android/Idea/post_14.html"><strong aria-hidden="true">1.4.1.</strong> 好玩系列：让项目中的相册支持Heif格式图片</a></li></ol></li><li class="chapter-item expanded "><a href="../../Android/Glide/index.html"><strong aria-hidden="true">1.5.</strong> Glide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Android/Glide/post_15.html"><strong aria-hidden="true">1.5.1.</strong> 三思系列：Glide 4.X全方位认知 -- 模块职责概览</a></li><li class="chapter-item expanded "><a href="../../Android/Glide/post_16.html"><strong aria-hidden="true">1.5.2.</strong> 三思系列：Glide 4.X加载过程一文掌握 | Glide（二）</a></li></ol></li><li class="chapter-item expanded "><a href="../../Android/KSP/index.html"><strong aria-hidden="true">1.6.</strong> KSP</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Android/KSP/post_24.html"><strong aria-hidden="true">1.6.1.</strong> 好玩系列 | 拥抱Kotlin Symbol Processing(KSP),项目实战</a></li></ol></li><li class="chapter-item expanded "><a href="../../Android/Base/index.html"><strong aria-hidden="true">1.7.</strong> 基础</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Android/Base/post_35.html"><strong aria-hidden="true">1.7.1.</strong> 孔乙己：你可知道页面和弹窗“通信“的方式有四种？</a></li></ol></li><li class="chapter-item expanded "><a href="../../Android/SysApp/index.html"><strong aria-hidden="true">1.8.</strong> 系统APP</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Android/SysApp/post_52.html"><strong aria-hidden="true">1.8.1.</strong> 使用日历丰富产品的用户体验</a></li></ol></li><li class="chapter-item expanded "><a href="../../Android/DI/index.html"><strong aria-hidden="true">1.9.</strong> Part4-依赖注入部分</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Android/DI/post_53.html"><strong aria-hidden="true">1.9.1.</strong> Hilt进阶--一文吃透Hilt自定义与跨壁垒</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../Compose/index.html"><strong aria-hidden="true">2.</strong> Jetpack Compose</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Compose/post_21.html"><strong aria-hidden="true">2.1.</strong> Jetpack Compose | 一文理解神奇的Modifier</a></li><li class="chapter-item expanded "><a href="../../Compose/post_26.html"><strong aria-hidden="true">2.2.</strong> Jetpack Compose | 控件篇（一） -- Text、TextField、Button</a></li><li class="chapter-item expanded "><a href="../../Compose/post_27.html"><strong aria-hidden="true">2.3.</strong> Jetpack Compose | 控件篇（二） -- Icon，Image</a></li><li class="chapter-item expanded "><a href="../../Compose/post_28.html"><strong aria-hidden="true">2.4.</strong> Jetpack Compose | 控件篇（三） -- Switch、CheckBox、RadioButton</a></li><li class="chapter-item expanded "><a href="../../Compose/post_29.html"><strong aria-hidden="true">2.5.</strong> Jetpack Compose | 控件篇（四）-- Box、Row、Column</a></li><li class="chapter-item expanded "><a href="../../Compose/post_30.html"><strong aria-hidden="true">2.6.</strong> Jetpack Compose | 控件篇（五）-- Spacer、LazyRow、LazyColumn & 让Column可滑动</a></li></ol></li><li class="chapter-item expanded "><a href="../../MultiThreading/index.html"><strong aria-hidden="true">3.</strong> Java多线程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../MultiThreading/post_33.html"><strong aria-hidden="true">3.1.</strong> 总纲</a></li><li class="chapter-item expanded "><a href="../../MultiThreading/post_37.html"><strong aria-hidden="true">3.2.</strong> Java基础--图解JVM内存模型和JVM线程模型</a></li><li class="chapter-item expanded "><a href="../../MultiThreading/post_38.html"><strong aria-hidden="true">3.3.</strong> Java多线程系列--掌控面试，一文吃透Synchronized锁</a></li><li class="chapter-item expanded "><a href="../../MultiThreading/post_39.html"><strong aria-hidden="true">3.4.</strong> Java多线程基础--线程生命周期与线程协作详解</a></li><li class="chapter-item expanded "><a href="../../MultiThreading/post_42.html"><strong aria-hidden="true">3.5.</strong> Java多线程基础--线程的创建与线程池管理</a></li><li class="chapter-item expanded "><a href="../../MultiThreading/post_46.html"><strong aria-hidden="true">3.6.</strong> Java多线程系列--掌握Future，轻松获取异步任务结果</a></li><li class="chapter-item expanded "><a href="../../MultiThreading/post_50.html"><strong aria-hidden="true">3.7.</strong> Java多线程系列--Fork&Join框架，分治的艺术</a></li><li class="chapter-item expanded "><a href="../../MultiThreading/post_54.html"><strong aria-hidden="true">3.8.</strong> Java多线程系列--掌握CompletableFuture，驾驭异步编程</a></li></ol></li><li class="chapter-item expanded "><a href="../../IO/index.html"><strong aria-hidden="true">4.</strong> Java IO系列</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../IO/post_55.html"><strong aria-hidden="true">4.1.</strong> Java IO 系列总纲</a></li><li class="chapter-item expanded "><a href="../../IO/post_56.html"><strong aria-hidden="true">4.2.</strong> Java IO系列 | 经典 IO</a></li><li class="chapter-item expanded "><a href="../../IO/post_57.html"><strong aria-hidden="true">4.3.</strong> Java IO 系列 | NIO-1.0一文速览</a></li><li class="chapter-item expanded "><a href="../../IO/post_58.html"><strong aria-hidden="true">4.4.</strong> Java IO系列 | NIO-1.0拾遗、NIO-2.0 & 零拷贝必吹的牛皮</a></li><li class="chapter-item expanded "><a href="../../IO/post_59.html"><strong aria-hidden="true">4.5.</strong> IO系列 | 一文掌握OKHTTP中的OKIO为什么这么OK</a></li></ol></li><li class="chapter-item expanded "><a href="../../Gradle/index.html"><strong aria-hidden="true">5.</strong> Gradle</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Gradle/Modularization/post_18.html"><strong aria-hidden="true">5.1.</strong> 组件化：三思系列：组件化场景下module依赖优雅实践方案</a></li><li class="chapter-item expanded "><a href="../../Gradle/Publish/post_17.html"><strong aria-hidden="true">5.2.</strong> MavenCentral发布：迁移到MavenCentral--再不行动起来，你的托管的library就没了</a></li><li class="chapter-item expanded "><a href="../../Gradle/post_22.html"><strong aria-hidden="true">5.3.</strong> Gradle | 依赖管理最佳实践</a></li></ol></li><li class="chapter-item expanded "><a href="../../Groovy/index.html"><strong aria-hidden="true">6.</strong> Groovy</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Groovy/why_write_groovy.html"><strong aria-hidden="true">6.1.</strong> 为什么撰写这个系列</a></li><li class="chapter-item expanded "><a href="../../Groovy/post_23.html"><strong aria-hidden="true">6.2.</strong> Groovy：MOP一文打尽</a></li></ol></li><li class="chapter-item expanded "><a href="../../Review/index.html"><strong aria-hidden="true">7.</strong> Review</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Review/post_10.html"><strong aria-hidden="true">7.1.</strong> 造完了这个轮子--Mocker，却让我感到很羞愧|项目复盘</a></li><li class="chapter-item expanded "><a href="../../Review/post_40.html"><strong aria-hidden="true">7.2.</strong> 三思系列：前人用GreenDao留下的坑，全线被扣了绩效</a></li><li class="chapter-item expanded "><a href="../../Review/post_44.html"><strong aria-hidden="true">7.3.</strong> 谈一谈在两个商业项目中使用MVI架构后的感悟</a></li><li class="chapter-item expanded "><a href="../../Review/post_45.html"><strong aria-hidden="true">7.4.</strong> Review | 这三个坑你遇到了吗？</a></li></ol></li><li class="chapter-item expanded "><a href="../../repo/index.html"><strong aria-hidden="true">8.</strong> 个人项目</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../repo/DaVinCi.html"><strong aria-hidden="true">8.1.</strong> DaVinCi,取代XML编写Shape或ColorStateList的方案</a></li><li class="chapter-item expanded "><a href="../../Android/Idea/post_32.html"><strong aria-hidden="true">8.2.</strong> 好玩系列：白嫖一个优雅的类图生成工具</a></li><li class="chapter-item expanded "><a href="../../Speculative/post_43.html"><strong aria-hidden="true">8.3.</strong> 初体验：动手搭建"小清新式"局域网文档系统</a></li><li class="chapter-item expanded "><a href="../../repo/post_48.html"><strong aria-hidden="true">8.4.</strong> 研究良久，终于发现了他代码写的快且bug少的原因</a></li><li class="chapter-item expanded "><a href="../../Speculative/post_61.html"><strong aria-hidden="true">8.5.</strong> 好玩系列 | 如果后端让你用SSE接收多次返回，那我们改造Retrofit吧</a></li></ol></li><li class="chapter-item expanded "><a href="../../Review/DataStructure/index.html"><strong aria-hidden="true">9.</strong> 数据结构</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Review/DataStructure/post_11.html"><strong aria-hidden="true">9.1.</strong> 温故：线性表</a></li><li class="chapter-item expanded "><a href="../../Review/DataStructure/post_12.html"><strong aria-hidden="true">9.2.</strong> 温故：栈</a></li><li class="chapter-item expanded "><a href="../../Review/DataStructure/post_13.html"><strong aria-hidden="true">9.3.</strong> 温故：队列</a></li></ol></li><li class="chapter-item expanded "><a href="../../Review/README2.html"><strong aria-hidden="true">10.</strong> 年终总结&计划</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Review/post_36.html"><strong aria-hidden="true">10.1.</strong> 2021年终总结</a></li><li class="chapter-item expanded "><a href="../../Review/post_51.html"><strong aria-hidden="true">10.2.</strong> 关于画一个句号--基于2022年终总结的反思与分享</a></li><li class="chapter-item expanded "><a href="../../Review/post_60.html"><strong aria-hidden="true">10.3.</strong> 突如其来的秋季反思</a></li><li class="chapter-item expanded "><a href="../../Review/post_63.html"><strong aria-hidden="true">10.4.</strong> 2023年总结 寻找到源于内心深处的无穷力量</a></li><li class="chapter-item expanded "><a href="../../Review/post_64.html"><strong aria-hidden="true">10.5.</strong> 2024年中思考，推倒樊笼重新出发</a></li></ol></li><li class="chapter-item expanded "><a href="../../Note/index.html"><strong aria-hidden="true">11.</strong> 读书笔记</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Note/post_41.html"><strong aria-hidden="true">11.1.</strong> 读书笔记：《简约至上--交互式设计四策略》</a></li></ol></li><li class="chapter-item expanded "><a href="../../Talk/index.html"><strong aria-hidden="true">12.</strong> 杂谈</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Talk/talk_1.html"><strong aria-hidden="true">12.1.</strong> 杂谈1-2022-11</a></li><li class="chapter-item expanded "><a href="../../Talk/talk_2_2023-03.html"><strong aria-hidden="true">12.2.</strong> 杂篇（二）-- 认识并战胜焦虑</a></li><li class="chapter-item expanded "><a href="../../Talk/talk_3_2024-08.html"><strong aria-hidden="true">12.3.</strong> 杂谈（三）-- 向钱看，你需要想明白企业在为什么而付钱</a></li></ol></li><li class="chapter-item expanded "><a href="../../Thought/index.html"><strong aria-hidden="true">13.</strong> 半成熟的思考</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Thought/post_62.html"><strong aria-hidden="true">13.1.</strong> 好玩系列 | 当SPI 和 设计模式、依赖注入发生碰撞，可以擦出怎样的火花</a></li></ol></li><li class="chapter-item expanded "><a href="../../info/index.html"><strong aria-hidden="true">14.</strong> 系列说明</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../info/about_view_series.html"><strong aria-hidden="true">14.1.</strong> 关于View系列</a></li><li class="chapter-item expanded "><a href="../../info/about_sansi_series.html"><strong aria-hidden="true">14.2.</strong> 关于三思系列</a></li><li class="chapter-item expanded "><a href="../../info/about_haowan_series.html"><strong aria-hidden="true">14.3.</strong> 关于好玩系列</a></li><li class="chapter-item expanded "><a href="../../info/about_wengu_series.html"><strong aria-hidden="true">14.4.</strong> 关于温故系列</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">leobert&#x27;s blog</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="迟来的续集--drawableanimator将优雅进行到底"><a class="header" href="#迟来的续集--drawableanimator将优雅进行到底">迟来的续集--Drawable+Animator，将优雅进行到底</a></h1>
<h2 id="前言"><a class="header" href="#前言">前言</a></h2>
<p>2021年初，读过一篇关于splash页面动效的推送文章，作者讲解了如何实现一个闪屏页效果：</p>
<blockquote>
<p>将一个英文单词拆分为多个字母，散落在屏幕中，然后按照一定的路径回归，最终展示一段流光效果。</p>
<p>通过自定义View的方式予以实现。</p>
</blockquote>
<p>当时我脑中闪过一个念头：他的实现很棒，但如果不需要点触、手势交互，使用Drawable实现更好。并由此编写了一篇文章：<a href="https://juejin.cn/post/6924240361317466125">三思系列：重新认识Drawable</a>
, 并在不久之后通过 <a href="https://juejin.cn/post/6934222774139518984">三思系列：为什么要自定义View</a> 一文阐释了对于 "自定义View适用场景" 的个人拙见。</p>
<p>简单通过思维导图回顾 <a href="https://juejin.cn/post/6924240361317466125">三思系列：重新认识Drawable</a> 一文的内容：
<img src="./post_2/Drawable_guide.png" alt="" /></p>
<p><em>阅读原文大约需要10-15分钟</em></p>
<p>文中，我们最终以该方案实现了 "自定义一个动画Drawable" ： <code>unscheduleSelf()</code> / <code>scheduleSelf()</code> 机制 <code>停止回调/设置定时回调</code> + <code>invalidateSelf()</code> 机制进行刷新绘制；
方案的本质是 <strong>在预设时间点绘制关键帧</strong> 。仔细观察后不难发现问题：<strong>效果并不顺滑</strong> 。效果如下：</p>
<img width="216" height="384" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e60cc97c4b04c9a9c520b955f76fbae~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp"/>
<p>视频：<a href="https://github.com/leobert-lan/Blog/blob/main/Android/Drawable/post_2/version_5.webm">链接</a></p>
<p>彼时，文章的主旨为重新认识Drawable，<strong>并未对此展开讨论并进一步优化</strong>。 本篇文章作为迟来的续集，将会 <strong>对问题展开讨论、探索优化方案、追究原理、并进一步拓宽思路</strong>。按照此方式展开将迎来久违的三思系列。</p>
<p><a href="https://leobert-lan.github.io/info/about_sansi_series.html">关于三思系列</a></p>
<h2 id="思危问题本质"><a class="header" href="#思危问题本质">思危：问题本质</a></h2>
<p>上文已经提到，我们通过 <code>unscheduleSelf()</code> / <code>scheduleSelf()</code> 机制 停止回调/设置定时回调，重新绘制关键帧。那么 <code>scheduleSelf()</code> 的本质又是什么？</p>
<p>阅读代码可知，源码中通过接口回调的设计，将功能的实现剥离：</p>
<pre><code class="language-java">class Drawable {
    public void scheduleSelf(@NonNull Runnable what, long when) {
        final Callback callback = getCallback();
        if (callback != null) {
            callback.scheduleDrawable(this, what, when);
        }
    }

    public final void setCallback(@Nullable Callback cb) {
        mCallback = cb != null ? new WeakReference&lt;&gt;(cb) : null;
    }

    @Nullable
    public Callback getCallback() {
        return mCallback != null ? mCallback.get() : null;
    }

    public interface Callback {
        void invalidateDrawable(@NonNull Drawable who);

        void scheduleDrawable(@NonNull Drawable who, @NonNull Runnable what, long when);

        void unscheduleDrawable(@NonNull Drawable who, @NonNull Runnable what);
    }
}
</code></pre>
<p>继续寻找 <code>Callback</code> 实现类：<em>重点关注 scheduleDrawable 即可</em></p>
<pre><code class="language-java">public class View implements Drawable.Callback {
    public void invalidateDrawable(@NonNull Drawable drawable) {
        if (verifyDrawable(drawable)) {
            final Rect dirty = drawable.getDirtyBounds();
            final int scrollX = mScrollX;
            final int scrollY = mScrollY;

            invalidate(dirty.left + scrollX, dirty.top + scrollY,
                    dirty.right + scrollX, dirty.bottom + scrollY);
            rebuildOutline();
        }
    }

    //看这里
    public void scheduleDrawable(@NonNull Drawable who, @NonNull Runnable what, long when) {
        if (verifyDrawable(who) &amp;&amp; what != null) {
            final long delay = when - SystemClock.uptimeMillis();
            if (mAttachInfo != null) {
                mAttachInfo.mViewRootImpl.mChoreographer.postCallbackDelayed(
                        Choreographer.CALLBACK_ANIMATION, what, who,
                        Choreographer.subtractFrameDelay(delay));
            } else {
                // Postpone the runnable until we know
                // on which thread it needs to run.
                getRunQueue().postDelayed(what, delay);
            }
        }
    }

    public void unscheduleDrawable(@NonNull Drawable who, @NonNull Runnable what) {
        if (verifyDrawable(who) &amp;&amp; what != null) {
            if (mAttachInfo != null) {
                mAttachInfo.mViewRootImpl.mChoreographer.removeCallbacks(
                        Choreographer.CALLBACK_ANIMATION, what, who);
            }
            getRunQueue().removeCallbacks(what);
        }
    }

    public void unscheduleDrawable(Drawable who) {
        if (mAttachInfo != null &amp;&amp; who != null) {
            mAttachInfo.mViewRootImpl.mChoreographer.removeCallbacks(
                    Choreographer.CALLBACK_ANIMATION, null, who);
        }
    }

}
</code></pre>
<p>简单解释程序逻辑如下：如果 "该Drawable作用于自身" 且 "Runnable非空"，计算回调的delay，如果View已经添加到Window，则交给Choreographer，否则丢入缓存队列。</p>
<p>而缓存队列的内容将在View添加到Window时交给 <code>Choreographer</code></p>
<pre><code class="language-java">public class View {
    void dispatchAttachedToWindow(AttachInfo info, int visibility) {
        //ignore

        // Transfer all pending runnables.
        if (mRunQueue != null) {
            mRunQueue.executeActions(info.mHandler);
            mRunQueue = null;
        }

        //ignore
    }
}
</code></pre>
<blockquote>
<p>读者诸君，如果您熟悉Android的 <code>屏幕刷新机制</code> 和 <code>消息机制</code> ，一定不会对 <code>Choreographer</code> 感到陌生</p>
</blockquote>
<p>Choreographer 直译为编舞者，暗含了 "编制视图变化效果" 的隐喻，其本质依旧是利用 VSync+Handler消息机制。<strong>delay Callback的设计存在毫秒级的误差</strong>。</p>
<p><em>作者按：本篇不再展开讨论Android的消息机制，以下仅给出 <code>基于消息机制的界面绘制设计</code> 关键部分流程图：</em></p>
<p><img src="./post_47/ui_msg_img.png" alt="img.png" /></p>
<p>结合前面的代码分析，<code>scheduleDrawable</code> 的流程可以参考此图理解。</p>
<p><em>作者按，虽然仍有差异，但机制一致，可参考理解</em></p>
<h3 id="验证"><a class="header" href="#验证">验证</a></h3>
<blockquote>
<p>Talk is cheap, show you the code</p>
</blockquote>
<p>在 <code>View</code> 中有一段代码和 <code>scheduleDrawable</code> 高度相似：</p>
<pre><code class="language-java">class View {
    public void postOnAnimationDelayed(Runnable action, long delayMillis) {
        final AttachInfo attachInfo = mAttachInfo;
        if (attachInfo != null) {
            attachInfo.mViewRootImpl.mChoreographer.postCallbackDelayed(
                    Choreographer.CALLBACK_ANIMATION, action, null, delayMillis);
        } else {
            // Postpone the runnable until we know
            // on which thread it needs to run.
            getRunQueue().postDelayed(action, delayMillis);
        }
    }
}
</code></pre>
<p>注意：<code>scheduleDrawable</code> 基于执行的目标时间 <code>when</code>，和当前系统时钟计算了delay，又额外调整了delay时间, <code>Choreographer.subtractFrameDelay(delay)</code>，_
它是隐藏API_</p>
<pre><code class="language-java">public final class Choreographer {
    private static final long DEFAULT_FRAME_DELAY = 10;
    // The number of milliseconds between animation frames.
    private static volatile long sFrameDelay = DEFAULT_FRAME_DELAY;

    public static long subtractFrameDelay(long delayMillis) {
        final long frameDelay = sFrameDelay;
        return delayMillis &lt;= frameDelay ? 0 : delayMillis - frameDelay;
    }
}
</code></pre>
<p>设计一个简单的验证代码：</p>
<pre><code class="language-kotlin">class Demo {
    //...

    fun test() {
        val btn = findViewById&lt;Button&gt;(R.id.btn)
        var index = 0
        var s = System.currentTimeMillis()

        val action: Runnable = object : Runnable {
            override fun run() {
                Log.e("lmsg", "$index, offset time ${System.currentTimeMillis() - s - index * 30}")
                index++
                if (index &lt; 100) {
                    btn.postOnAnimationDelayed(
                        this,
                        30L - 10L /*hide api:android.view.Choreographer#subtractFrameDelay*/
                    )
                } else {
                    Log.e("lmsg", "finish, total time ${System.currentTimeMillis() - s}")

                }
            }
        }

        btn.setOnClickListener {
            index = 0
            s = System.currentTimeMillis()
            it.postOnAnimationDelayed(action, 0L)
        }
    }
}
</code></pre>
<p>参考一下结果：<em>注意执行结果不会幂等，但整体表现为超出预期时长</em></p>
<p><img src="./post_47/result_1.png" alt="" /></p>
<h2 id="思退使用animator改进"><a class="header" href="#思退使用animator改进">思退：使用Animator改进</a></h2>
<p>Android 在 <code>Android 3.0，API11</code> 中提供了更强大的动画 <code>Animator</code>，借助其中的 <code>ValueAnimator</code>，可以很方便的 <code>编排</code> 动画。</p>
<p><em>即便尚未分析原理，只要使用过属性动画，也知道它具有非常丝滑的效果</em></p>
<p>以上还都是推测，接下来进行实测。</p>
<h3 id="实现"><a class="header" href="#实现">实现</a></h3>
<p>刨去一致部分，我们需要完成以下两点：</p>
<ul>
<li>创建 <code>ValueAnimator</code> 实例，并按照动画需求设置 <code>时长</code>、<code>插值器</code>、<code>UpdateListener</code> 等</li>
<li>若没有额外需要，可将 <code>Animatable2</code> 弱化为 <code>Animatable</code>，仅保留动画控制API，通过 <code>ValueAnimator</code> 实例委托实现API业务逻辑。</li>
</ul>
<p>核心代码如下： <em>完整代码可从github获取：<a href="https://github.com/leobert-lan/DrawableWorkShop">DrawableWorkShop</a></em></p>
<pre><code class="language-kotlin">class AnimLetterDrawable2 : Drawable(), Animatable {
    // 相似部分略去

    private val totalFrames = 30 * 3 //3 second, 30frames per second

    private val valueAnimator = ValueAnimator.ofInt(totalFrames).apply {
        duration = 3000L

        this.interpolator = LinearInterpolator()

        addUpdateListener {
            setFrame(it.animatedValue as Int)
        }
    }

    private var frameIndex = 0


    private fun setFrame(frame: Int) {
        if (frame &gt;= totalFrames) {
            return
        }
        frameIndex = frame
        invalidateSelf()
    }

    override fun start() {
        Log.d(tag, "start called")
        valueAnimator.start()
    }

    override fun stop() {
        valueAnimator.cancel()
        setFrame(0)
    }

    override fun isRunning(): Boolean {
        return valueAnimator.isRunning
    }

}
</code></pre>
<h3 id="效果和关键代码对比"><a class="header" href="#效果和关键代码对比">效果和关键代码对比</a></h3>
<img width="216" height="384" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f38dfc6780fd45c38edccc91fcd6d0ea~tplv-k3u1fbpfcp-watermark.image?"/>
<p>gif的效果太差，可以在 <a href="https://github.com/leobert-lan/DrawableWorkShop/blob/main/DrawableWorkShop/animator%E6%95%88%E6%9E%9C.webm">github项目仓库</a>
中获取 webm视频</p>
<p>关键代码差异：</p>
<p>在原方案中，我们计算了下一帧的播放时间点，借助 <code>scheduleSelf</code> -&gt; <code>View#scheduleDrawable</code> 进行了刷新</p>
<pre><code class="language-kotlin">class AnimLetterDrawable {
    private fun setFrame(frame: Int, unschedule: Boolean, animate: Boolean) {
        if (frame &gt;= totalFrames) {
            return
        }
        mAnimating = animate
        frameIndex = frame

        if (unschedule || animate) {
            unscheduleSelf(this)
        }
        if (animate) {
            // Unscheduling may have clobbered these values; restore them
            frameIndex = frame

            scheduleSelf(this, SystemClock.uptimeMillis() + durationPerFrame)
        }
        invalidateSelf()
    }
}
</code></pre>
<p>而新方案中，我们借助ValueAnimator的更新回调函数直接刷新，显示预定帧</p>
<pre><code class="language-kotlin">class AnimLetterDrawable2 {
    private val valueAnimator = ValueAnimator.ofInt(totalFrames).apply {
        duration = 3000L

        this.interpolator = LinearInterpolator()

        addUpdateListener {
            setFrame(it.animatedValue as Int)
        }
    }

    private fun setFrame(frame: Int) {
        if (frame &gt;= totalFrames) {
            return
        }
        frameIndex = frame
        invalidateSelf()
    }
}
</code></pre>
<h2 id="animator的原理"><a class="header" href="#animator的原理">Animator的原理</a></h2>
<p>此时，再来思索一番，为何 <code>Animator</code> 的实现效果明显丝滑呢？</p>
<blockquote>
<p>思危：是否和scheduleDrawable相比使用了不一样的底层机制？</p>
</blockquote>
<h3 id="源码跟进"><a class="header" href="#源码跟进">源码跟进</a></h3>
<p>单纯阅读文章内的代码会很枯燥，建议读者诸君对文中列出的源码进行泛读，抓住思路后再精读一遍源码。</p>
<p>以下将有6个关键点，可厘清其原理</p>
<ul>
<li>1，start方法 -- 找到动画被驱动的核心</li>
<li>2， AnimationHandler#addAnimationFrameCallback(AnimationFrameCallback)</li>
<li>3，<code>mAnimationCallbacks</code> 何时移除元素</li>
<li>4，<code>AnimationHandler#doAnimationFrame</code> 方法的逻辑</li>
<li>5，向前看，何人调用FrameCallback -- 驱动动画的底层逻辑</li>
<li>6，向后看，ValueAnimator#doAnimationFrame -- 丝滑的原因</li>
</ul>
<h4 id="1start方法"><a class="header" href="#1start方法">1，start方法</a></h4>
<pre><code class="language-java">class ValueAnimator {

    public void start() {
        start(false);
    }

    private void start(boolean playBackwards) {
        if (Looper.myLooper() == null) {
            throw new AndroidRuntimeException("Animators may only be run on Looper threads");
        }
        //略去一部分
        addAnimationCallback(0); //这里是核心

        if (mStartDelay == 0 || mSeekFraction &gt;= 0 || mReversing) {
            startAnimation();
            if (mSeekFraction == -1) {
                setCurrentPlayTime(0);
            } else {
                setCurrentFraction(mSeekFraction);
            }
        }
    }

    private void addAnimationCallback(long delay) {
        //startWithoutPulsing 才会return
        if (!mSelfPulse) {
            return;
        }
        getAnimationHandler().addAnimationFrameCallback(this, delay); //这里是核心
    }
}
</code></pre>
<p>简单阅读，可以排除掉 <code>startAnimation</code> <code>setCurrentPlayTime</code> <code>setCurrentFraction</code>，他们均不是动画回调的核心，只是在进行必要地初始化和FLAG状态维护。</p>
<p>真正的核心是：<code>getAnimationHandler().addAnimationFrameCallback(this, delay);</code></p>
<p>注意：AnimationHandler 存在线程单例设计:</p>
<pre><code class="language-java">
//使用方：
class ValueAnimator {
    public AnimationHandler getAnimationHandler() {
        return mAnimationHandler != null ? mAnimationHandler : AnimationHandler.getInstance();
    }
}

//ThreadLocal线程单例设计
class AnimationHandler {
    public final static ThreadLocal&lt;AnimationHandler&gt; sAnimatorHandler = new ThreadLocal&lt;&gt;();
    private boolean mListDirty = false;

    public static AnimationHandler getInstance() {
        if (sAnimatorHandler.get() == null) {
            sAnimatorHandler.set(new AnimationHandler());
        }
        return sAnimatorHandler.get();
    }
}
</code></pre>
<h4 id="2-animationhandleraddanimationframecallbackanimationframecallback"><a class="header" href="#2-animationhandleraddanimationframecallbackanimationframecallback">2, AnimationHandler#addAnimationFrameCallback(AnimationFrameCallback)</a></h4>
<p>方法逻辑中，有两处需要关注：</p>
<ul>
<li><strong>如果无 <code>AnimationFrameCallback</code> 回调实例</strong> ， <em>说明没有在运行中的动画</em> ，<strong>则挂载 <code>Choreographer.FrameCallback mFrameCallback</code></strong> ， 为更新动画（_
调用动画的AnimationFrameCallback回调接口_）做准备。</li>
<li><strong>在动画的 <code>AnimationFrameCallback</code> 回调实例未被注册的情况下</strong>，注册该回调实例</li>
</ul>
<p>看完这一段源码，读者诸君一定会对以下两点产生兴趣，我们在下文展开：</p>
<ul>
<li><code>doAnimationFrame</code> 方法的逻辑</li>
<li><code>mAnimationCallbacks</code> 何时移除元素</li>
</ul>
<p>先看源码：</p>
<pre><code class="language-java">public class AnimationHandler {
    private final Choreographer.FrameCallback mFrameCallback = new Choreographer.FrameCallback() {
        @Override
        public void doFrame(long frameTimeNanos) {
            doAnimationFrame(getProvider().getFrameTime());

            //这不就破案了，只要还有动画的 AnimationFrameCallback，就挂载 mFrameCallback

            if (mAnimationCallbacks.size() &gt; 0) {
                getProvider().postFrameCallback(this);
            }
        }
    };

    private AnimationFrameCallbackProvider getProvider() {
        if (mProvider == null) {
            mProvider = new MyFrameCallbackProvider();
        }
        return mProvider;
    }

    public void addAnimationFrameCallback(final AnimationFrameCallback callback, long delay) {
        if (mAnimationCallbacks.size() == 0) {
            getProvider().postFrameCallback(mFrameCallback);
        }
        if (!mAnimationCallbacks.contains(callback)) {
            mAnimationCallbacks.add(callback);
        }

        //注意，delay为0，阅读时可以忽略这段逻辑
        if (delay &gt; 0) {
            mDelayedCallbackStartTime.put(callback, (SystemClock.uptimeMillis() + delay));
        }
    }
}
</code></pre>
<h4 id="3manimationcallbacks-何时移除元素"><a class="header" href="#3manimationcallbacks-何时移除元素">3，<code>mAnimationCallbacks</code> 何时移除元素</a></h4>
<p>AnimationHandler中 "清理" <code>mAnimationCallbacks</code> 的设计 : 先设置null，再择机集中清理null，维护链表结构。<em>可以避免循环过程中移除元素带来的潜在bug、以及避免频繁调整链表空间带来的损耗</em></p>
<p>关键代码为：<code>android.animation.AnimationHandler#removeCallback</code>，它有两处调用点，看完下面这一段源码后再行分析。</p>
<pre><code class="language-java">class AnimationHandler {
    public void removeCallback(AnimationFrameCallback callback) {
        mCommitCallbacks.remove(callback);
        mDelayedCallbackStartTime.remove(callback);
        int id = mAnimationCallbacks.indexOf(callback);
        if (id &gt;= 0) {
            mAnimationCallbacks.set(id, null);
            mListDirty = true;
        }
    }

    private void cleanUpList() {
        if (mListDirty) {
            for (int i = mAnimationCallbacks.size() - 1; i &gt;= 0; i--) {
                if (mAnimationCallbacks.get(i) == null) {
                    mAnimationCallbacks.remove(i);
                }
            }
            mListDirty = false;
        }
    }
}
</code></pre>
<p><code>removeCallback</code> 存在一个直接调用，进而可找到两个间接调用点：</p>
<ul>
<li><code>endAnimation</code> 停止动画时, 主动停止以及计算出动画已结束</li>
<li><code>doAnimationFrame</code> 中发现动画已经被暂停</li>
</ul>
<p><em>再看一下源码：</em></p>
<pre><code class="language-java">class ValueAnimator {
    private void removeAnimationCallback() {
        if (!mSelfPulse) {
            return;
        }
        //直接调用-1
        getAnimationHandler().removeCallback(this);
    }

    private void endAnimation() {
        if (mAnimationEndRequested) {
            return;
        }
        //间接调用-1
        removeAnimationCallback();
        //略去
    }

    public final boolean doAnimationFrame(long frameTime) {
        if (mStartTime &lt; 0) {
            // First frame. If there is start delay, start delay count down will happen *after* this
            // frame.
            mStartTime = mReversing
                    ? frameTime
                    : frameTime + (long) (mStartDelay * resolveDurationScale());
        }

        // Handle pause/resume
        if (mPaused) {
            mPauseTime = frameTime;
            //间接调用-2
            removeAnimationCallback();
            return false;
        }
        //略
    }
}
</code></pre>
<h4 id="4animationhandlerdoanimationframe-方法的逻辑"><a class="header" href="#4animationhandlerdoanimationframe-方法的逻辑">4，<code>AnimationHandler#doAnimationFrame</code> 方法的逻辑</a></h4>
<p>一共有三个业务目的：</p>
<ul>
<li>筛选，调用回调</li>
<li>处理 CommitCallback 情况</li>
<li>清理 <code>mAnimationCallbacks</code> 详见3</li>
</ul>
<pre><code class="language-java">class AnimationHandler {
    private void doAnimationFrame(long frameTime) {
        long currentTime = SystemClock.uptimeMillis();
        final int size = mAnimationCallbacks.size();
        for (int i = 0; i &lt; size; i++) {
            final AnimationFrameCallback callback = mAnimationCallbacks.get(i);

            // `为何会有null？` 请看3 `mAnimationCallbacks` 何时移除元素
            if (callback == null) {
                continue;
            }

            //如果是延迟执行的callback，在未到预定时间时为false
            if (isCallbackDue(callback, currentTime)) {

                // 回调，实际逻辑：android.animation.ValueAnimator#doAnimationFrame
                callback.doAnimationFrame(frameTime);

                // 此处值得再写一篇文章
                if (mCommitCallbacks.contains(callback)) {
                    getProvider().postCommitCallback(new Runnable() {
                        @Override
                        public void run() {
                            commitAnimationFrame(callback, getProvider().getFrameTime());
                        }
                    });
                }
            }
        }
        cleanUpList();
    }

    private void commitAnimationFrame(AnimationFrameCallback callback, long frameTime) {
        if (!mDelayedCallbackStartTime.containsKey(callback) &amp;&amp;
                mCommitCallbacks.contains(callback)) {
            callback.commitAnimationFrame(frameTime);
            mCommitCallbacks.remove(callback);
        }
    }
}
</code></pre>
<blockquote>
<p>作者按：值得一提的是，AnimationHandler中定义了所谓的 <code>OneShotCommitCallback</code> ，均添加到 <code>mCommitCallbacks</code>中。</p>
<p>ValueAnimator 中曾利用它调整动画起始帧回调</p>
<p>SDK 24 、25 中明确存在，从26直至32均未发现使用。注意，我此次翻阅源码时较为粗略，仍需详查 <code>android.animation.ValueAnimator#addOneShotCommitCallback</code> 方可定论，如有谬误还请读者指出，避免误导。</p>
</blockquote>
<h4 id="5向前看何人调用framecallback"><a class="header" href="#5向前看何人调用framecallback">5，向前看，何人调用FrameCallback</a></h4>
<p>跟进 <code>getProvider().postFrameCallback(mFrameCallback);</code> 发现是暗度陈仓</p>
<pre><code class="language-java">class AnimationHandler {
    private AnimationFrameCallbackProvider getProvider() {
        if (mProvider == null) {
            mProvider = new MyFrameCallbackProvider();
        }
        return mProvider;
    }

    private class MyFrameCallbackProvider implements AnimationFrameCallbackProvider {

        final Choreographer mChoreographer = Choreographer.getInstance();

        @Override
        public void postFrameCallback(Choreographer.FrameCallback callback) {
            mChoreographer.postFrameCallback(callback);
        }

        @Override
        public void postCommitCallback(Runnable runnable) {
            mChoreographer.postCallback(Choreographer.CALLBACK_COMMIT, runnable, null);
        }

        @Override
        public long getFrameTime() {
            return mChoreographer.getFrameTime();
        }

        @Override
        public long getFrameDelay() {
            return Choreographer.getFrameDelay();
        }

        @Override
        public void setFrameDelay(long delay) {
            Choreographer.setFrameDelay(delay);
        }
    }
}
</code></pre>
<p>又见 <code>Choreographer</code> ，这回应该不陌生了，跟进代码：</p>
<pre><code class="language-java">class Choreographer {
    public void postFrameCallback(FrameCallback callback) {
        postFrameCallbackDelayed(callback, 0);
    }

    public void postFrameCallbackDelayed(FrameCallback callback, long delayMillis) {
        if (callback == null) {
            throw new IllegalArgumentException("callback must not be null");
        }

        postCallbackDelayedInternal(CALLBACK_ANIMATION,
                callback, FRAME_CALLBACK_TOKEN, delayMillis);
    }
}
</code></pre>
<p>值得注意的是：此次使用的是：<code>CALLBACK_ANIMATION</code></p>
<p><code>Choreographer</code> 中将Callback一共 <strong>分为5类</strong></p>
<ul>
<li>CALLBACK_INPUT = 0;</li>
<li>CALLBACK_ANIMATION = 1;</li>
<li>CALLBACK_INSETS_ANIMATION = 2;</li>
<li>CALLBACK_TRAVERSAL = 3;</li>
<li>CALLBACK_COMMIT = 4;</li>
</ul>
<p>回调时的顺序也是如此。</p>
<p>读者诸君可还记得前文给出的 <code>基于消息机制处理UI绘制</code> 的关键流程图？其中多次出现关键字样：<code>TRAVERSAL</code>，对应此处的 <code>CALLBACK_TRAVERSAL</code>，它负责界面布局和绘制相关的业务。</p>
<p>而在上文 <code>View#scheduleDrawable</code> 的分析中，发现它使用的类型为：<code>Choreographer.CALLBACK_ANIMATION</code>，<strong>和 Animator 是一致的！</strong></p>
<blockquote>
<p>至此，我们悬着的心可以放下，Animator 和 View#scheduleDrawable 相比，使用了同样的底层机制</p>
</blockquote>
<p>但是我们的疑问尚未得到答案，再顺着整个流程向后看。</p>
<h4 id="6向后看valueanimatordoanimationframe"><a class="header" href="#6向后看valueanimatordoanimationframe">6，向后看，ValueAnimator#doAnimationFrame</a></h4>
<p><em>作者按，以API25之后的源码解析，以下源码为API30，注意24之前、24&amp;25，均存在差异，主要体现为首帧的开始。省略部分不重要的源码细节</em></p>
<p><em>不难发现，重点部分为：<code>animateBasedOnTime(currentTime)</code></em></p>
<pre><code class="language-java">class ValueAnimator {
    public final boolean doAnimationFrame(long frameTime) {
        if (mStartTime &lt; 0) {
            // First frame. If there is start delay, start delay count down will happen *after* this
            // frame.
            mStartTime = mReversing
                    ? frameTime
                    : frameTime + (long) (mStartDelay * resolveDurationScale());
        }

        // Handle pause/resume
        //省略 暂停、恢复的处理

        if (!mRunning) {
            //省略，判断是否可以开始播放首帧
        }

        if (mLastFrameTime &lt; 0) {
            //省略，处理动画是否seek的情况
        }
        mLastFrameTime = frameTime;

        // The frame time might be before the start time during the first frame of
        // an animation.  The "current time" must always be on or after the start
        // time to avoid animating frames at negative time intervals.  In practice, this
        // is very rare and only happens when seeking backwards.
        final long currentTime = Math.max(frameTime, mStartTime);

        //此处为重点
        boolean finished = animateBasedOnTime(currentTime);

        //完毕的处理
        if (finished) {
            endAnimation();
        }
        return finished;
    }
}
</code></pre>
<p>继续抓住重点：<code>animateBasedOnTime(currentTime)</code></p>
<pre><code class="language-java">class ValueAnimator {
    boolean animateBasedOnTime(long currentTime) {
        boolean done = false;
        if (mRunning) {
            //确定lastFraction、fraction
            final long scaledDuration = getScaledDuration();
            
            //差别在这里 
            final float fraction = scaledDuration &gt; 0 ?
                    (float) (currentTime - mStartTime) / scaledDuration : 1f;
            final float lastFraction = mOverallFraction;

            //确定轮播迭代标记
            final boolean newIteration = (int) fraction &gt; (int) lastFraction;
            final boolean lastIterationFinished = (fraction &gt;= mRepeatCount + 1) &amp;&amp;
                    (mRepeatCount != INFINITE);

            // 确定 done
            if (scaledDuration == 0) {
                // 0 duration animator, ignore the repeat count and skip to the end
                done = true;
            } else if (newIteration &amp;&amp; !lastIterationFinished) {
                // Time to repeat
                if (mListeners != null) {
                    int numListeners = mListeners.size();
                    for (int i = 0; i &lt; numListeners; ++i) {
                        mListeners.get(i).onAnimationRepeat(this);
                    }
                }
            } else if (lastIterationFinished) {
                done = true;
            }

            //确定fraction 重点1
            mOverallFraction = clampFraction(fraction);
            float currentIterationFraction = getCurrentIterationFraction(
                    mOverallFraction, mReversing);

            //重点2
            animateValue(currentIterationFraction);
        }
        return done;
    }
}
</code></pre>
<p>此处有两处重点：</p>
<ul>
<li>确定 currentIterationFraction</li>
<li>animateValue 执行动画帧</li>
</ul>
<p>看重点1：<em>泛读即可，主要理解fraction的设计</em></p>
<pre><code class="language-java">class ValueAnimator {
    private float clampFraction(float fraction) {
        if (fraction &lt; 0) {
            fraction = 0;
        } else if (mRepeatCount != INFINITE) {
            fraction = Math.min(fraction, mRepeatCount + 1);
        }
        return fraction;
    }

    //重点1 整数部分代表iteration，小数部分代表当前iteration的fraction
    private float getCurrentIterationFraction(float fraction, boolean inReverse) {
        fraction = clampFraction(fraction);
        int iteration = getCurrentIteration(fraction);
        float currentFraction = fraction - iteration;
        return shouldPlayBackward(iteration, inReverse)
                ? 1f - currentFraction
                : currentFraction;
    }

    //依据是fraction和iteration的设计：
    //    Calculates current iteration based on the overall fraction. 
    //    The overall fraction will be in the range of [0, mRepeatCount + 1]. 
    //    Both current iteration and fraction in the current iteration can be derived from it.
    private int getCurrentIteration(float fraction) {
        fraction = clampFraction(fraction);
        // If the overall fraction is a positive integer, we consider the current iteration to be
        // complete. In other words, the fraction for the current iteration would be 1, and the
        // current iteration would be overall fraction - 1.
        double iteration = Math.floor(fraction);
        if (fraction == iteration &amp;&amp; fraction &gt; 0) {
            iteration--;
        }
        return (int) iteration;
    }

    //和动画正向、反向播放有关，可先忽略
    private boolean shouldPlayBackward(int iteration, boolean inReverse) {
        if (iteration &gt; 0 &amp;&amp; mRepeatMode == REVERSE &amp;&amp;
                (iteration &lt; (mRepeatCount + 1) || mRepeatCount == INFINITE)) {
            // if we were seeked to some other iteration in a reversing animator,
            // figure out the correct direction to start playing based on the iteration
            if (inReverse) {
                return (iteration % 2) == 0;
            } else {
                return (iteration % 2) != 0;
            }
        } else {
            return inReverse;
        }
    }
}
</code></pre>
<p>看重点2：</p>
<pre><code class="language-java">class ValueAnimator {
    void animateValue(float fraction) {
        //插值器重新计算fraction -- 优雅的设计
        fraction = mInterpolator.getInterpolation(fraction);
        mCurrentFraction = fraction;
        int numValues = mValues.length;
        
        //PropertyValuesHolder 计算value -- 又是一个优雅的设计
        for (int i = 0; i &lt; numValues; ++i) {
            mValues[i].calculateValue(fraction);
        }
        
        //回调，onAnimationUpdate 常用到 getAnimatedValue，和 calculateValue 对应
        if (mUpdateListeners != null) {
            int numListeners = mUpdateListeners.size();
            for (int i = 0; i &lt; numListeners; ++i) {
                mUpdateListeners.get(i).onAnimationUpdate(this);
            }
        }
    }
}
</code></pre>
<h3 id="阶段性小结"><a class="header" href="#阶段性小结">阶段性小结</a></h3>
<p>源码内容着实很多，经过刚才的源码重点拆解，也已梳理出大致流程。</p>
<p>回归到我们阅读源码前的问题：</p>
<blockquote>
<p>Animator 是否和scheduleDrawable相比使用了不一样的底层机制？</p>
<p>否, 均使用了 <strong>Choreographer</strong> <em>[ˌkɔːriˈɑːɡrəfər],记住它的读写</em> + <strong>Vsync</strong> + <strong>Android 消息机制</strong> ，且回调类型一致，均为 <code>CALLBACK_ANIMATION</code></p>
<p>为何更加丝滑？</p>
<p>动画内部调用频次 ≥ 原方案，回调时依据时间计算帧号的算法更加准确合理</p>
</blockquote>
<p><code>ValueAnimator#animateBasedOnTime</code> 中，使用了准确、合理的计算方式 ：<code>final float fraction = scaledDuration &gt; 0 ? (float) (currentTime - mStartTime) / scaledDuration : 1f;</code></p>
<p>而先前文章中的代码，并没有依据当前实际时间调整帧。</p>
<h2 id="思变打开思路"><a class="header" href="#思变打开思路">思变：打开思路</a></h2>
<p>至此，动画的核心奥秘已经揭开，似乎一切已尽在不言中，轮子也均已完备，也并不需要再额外实现一套插值器、估值器逻辑。</p>
<p>既然如此，我们不再对第一篇中的例子进行以下改进："依据时间调整帧"，"提升回调频率"。</p>
<p><em>作者按：如果下次计划写插值器、估值器的文章，可能以逐步完善造轮子的方式进行内容展开</em></p>
<p>那么本篇的核心内容，除了面试或者给同事科普外，还能带来什么呢？</p>
<p>整体回顾一下，并打开思路：</p>
<ol>
<li>我们从一个实例出发进行完善，并收获一个经验：可以通过 Drawable+Animator，将动画内容推广到任意View做显示，<em>如果没有必要，可以少做一些自定义View的事情</em>。</li>
<li>分析了Drawable更新内容的底层实现，是否可以将这种动画效果推广到更多地方呢？例如 <code>TextView的DrawableStart</code>、<code>ImageSpan</code>，<strong>是否都能正确显示动效呢</strong>？，<strong>如果不能要怎么做？</strong></li>
<li>我们分析动画被驱动的过程中，遇到一个宝藏 <code>Choreographer</code>，是否可以拿来干点有趣的事情？例如：<strong>FPS监测</strong></li>
<li>将ValueAnimator的核心机制复刻，在别的平台搞点好玩的东西😂</li>
<li>在<code>视觉呈现内容</code> 与 <code>时间</code> 的函数关系确定时，使用 <code>ValueAnimator</code> 作为核心驱动，将问题变为一个纯数学问题，例如 <code>点迹动效绘制</code>，<code>全景图锚点A到锚点B之间的渐变</code></li>
<li>融合以上内容，自定义一套数据协议，解析后，所见皆可动起来</li>
</ol>
<h2 id="闲话一二"><a class="header" href="#闲话一二">闲话一二</a></h2>
<p>文中出现的源码，除去AOSP部分，均收录于仓库中：<a href="https://github.com/leobert-lan/DrawableWorkShop">DrawableWorkShop</a></p>
<p>最近还处于瓶颈之中，我花了大约半年的时间，让自己 "慢" 下来，却还没有做到真正松弛下来，礼记中言："张而不弛，文武弗能也；弛而不张，文武弗为也；一张一弛，文武之道也。"</p>
<p>有两个方面的瓶颈，让我颇为难受：</p>
<ul>
<li>"输出质量的高期望" 与 "输入、知识体系存货达不到更高层次" 之间的矛盾带来的内容瓶颈</li>
<li>"不同读者需要的知识深度不同" 与 "博客内容提纲不能照顾到各个深度" 之间的矛盾带来的编写瓶颈</li>
</ul>
<p>我还需要调整好节奏、捋一捋下一个五年，再进行知识重整合，才能先驰后张，输出更有意义的内容，这能解决第一个瓶颈问题。但第二个瓶颈问题，确实没找到办法。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../Android/Drawable/post_4.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../Android/Drawable/post_49.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../Android/Drawable/post_4.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../Android/Drawable/post_49.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
