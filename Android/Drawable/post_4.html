<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>好玩系列：拥有它，XML文件少一半--更方便的处理View背景 - leobert&#x27;s blog</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">目录</li><li class="chapter-item expanded "><a href="../../Android/index.html"><strong aria-hidden="true">1.</strong> Android</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Android/View/index.html"><strong aria-hidden="true">1.1.</strong> View</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Android/View/post_1.html"><strong aria-hidden="true">1.1.1.</strong> 好玩系列：优雅的处理ButterKnife和KAE被废弃</a></li><li class="chapter-item expanded "><a href="../../Android/View/post_6.html"><strong aria-hidden="true">1.1.2.</strong> 三思系列：View体系认知(一)，内容是如何正确被展现出来的--视觉呈现概览</a></li><li class="chapter-item expanded "><a href="../../Android/View/post_7.html"><strong aria-hidden="true">1.1.3.</strong> 三思系列：为什么自定义View</a></li><li class="chapter-item expanded "><a href="../../Android/Idea/post_9.html"><strong aria-hidden="true">1.1.4.</strong> 三思系列："声明式UI"和"命令式UI"，你的理解可能是错的</a></li></ol></li><li class="chapter-item expanded "><a href="../../Android/Drawable/index.html"><strong aria-hidden="true">1.2.</strong> Drawable</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Android/Drawable/post_2.html"><strong aria-hidden="true">1.2.1.</strong> 三思系列：重新认识Drawable</a></li><li class="chapter-item expanded "><a href="../../Android/Drawable/post_4.html" class="active"><strong aria-hidden="true">1.2.2.</strong> 好玩系列：拥有它，XML文件少一半--更方便的处理View背景</a></li><li class="chapter-item expanded "><a href="../../Android/Drawable/post_47.html"><strong aria-hidden="true">1.2.3.</strong> 迟来的续集--Drawable+Animator，将优雅进行到底</a></li><li class="chapter-item expanded "><a href="../../Android/Drawable/post_49.html"><strong aria-hidden="true">1.2.4.</strong> 好玩系列：让ImageSpan动起来</a></li></ol></li><li class="chapter-item expanded "><a href="../../Android/Mechanism/Message/index.html"><strong aria-hidden="true">1.3.</strong> 消息机制</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Android/Mechanism/Message/post_8.html"><strong aria-hidden="true">1.3.1.</strong> 三思系列：Android的消息机制，一文吃透</a></li></ol></li><li class="chapter-item expanded "><a href="../../Android/Idea/post_14/index.html"><strong aria-hidden="true">1.4.</strong> 兼容</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Android/Idea/post_14.html"><strong aria-hidden="true">1.4.1.</strong> 好玩系列：让项目中的相册支持Heif格式图片</a></li></ol></li><li class="chapter-item expanded "><a href="../../Android/Glide/index.html"><strong aria-hidden="true">1.5.</strong> Glide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Android/Glide/post_15.html"><strong aria-hidden="true">1.5.1.</strong> 三思系列：Glide 4.X全方位认知 -- 模块职责概览</a></li><li class="chapter-item expanded "><a href="../../Android/Glide/post_16.html"><strong aria-hidden="true">1.5.2.</strong> 三思系列：Glide 4.X加载过程一文掌握 | Glide（二）</a></li></ol></li><li class="chapter-item expanded "><a href="../../Android/KSP/index.html"><strong aria-hidden="true">1.6.</strong> KSP</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Android/KSP/post_24.html"><strong aria-hidden="true">1.6.1.</strong> 好玩系列 | 拥抱Kotlin Symbol Processing(KSP),项目实战</a></li></ol></li><li class="chapter-item expanded "><a href="../../Android/Base/index.html"><strong aria-hidden="true">1.7.</strong> 基础</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Android/Base/post_35.html"><strong aria-hidden="true">1.7.1.</strong> 孔乙己：你可知道页面和弹窗“通信“的方式有四种？</a></li></ol></li><li class="chapter-item expanded "><a href="../../Android/SysApp/index.html"><strong aria-hidden="true">1.8.</strong> 系统APP</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Android/SysApp/post_52.html"><strong aria-hidden="true">1.8.1.</strong> 使用日历丰富产品的用户体验</a></li></ol></li><li class="chapter-item expanded "><a href="../../Android/DI/index.html"><strong aria-hidden="true">1.9.</strong> Part4-依赖注入部分</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Android/DI/post_53.html"><strong aria-hidden="true">1.9.1.</strong> Hilt进阶--一文吃透Hilt自定义与跨壁垒</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../Compose/index.html"><strong aria-hidden="true">2.</strong> Jetpack Compose</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Compose/post_21.html"><strong aria-hidden="true">2.1.</strong> Jetpack Compose | 一文理解神奇的Modifier</a></li><li class="chapter-item expanded "><a href="../../Compose/post_26.html"><strong aria-hidden="true">2.2.</strong> Jetpack Compose | 控件篇（一） -- Text、TextField、Button</a></li><li class="chapter-item expanded "><a href="../../Compose/post_27.html"><strong aria-hidden="true">2.3.</strong> Jetpack Compose | 控件篇（二） -- Icon，Image</a></li><li class="chapter-item expanded "><a href="../../Compose/post_28.html"><strong aria-hidden="true">2.4.</strong> Jetpack Compose | 控件篇（三） -- Switch、CheckBox、RadioButton</a></li><li class="chapter-item expanded "><a href="../../Compose/post_29.html"><strong aria-hidden="true">2.5.</strong> Jetpack Compose | 控件篇（四）-- Box、Row、Column</a></li><li class="chapter-item expanded "><a href="../../Compose/post_30.html"><strong aria-hidden="true">2.6.</strong> Jetpack Compose | 控件篇（五）-- Spacer、LazyRow、LazyColumn & 让Column可滑动</a></li></ol></li><li class="chapter-item expanded "><a href="../../MultiThreading/index.html"><strong aria-hidden="true">3.</strong> Java多线程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../MultiThreading/post_33.html"><strong aria-hidden="true">3.1.</strong> 总纲</a></li><li class="chapter-item expanded "><a href="../../MultiThreading/post_37.html"><strong aria-hidden="true">3.2.</strong> Java基础--图解JVM内存模型和JVM线程模型</a></li><li class="chapter-item expanded "><a href="../../MultiThreading/post_38.html"><strong aria-hidden="true">3.3.</strong> Java多线程系列--掌控面试，一文吃透Synchronized锁</a></li><li class="chapter-item expanded "><a href="../../MultiThreading/post_39.html"><strong aria-hidden="true">3.4.</strong> Java多线程基础--线程生命周期与线程协作详解</a></li><li class="chapter-item expanded "><a href="../../MultiThreading/post_42.html"><strong aria-hidden="true">3.5.</strong> Java多线程基础--线程的创建与线程池管理</a></li><li class="chapter-item expanded "><a href="../../MultiThreading/post_46.html"><strong aria-hidden="true">3.6.</strong> Java多线程系列--掌握Future，轻松获取异步任务结果</a></li><li class="chapter-item expanded "><a href="../../MultiThreading/post_50.html"><strong aria-hidden="true">3.7.</strong> Java多线程系列--Fork&Join框架，分治的艺术</a></li><li class="chapter-item expanded "><a href="../../MultiThreading/post_54.html"><strong aria-hidden="true">3.8.</strong> Java多线程系列--掌握CompletableFuture，驾驭异步编程</a></li></ol></li><li class="chapter-item expanded "><a href="../../IO/index.html"><strong aria-hidden="true">4.</strong> Java IO系列</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../IO/post_55.html"><strong aria-hidden="true">4.1.</strong> Java IO 系列总纲</a></li><li class="chapter-item expanded "><a href="../../IO/post_56.html"><strong aria-hidden="true">4.2.</strong> Java IO系列 | 经典 IO</a></li><li class="chapter-item expanded "><a href="../../IO/post_57.html"><strong aria-hidden="true">4.3.</strong> Java IO 系列 | NIO-1.0一文速览</a></li><li class="chapter-item expanded "><a href="../../IO/post_58.html"><strong aria-hidden="true">4.4.</strong> Java IO系列 | NIO-1.0拾遗、NIO-2.0 & 零拷贝必吹的牛皮</a></li><li class="chapter-item expanded "><a href="../../IO/post_59.html"><strong aria-hidden="true">4.5.</strong> IO系列 | 一文掌握OKHTTP中的OKIO为什么这么OK</a></li></ol></li><li class="chapter-item expanded "><a href="../../Gradle/index.html"><strong aria-hidden="true">5.</strong> Gradle</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Gradle/Modularization/post_18.html"><strong aria-hidden="true">5.1.</strong> 组件化：三思系列：组件化场景下module依赖优雅实践方案</a></li><li class="chapter-item expanded "><a href="../../Gradle/Publish/post_17.html"><strong aria-hidden="true">5.2.</strong> MavenCentral发布：迁移到MavenCentral--再不行动起来，你的托管的library就没了</a></li><li class="chapter-item expanded "><a href="../../Gradle/post_22.html"><strong aria-hidden="true">5.3.</strong> Gradle | 依赖管理最佳实践</a></li></ol></li><li class="chapter-item expanded "><a href="../../Groovy/index.html"><strong aria-hidden="true">6.</strong> Groovy</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Groovy/why_write_groovy.html"><strong aria-hidden="true">6.1.</strong> 为什么撰写这个系列</a></li><li class="chapter-item expanded "><a href="../../Groovy/post_23.html"><strong aria-hidden="true">6.2.</strong> Groovy：MOP一文打尽</a></li></ol></li><li class="chapter-item expanded "><a href="../../Review/index.html"><strong aria-hidden="true">7.</strong> Review</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Review/post_10.html"><strong aria-hidden="true">7.1.</strong> 造完了这个轮子--Mocker，却让我感到很羞愧|项目复盘</a></li><li class="chapter-item expanded "><a href="../../Review/post_40.html"><strong aria-hidden="true">7.2.</strong> 三思系列：前人用GreenDao留下的坑，全线被扣了绩效</a></li><li class="chapter-item expanded "><a href="../../Review/post_44.html"><strong aria-hidden="true">7.3.</strong> 谈一谈在两个商业项目中使用MVI架构后的感悟</a></li><li class="chapter-item expanded "><a href="../../Review/post_45.html"><strong aria-hidden="true">7.4.</strong> Review | 这三个坑你遇到了吗？</a></li></ol></li><li class="chapter-item expanded "><a href="../../repo/index.html"><strong aria-hidden="true">8.</strong> 个人项目</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../repo/DaVinCi.html"><strong aria-hidden="true">8.1.</strong> DaVinCi,取代XML编写Shape或ColorStateList的方案</a></li><li class="chapter-item expanded "><a href="../../Android/Idea/post_32.html"><strong aria-hidden="true">8.2.</strong> 好玩系列：白嫖一个优雅的类图生成工具</a></li><li class="chapter-item expanded "><a href="../../Speculative/post_43.html"><strong aria-hidden="true">8.3.</strong> 初体验：动手搭建"小清新式"局域网文档系统</a></li><li class="chapter-item expanded "><a href="../../repo/post_48.html"><strong aria-hidden="true">8.4.</strong> 研究良久，终于发现了他代码写的快且bug少的原因</a></li><li class="chapter-item expanded "><a href="../../Speculative/post_61.html"><strong aria-hidden="true">8.5.</strong> 好玩系列 | 如果后端让你用SSE接收多次返回，那我们改造Retrofit吧</a></li></ol></li><li class="chapter-item expanded "><a href="../../Review/DataStructure/index.html"><strong aria-hidden="true">9.</strong> 数据结构</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Review/DataStructure/post_11.html"><strong aria-hidden="true">9.1.</strong> 温故：线性表</a></li><li class="chapter-item expanded "><a href="../../Review/DataStructure/post_12.html"><strong aria-hidden="true">9.2.</strong> 温故：栈</a></li><li class="chapter-item expanded "><a href="../../Review/DataStructure/post_13.html"><strong aria-hidden="true">9.3.</strong> 温故：队列</a></li></ol></li><li class="chapter-item expanded "><a href="../../Review/README2.html"><strong aria-hidden="true">10.</strong> 年终总结&计划</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Review/post_36.html"><strong aria-hidden="true">10.1.</strong> 2021年终总结</a></li><li class="chapter-item expanded "><a href="../../Review/post_51.html"><strong aria-hidden="true">10.2.</strong> 关于画一个句号--基于2022年终总结的反思与分享</a></li><li class="chapter-item expanded "><a href="../../Review/post_60.html"><strong aria-hidden="true">10.3.</strong> 突如其来的秋季反思</a></li><li class="chapter-item expanded "><a href="../../Review/post_63.html"><strong aria-hidden="true">10.4.</strong> 2023年总结 寻找到源于内心深处的无穷力量</a></li><li class="chapter-item expanded "><a href="../../Review/post_64.html"><strong aria-hidden="true">10.5.</strong> 2024年中思考，推倒樊笼重新出发</a></li></ol></li><li class="chapter-item expanded "><a href="../../Note/index.html"><strong aria-hidden="true">11.</strong> 读书笔记</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Note/post_41.html"><strong aria-hidden="true">11.1.</strong> 读书笔记：《简约至上--交互式设计四策略》</a></li></ol></li><li class="chapter-item expanded "><a href="../../Talk/index.html"><strong aria-hidden="true">12.</strong> 杂谈</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Talk/talk_1.html"><strong aria-hidden="true">12.1.</strong> 杂谈1-2022-11</a></li><li class="chapter-item expanded "><a href="../../Talk/talk_2_2023-03.html"><strong aria-hidden="true">12.2.</strong> 杂篇（二）-- 认识并战胜焦虑</a></li><li class="chapter-item expanded "><a href="../../Talk/talk_3_2024-08.html"><strong aria-hidden="true">12.3.</strong> 杂谈（三）-- 向钱看，你需要想明白企业在为什么而付钱</a></li></ol></li><li class="chapter-item expanded "><a href="../../Thought/index.html"><strong aria-hidden="true">13.</strong> 半成熟的思考</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Thought/post_62.html"><strong aria-hidden="true">13.1.</strong> 好玩系列 | 当SPI 和 设计模式、依赖注入发生碰撞，可以擦出怎样的火花</a></li></ol></li><li class="chapter-item expanded "><a href="../../info/index.html"><strong aria-hidden="true">14.</strong> 系列说明</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../info/about_view_series.html"><strong aria-hidden="true">14.1.</strong> 关于View系列</a></li><li class="chapter-item expanded "><a href="../../info/about_sansi_series.html"><strong aria-hidden="true">14.2.</strong> 关于三思系列</a></li><li class="chapter-item expanded "><a href="../../info/about_haowan_series.html"><strong aria-hidden="true">14.3.</strong> 关于好玩系列</a></li><li class="chapter-item expanded "><a href="../../info/about_wengu_series.html"><strong aria-hidden="true">14.4.</strong> 关于温故系列</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">leobert&#x27;s blog</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="好玩系列拥有它xml文件少一半--更方便的处理view背景"><a class="header" href="#好玩系列拥有它xml文件少一半--更方便的处理view背景">好玩系列：拥有它，XML文件少一半--更方便的处理View背景</a></h1>
<h2 id="前言"><a class="header" href="#前言">前言</a></h2>
<p><a href="https://github.com/leobert-lan/Blog/blob/main/info/%E5%85%B3%E4%BA%8E%E5%A5%BD%E7%8E%A9%E7%B3%BB%E5%88%97.md">关于好玩系列</a></p>
<p>这是一项已经被我们项目<code>实验性投产</code>将近一年的方案，虽然还处于实验性阶段，但<code>稳定性</code>和<code>实用性</code>都不错。</p>
<p><a href="https://github.com/leobert-lan/DaVinCi">DaVinCi 仓库链接</a></p>
<blockquote>
<p>问题背景：Android 中普遍使用XML来定义资源，对于视图的背景样式而言，需要定义大量的
<code>GradientDrawable</code>、<code>StateListDrawable</code> 资源等。当项目体量很大时。这些资源就会出现难管理的问题。</p>
</blockquote>
<p>诚然，从<code>最佳实践</code>角度出发，<strong>对项目中的资源进行合理地命名以满足查询索引规则，按照设计风格定义对应的Style，视图定义时利用Style约束其样式</strong>。这才是
<code>优秀的做法</code>。但是，事与愿违，按照国内的从业者现状看，大多数处理大型项目的团队都<code>没有</code>做好这一点的<code>必要条件</code>。</p>
<p>在展开实践之前，我们不妨反思下为何会如此，不外乎：</p>
<ul>
<li>缺乏或者频繁变动顶层<code>设计语言</code>，<em>这个词可能并不太准确</em></li>
<li>以往的页面已经在线上运行了，设计新的页面簇改变了设计风格时，没有安排原有内容的统一修改并给到时间。</li>
<li>以上两条导致全栈Style混乱</li>
<li>当Style超过3种风格时，开发团队一般选择<code>毁灭吧，我累了</code>，谁动全栈风格跟谁急。</li>
</ul>
<p>OK，既然都选择了毁灭吧,那为什么不选择一种更加舒适的方式来处理常见的背景问题。</p>
<h2 id="挑选目标--最常用的drawable资源"><a class="header" href="#挑选目标--最常用的drawable资源">挑选目标--最常用的Drawable资源</a></h2>
<p>经过一番草率的筛选，我们很快锁定了目标：selector、shape</p>
<p>举个例子，窥一斑而见全豹：</p>
<p><img src="post_4/img_a_lot_of_drawable.png" alt="大量的资源" /></p>
<p>这还只是一小部分，相信各位的项目中也会有这样的痛点吧。</p>
<p>且不谈 <code>命名规则</code> 是否合情合理，这是一种很反人类的设定，就像你忘记了密码，申请重置，按照一系列的密码规则， 终于设定了一个 <code>让你惴惴不安</code> 担心 <code>再次忘记</code> 的密码后，提交提示：不能和原密码一致。</p>
<p>对Drawable体系有一定了解的话，我们知道 selector、shape 分别对应：</p>
<ul>
<li><code>StateListDrawable</code></li>
<li><code>GradientDrawable</code></li>
</ul>
<p><em>如果对Drawable体系还不太清楚的话，<a href="post_2.html">可以简要阅读一下我之前的一篇博客：三思系列：重新认识Drawable</a></em></p>
<h2 id="换一种定义资源解析资源的方式"><a class="header" href="#换一种定义资源解析资源的方式">换一种定义资源、解析资源的方式</a></h2>
<p>布局文件中使用这些Drawable资源时，在View被创建后，会解析配置的属性，而Drawable相关的资源，会被DrawableInflater加载并运用。</p>
<p>这一点就不展开了。毫无疑问，如果要替换掉基于xml的资源定义方式，我们只能采用一个新的方式。但是，我们并<code>没有打算</code> 抛弃使用xml文件定义布局资源</p>
<p>且不卖关子，当时搜索枯肠，要满足：</p>
<ul>
<li>丢弃单独文件定义</li>
<li>方便，不需要查手册</li>
</ul>
<p>两个要素，只想到两个关键词： <code>DSL</code>，<code>OO</code>，没错，<code>领域特定语言</code> 和 <code>面向对象</code>。</p>
<p>严格来说，这两者基本是互斥的。</p>
<p>但是很抱歉，这里必须要先打住，要先讲点别的，然后再回到这个话题。</p>
<blockquote>
<p>注，后面很大一段篇幅，会用于：</p>
<ul>
<li>解释抛弃自定义View和属性的方案</li>
<li>使用Builder简化Drawable构造过程</li>
<li>DSL简介</li>
<li>用DSL解决这个问题</li>
</ul>
<p>个人认为 <code>使用自定义文法</code> 和 <code>解释器</code>处理文法解析 是一件挺好玩的事情，值得玩一玩，
但限于我的水平，这段内容读起来可能很晦涩，如果不是非常感兴趣，可以直接跳过到：<a href="#anchor2">到底是DSL还是OO</a></p>
</blockquote>
<h3 id="抛弃了自定义view和属性的方式"><a class="header" href="#抛弃了自定义view和属性的方式">抛弃了自定义View和属性的方式</a></h3>
<p>在开始时，我考虑过这种方案。但是使用 <code>自定义的</code> <code>LayoutInflater</code> 或者 <code>hook</code> 系统LayoutInflater 都是可能影响到某些 <code>黑科技</code>的</p>
<p>就算不考虑干扰到其他黑科技，也需要严格的处理各种属性组合，并提供完善的查询手册，这很 <code>不人道主义</code>，</p>
<p>而基于十几个属性组合场景自定义lint规则，这 <code>很烦</code> ，一点都 <code>不好玩</code></p>
<p>所以这个方案直接被否决</p>
<h2 id="工欲善其事必先利其器drawable对象构建工具----drawable-builder"><a class="header" href="#工欲善其事必先利其器drawable对象构建工具----drawable-builder">工欲善其事必先利其器，Drawable对象构建工具 -- Drawable Builder</a></h2>
<p>因为 <code>StateListDrawable</code> 和 <code>GradientDrawable</code> 的内部细节都是比较多的，这句话等价于：构建这两者的实例对象比较复杂。</p>
<p>这很符合Builder模式的使用场景，我们先设计一个Builder来处理这两者的构建，并在构建过程中检验信息</p>
<blockquote>
<p>这是一件比较枯燥的事情，代码略。详见DaVinCiCore.kt</p>
</blockquote>
<p>在我们完善的考虑了 各种state下： 形状，渐变的角度、方式，填充，描边，尺寸，指定的drawable等之后，我们可以 "很方便" 的创建Drawable啦！</p>
<h2 id="一套适应场景的dsl----定义规则"><a class="header" href="#一套适应场景的dsl----定义规则">一套适应场景的DSL -- 定义规则</a></h2>
<p>在内容展开之前，我们再回顾一下DSL的基础。</p>
<p><code>DSL</code>即 <code>Domain Specified Language</code> 、<code>领域专用语言</code>。</p>
<p>Wikipedia中关于这个词条的描述：</p>
<blockquote>
<p>A specialized computer language designed for a specific task.</p>
</blockquote>
<p>为了解决 <code>某类</code> <code>特定问题</code> 而设计的一种 <code>特殊</code> 的计算机语言</p>
<p>而马丁老爷子关于它的描述，看起来就很高深了，但我更喜欢这一个描述：</p>
<blockquote>
<p>A computer programming language of limited expressiveness focused on a particular domain.</p>
</blockquote>
<p>一种 <code>抑制表达能力</code> 以 <code>专注于</code> <code>特定领域</code> 的计算机语言。</p>
<p>这种抑制，让它专注于特定的领域，而抛弃了其他的领域，以达到更加高效、准确的目的。</p>
<p>我们知道，xml协议的<code>扩展性非常强</code>，而这种扩展性，让它的<code>解析</code>变得非常的<code>繁琐</code>，继而带来了效率问题。Android中，为了 <code>兼顾</code> xml的 <code>扩展性</code> 和 使用的 <code>效率问题</code>， 定制了各类Inflater以处理特定的问题。</p>
<p>显然，我们这次不打算在巨人的肩膀上更进一步，而是要在特定问题上，剑走偏锋。</p>
<p>按照我们积累的知识，要构建一个 <code>GradientDrawable</code>，可能用到：</p>
<ul>
<li>形状 shape</li>
<li>纯色填充色 solidColor</li>
<li>圆角相关：
<ul>
<li>cornersRadius</li>
<li>cornersBottomLeftRadius</li>
<li>cornersBottomRightRadius</li>
<li>cornersTopLeftRadius</li>
<li>cornersTopRightRadius</li>
</ul>
</li>
<li>填充渐变：
<ul>
<li>渐变方向角 gradientAngle</li>
<li>渐变中点x gradientCenterX</li>
<li>渐变中点y gradientCenterY</li>
<li>渐变起始颜色 gradientStartColor</li>
<li>渐变中点颜色 gradientCenterColor</li>
<li>渐变终点颜色 gradientEndColor</li>
</ul>
</li>
<li>渐变形式 gradient</li>
<li>形式为 RADIAL_GRADIENT时的 gradientRadius</li>
<li>useLevel</li>
<li>padding</li>
<li>sizeWidth</li>
<li>sizeHeight</li>
<li>描边宽度 strokeWidth</li>
<li>描边颜色 strokeColor</li>
<li>虚线段宽度 strokeDashWidth</li>
<li>虚线段间距 strokeDashGap</li>
</ul>
<p>当然，我们还需要考虑到 <code>不同的状态</code>，和一些 <code>细节</code> ，这里先不展开</p>
<p>此时我们有两个选择方向，让我们的DSL类似于：</p>
<pre><code>shape:[
    gradient:[type:linear;startColor:#ff3c08;endColor:#353538 ];
    st:[Oval];
    corners:[40 dp];
    stroke:[width:4 dp;color:rc / colorAccent ]
]
</code></pre>
<p><em>ps，因为目标固定为设置background，所以语法式中忽略这种描述</em></p>
<p>或者类似于sql的insert语句。</p>
<p>不过后者的 <code>字段</code> 太多，实在不适合阅读，而且SQL的 <code>表达能力</code> 相对于我们要处理的问题，还是过强了一点。</p>
<p>ok，我们再仔细设计一下规则。</p>
<p>终结符：</p>
<ul>
<li><code>[</code> <code>]</code>,当前域的子句均置于其中，例：</li>
</ul>
<pre><code class="language-kotlin">域:[子域1:[值]]

shape:[st:[Oval]]
</code></pre>
<ul>
<li><code>;</code>,当前域有多个子域时，子域之间用 <code>;</code> 分隔</li>
</ul>
<p>非终结符：</p>
<ul>
<li>shape: 代表创建一个GradientDrawable</li>
<li>st: 代表shape类型，枚举值为
<ul>
<li>Rectangle</li>
<li>Oval</li>
<li>Line</li>
<li>Ring</li>
</ul>
</li>
<li>corners: 圆角相关设置，值置于[]中，一个值代表4个角，4个值代表 左上、右上、右下、左下 四个值对应设置</li>
<li>solid: 纯色填充，[]内为色值，色值表达见后</li>
<li>gradient:渐变色，子命令置于 [] 中
<ul>
<li>type：渐变类型，枚举为：
<ul>
<li>linear</li>
<li>radial</li>
<li>sweep</li>
</ul>
</li>
<li>startColor: 起始色</li>
<li>centerColor: 中间色</li>
<li>endColor: 结束色</li>
<li>centerX: 中点x</li>
<li>centerY: 中点y</li>
<li>angle: 渐变角度</li>
</ul>
</li>
<li>stroke: 描边，子命令置于 [] 中
<ul>
<li>width: 描边宽度</li>
<li>color: 描边颜色</li>
<li>dashWidth: 虚线宽</li>
<li>dashGap: 虚线间距</li>
</ul>
</li>
<li>size: 尺寸
<ul>
<li>width:</li>
<li>height:</li>
</ul>
</li>
<li>padding: 内边距
<ul>
<li>left</li>
<li>top</li>
<li>right</li>
<li>bottom</li>
</ul>
</li>
</ul>
<p>特殊规则：</p>
<ul>
<li>尺寸描述：纯数字代表px，数值+dp 代表dp值，<code>w</code>代表 <code>wrap_content</code>，<code>m</code> 代表 <code>match_parent</code></li>
<li>颜色表达："#ffffff"等色值字符串，代表ARGB值的 int 值，"rc/资源名" 表达资源引用， 以及用"@idName"来获取目标View的tag，tag值需为颜色字符串或者ARGB色</li>
</ul>
<p>为了适当减少类的数量，我们约定：</p>
<ul>
<li>不拥有子域的域弱化为属性，以<code>属性名:属性值</code>的方式表达，而不再需要 <code>[]</code> 符号</li>
<li>当某个域的属性只存在一个或者已经被约定时，可以忽略其属性名，直接使用属性值</li>
</ul>
<blockquote>
<p>注:重新整理时，我发现最开始编码的 <code>ShapeType</code> 和 <code>Corners</code> 没有重新按照上述约定修正，
这是一处遗忘修改的bug，准确的讲，是将子域弱化为属性时，期望略去终结符而带来的文法规则缺陷，读者<strong>不要深究</strong>。</p>
<p>出现这个bug的根本原因是：我当时想减少小类数量，并
一定程度上降低解析复杂度，将非终结符识别标记 和终结符 <code>[</code> 组合在了一起，替代原先的非终结符识别标记使用。</p>
</blockquote>
<blockquote>
<p>注2：主体是 GradientDrawable ，为什么用 Shape去对应？因为国内普遍存在的文章中，绝大多数都已经将
Gradient 对应为"颜色的梯度渐变"，而将这一资源文件定义为 "形状"、带"填充"和"描边"的形状。而Android的资源定义语法中，
也是类似的。大家也都习惯了，索性尊重习惯。</p>
</blockquote>
<h2 id="解释器----处理表达式解析"><a class="header" href="#解释器----处理表达式解析">解释器 -- 处理表达式解析</a></h2>
<blockquote>
<p>在GOF的设计模式中，<code>解释器模式</code> ( <code>Interpreter Pattern</code> ) 提供了 <code>评估</code> 语言的 <code>语法</code> 或 <code>表达式</code> 的方式，它属于 <code>行为型模式</code>。</p>
</blockquote>
<p>需要注意，其实在这个问题的实际场景中，一条语句，子句出现的频率可能并不会太高，但解释器模式 <code>依旧是场景适用</code> 的。</p>
<p>我们再回顾一下解释器模式的 <code>优缺点</code>：</p>
<p>优点：</p>
<ul>
<li>可扩展性比较好，灵活。</li>
<li>易于实现简单文法。</li>
</ul>
<p>缺点：</p>
<ul>
<li>对于复杂的文法比较难维护</li>
<li>可能引起类膨胀</li>
<li>采用递归调用方法，层级过深，可能出现效率问题</li>
</ul>
<h3 id="定义上下文"><a class="header" href="#定义上下文">定义上下文</a></h3>
<p><img src="post_4/img_uml_davinci.png" alt="uml_davinci" /></p>
<p>其中 <code>core:DaVinCiCore</code> 是上面提到的构建者，未遵循习惯命名法。
<code>view:View</code> 是要操作的View。</p>
<p><strong>源码枯燥，略</strong></p>
<h3 id="抽象表达式"><a class="header" href="#抽象表达式">抽象表达式</a></h3>
<p><img src="post_4/img_uml_davinciexp.png" alt="uml_davinci" /></p>
<pre><code class="language-kotlin">sealed class DaVinCiExpression(var daVinCi: DaVinCi? = null) {

    // 节点名称
    protected var tokenName: String? = null

    // 文本内容
    protected var text: String? = null

    //实际属性是否需要从text解析，手动创建并给了专有属性的，设为false，就不会被覆盖了
    protected var parseFromText = true

    abstract fun injectThenParse(daVinCi: DaVinCi?)

    /*
     * 执行方法
     */
    abstract fun interpret()

    open fun startTag(): String = ""

    companion object {
        @JvmStatic
        fun shape(): Shape = Shape(true)

        const val sLogTag = "DaVinCi"

        const val END = "]"

        const val NEXT = "];"

        const val sResourceColor = "rc/"
    }
}
</code></pre>
<h3 id="终结符处理"><a class="header" href="#终结符处理">终结符处理</a></h3>
<p>只需要处理兄弟域的关系即可，例如，我们知道 solid 和 stroke 就是兄弟域，</p>
<pre><code class="language-kotlin"> protected class ListExpression(daVinCi: DaVinCi? = null, private val manual: Boolean = false) :
    DaVinCiExpression(daVinCi) {
    private val list: ArrayList&lt;DaVinCiExpression&gt; = ArrayList()

    fun append(exp: DaVinCiExpression) {
        list.add(exp)
    }

    override fun injectThenParse(daVinCi: DaVinCi?) {
        this.daVinCi = daVinCi
        if (manual) {
            list.forEach { it.injectThenParse(daVinCi) }
            return
        }

        // 在ListExpression解析表达式中,循环解释语句中的每一个单词,直到终结符表达式或者异常情况退出
        daVinCi?.let {
            var i = 0
            while (i &lt; 100) { // true,语法错误时有点可怕，先上限100
                if (it.currentToken == null) { // 获取当前节点如果为 null 则表示缺少]表达式
                    println("Error: The Expression Missing ']'! ")
                    break
                } else if (it.equalsWithCommand(END)) {
                    it.next()
                    // 解析正常结束
                    break
                } else if (it.equalsWithCommand(NEXT)) {
                    //进入同级别下一个解析
                    it.next()
                } else { // 建立Command 表达式
                    try {
                        val expressions: DaVinCiExpression = CommandExpression(it)
                        list.add(expressions)
                    } catch (e: Exception) {
                        if (DaVinCi.enableDebugLog) Log.e(sLogTag, "语法解析有误", e)
                        break
                    }
                }
                i++
            }
            if (i == 100) {
                if (DaVinCi.enableDebugLog) Log.e(sLogTag, "语法解析有误，进入死循环，强制跳出")
            }
        }
    }

    override fun interpret() { // 循环list列表中每一个表达式 解释执行
        list.forEach { it.interpret() }
    }

    override fun toString(): String {
        val b = StringBuilder()

        val iMax: Int = list.size - 1
        if (iMax == -1) return ""
        var i = 0
        while (true) {
            b.append(list[i].toString())
            if (i == iMax) return b.toString()
            b.append("; ")
            i++
        }
    }
}
</code></pre>
<h3 id="非终结符的规则处理"><a class="header" href="#非终结符的规则处理">非终结符的规则处理</a></h3>
<pre><code class="language-kotlin">
open class CommandExpression(daVinCi: DaVinCi? = null, val manual: Boolean = false) :
    DaVinCiExpression(daVinCi) {
    private var expressions: DaVinCiExpression? = null

    init {
        //因为是嵌套层，且作为父类了，避免递归
        if (this::class == CommandExpression::class)
            onParse(daVinCi)
    }

    override fun injectThenParse(daVinCi: DaVinCi?) {
        onParse(daVinCi)
    }

    protected fun toPx(str: String, context: Context): Int? {
        //略
    }

    protected fun parseColor(text: String?): Int? {
        //略
    }

    protected fun parseInt(text: String?, default: Int?): Int? {
        //略
    }

    protected fun parseFloat(text: String?, default: Float?): Float? {
        //略
    }

    protected fun getTag(context: Context?, resName: String): String? {
        //略
    }

    protected fun getColor(context: Context?, resName: String?): Int? {
        //略
    }

    @Throws(Exception::class)
    private fun onParse(daVinCi: DaVinCi?) {
        this.daVinCi = daVinCi
        if (manual) return
        daVinCi?.let {
            expressions = when (it.currentToken) {
                Corners.tag -&gt; Corners(it)
                Solid.tag -&gt; Solid(it)
                ShapeType.tag -&gt; ShapeType(it)
                Stroke.tag -&gt; Stroke(it)
                Size.tag -&gt; Size(it)
                Padding.tag -&gt; Padding(it)
                Gradient.tag -&gt; Gradient(it)
                else -&gt; throw Exception("cannot parse ${it.currentToken}")
            }
        }
    }

    protected fun asPrimitiveParse(start: String, daVinCi: DaVinCi?) {
        this.daVinCi = daVinCi
        daVinCi?.let {
            tokenName = it.currentToken
            it.next()
            if (start == tokenName) {
                this.text = it.currentToken
                it.next()
            } else {
                it.next()
            }
        }
    }

    override fun interpret() {
        expressions?.interpret()
    }

    override fun toString(): String {
        return "$expressions"
    }
}
</code></pre>
<p>以solid为例：</p>
<pre><code class="language-kotlin">class Solid(daVinCi: DaVinCi? = null, manual: Boolean = false) :
    CommandExpression(daVinCi, manual) {
    @ColorInt
    internal var colorInt: Int? = null //这是解析出来的，不要乱赋值

    companion object {
        const val tag = "solid:["
    }

    init {
        injectThenParse(daVinCi)
    }

    override fun injectThenParse(daVinCi: DaVinCi?) {
        this.daVinCi = daVinCi

        if (manual) {
            if (parseFromText)
                colorInt = parseColor(text)
            return
        }
        colorInt = null
        asPrimitiveParse(tag, daVinCi)
        colorInt = parseColor(text)

    }

    override fun interpret() {
        if (tag == tokenName || manual) {
            daVinCi?.let {
                colorInt?.let { color -&gt;
                    it.core.setSolidColor(color)
                }
            }
        }
    }

    override fun toString(): String {
        return "$tag ${if (parseFromText) text else colorInt?.run { text }} $END"
    }
}
</code></pre>
<p>同理，我们处理完：</p>
<ul>
<li>Corners</li>
<li>ShapeType</li>
<li>Stroke</li>
<li>Size</li>
<li>Padding</li>
<li>Gradient</li>
</ul>
<p>即可。</p>
<h4 id="最重要的shape"><a class="header" href="#最重要的shape">最重要的Shape</a></h4>
<p>至此，我们只需要再解析 <code>shape:[]</code> 即可完成工作。</p>
<p>很简单，只要我们识别出来，其子域的描述子句均可被提取出来，<em>利用 <code>;</code> 分割子句</em>，那么我们只需要用 <code>ListExpression</code> 即可储存子句。</p>
<p>代码略</p>
<blockquote>
<p>注，至此，我们完成了文法的定义和解析处理，注意，目前所有的主体都是 GradientDrawable，他的文法已经足够复杂了，</p>
<p>StateListDrawable 所对应的各种状态
我们不在文法中进行扩展了，否则单条语句的长度会非常可怕。</p>
</blockquote>
<h2 id="到底是dsl还是oo"><a class="header" href="#到底是dsl还是oo"><a id="anchor2">到底是DSL还是OO</a></a></h2>
<blockquote>
<p>前面我们谈到了这个问题，要满足</p>
<ul>
<li>丢弃单独文件定义</li>
<li>方便，不需要查手册</li>
</ul>
<p>两个要素，只想到两个关键词： <code>DSL</code>，<code>OO</code>，即 <code>领域特定语言</code> 和 <code>面向对象</code>。</p>
</blockquote>
<p>当时我们切到了其他话题，并顺带着已经把 <code>DSL方案</code> 的核心实现了。</p>
<p>我们注意到，如果使用DSL，直接使用 <code>字符串形式</code> 的 <code>表达语句</code>，这 <code>很不人道主义</code>。</p>
<blockquote>
<p>我们不太可能像web技术那样，再走一条 css 方式的道路</p>
</blockquote>
<p>那么，我们目前做的都是鸡肋吗？</p>
<p>这个问题，笔者我目前也无法回答，因为我站得高度还不够高。</p>
<p>但是，这不影响我们继续探究：如何使用OO思想，让构建变得更加简单</p>
<h3 id="在文法符号的相关类基础上面向对象"><a class="header" href="#在文法符号的相关类基础上面向对象">在文法符号的相关类基础上，面向对象</a></h3>
<p>在前面的工作中，我们定义了一堆 <code>终结符</code> 和 <code>非终结符</code> 对应的类，而其语法树结构，是通过直接反解
一段 <code>文法表达式字符串</code> 得到的。</p>
<p>反过来想，我们直接面向对象操作，也可以直接构建出期望的语法树。</p>
<p>只要有正确的语法树，执行后一样可以得到期望的结果。</p>
<p><strong>想通这一点，编码就很容易了，这里我们略去相关源码。</strong></p>
<blockquote>
<p>注：至此，究竟是 <code>面向对象</code> 构建语法树处理问题，还是使用 <code>文法表达式字符串</code> 构建语法树，已经不再重要。
其本质都是构建语法树以描述Drawable的构建规则，只不过是在两个世界中的不同表达形式</p>
</blockquote>
<h3 id="最后一步巧借东风借助databinding直接在xml中使用"><a class="header" href="#最后一步巧借东风借助databinding直接在xml中使用">最后一步，巧借东风，借助DataBinding，直接在xml中使用</a></h3>
<p>我们知道，利用DataBinding，可以直接在xml中实现声明使用</p>
<p>再结合 <code>BindingAdapter</code> 机制，我们就可以实现 <code>声明背景</code> 的目标。</p>
<pre><code class="language-kotlin">
@BindingAdapter(
    "daVinCi_bg", "daVinCi_bg_pressed", "daVinCi_bg_unpressed",
    "daVinCi_bg_checkable", "daVinCi_bg_uncheckable", "daVinCi_bg_checked", "daVinCi_bg_unchecked",
    requireAll = false
)
fun View.daVinCi(
    normal: DaVinCiExpression? = null,
    pressed: DaVinCiExpression? = null, unpressed: DaVinCiExpression? = null,
    checkable: DaVinCiExpression? = null, uncheckable: DaVinCiExpression? = null,
    checked: DaVinCiExpression? = null, unchecked: DaVinCiExpression? = null
) {
    val daVinCi = DaVinCi(null, this)
    //用于多次构建
    val daVinCiLoop = DaVinCi(null, this)

    normal?.let {
        daVinCi.apply {
            currentToken = normal.startTag()
        }
        if (DaVinCi.enableDebugLog) Log.d(sLogTag, "${this.logTag()} daVinCi normal:$normal")

        normal.injectThenParse(daVinCi)
        normal.interpret()
    }

    pressed?.let {
        simplify(daVinCiLoop, it, "pressed", this)
        daVinCi.core.setPressedDrawable(daVinCiLoop.core.build())
        daVinCiLoop.core.clear()
    }

    unpressed?.let {
        simplify(daVinCiLoop, it, "unpressed", this)
        daVinCi.core.setUnPressedDrawable(daVinCiLoop.core.build())
        daVinCiLoop.core.clear()
    }

    checkable?.let {
        simplify(daVinCiLoop, it, "checkable", this)
        daVinCi.core.setCheckableDrawable(daVinCiLoop.core.build())
        daVinCiLoop.core.clear()
    }

    uncheckable?.let {
        simplify(daVinCiLoop, it, "uncheckable", this)
        daVinCi.core.setUnCheckableDrawable(daVinCiLoop.core.build())
        daVinCiLoop.core.clear()
    }

    checked?.let {
        simplify(daVinCiLoop, it, "checked", this)
        daVinCi.core.setCheckedDrawable(daVinCiLoop.core.build())
        daVinCiLoop.core.clear()
    }

    unchecked?.let {
        simplify(daVinCiLoop, it, "unchecked", this)
        daVinCi.core.setUnCheckedDrawable(daVinCiLoop.core.build())
        daVinCiLoop.core.clear()
    }


    //下面的略
    //    private var enabledDrawable: Drawable? = null
    //    private var unEnabledDrawable: Drawable? = null
    //    private var selectedDrawable: Drawable? = null
    //    private var focusedDrawable: Drawable? = null
    //    private var focusedHovered: Drawable? = null
    //    private var focusedActivated: Drawable? = null
    //    private var unSelectedDrawable: Drawable? = null
    //    private var unFocusedDrawable: Drawable? = null
    //    private var unFocusedHovered: Drawable? = null
    //    private var unFocusedActivated: Drawable? = null

    ViewCompat.setBackground(this, daVinCi.core.build())
}
</code></pre>
<p>示例：</p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;layout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"&gt;

    &lt;data&gt;

        &lt;variable
            name="a"
            type="String" /&gt;

        &lt;import type="osp.leobert.android.davinci.DaVinCiExpression" /&gt;

    &lt;/data&gt;

    &lt;androidx.core.widget.NestedScrollView
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        tools:context=".MainActivity"&gt;

        &lt;LinearLayout
            daVinCi_bg="@{DaVinCiExpression.shape().solid(`#eaeaea`)}"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:padding="10dp"&gt;

            &lt;TextView
                android:id="@+id/test"
                daVinCi_bg="@{DaVinCiExpression.shape().corner(60).solid(`@i2`).stroke(`4dp`,`@i2`)}"
                android:layout_width="match_parent"
                android:layout_height="100dp"
                android:layout_marginTop="10dp"
                android:background="@drawable/test"
                android:gravity="center"
                android:text="@string/app_name"&gt;

                &lt;tag
                    android:id="@id/i1"
                    android:value="@color/colorPrimaryDark" /&gt;

                &lt;tag
                    android:id="@id/i2"
                    android:value="@color/colorAccent" /&gt;
            &lt;/TextView&gt;

            &lt;Button
                daVinCi_bg_pressed="@{DaVinCiExpression.shape().corner(`10dp,15dp,20dp,30dp`).stroke(`4dp`,`@i2`).gradient(`#26262a`,`#ff0699`,0)}"
                daVinCi_bg_unpressed="@{DaVinCiExpression.shape().corner(60).solid(`@i1`).stroke(`4dp`,`@i2`)}"
                android:layout_width="match_parent"
                android:layout_height="100dp"
                android:gravity="center"
                android:text="Hello World!"&gt;

                &lt;tag
                    android:id="@id/i1"
                    android:value="@color/colorPrimaryDark" /&gt;

                &lt;tag
                    android:id="@id/i2"
                    android:value="@color/colorAccent" /&gt;
            &lt;/Button&gt;

            &lt;TextView
                android:id="@+id/test2"
                daVinCi_bg="@{DaVinCiExpression.shape().corner(`10dp,15dp,20dp,30dp`).stroke(`4dp`,`@i2`).gradient(`#26262a`,`#ff0699`,0)}"
                android:layout_width="match_parent"
                android:layout_height="100dp"
                android:layout_marginTop="10dp"
                android:background="@drawable/test"
                android:gravity="center"
                android:text="@string/app_name"&gt;

                &lt;tag
                    android:id="@id/i1"
                    android:value="@color/colorPrimaryDark" /&gt;

                &lt;tag
                    android:id="@id/i2"
                    android:value="@color/colorAccent" /&gt;
            &lt;/TextView&gt;

            &lt;CheckBox
                daVinCi_bg="@{DaVinCiExpression.shape().corner(60).solid(`@i2`).stroke(`4dp`,`@i2`)}"
                daVinCi_bg_pressed="@{DaVinCiExpression.shape().corner(`10dp,15dp,20dp,30dp`).stroke(`4dp`,`@i2`).gradient(`#26262a`,`#ff0699`,0)}"
                android:layout_width="match_parent"
                android:layout_height="100dp"
                android:layout_marginTop="10dp"
                android:background="@drawable/test"
                android:gravity="center"
                android:text="错误示范：daVinCi_bg只能单独使用，一旦有其他的，就需要使用相应的成对的"&gt;

                &lt;tag
                    android:id="@id/i1"
                    android:value="@color/colorPrimaryDark" /&gt;

                &lt;tag
                    android:id="@id/i2"
                    android:value="@color/colorAccent" /&gt;
            &lt;/CheckBox&gt;

            &lt;CheckBox
                daVinCi_bg_checked="@{DaVinCiExpression.shape().corner(60).solid(`@i2`).stroke(`4dp`,`@i2`)}"
                daVinCi_bg_unchecked="@{DaVinCiExpression.shape().corner(`10dp,15dp,20dp,30dp`).stroke(`4dp`,`@i2`).gradient(`#26262a`,`#ff0699`,0)}"
                android:layout_width="match_parent"
                android:layout_height="100dp"
                android:layout_marginTop="10dp"
                android:background="@drawable/test"
                android:gravity="center"
                android:text="check状态"&gt;

                &lt;tag
                    android:id="@id/log_tag"
                    android:value="测试log tag" /&gt;

                &lt;tag
                    android:id="@id/i1"
                    android:value="@color/colorPrimaryDark" /&gt;

                &lt;tag
                    android:id="@id/i2"
                    android:value="@color/colorAccent" /&gt;

                &lt;tag
                    android:id="@id/i3"
                    android:value="@string/app_name" /&gt;
            &lt;/CheckBox&gt;

        &lt;/LinearLayout&gt;

    &lt;/androidx.core.widget.NestedScrollView&gt;

&lt;/layout&gt;
</code></pre>
<p>粗糙的Demo效果，见笑了： <em>感谢读者<code>鲁班贼六</code>同学提醒我补充效果图</em></p>
<p><img src="post_4/demo2.png" alt="demo" /></p>
<p>甚至可以玩杂耍，直接使用字符串形式的DSL内容：</p>
<pre><code class="language-kotlin">binding.test2.setOnClickListener {
    it.daVinCi("shape:[ gradient:[ type:linear;startColor:#ff3c08;endColor:#353538 ];" +
            " st:[ Oval ]; corners:[ 40dp ]; stroke:[ width:4dp;color:rc/colorAccent ] ]")
}
</code></pre>
<p>注意，这个方式不推荐使用，很不利于维护，就是 <code>杂耍</code>，可以直接更新背景：</p>
<p><img src="post_4/demo3.png" alt="demo3" /></p>
<h2 id="总结和展望"><a class="header" href="#总结和展望">总结和展望</a></h2>
<p>这一篇，我们从一个问题：</p>
<blockquote>
<p>xml定义的资源文件难以管理、维护</p>
</blockquote>
<p>开始，尝试性的提出了一种 替代xml 定义背景资源文件的方式。并进行了知识展开和拓展。
最终实现了期望目标。</p>
<p>但是，使用 <code>xml文件</code> 或者其他形式的文件来定义资源，是有它的道理的，虽然，这种方式的弊端已经被长久诟病，
并且在新兴技术中，资源和代码的存在位置已经开始交融。</p>
<p>我们知道，Compose这一革命性技术，新事物想要完全替代旧事物，不是一朝一夕的事情，旧事物不会突然消失。</p>
<p>本文中的方案，我将其视为一次 <code>好玩</code> ，<code>跟时髦</code> 的尝试。并且我个人认为，这一方案还是有存在价值的。</p>
<p>而在此基础上，还可以继续开展 style定义和使用，<code>ColorStateList</code> 文法表达式。</p>
<p>今天是除夕，祝大家除夕快乐。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../Android/Drawable/post_2.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../Android/Drawable/post_47.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../Android/Drawable/post_2.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../Android/Drawable/post_47.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
