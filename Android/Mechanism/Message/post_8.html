<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>三思系列：Android的消息机制，一文吃透 - leobert&#x27;s blog</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../../favicon.svg">
        <link rel="shortcut icon" href="../../../favicon.png">
        <link rel="stylesheet" href="../../../css/variables.css">
        <link rel="stylesheet" href="../../../css/general.css">
        <link rel="stylesheet" href="../../../css/chrome.css">
        <link rel="stylesheet" href="../../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../../highlight.css">
        <link rel="stylesheet" href="../../../tomorrow-night.css">
        <link rel="stylesheet" href="../../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">目录</li><li class="chapter-item expanded "><a href="../../../Android/index.html"><strong aria-hidden="true">1.</strong> Android</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../Android/View/index.html"><strong aria-hidden="true">1.1.</strong> View</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../Android/View/post_1.html"><strong aria-hidden="true">1.1.1.</strong> 好玩系列：优雅的处理ButterKnife和KAE被废弃</a></li><li class="chapter-item expanded "><a href="../../../Android/View/post_6.html"><strong aria-hidden="true">1.1.2.</strong> 三思系列：View体系认知(一)，内容是如何正确被展现出来的--视觉呈现概览</a></li><li class="chapter-item expanded "><a href="../../../Android/View/post_7.html"><strong aria-hidden="true">1.1.3.</strong> 三思系列：为什么自定义View</a></li><li class="chapter-item expanded "><a href="../../../Android/Idea/post_9.html"><strong aria-hidden="true">1.1.4.</strong> 三思系列："声明式UI"和"命令式UI"，你的理解可能是错的</a></li></ol></li><li class="chapter-item expanded "><a href="../../../Android/Drawable/index.html"><strong aria-hidden="true">1.2.</strong> Drawable</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../Android/Drawable/post_2.html"><strong aria-hidden="true">1.2.1.</strong> 三思系列：重新认识Drawable</a></li><li class="chapter-item expanded "><a href="../../../Android/Drawable/post_4.html"><strong aria-hidden="true">1.2.2.</strong> 好玩系列：拥有它，XML文件少一半--更方便的处理View背景</a></li><li class="chapter-item expanded "><a href="../../../Android/Drawable/post_47.html"><strong aria-hidden="true">1.2.3.</strong> 迟来的续集--Drawable+Animator，将优雅进行到底</a></li><li class="chapter-item expanded "><a href="../../../Android/Drawable/post_49.html"><strong aria-hidden="true">1.2.4.</strong> 好玩系列：让ImageSpan动起来</a></li></ol></li><li class="chapter-item expanded "><a href="../../../Android/Mechanism/Message/index.html"><strong aria-hidden="true">1.3.</strong> 消息机制</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../Android/Mechanism/Message/post_8.html" class="active"><strong aria-hidden="true">1.3.1.</strong> 三思系列：Android的消息机制，一文吃透</a></li></ol></li><li class="chapter-item expanded "><a href="../../../Android/Idea/post_14/index.html"><strong aria-hidden="true">1.4.</strong> 兼容</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../Android/Idea/post_14.html"><strong aria-hidden="true">1.4.1.</strong> 好玩系列：让项目中的相册支持Heif格式图片</a></li></ol></li><li class="chapter-item expanded "><a href="../../../Android/Glide/index.html"><strong aria-hidden="true">1.5.</strong> Glide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../Android/Glide/post_15.html"><strong aria-hidden="true">1.5.1.</strong> 三思系列：Glide 4.X全方位认知 -- 模块职责概览</a></li><li class="chapter-item expanded "><a href="../../../Android/Glide/post_16.html"><strong aria-hidden="true">1.5.2.</strong> 三思系列：Glide 4.X加载过程一文掌握 | Glide（二）</a></li></ol></li><li class="chapter-item expanded "><a href="../../../Android/KSP/index.html"><strong aria-hidden="true">1.6.</strong> KSP</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../Android/KSP/post_24.html"><strong aria-hidden="true">1.6.1.</strong> 好玩系列 | 拥抱Kotlin Symbol Processing(KSP),项目实战</a></li></ol></li><li class="chapter-item expanded "><a href="../../../Android/Base/index.html"><strong aria-hidden="true">1.7.</strong> 基础</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../Android/Base/post_35.html"><strong aria-hidden="true">1.7.1.</strong> 孔乙己：你可知道页面和弹窗“通信“的方式有四种？</a></li></ol></li><li class="chapter-item expanded "><a href="../../../Android/SysApp/index.html"><strong aria-hidden="true">1.8.</strong> 系统APP</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../Android/SysApp/post_52.html"><strong aria-hidden="true">1.8.1.</strong> 使用日历丰富产品的用户体验</a></li></ol></li><li class="chapter-item expanded "><a href="../../../Android/DI/index.html"><strong aria-hidden="true">1.9.</strong> Part4-依赖注入部分</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../Android/DI/post_53.html"><strong aria-hidden="true">1.9.1.</strong> Hilt进阶--一文吃透Hilt自定义与跨壁垒</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../../Compose/index.html"><strong aria-hidden="true">2.</strong> Jetpack Compose</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../Compose/post_21.html"><strong aria-hidden="true">2.1.</strong> Jetpack Compose | 一文理解神奇的Modifier</a></li><li class="chapter-item expanded "><a href="../../../Compose/post_26.html"><strong aria-hidden="true">2.2.</strong> Jetpack Compose | 控件篇（一） -- Text、TextField、Button</a></li><li class="chapter-item expanded "><a href="../../../Compose/post_27.html"><strong aria-hidden="true">2.3.</strong> Jetpack Compose | 控件篇（二） -- Icon，Image</a></li><li class="chapter-item expanded "><a href="../../../Compose/post_28.html"><strong aria-hidden="true">2.4.</strong> Jetpack Compose | 控件篇（三） -- Switch、CheckBox、RadioButton</a></li><li class="chapter-item expanded "><a href="../../../Compose/post_29.html"><strong aria-hidden="true">2.5.</strong> Jetpack Compose | 控件篇（四）-- Box、Row、Column</a></li><li class="chapter-item expanded "><a href="../../../Compose/post_30.html"><strong aria-hidden="true">2.6.</strong> Jetpack Compose | 控件篇（五）-- Spacer、LazyRow、LazyColumn & 让Column可滑动</a></li></ol></li><li class="chapter-item expanded "><a href="../../../MultiThreading/index.html"><strong aria-hidden="true">3.</strong> Java多线程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../MultiThreading/post_33.html"><strong aria-hidden="true">3.1.</strong> 总纲</a></li><li class="chapter-item expanded "><a href="../../../MultiThreading/post_37.html"><strong aria-hidden="true">3.2.</strong> Java基础--图解JVM内存模型和JVM线程模型</a></li><li class="chapter-item expanded "><a href="../../../MultiThreading/post_38.html"><strong aria-hidden="true">3.3.</strong> Java多线程系列--掌控面试，一文吃透Synchronized锁</a></li><li class="chapter-item expanded "><a href="../../../MultiThreading/post_39.html"><strong aria-hidden="true">3.4.</strong> Java多线程基础--线程生命周期与线程协作详解</a></li><li class="chapter-item expanded "><a href="../../../MultiThreading/post_42.html"><strong aria-hidden="true">3.5.</strong> Java多线程基础--线程的创建与线程池管理</a></li><li class="chapter-item expanded "><a href="../../../MultiThreading/post_46.html"><strong aria-hidden="true">3.6.</strong> Java多线程系列--掌握Future，轻松获取异步任务结果</a></li><li class="chapter-item expanded "><a href="../../../MultiThreading/post_50.html"><strong aria-hidden="true">3.7.</strong> Java多线程系列--Fork&Join框架，分治的艺术</a></li><li class="chapter-item expanded "><a href="../../../MultiThreading/post_54.html"><strong aria-hidden="true">3.8.</strong> Java多线程系列--掌握CompletableFuture，驾驭异步编程</a></li></ol></li><li class="chapter-item expanded "><a href="../../../IO/index.html"><strong aria-hidden="true">4.</strong> Java IO系列</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../IO/post_55.html"><strong aria-hidden="true">4.1.</strong> Java IO 系列总纲</a></li><li class="chapter-item expanded "><a href="../../../IO/post_56.html"><strong aria-hidden="true">4.2.</strong> Java IO系列 | 经典 IO</a></li><li class="chapter-item expanded "><a href="../../../IO/post_57.html"><strong aria-hidden="true">4.3.</strong> Java IO 系列 | NIO-1.0一文速览</a></li><li class="chapter-item expanded "><a href="../../../IO/post_58.html"><strong aria-hidden="true">4.4.</strong> Java IO系列 | NIO-1.0拾遗、NIO-2.0 & 零拷贝必吹的牛皮</a></li><li class="chapter-item expanded "><a href="../../../IO/post_59.html"><strong aria-hidden="true">4.5.</strong> IO系列 | 一文掌握OKHTTP中的OKIO为什么这么OK</a></li></ol></li><li class="chapter-item expanded "><a href="../../../Gradle/index.html"><strong aria-hidden="true">5.</strong> Gradle</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../Gradle/Modularization/post_18.html"><strong aria-hidden="true">5.1.</strong> 组件化：三思系列：组件化场景下module依赖优雅实践方案</a></li><li class="chapter-item expanded "><a href="../../../Gradle/Publish/post_17.html"><strong aria-hidden="true">5.2.</strong> MavenCentral发布：迁移到MavenCentral--再不行动起来，你的托管的library就没了</a></li><li class="chapter-item expanded "><a href="../../../Gradle/post_22.html"><strong aria-hidden="true">5.3.</strong> Gradle | 依赖管理最佳实践</a></li></ol></li><li class="chapter-item expanded "><a href="../../../Groovy/index.html"><strong aria-hidden="true">6.</strong> Groovy</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../Groovy/why_write_groovy.html"><strong aria-hidden="true">6.1.</strong> 为什么撰写这个系列</a></li><li class="chapter-item expanded "><a href="../../../Groovy/post_23.html"><strong aria-hidden="true">6.2.</strong> Groovy：MOP一文打尽</a></li></ol></li><li class="chapter-item expanded "><a href="../../../Review/index.html"><strong aria-hidden="true">7.</strong> Review</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../Review/post_10.html"><strong aria-hidden="true">7.1.</strong> 造完了这个轮子--Mocker，却让我感到很羞愧|项目复盘</a></li><li class="chapter-item expanded "><a href="../../../Review/post_40.html"><strong aria-hidden="true">7.2.</strong> 三思系列：前人用GreenDao留下的坑，全线被扣了绩效</a></li><li class="chapter-item expanded "><a href="../../../Review/post_44.html"><strong aria-hidden="true">7.3.</strong> 谈一谈在两个商业项目中使用MVI架构后的感悟</a></li><li class="chapter-item expanded "><a href="../../../Review/post_45.html"><strong aria-hidden="true">7.4.</strong> Review | 这三个坑你遇到了吗？</a></li></ol></li><li class="chapter-item expanded "><a href="../../../repo/index.html"><strong aria-hidden="true">8.</strong> 个人项目</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../repo/DaVinCi.html"><strong aria-hidden="true">8.1.</strong> DaVinCi,取代XML编写Shape或ColorStateList的方案</a></li><li class="chapter-item expanded "><a href="../../../Android/Idea/post_32.html"><strong aria-hidden="true">8.2.</strong> 好玩系列：白嫖一个优雅的类图生成工具</a></li><li class="chapter-item expanded "><a href="../../../Speculative/post_43.html"><strong aria-hidden="true">8.3.</strong> 初体验：动手搭建"小清新式"局域网文档系统</a></li><li class="chapter-item expanded "><a href="../../../repo/post_48.html"><strong aria-hidden="true">8.4.</strong> 研究良久，终于发现了他代码写的快且bug少的原因</a></li><li class="chapter-item expanded "><a href="../../../Speculative/post_61.html"><strong aria-hidden="true">8.5.</strong> 好玩系列 | 如果后端让你用SSE接收多次返回，那我们改造Retrofit吧</a></li></ol></li><li class="chapter-item expanded "><a href="../../../Review/DataStructure/index.html"><strong aria-hidden="true">9.</strong> 数据结构</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../Review/DataStructure/post_11.html"><strong aria-hidden="true">9.1.</strong> 温故：线性表</a></li><li class="chapter-item expanded "><a href="../../../Review/DataStructure/post_12.html"><strong aria-hidden="true">9.2.</strong> 温故：栈</a></li><li class="chapter-item expanded "><a href="../../../Review/DataStructure/post_13.html"><strong aria-hidden="true">9.3.</strong> 温故：队列</a></li></ol></li><li class="chapter-item expanded "><a href="../../../Review/README2.html"><strong aria-hidden="true">10.</strong> 年终总结&计划</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../Review/post_36.html"><strong aria-hidden="true">10.1.</strong> 2021年终总结</a></li><li class="chapter-item expanded "><a href="../../../Review/post_51.html"><strong aria-hidden="true">10.2.</strong> 关于画一个句号--基于2022年终总结的反思与分享</a></li><li class="chapter-item expanded "><a href="../../../Review/post_60.html"><strong aria-hidden="true">10.3.</strong> 突如其来的秋季反思</a></li><li class="chapter-item expanded "><a href="../../../Review/post_63.html"><strong aria-hidden="true">10.4.</strong> 2023年总结 寻找到源于内心深处的无穷力量</a></li><li class="chapter-item expanded "><a href="../../../Review/post_64.html"><strong aria-hidden="true">10.5.</strong> 2024年中思考，推倒樊笼重新出发</a></li></ol></li><li class="chapter-item expanded "><a href="../../../Note/index.html"><strong aria-hidden="true">11.</strong> 读书笔记</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../Note/post_41.html"><strong aria-hidden="true">11.1.</strong> 读书笔记：《简约至上--交互式设计四策略》</a></li></ol></li><li class="chapter-item expanded "><a href="../../../Talk/index.html"><strong aria-hidden="true">12.</strong> 杂谈</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../Talk/talk_1.html"><strong aria-hidden="true">12.1.</strong> 杂谈1-2022-11</a></li><li class="chapter-item expanded "><a href="../../../Talk/talk_2_2023-03.html"><strong aria-hidden="true">12.2.</strong> 杂篇（二）-- 认识并战胜焦虑</a></li><li class="chapter-item expanded "><a href="../../../Talk/talk_3_2024-08.html"><strong aria-hidden="true">12.3.</strong> 杂谈（三）-- 向钱看，你需要想明白企业在为什么而付钱</a></li></ol></li><li class="chapter-item expanded "><a href="../../../Thought/index.html"><strong aria-hidden="true">13.</strong> 半成熟的思考</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../Thought/post_62.html"><strong aria-hidden="true">13.1.</strong> 好玩系列 | 当SPI 和 设计模式、依赖注入发生碰撞，可以擦出怎样的火花</a></li></ol></li><li class="chapter-item expanded "><a href="../../../info/index.html"><strong aria-hidden="true">14.</strong> 系列说明</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../info/about_view_series.html"><strong aria-hidden="true">14.1.</strong> 关于View系列</a></li><li class="chapter-item expanded "><a href="../../../info/about_sansi_series.html"><strong aria-hidden="true">14.2.</strong> 关于三思系列</a></li><li class="chapter-item expanded "><a href="../../../info/about_haowan_series.html"><strong aria-hidden="true">14.3.</strong> 关于好玩系列</a></li><li class="chapter-item expanded "><a href="../../../info/about_wengu_series.html"><strong aria-hidden="true">14.4.</strong> 关于温故系列</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">leobert&#x27;s blog</h1>

                    <div class="right-buttons">
                        <a href="../../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="三思系列android的消息机制一文吃透"><a class="header" href="#三思系列android的消息机制一文吃透">三思系列：Android的消息机制，一文吃透</a></h1>
<blockquote>
<p>三思系列是我最新的学习、总结形式，着重于:<strong>问题分析</strong>、<strong>技术积累</strong>、<strong>视野拓展</strong>，<a href="https://leobert-lan.github.io/info/about_sansi_series.html">关于三思系列</a></p>
</blockquote>
<p>这次，真的可以一文吃透：</p>
<ul>
<li>Java层消息队列的设计</li>
<li>Java层Looper分发</li>
<li>Native层消息队列和Java层消息队列的关系</li>
<li>Native层Looper分发</li>
<li>消息</li>
<li>epoll</li>
</ul>
<h2 id="前言"><a class="header" href="#前言">前言</a></h2>
<p>作为Android中 <code>至关重要</code> 的机制之一，十多年来，分析它的文章不断，大量的内容已经被挖掘过了。所以：</p>
<ul>
<li>已经对这一机制比较 <code>熟稔</code> 的读者，在这篇文章中，看不到 <code>新东西</code> 了。</li>
<li>还不太熟悉消息机制的读者，可以在文章的基础上，继续挖一挖。</li>
</ul>
<p>但是，经过简单的检索和分析，<code>大部分</code> 的文章是围绕：</p>
<ul>
<li>Handler，Looper，MQ的关系</li>
<li>上层的Handler，Looper、MQ 源码分析</li>
</ul>
<p>展开的。单纯的从这些角度学习的话，并不能 <code>完全理解</code> 消息机制。</p>
<p>这篇文章本质还是 <code>一次脑暴</code> ，一来 <code>避免脑暴跑偏</code> ，二来帮助读者 <code>捋清内容脉络</code> 。先放出脑图：</p>
<p><img src="%E4%B8%89%E6%80%9D%E7%B3%BB%E5%88%97%EF%BC%9AAndroid%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%EF%BC%8C%E4%B8%80%E6%96%87%E5%90%83%E9%80%8F/guide.png" alt="guide" /></p>
<h2 id="脑暴os解决进程间通信问题"><a class="header" href="#脑暴os解决进程间通信问题">脑暴：OS解决进程间通信问题</a></h2>
<p>程序世界中，存在着大量的 <code>通信</code> 场景。搜索我们的知识，解决 <code>进程间通信</code> 问题有以下几种方式：</p>
<p><em>这段内容可以泛读，了解就行，不影响往下阅读</em></p>
<blockquote>
<ul>
<li>
<p>管道</p>
<ul>
<li>普通管道pipe：一种 <code>半双工</code> 的通信方式，数据只能 <code>单向流动</code> ，而且只能在具有 <code>亲缘关系</code> 的进程间使用。</li>
<li>命令流管道s_pipe: <code>全双工</code>，可以同时双向传输</li>
<li>命名管道FIFO：<code>半双工</code> 的通信方式，<code>允许</code> 在 <code>无亲缘关系</code> 的进程间通信。</li>
</ul>
</li>
<li>
<p>消息队列 MessageQueue：</p>
</li>
</ul>
<p><code>消息的链表</code>，<code>存放在内核</code> 中 并由 <code>消息队列标识符</code> 标识。
消息队列克服了 <code>信号传递信息少</code>、<code>管道</code> 只能承载 <code>无格式字节流</code> 以及 <code>缓冲区大小受限</code> 等缺点。</p>
<ul>
<li>共享存储 SharedMemory：</li>
</ul>
<p>映射一段 <code>能被其他进程所访问</code> 的内存，这段共享内存由 <code>一个进程创建</code>，但 <code>多个进程都可以访问</code>。
共享内存是 <code>最快的 IPC 方式</code>，它是针对 <code>其他</code> 进程间通信方式 <code>运行效率低</code> 而专门设计的。
往往与其他通信机制一同使用，如 <code>信号量</code> 配合使用，来实现进程间的同步和通信。</p>
<ul>
<li>信号量 Semaphore：</li>
</ul>
<p>是一个 <code>计数器</code> ，可以用来控制多个进程对共享资源的访问。它常作为一种 <code>锁机制</code>，防止某进程正在访问共享资源时，
其他进程也访问该资源，实现 <code>资源的进程独占</code>。因此，主要作为 <code>进程间</code> 以及 <code>同一进程内线程间</code> 的同步手段。</p>
<ul>
<li>套接字Socket：</li>
</ul>
<p>与其他通信机制不同的是，它可以 <code>通过网络</code> ，在 <code>不同机器之间</code> 进行进程通信。</p>
<ul>
<li>信号 signal：</li>
</ul>
<p>用于通知接收进程 <code>某事件已发生</code>。机制比较复杂。</p>
</blockquote>
<p>我们可以想象，Android之间也有大量的 <code>进程间通信场景</code>，OS必须采用 <code>至少一种</code> 机制，以实现进程间通信。</p>
<p>仔细研究下去，我们发现，Android OS用了不止一种方式。而且，Android 还基于 <code>OpenBinder</code> 开发了 <code>Binder</code> 用于 <code>用户空间</code> 内的进程间通信。</p>
<p>关于 <strong>为什么不直接使用Linux中现有的进程间通信方式</strong> ，可以看看<a href="https://www.zhihu.com/question/39440766/answer/89210950">这篇知乎问答</a></p>
<p><a href="https://www.jianshu.com/p/1b25bc6b861e">这篇文章</a> 也简单探讨了 "内核空间内的消息队列"</p>
<p>这里我们留一个问题以后探究：</p>
<blockquote>
<p>Android 有没有使用 Linux内核中的MessageQueue机制 干事情</p>
</blockquote>
<p>基于消息队列的消息机制设计有很多优势，Android 在很多通信场景内，采用了这一设计思路。</p>
<h2 id="消息机制的三要素"><a class="header" href="#消息机制的三要素">消息机制的三要素</a></h2>
<p>不管在哪，我们谈到消息机制，都会有这三个要素：</p>
<ul>
<li><code>消息队列</code></li>
<li><code>消息循环（分发）</code></li>
<li><code>消息处理</code></li>
</ul>
<p><code>消息队列</code> ，是 <code>消息对象</code> 的队列，基本规则是 <code>FIFO</code>。</p>
<p><code>消息循环（分发）</code>， 基本是通用的机制，利用 <code>死循环</code> 不断的取出消息队列头部的消息，派发执行</p>
<p><code>消息处理</code>，这里不得不提到 <code>消息</code> 有两种形式：</p>
<ul>
<li>Enrichment 自身信息完备</li>
<li>Query-Back 自身信息不完备，需要回查</li>
</ul>
<p>这两者的取舍，主要看系统中 <code>生成消息的开销</code> 和 <code>回查信息的开销</code> 两者的博弈。</p>
<p>在信息完备后，接收者即可处理消息。</p>
<h2 id="android-framework中的消息队列"><a class="header" href="#android-framework中的消息队列">Android Framework中的消息队列</a></h2>
<p>Android 的Framework中的消息队列有两个：</p>
<ul>
<li>Java层  <code>frameworks/base/core/java/android/os/MessageQueue.java</code></li>
<li>Native层 <code>frameworks/base/core/jni/android_os_MessageQueue.cpp</code></li>
</ul>
<p>Java层的MQ并不是 <code>List</code> 或者 <code>Queue</code> 之类的 Jdk内的数据结构实现。</p>
<p>Native层的源码我下载了一份 Android 10 的 <a href="https://github.com/leobert-lan/Blog/blob/main/Android/Mechanism/Message/code/android_os_MessageQueue.cpp">源码</a> ，并不长，大家可以完整的读一读。</p>
<blockquote>
<p>并不难理解：<code>用户空间</code> 会接收到来自 <code>内核空间</code> 的 <code>消息</code> ， 从 <code>下图</code> 我们可知，这部分消息先被 <code>Native层</code> 获知，所以：</p>
<ul>
<li>通过 <code>Native层</code> 建立消息队列，它拥有消息队列的各种基本能力</li>
<li>利用<code>JNI</code> 打通 <code>Java层</code> 和 <code>Native层</code> 的 <code>Runtime屏障</code>，在Java层 <code>映射</code> 出消息队列</li>
<li>应用建立在Java层之上，在Java层中实现消息的 <code>分发</code> 和 <code>处理</code></li>
</ul>
<p>PS：在Android 2.3那个时代，消息队列的实现是在Java层的，至于10年前为何改成了 native实现，
推测和CPU空转有关，笔者没有继续探究下去，如果有读者了解，希望可以留言帮我解惑。</p>
</blockquote>
<p><img src="https://developer.android.google.cn/guide/platform/images/android-stack_2x.png" alt="" /></p>
<p><em>PS:还有一张经典的 <code>系统启动架构图</code> 没有找到，这张图更加直观</em></p>
<h3 id="代码解析"><a class="header" href="#代码解析">代码解析</a></h3>
<p>我们简单的 阅读、分析 下Native中的MQ源码</p>
<p>Native层消息队列的创建：</p>
<pre><code class="language-cpp">static jlong android_os_MessageQueue_nativeInit(JNIEnv* env, jclass clazz) {
    NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue();
    if (!nativeMessageQueue) {
        jniThrowRuntimeException(env, "Unable to allocate native queue");
        return 0;
    }

    nativeMessageQueue-&gt;incStrong(env);
    return reinterpret_cast&lt;jlong&gt;(nativeMessageQueue);
}
</code></pre>
<p>很简单，创建一个Native层的消息队列，如果创建失败，抛异常信息,返回0，否则将指针转换为Java的long型值返回。当然，会<code>被Java层的MQ所持有</code>。</p>
<p><code>NativeMessageQueue</code> 类的构造函数</p>
<pre><code class="language-cpp">NativeMessageQueue::NativeMessageQueue() :
        mPollEnv(NULL), mPollObj(NULL), mExceptionObj(NULL) {
    mLooper = Looper::getForThread();
    if (mLooper == NULL) {
        mLooper = new Looper(false);
        Looper::setForThread(mLooper);
    }
}
</code></pre>
<p>这里的Looper是native层Looper，通过静态方法 <code>Looper::getForThread()</code> 获取对象实例，如果未获取到，则创建实例，并通过静态方法设置。</p>
<p>看一下Java层MQ中会使用到的native方法</p>
<pre><code class="language-java">class MessageQueue {
    private long mPtr; // used by native code

    private native static long nativeInit();

    private native static void nativeDestroy(long ptr);

    private native void nativePollOnce(long ptr, int timeoutMillis); /*non-static for callbacks*/

    private native static void nativeWake(long ptr);

    private native static boolean nativeIsPolling(long ptr);

    private native static void nativeSetFileDescriptorEvents(long ptr, int fd, int events);
}
</code></pre>
<p>对应签名：</p>
<pre><code class="language-cpp">static const JNINativeMethod gMessageQueueMethods[] = {
    /* name, signature, funcPtr */
    { "nativeInit", "()J", (void*)android_os_MessageQueue_nativeInit },
    { "nativeDestroy", "(J)V", (void*)android_os_MessageQueue_nativeDestroy },
    { "nativePollOnce", "(JI)V", (void*)android_os_MessageQueue_nativePollOnce },
    { "nativeWake", "(J)V", (void*)android_os_MessageQueue_nativeWake },
    { "nativeIsPolling", "(J)Z", (void*)android_os_MessageQueue_nativeIsPolling },
    { "nativeSetFileDescriptorEvents", "(JII)V",
            (void*)android_os_MessageQueue_nativeSetFileDescriptorEvents },
};
</code></pre>
<p><code>mPtr</code> 是Native层MQ的内存地址在Java层的映射。</p>
<h4 id="java层判断mq是否还在工作"><a class="header" href="#java层判断mq是否还在工作">Java层判断MQ是否还在工作：</a></h4>
<pre><code class="language-java">private boolean isPollingLocked() {
    // If the loop is quitting then it must not be idling.
    // We can assume mPtr != 0 when mQuitting is false.
    return !mQuitting &amp;&amp; nativeIsPolling(mPtr);
}
</code></pre>
<pre><code class="language-cpp">static jboolean android_os_MessageQueue_nativeIsPolling(JNIEnv* env, jclass clazz, jlong ptr) {
    NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr);
    return nativeMessageQueue-&gt;getLooper()-&gt;isPolling();
}
</code></pre>
<pre><code class="language-cpp">/**
 * Returns whether this looper's thread is currently polling for more work to do.
 * This is a good signal that the loop is still alive rather than being stuck
 * handling a callback.  Note that this method is intrinsically racy, since the
 * state of the loop can change before you get the result back.
 */
bool isPolling() const;
</code></pre>
<h4 id="唤醒-native层mq"><a class="header" href="#唤醒-native层mq">唤醒 Native层MQ：</a></h4>
<pre><code class="language-cpp">static void android_os_MessageQueue_nativeWake(JNIEnv* env, jclass clazz, jlong ptr) {
    NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr);
    nativeMessageQueue-&gt;wake();
}

void NativeMessageQueue::wake() {
    mLooper-&gt;wake();
}
</code></pre>
<h4 id="native层poll"><a class="header" href="#native层poll">Native层Poll：</a></h4>
<pre><code class="language-cpp">static void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jobject obj,
        jlong ptr, jint timeoutMillis) {
    NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr);
    nativeMessageQueue-&gt;pollOnce(env, obj, timeoutMillis);
}

void NativeMessageQueue::pollOnce(JNIEnv* env, jobject pollObj, int timeoutMillis) {
    mPollEnv = env;
    mPollObj = pollObj;
    mLooper-&gt;pollOnce(timeoutMillis);
    mPollObj = NULL;
    mPollEnv = NULL;

    if (mExceptionObj) {
        env-&gt;Throw(mExceptionObj);
        env-&gt;DeleteLocalRef(mExceptionObj);
        mExceptionObj = NULL;
    }
}
</code></pre>
<p>这里比较重要，我们先大概看下 Native层的Looper是 <code>如何分发消息</code> 的</p>
<pre><code class="language-cpp">//Looper.h

int pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData);
inline int pollOnce(int timeoutMillis) {
    return pollOnce(timeoutMillis, NULL, NULL, NULL);
}

//实现

int Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) {
    int result = 0;
    for (;;) {
        while (mResponseIndex &lt; mResponses.size()) {
            const Response&amp; response = mResponses.itemAt(mResponseIndex++);
            int ident = response.request.ident;
            if (ident &gt;= 0) {
                int fd = response.request.fd;
                int events = response.events;
                void* data = response.request.data;
#if DEBUG_POLL_AND_WAKE
                ALOGD("%p ~ pollOnce - returning signalled identifier %d: "
                        "fd=%d, events=0x%x, data=%p",
                        this, ident, fd, events, data);
#endif
                if (outFd != NULL) *outFd = fd;
                if (outEvents != NULL) *outEvents = events;
                if (outData != NULL) *outData = data;
                return ident;
            }
        }

        if (result != 0) {
#if DEBUG_POLL_AND_WAKE
            ALOGD("%p ~ pollOnce - returning result %d", this, result);
#endif
            if (outFd != NULL) *outFd = 0;
            if (outEvents != NULL) *outEvents = 0;
            if (outData != NULL) *outData = NULL;
            return result;
        }

        result = pollInner(timeoutMillis);
    }
}

</code></pre>
<p>先处理Native层滞留的Response，然后调用pollInner。这里的细节比较复杂，稍后我们在 <a href="#native_looper">Native Looper解析</a> 中进行脑暴。</p>
<blockquote>
<p>先于此处细节分析，我们知道，调用一个方法，这是<code>阻塞的</code> ，用大白话描述即在方法返回前，调用者在 <code>等待</code>。</p>
</blockquote>
<p>Java层调动 <code>native void nativePollOnce(long ptr, int timeoutMillis);</code> 过程中是阻塞的。</p>
<p>此时我们再阅读下Java层MQ的消息获取：代码比较长，直接在代码中进行要点注释。</p>
<p>在看之前，我们先单纯从 <code>TDD的角度</code> 思考下，有哪些 <code>主要场景</code> ：<em>当然，这些场景不一定都合乎Android现有的设计</em></p>
<ul>
<li>消息队列是否在工作中
<ul>
<li>工作中，期望返回消息</li>
<li>不工作，期望返回null</li>
</ul>
</li>
<li>工作中的消息队列 <code>当前</code> 是否有消息
<ul>
<li>不存在消息，阻塞 or 返回null？-- 如果返回null，则在外部需要需要 <code>保持空转</code> 或者 <code>唤醒机制</code>，以支持正常运作。从封装角度出发，应当 <code>保持空转</code>，自己解决问题</li>
<li>存在消息
<ul>
<li>特殊的 <code>内部功能性消息</code>，期望MQ内部自行处理</li>
<li>已经到处理时间的消息， <strong>返回消息</strong></li>
<li>未到处理时间，<em>如果都是排过序的</em>，期望 <code>空转保持阻塞</code> or <code>返回静默并设置唤醒</code>？ 按照前面的讨论，是期望 <code>保持空转</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-java">class MessageQueue {
    Message next() {
        // Return here if the message loop has already quit and been disposed.
        // This can happen if the application tries to restart a looper after quit
        // which is not supported.
        // 1. 如果 native消息队列指针映射已经为0，即虚引用，说明消息队列已经退出，没有消息了。
        // 则返回 null
        final long ptr = mPtr;
        if (ptr == 0) {
            return null;
        }

        int pendingIdleHandlerCount = -1; // -1 only during first iteration
        int nextPollTimeoutMillis = 0;
        
        // 2. 死循环，当为获取到需要 `分发处理` 的消息时，保持空转
        for (;;) {
            if (nextPollTimeoutMillis != 0) {
                Binder.flushPendingCommands();
            }

            // 3. 调用native层方法，poll message，注意，消息还存在于native层
            nativePollOnce(ptr, nextPollTimeoutMillis);

            synchronized (this) {
                // Try to retrieve the next message.  Return if found.
                final long now = SystemClock.uptimeMillis();
                Message prevMsg = null;
                Message msg = mMessages;
                
                //4. 如果发现 barrier ，即同步屏障，则寻找队列中的下一个可能存在的异步消息
                if (msg != null &amp;&amp; msg.target == null) {
                    // Stalled by a barrier.  Find the next asynchronous message in the queue.
                    do {
                        prevMsg = msg;
                        msg = msg.next;
                    } while (msg != null &amp;&amp; !msg.isAsynchronous());
                }
                
                if (msg != null) {
                    // 5. 发现了消息，
                    // 如果是还没有到约定时间的消息，则设置一个 `下次唤醒` 的最大时间差
                    // 否则 `维护单链表信息` 并返回消息
                    
                    if (now &lt; msg.when) {
                        // Next message is not ready.  Set a timeout to wake up when it is ready.
                        nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
                    } else {
                        // 寻找到了 `到处理时间` 的消息。 `维护单链表信息` 并返回消息
                        // Got a message.
                        mBlocked = false;
                        if (prevMsg != null) {
                            prevMsg.next = msg.next;
                        } else {
                            mMessages = msg.next;
                        }
                        msg.next = null;
                        if (DEBUG) Log.v(TAG, "Returning message: " + msg);
                        msg.markInUse();
                        return msg;
                    }
                } else {
                    // No more messages.
                    nextPollTimeoutMillis = -1;
                }

                // 处理 是否需要 停止消息队列                
                // Process the quit message now that all pending messages have been handled.
                if (mQuitting) {
                    dispose();
                    return null;
                }

                // 维护 接下来需要处理的 IDLEHandler 信息，
                // 如果没有 IDLEHandler，则直接进入下一轮消息获取环节
                // 否则处理 IDLEHandler
                // If first time idle, then get the number of idlers to run.
                // Idle handles only run if the queue is empty or if the first message
                // in the queue (possibly a barrier) is due to be handled in the future.
                if (pendingIdleHandlerCount &lt; 0
                        &amp;&amp; (mMessages == null || now &lt; mMessages.when)) {
                    pendingIdleHandlerCount = mIdleHandlers.size();
                }
                if (pendingIdleHandlerCount &lt;= 0) {
                    // No idle handlers to run.  Loop and wait some more.
                    mBlocked = true;
                    continue;
                }

                if (mPendingIdleHandlers == null) {
                    mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];
                }
                mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);
            }

            // 处理 IDLEHandler
            // Run the idle handlers.
            // We only ever reach this code block during the first iteration.
            for (int i = 0; i &lt; pendingIdleHandlerCount; i++) {
                final IdleHandler idler = mPendingIdleHandlers[i];
                mPendingIdleHandlers[i] = null; // release the reference to the handler

                boolean keep = false;
                try {
                    keep = idler.queueIdle();
                } catch (Throwable t) {
                    Log.wtf(TAG, "IdleHandler threw exception", t);
                }

                if (!keep) {
                    synchronized (this) {
                        mIdleHandlers.remove(idler);
                    }
                }
            }

            // Reset the idle handler count to 0 so we do not run them again.
            pendingIdleHandlerCount = 0;

            // While calling an idle handler, a new message could have been delivered
            // so go back and look again for a pending message without waiting.
            nextPollTimeoutMillis = 0;
        }
    }
}
</code></pre>
<h4 id="java层压入消息"><a class="header" href="#java层压入消息">Java层压入消息</a></h4>
<p>这就比较简单了，当消息本身合法，且消息队列还在工作中时。
依旧从 <code>TDD角度</code> 出发：</p>
<ul>
<li>如果消息队列没有头，期望直接作为头</li>
<li>如果有头
<ul>
<li><code>消息处理时间</code> 先于 <code>头消息</code> 或者是需要立即处理的消息，则作为新的头</li>
<li>否则按照 <code>处理时间</code> 插入到合适位置</li>
</ul>
</li>
</ul>
<pre><code class="language-java"> boolean enqueueMessage(Message msg, long when) {
        if (msg.target == null) {
            throw new IllegalArgumentException("Message must have a target.");
        }

        synchronized (this) {
            if (msg.isInUse()) {
                throw new IllegalStateException(msg + " This message is already in use.");
            }

            if (mQuitting) {
                IllegalStateException e = new IllegalStateException(
                        msg.target + " sending message to a Handler on a dead thread");
                Log.w(TAG, e.getMessage(), e);
                msg.recycle();
                return false;
            }

            msg.markInUse();
            msg.when = when;
            Message p = mMessages;
            boolean needWake;
            if (p == null || when == 0 || when &lt; p.when) {
                // New head, wake up the event queue if blocked.
                msg.next = p;
                mMessages = msg;
                needWake = mBlocked;
            } else {
                // Inserted within the middle of the queue.  Usually we don't have to wake
                // up the event queue unless there is a barrier at the head of the queue
                // and the message is the earliest asynchronous message in the queue.
                needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();
                Message prev;
                for (;;) {
                    prev = p;
                    p = p.next;
                    if (p == null || when &lt; p.when) {
                        break;
                    }
                    if (needWake &amp;&amp; p.isAsynchronous()) {
                        needWake = false;
                    }
                }
                msg.next = p; // invariant: p == prev.next
                prev.next = msg;
            }

            // We can assume mPtr != 0 because mQuitting is false.
            if (needWake) {
                nativeWake(mPtr);
            }
        }
        return true;
    }
</code></pre>
<p><code>同步屏障 barrier</code>后面单独脑暴， 其他部分就先不看了</p>
<h2 id="java层消息分发"><a class="header" href="#java层消息分发">Java层消息分发</a></h2>
<p>这一节开始，我们脑暴消息分发，前面我们已经看过了 <code>MessageQueue</code> ，消息分发就是 <code>不停地</code> 从 <code>MessageQueue</code> 中取出消息，并指派给处理者。
完成这一工作的，是Looper。</p>
<p>在前面，我们已经知道了，Native层也有Looper，但是<code>不难理解</code>：</p>
<ul>
<li>消息队列需要 <code>桥梁</code> 连通 Java层和Native层</li>
<li>Looper只需要 <code>在自己这一端</code>，处理自己的消息队列分发即可</li>
</ul>
<p>所以，我们看Java层的消息分发时，看Java层的Looper即可。</p>
<p>关注三个主要方法：</p>
<ul>
<li>出门上班</li>
<li>工作</li>
<li>下班回家</li>
</ul>
<h3 id="出门上班-prepare"><a class="header" href="#出门上班-prepare">出门上班 prepare</a></h3>
<pre><code class="language-java">class Looper {

    public static void prepare() {
        prepare(true);
    }

    private static void prepare(boolean quitAllowed) {
        if (sThreadLocal.get() != null) {
            throw new RuntimeException("Only one Looper may be created per thread");
        }
        sThreadLocal.set(new Looper(quitAllowed));
    }
}
</code></pre>
<p>这里有两个注意点：</p>
<ul>
<li>已经出了门，除非再进门，否则没法再出门了。同样，一个线程有一个Looper就够了，只要它还活着，就没必要再建一个。</li>
<li>责任到人，一个Looper服务于一个Thread，这需要 <code>注册</code> ，代表着 <code>某个Thread</code> 已经由自己服务了。利用了ThreadLocal，因为多线程访问集合，<code>总需要考虑 竞争</code>，这很不人道主义，干脆分家，每个Thread操作自己的内容互不干扰，也就没有了竞争，于是封装了 <code>ThreadLocal</code></li>
</ul>
<h3 id="上班-loop"><a class="header" href="#上班-loop">上班 loop</a></h3>
<p>注意工作性质是 <code>分发</code>，并不需要自己处理</p>
<ul>
<li>没有 <code>注册</code> 自然就找不到负责这份工作的人。</li>
<li>已经在工作了就不要催，催了会导致工作出错，顺序出现问题。</li>
<li>工作就是不断的取出 <code>老板</code>-- <code>MQ</code> 的 <code>指令</code> -- <code>Message</code>，并交给 <code>相关负责人</code> -- <code>Handler</code> 去处理，并记录信息</li>
<li><code>007</code>，不眠不休，<code>当MQ再也不发出消息了</code>，没活干了，大家都散了吧，下班回家</li>
</ul>
<pre><code class="language-java">class Looper {
    public static void loop() {
        final Looper me = myLooper();
        if (me == null) {
            throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread.");
        }
        if (me.mInLoop) {
            Slog.w(TAG, "Loop again would have the queued messages be executed"
                    + " before this one completed.");
        }

        me.mInLoop = true;
        final MessageQueue queue = me.mQueue;

        // Make sure the identity of this thread is that of the local process,
        // and keep track of what that identity token actually is.
        Binder.clearCallingIdentity();
        final long ident = Binder.clearCallingIdentity();

        // Allow overriding a threshold with a system prop. e.g.
        // adb shell 'setprop log.looper.1000.main.slow 1 &amp;&amp; stop &amp;&amp; start'
        final int thresholdOverride =
                SystemProperties.getInt("log.looper."
                        + Process.myUid() + "."
                        + Thread.currentThread().getName()
                        + ".slow", 0);

        boolean slowDeliveryDetected = false;

        for (;;) {
            Message msg = queue.next(); // might block
            if (msg == null) {
                // No message indicates that the message queue is quitting.
                return;
            }

            // This must be in a local variable, in case a UI event sets the logger
            final Printer logging = me.mLogging;
            if (logging != null) {
                logging.println("&gt;&gt;&gt;&gt;&gt; Dispatching to " + msg.target + " " +
                        msg.callback + ": " + msg.what);
            }
            // Make sure the observer won't change while processing a transaction.
            final Observer observer = sObserver;

            final long traceTag = me.mTraceTag;
            long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;
            long slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs;
            if (thresholdOverride &gt; 0) {
                slowDispatchThresholdMs = thresholdOverride;
                slowDeliveryThresholdMs = thresholdOverride;
            }
            final boolean logSlowDelivery = (slowDeliveryThresholdMs &gt; 0) &amp;&amp; (msg.when &gt; 0);
            final boolean logSlowDispatch = (slowDispatchThresholdMs &gt; 0);

            final boolean needStartTime = logSlowDelivery || logSlowDispatch;
            final boolean needEndTime = logSlowDispatch;

            if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) {
                Trace.traceBegin(traceTag, msg.target.getTraceName(msg));
            }

            final long dispatchStart = needStartTime ? SystemClock.uptimeMillis() : 0;
            final long dispatchEnd;
            Object token = null;
            if (observer != null) {
                token = observer.messageDispatchStarting();
            }
            long origWorkSource = ThreadLocalWorkSource.setUid(msg.workSourceUid);
            try {
                //注意这里
                msg.target.dispatchMessage(msg);
                if (observer != null) {
                    observer.messageDispatched(token, msg);
                }
                dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0;
            } catch (Exception exception) {
                if (observer != null) {
                    observer.dispatchingThrewException(token, msg, exception);
                }
                throw exception;
            } finally {
                ThreadLocalWorkSource.restore(origWorkSource);
                if (traceTag != 0) {
                    Trace.traceEnd(traceTag);
                }
            }
            if (logSlowDelivery) {
                if (slowDeliveryDetected) {
                    if ((dispatchStart - msg.when) &lt;= 10) {
                        Slog.w(TAG, "Drained");
                        slowDeliveryDetected = false;
                    }
                } else {
                    if (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, "delivery",
                            msg)) {
                        // Once we write a slow delivery log, suppress until the queue drains.
                        slowDeliveryDetected = true;
                    }
                }
            }
            if (logSlowDispatch) {
                showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, "dispatch", msg);
            }

            if (logging != null) {
                logging.println("&lt;&lt;&lt;&lt;&lt; Finished to " + msg.target + " " + msg.callback);
            }

            // Make sure that during the course of dispatching the
            // identity of the thread wasn't corrupted.
            final long newIdent = Binder.clearCallingIdentity();
            if (ident != newIdent) {
                Log.wtf(TAG, "Thread identity changed from 0x"
                        + Long.toHexString(ident) + " to 0x"
                        + Long.toHexString(newIdent) + " while dispatching to "
                        + msg.target.getClass().getName() + " "
                        + msg.callback + " what=" + msg.what);
            }

            msg.recycleUnchecked();
        }
    }
}

</code></pre>
<h3 id="下班-quitquitsafely"><a class="header" href="#下班-quitquitsafely">下班 quit/quitSafely</a></h3>
<p>这是比较粗暴的行为，MQ离开了Looper就没法正常工作了，即下班即意味着辞职</p>
<pre><code class="language-java">class Looper {
    public void quit() {
        mQueue.quit(false);
    }
    
    public void quitSafely() {
        mQueue.quit(true);
    }
}
</code></pre>
<h2 id="消息处理-handler"><a class="header" href="#消息处理-handler">消息处理 Handler</a></h2>
<p>这里就比较清晰了。API基本分为以下几类：</p>
<p>面向使用者：</p>
<ul>
<li>创建Message，通过Message的 <code>享元模式</code></li>
<li>发送消息，注意postRunnable也是一个消息</li>
<li>移除消息，</li>
<li>退出等</li>
</ul>
<p>面向消息处理：</p>
<pre><code class="language-java">class Handler {
    /**
     * Subclasses must implement this to receive messages.
     */
    public void handleMessage(@NonNull Message msg) {
    }

    /**
     * Handle system messages here.
     * Looper分发时调用的API
     */
    public void dispatchMessage(@NonNull Message msg) {
        if (msg.callback != null) {
            handleCallback(msg);
        } else {
            if (mCallback != null) {
                if (mCallback.handleMessage(msg)) {
                    return;
                }
            }
            handleMessage(msg);
        }
    }
}
</code></pre>
<p>如果有 <code>Handler callback</code>，则交给callback处理，否则自己处理，如果没覆写 <code>handleMessage</code> ，消息相当于被 drop 了。</p>
<p>消息发送部分可以结合下图梳理：</p>
<p><img src="%E4%B8%89%E6%80%9D%E7%B3%BB%E5%88%97%EF%BC%9AAndroid%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%EF%BC%8C%E4%B8%80%E6%96%87%E5%90%83%E9%80%8F/send_msg.webp" alt="send_msg" /></p>
<hr />
<blockquote>
<p>阶段性小结,至此，我们已经对 <code>Framework层的消息机制</code> 有一个完整的了解了。
前面我们梳理了：</p>
<ul>
<li>Native层 和 Java层均有消息队列，并且通过JNI和指针映射，存在对应关系</li>
<li>Native层 和 Java层MQ <code>消息获取时的大致过程</code></li>
<li>Java层 Looper 如何工作</li>
<li>Java层 Handler 大致概览</li>
</ul>
<p>根据前面梳理的内容，可以总结：从 <code>Java Runtime</code> 看：</p>
<ul>
<li>消息队列机制服务于 <code>线程级别</code>，即一个线程有一个工作中的消息队列即可，当然，也可以没有。
即，一个Thread <code>至多有</code> 一个工作中的Looper。</li>
<li>Looper 和 Java层MQ <code>一一对应</code></li>
<li>Handler 是MQ的入口，也是 <code>消息</code> 的处理者</li>
<li>消息-- <code>Message</code> 应用了 <code>享元模式</code>，自身信息足够，满足 <code>自洽</code>，创建消息的开销性对较大，所以利用享元模式对消息对象进行复用。</li>
</ul>
</blockquote>
<p>下面我们再继续探究细节，解决前面语焉不详处留下的疑惑：</p>
<ul>
<li>消息的类型和本质</li>
<li>Native层Looper 的pollInner</li>
</ul>
<hr />
<h2 id="消息的类型和本质"><a class="header" href="#消息的类型和本质">消息的类型和本质</a></h2>
<p>message中的几个重要成员变量：</p>
<pre><code class="language-java">class Message {
   
    public int what;
    
    public int arg1;
    
    public int arg2;
    
    public Object obj;

    public Messenger replyTo;

    /*package*/ int flags;
    
    public long when;

    /*package*/ Bundle data;

    /*package*/ Handler target;

    /*package*/ Runnable callback;

}
</code></pre>
<p>其中 target是 <code>目标</code>，如果没有目标，那就是一个特殊的消息： <code>同步屏障</code> 即 <code>barrier</code>；</p>
<p>what 是消息标识
arg1 和 arg2 是开销较小的 <code>数据</code>，如果 <code>不足以表达信息</code>  则可以放入 <code>Bundle data</code> 中。</p>
<p>replyTo 和 obj 是跨进程传递消息时使用的，暂且不看。</p>
<p>flags 是 message 的状态标识，例如 <code>是否在使用中</code>，<code>是否是同步消息</code></p>
<blockquote>
<p>上面提到的同步屏障，即 barrier，其作用是拦截后面的 <code>同步消息</code> 不被获取，在前面阅读Java层MQ的next方法时读到过。</p>
<p>我们还记得，next方法中，使用死循环，尝试读出一个满足处理条件的消息，如果取不到，因为死循环的存在，调用者（Looper）会被一直阻塞。</p>
</blockquote>
<p>此时可以印证一个结论，消息按照 <code>功能分类</code> 可以分为 <code>三种</code>：</p>
<ul>
<li>普通消息</li>
<li>同步屏障消息</li>
<li>异步消息</li>
</ul>
<p>其中同步消息是一种内部机制。设置屏障之后需要在合适时间取消屏障，否则会导致 <code>普通消息永远无法被处理</code>，而取消时，需要用到设置屏障时返回的token。</p>
<h2 id="native层looper"><a class="header" href="#native层looper"><a id="native_looper">Native层Looper</a></a></h2>
<p>相信大家都对 <code>Native层</code> 的Looper产生兴趣了，想看看它在Native层都干些什么。</p>
<p>对完整源码感兴趣的可以看 <a href="https://github.com/leobert-lan/Blog/blob/main/Android/Mechanism/Message/code/Looper.cpp">这里</a> ，下面我们节选部分进行阅读。</p>
<p>前面提到了Looper的pollOnce，处理完搁置的Response之后，会调用pollInner获取消息</p>
<pre><code class="language-cpp">int Looper::pollInner(int timeoutMillis) {
#if DEBUG_POLL_AND_WAKE
    ALOGD("%p ~ pollOnce - waiting: timeoutMillis=%d", this, timeoutMillis);
#endif

    // Adjust the timeout based on when the next message is due.
    if (timeoutMillis != 0 &amp;&amp; mNextMessageUptime != LLONG_MAX) {
        nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);
        int messageTimeoutMillis = toMillisecondTimeoutDelay(now, mNextMessageUptime);
        if (messageTimeoutMillis &gt;= 0
                &amp;&amp; (timeoutMillis &lt; 0 || messageTimeoutMillis &lt; timeoutMillis)) {
            timeoutMillis = messageTimeoutMillis;
        }
#if DEBUG_POLL_AND_WAKE
        ALOGD("%p ~ pollOnce - next message in %lldns, adjusted timeout: timeoutMillis=%d",
                this, mNextMessageUptime - now, timeoutMillis);
#endif
    }

    // Poll.
    int result = ALOOPER_POLL_WAKE;
    mResponses.clear();
    mResponseIndex = 0;

    struct epoll_event eventItems[EPOLL_MAX_EVENTS];
    
    //注意 1
    int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);

    // Acquire lock.
    mLock.lock();

// 注意 2
    // Check for poll error.
    if (eventCount &lt; 0) {
        if (errno == EINTR) {
            goto Done;
        }
        ALOGW("Poll failed with an unexpected error, errno=%d", errno);
        result = ALOOPER_POLL_ERROR;
        goto Done;
    }

// 注意 3
    // Check for poll timeout.
    if (eventCount == 0) {
#if DEBUG_POLL_AND_WAKE
        ALOGD("%p ~ pollOnce - timeout", this);
#endif
        result = ALOOPER_POLL_TIMEOUT;
        goto Done;
    }

//注意 4
    // Handle all events.
#if DEBUG_POLL_AND_WAKE
    ALOGD("%p ~ pollOnce - handling events from %d fds", this, eventCount);
#endif

    for (int i = 0; i &lt; eventCount; i++) {
        int fd = eventItems[i].data.fd;
        uint32_t epollEvents = eventItems[i].events;
        if (fd == mWakeReadPipeFd) {
            if (epollEvents &amp; EPOLLIN) {
                awoken();
            } else {
                ALOGW("Ignoring unexpected epoll events 0x%x on wake read pipe.", epollEvents);
            }
        } else {
            ssize_t requestIndex = mRequests.indexOfKey(fd);
            if (requestIndex &gt;= 0) {
                int events = 0;
                if (epollEvents &amp; EPOLLIN) events |= ALOOPER_EVENT_INPUT;
                if (epollEvents &amp; EPOLLOUT) events |= ALOOPER_EVENT_OUTPUT;
                if (epollEvents &amp; EPOLLERR) events |= ALOOPER_EVENT_ERROR;
                if (epollEvents &amp; EPOLLHUP) events |= ALOOPER_EVENT_HANGUP;
                pushResponse(events, mRequests.valueAt(requestIndex));
            } else {
                ALOGW("Ignoring unexpected epoll events 0x%x on fd %d that is "
                        "no longer registered.", epollEvents, fd);
            }
        }
    }
Done: ;

// 注意 5
    // Invoke pending message callbacks.
    mNextMessageUptime = LLONG_MAX;
    while (mMessageEnvelopes.size() != 0) {
        nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);
        const MessageEnvelope&amp; messageEnvelope = mMessageEnvelopes.itemAt(0);
        if (messageEnvelope.uptime &lt;= now) {
            // Remove the envelope from the list.
            // We keep a strong reference to the handler until the call to handleMessage
            // finishes.  Then we drop it so that the handler can be deleted *before*
            // we reacquire our lock.
            { // obtain handler
                sp&lt;MessageHandler&gt; handler = messageEnvelope.handler;
                Message message = messageEnvelope.message;
                mMessageEnvelopes.removeAt(0);
                mSendingMessage = true;
                mLock.unlock();

#if DEBUG_POLL_AND_WAKE || DEBUG_CALLBACKS
                ALOGD("%p ~ pollOnce - sending message: handler=%p, what=%d",
                        this, handler.get(), message.what);
#endif
                handler-&gt;handleMessage(message);
            } // release handler

            mLock.lock();
            mSendingMessage = false;
            result = ALOOPER_POLL_CALLBACK;
        } else {
            // The last message left at the head of the queue determines the next wakeup time.
            mNextMessageUptime = messageEnvelope.uptime;
            break;
        }
    }

    // Release lock.
    mLock.unlock();

//注意 6
    // Invoke all response callbacks.
    for (size_t i = 0; i &lt; mResponses.size(); i++) {
        Response&amp; response = mResponses.editItemAt(i);
        if (response.request.ident == ALOOPER_POLL_CALLBACK) {
            int fd = response.request.fd;
            int events = response.events;
            void* data = response.request.data;
#if DEBUG_POLL_AND_WAKE || DEBUG_CALLBACKS
            ALOGD("%p ~ pollOnce - invoking fd event callback %p: fd=%d, events=0x%x, data=%p",
                    this, response.request.callback.get(), fd, events, data);
#endif
            int callbackResult = response.request.callback-&gt;handleEvent(fd, events, data);
            if (callbackResult == 0) {
                removeFd(fd);
            }
            // Clear the callback reference in the response structure promptly because we
            // will not clear the response vector itself until the next poll.
            response.request.callback.clear();
            result = ALOOPER_POLL_CALLBACK;
        }
    }
    return result;
}
</code></pre>
<p>上面标记了注意点</p>
<ul>
<li>1 epoll机制，等待 <code>mEpollFd</code> 产生事件, 这个等待具有超时时间。</li>
<li>2，3，4 是等待的三种结果，<code>goto</code> 语句可以直接跳转到 <code>标记</code> 处</li>
<li>2 检测poll <code>是否出错</code>，如果有，跳转到 Done</li>
<li>3 检测pool <code>是否超时</code>，如果有，跳转到 Done</li>
<li>4 处理epoll后所有的事件</li>
<li>5 处理 pending 消息的回调</li>
<li>6 处理 所有 Response的回调</li>
</ul>
<p>并且我们可以发现返回的结果有以下几种：</p>
<ul>
<li>ALOOPER_POLL_CALLBACK</li>
</ul>
<p>有 <code>pending message</code> 或者 <code>request.ident</code> 值为 <code>ALOOPER_POLL_CALLBACK</code> 的 Response被处理了。
如果没有：</p>
<ul>
<li>ALOOPER_POLL_WAKE 正常唤醒</li>
<li>ALOOPER_POLL_ERROR epoll错误</li>
<li>ALOOPER_POLL_TIMEOUT epoll超时</li>
</ul>
<p>查找了一下枚举值:</p>
<pre><code class="language-java">ALOOPER_POLL_WAKE = -1,
ALOOPER_POLL_CALLBACK = -2,
ALOOPER_POLL_TIMEOUT = -3,
ALOOPER_POLL_ERROR = -4
</code></pre>
<hr />
<blockquote>
<p>阶段性小结, 我们对 <code>消息</code> 和 <code>Native层的pollInner</code> 进行了一次脑暴，引出了epoll机制。</p>
<p>其实Native层的 <code>Looper分发</code>还有不少值得脑暴的点，但我们先缓缓，已经迫不及待的要对 <code>epoll</code>机制进行脑暴了。</p>
</blockquote>
<hr />
<p>##脑暴：Linux中的I/O模型</p>
<blockquote>
<p>这部分内容，推荐一篇文章：<a href="https://blog.csdn.net/hguisu/article/details/38638183#t12">使用 libevent 和 libev 提高网络应用性能——I/O模型演进变化史</a> 作者 hguisu</p>
<p>PS:本段中，存在部分图片直接引用自该文，我偷了个懒，没有去找原版内容并标记出处</p>
</blockquote>
<p>阻塞I/O模型图：在调用recv()函数时，发生在内核中等待数据和复制数据的过程</p>
<p><img src="https://img-blog.csdnimg.cn/20190525214406514.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hndWlzdQ==,size_16,color_FFFFFF,t_70" alt="阻塞I/O模型" /></p>
<p>实现非常的 <code>简单</code>，但是存在一个问题，阻塞导致线程无法执行其他任何计算，如果是在网络编程背景下，需要使用多线程提高处理并发的能力。</p>
<p><strong>注意，不要用 Android中的 <code>点击屏幕等硬件被触发事件</code> 去对应这里的 <code>网络并发</code>，这是两码事。</strong></p>
<p>如果采用了 <code>多进程</code> 或者 <code>多线程</code> 实现 <code>并发应答</code>，模型如下：</p>
<p><img src="https://img-blog.csdn.net/20140818224818116?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGd1aXN1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="应答模型" /></p>
<p>到这里，我们看的都是 I/O 阻塞 模型。</p>
<blockquote>
<p>脑暴，阻塞为调用方法后一直在等待返回值，线程内执行的内容就像 <code>卡顿</code> 在这里。</p>
</blockquote>
<p>如果要消除这种卡顿，那就不能调用方法等待I/O结果，而是要 <code>立即返回</code> ！</p>
<p>举个例子：</p>
<ul>
<li>去西装店定制西装，确定好款式和尺寸后，你坐在店里一直等着，等到做好了拿给你，这就是阻塞型的，这能等死你；</li>
<li>去西装店定制西装，确定好款式和尺寸后，店员告诉你别干等着，好多天呢，等你有空了来看看，这就是非阻塞型的。</li>
</ul>
<p>改变为非阻塞模型后，应答模型如下：</p>
<p><img src="https://img-blog.csdn.net/20140825233622500" alt="应答模型——非阻塞" /></p>
<p>不难理解，这种方式需要顾客去 <code>轮询</code> 。对客户不友好，但是对店家可是一点损失都没有，还让等候区没那么挤了。</p>
<p>有些西装店进行了改革，对客户更加友好了:</p>
<blockquote>
<p>去西装店定制西装，确定好款式和尺寸后，留下联系方式，等西服做好了联系客户，让他来取。</p>
</blockquote>
<p>这就变成了 <code>select</code> or <code>poll</code> 模型：</p>
<p><img src="https://img-blog.csdnimg.cn/20190603172255403.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ndWlzdS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="select模型" /></p>
<p><strong>注意</strong>：进行改革的西装店需要增加一个员工，<em>图中标识的用户线程</em>，他的工作是：</p>
<ul>
<li>在前台记录客户订单和联系方式</li>
<li>拿记录着 <code>订单</code> 的小本子去找制作间，<code>不断检查</code> 订单是否完工，完工的就可以提走并联系客户了。</li>
</ul>
<p>而且，他去看订单完工时，无法在前台记录客户信息，这意味他 <code>阻塞</code> 了，其他工作只能先搁置着。</p>
<p>这个做法，对于制作间而言，和 <code>非阻塞模型</code> 并没有多大区别。还增加了一个店员，但是，用 <code>一个店员</code> 就解决了之前 <code>很多店员</code> 都会跑去 <code>制作间</code> 帮客户问"订单好了没有？" 的问题。</p>
<blockquote>
<p>值得一提的是，为了提高服务质量，这个员工每次去制作间询问一个订单时，都需要记录一些信息：</p>
<ul>
<li>订单完成度询问时，是否被应答；</li>
<li>应答有没有说谎；等</li>
</ul>
<p>有些店对每种不同的考核项均准备了记录册，这和 <code>select</code>模型类似</p>
<p>有些店只用一本记录册，但是册子上可以利用表格记录各种考核项，这和 <code>poll</code> 模型类似</p>
</blockquote>
<p><code>select</code> 模型 和 <code>poll</code> 模型的近似度比较高。</p>
<p>没多久，老板就发现了，这个店员的工作效率有点低下，他每次都要拿着一本订单簿，去把订单都问一遍，倒不是员工不勤快，是这个模式有点问题。</p>
<p>于是老板又进行了改革：</p>
<ul>
<li>在 <code>前台</code> 和 <code>制作间</code> 之间加一个送信管道。</li>
<li>制作间有进度需要汇报了，就送一份信到前台，信上写着订单号。</li>
<li>前台员工直接去问对应的订单。</li>
</ul>
<p>这就变成了 <code>epoll模型</code>解决了 <code>select/poll</code> 模型的遍历效率问题。</p>
<p>这样改革后，前台员工就不再需要按着订单簿从上到下挨个问了。提高了效率，前台员工只要<code>无事发生</code>，就可以优雅的划水了。</p>
<p>我们看一下NativeLooper的构造函数：</p>
<pre><code class="language-cpp">Looper::Looper(bool allowNonCallbacks) :
        mAllowNonCallbacks(allowNonCallbacks), mSendingMessage(false),
        mResponseIndex(0), mNextMessageUptime(LLONG_MAX) {
    int wakeFds[2];
    int result = pipe(wakeFds);
    LOG_ALWAYS_FATAL_IF(result != 0, "Could not create wake pipe.  errno=%d", errno);

    mWakeReadPipeFd = wakeFds[0];
    mWakeWritePipeFd = wakeFds[1];

    result = fcntl(mWakeReadPipeFd, F_SETFL, O_NONBLOCK);
    LOG_ALWAYS_FATAL_IF(result != 0, "Could not make wake read pipe non-blocking.  errno=%d",
            errno);

    result = fcntl(mWakeWritePipeFd, F_SETFL, O_NONBLOCK);
    LOG_ALWAYS_FATAL_IF(result != 0, "Could not make wake write pipe non-blocking.  errno=%d",
            errno);

    // Allocate the epoll instance and register the wake pipe.
    mEpollFd = epoll_create(EPOLL_SIZE_HINT);
    LOG_ALWAYS_FATAL_IF(mEpollFd &lt; 0, "Could not create epoll instance.  errno=%d", errno);

    struct epoll_event eventItem;
    memset(&amp; eventItem, 0, sizeof(epoll_event)); // zero out unused members of data field union
    eventItem.events = EPOLLIN;
    eventItem.data.fd = mWakeReadPipeFd;
    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp; eventItem);
    LOG_ALWAYS_FATAL_IF(result != 0, "Could not add wake read pipe to epoll instance.  errno=%d",
            errno);
}
</code></pre>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<p>相信看到这里，大家已经自己悟透了各种问题。按照惯例，还是要总结下，因为 <code>这篇是脑暴</code>，所以 <code>思绪</code> 是比较 <code>跳跃</code> 的，内容前后关系不太明显。</p>
<p>我们结合一个问题来点明内容前后关系。</p>
<blockquote>
<p>Java层 Looper和MQ 会什么使用了死循环但是 <code>不会"阻塞"UI线程</code> / <code>没造成ANR</code> / <code>依旧可以响应点击事件</code></p>
</blockquote>
<ul>
<li>Android是基于 <code>事件驱动</code> 的，并建立了 <code>完善的</code> 消息机制</li>
<li>Java层的消息机制只是一个局部，其负责的就是面向消息队列，处理 <code>消息队列管理</code>，<code>消息分发</code>，<code>消息处理</code></li>
<li>Looper的死循环保障了 <code>消息队列</code> 的 <code>消息分发</code> 一直处于有效运行中，不循环就停止了分发。</li>
<li>MessageQueue的 <code>死循环</code> 保障了 <code>Looper可以获取有效的消息</code>，保障了Looper <code>只要有消息，就一直运行</code>，发现有效消息，就跳出了死循环。</li>
<li>而且Java层MessageQueue在 next() 方法中的死循环中，通过JNI调用了 Native层MQ的 <code>pollOnce</code>，驱动了Native层去处理Native层消息</li>
<li>值得一提的是，UI线程处理的事情也都是基于消息的，无论是更新UI还是响应点击事件等。</li>
</ul>
<p>所以，正是Looper 进行loop()之后的死循环，保障了UI线程的各项工作正常执行。</p>
<p>再说的ANR，这是Android 确认<code>主线程</code> 消息机制 <code>正常</code> 且 <code>健康</code> 运转的一种检测机制。</p>
<p>因为主线程Looper需要利用 <code>消息机制</code> 驱动UI渲染和交互事件处理，
如果某个消息的执行，或者其衍生出的业务，在主线程占用了大量的时间，导致主线程长期阻塞，会影响用户体验。</p>
<p>所以ANR检测采用了一种 <code>埋定时炸弹</code> 的机制，必须依靠Looper的高效运转来消除之前装的定时炸弹。而这种定时炸弹比较有意思，<code>被发现了才会炸</code>。</p>
<p>在说到 <code>响应点击事件</code>，类似的事件总是从硬件出发的，在到内核，再进程间通信到用户空间，这些事件以消息的形式存在于Native层，经过处理后，表现出：</p>
<blockquote>
<p>ViewRootImpl收到了InputManager的输入，并进行了事件处理</p>
</blockquote>
<hr />
<p>这里我们借用一张图总结整个消息机制流程：</p>
<p><img src="https://img.jbzj.com/file_images/article/201609/2016922103751644.jpg?2016822103759" alt="" /></p>
<p><em>图片来自 《Android7.0 MessageQueue详解》 作者 Gaugamela</em></p>
<blockquote>
<p>PS:这篇文章写得很长，内容长，耗时也长，大约花费了10天的时间，其中还有不少内容写得未能尽兴。例如：
"Java层在哪些情况下利用JNI调取Native层的唤醒，为什么这么干？"等等。</p>
<p>但是考虑到篇幅，决定不再往下挖了。</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../../Android/Mechanism/Message/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../../Android/Idea/post_14/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../../Android/Mechanism/Message/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../../Android/Idea/post_14/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../../elasticlunr.min.js"></script>
        <script src="../../../mark.min.js"></script>
        <script src="../../../searcher.js"></script>

        <script src="../../../clipboard.min.js"></script>
        <script src="../../../highlight.js"></script>
        <script src="../../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
