<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>三思系列：View体系认知(一)，内容是如何正确被展现出来的--视觉呈现概览 - leobert&#x27;s blog</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">目录</li><li class="chapter-item expanded "><a href="../../Android/index.html"><strong aria-hidden="true">1.</strong> Android</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Android/View/index.html"><strong aria-hidden="true">1.1.</strong> View</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Android/View/post_1.html"><strong aria-hidden="true">1.1.1.</strong> 好玩系列：优雅的处理ButterKnife和KAE被废弃</a></li><li class="chapter-item expanded "><a href="../../Android/View/post_6.html" class="active"><strong aria-hidden="true">1.1.2.</strong> 三思系列：View体系认知(一)，内容是如何正确被展现出来的--视觉呈现概览</a></li><li class="chapter-item expanded "><a href="../../Android/View/post_7.html"><strong aria-hidden="true">1.1.3.</strong> 三思系列：为什么自定义View</a></li><li class="chapter-item expanded "><a href="../../Android/Idea/post_9.html"><strong aria-hidden="true">1.1.4.</strong> 三思系列："声明式UI"和"命令式UI"，你的理解可能是错的</a></li></ol></li><li class="chapter-item expanded "><a href="../../Android/Drawable/index.html"><strong aria-hidden="true">1.2.</strong> Drawable</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Android/Drawable/post_2.html"><strong aria-hidden="true">1.2.1.</strong> 三思系列：重新认识Drawable</a></li><li class="chapter-item expanded "><a href="../../Android/Drawable/post_4.html"><strong aria-hidden="true">1.2.2.</strong> 好玩系列：拥有它，XML文件少一半--更方便的处理View背景</a></li><li class="chapter-item expanded "><a href="../../Android/Drawable/post_47.html"><strong aria-hidden="true">1.2.3.</strong> 迟来的续集--Drawable+Animator，将优雅进行到底</a></li><li class="chapter-item expanded "><a href="../../Android/Drawable/post_49.html"><strong aria-hidden="true">1.2.4.</strong> 好玩系列：让ImageSpan动起来</a></li></ol></li><li class="chapter-item expanded "><a href="../../Android/Mechanism/Message/index.html"><strong aria-hidden="true">1.3.</strong> 消息机制</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Android/Mechanism/Message/post_8.html"><strong aria-hidden="true">1.3.1.</strong> 三思系列：Android的消息机制，一文吃透</a></li></ol></li><li class="chapter-item expanded "><a href="../../Android/Idea/post_14/index.html"><strong aria-hidden="true">1.4.</strong> 兼容</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Android/Idea/post_14.html"><strong aria-hidden="true">1.4.1.</strong> 好玩系列：让项目中的相册支持Heif格式图片</a></li></ol></li><li class="chapter-item expanded "><a href="../../Android/Glide/index.html"><strong aria-hidden="true">1.5.</strong> Glide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Android/Glide/post_15.html"><strong aria-hidden="true">1.5.1.</strong> 三思系列：Glide 4.X全方位认知 -- 模块职责概览</a></li><li class="chapter-item expanded "><a href="../../Android/Glide/post_16.html"><strong aria-hidden="true">1.5.2.</strong> 三思系列：Glide 4.X加载过程一文掌握 | Glide（二）</a></li></ol></li><li class="chapter-item expanded "><a href="../../Android/KSP/index.html"><strong aria-hidden="true">1.6.</strong> KSP</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Android/KSP/post_24.html"><strong aria-hidden="true">1.6.1.</strong> 好玩系列 | 拥抱Kotlin Symbol Processing(KSP),项目实战</a></li></ol></li><li class="chapter-item expanded "><a href="../../Android/Base/index.html"><strong aria-hidden="true">1.7.</strong> 基础</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Android/Base/post_35.html"><strong aria-hidden="true">1.7.1.</strong> 孔乙己：你可知道页面和弹窗“通信“的方式有四种？</a></li></ol></li><li class="chapter-item expanded "><a href="../../Android/SysApp/index.html"><strong aria-hidden="true">1.8.</strong> 系统APP</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Android/SysApp/post_52.html"><strong aria-hidden="true">1.8.1.</strong> 使用日历丰富产品的用户体验</a></li></ol></li><li class="chapter-item expanded "><a href="../../Android/DI/index.html"><strong aria-hidden="true">1.9.</strong> Part4-依赖注入部分</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Android/DI/post_53.html"><strong aria-hidden="true">1.9.1.</strong> Hilt进阶--一文吃透Hilt自定义与跨壁垒</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../Compose/index.html"><strong aria-hidden="true">2.</strong> Jetpack Compose</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Compose/post_21.html"><strong aria-hidden="true">2.1.</strong> Jetpack Compose | 一文理解神奇的Modifier</a></li><li class="chapter-item expanded "><a href="../../Compose/post_26.html"><strong aria-hidden="true">2.2.</strong> Jetpack Compose | 控件篇（一） -- Text、TextField、Button</a></li><li class="chapter-item expanded "><a href="../../Compose/post_27.html"><strong aria-hidden="true">2.3.</strong> Jetpack Compose | 控件篇（二） -- Icon，Image</a></li><li class="chapter-item expanded "><a href="../../Compose/post_28.html"><strong aria-hidden="true">2.4.</strong> Jetpack Compose | 控件篇（三） -- Switch、CheckBox、RadioButton</a></li><li class="chapter-item expanded "><a href="../../Compose/post_29.html"><strong aria-hidden="true">2.5.</strong> Jetpack Compose | 控件篇（四）-- Box、Row、Column</a></li><li class="chapter-item expanded "><a href="../../Compose/post_30.html"><strong aria-hidden="true">2.6.</strong> Jetpack Compose | 控件篇（五）-- Spacer、LazyRow、LazyColumn & 让Column可滑动</a></li></ol></li><li class="chapter-item expanded "><a href="../../MultiThreading/index.html"><strong aria-hidden="true">3.</strong> Java多线程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../MultiThreading/post_33.html"><strong aria-hidden="true">3.1.</strong> 总纲</a></li><li class="chapter-item expanded "><a href="../../MultiThreading/post_37.html"><strong aria-hidden="true">3.2.</strong> Java基础--图解JVM内存模型和JVM线程模型</a></li><li class="chapter-item expanded "><a href="../../MultiThreading/post_38.html"><strong aria-hidden="true">3.3.</strong> Java多线程系列--掌控面试，一文吃透Synchronized锁</a></li><li class="chapter-item expanded "><a href="../../MultiThreading/post_39.html"><strong aria-hidden="true">3.4.</strong> Java多线程基础--线程生命周期与线程协作详解</a></li><li class="chapter-item expanded "><a href="../../MultiThreading/post_42.html"><strong aria-hidden="true">3.5.</strong> Java多线程基础--线程的创建与线程池管理</a></li><li class="chapter-item expanded "><a href="../../MultiThreading/post_46.html"><strong aria-hidden="true">3.6.</strong> Java多线程系列--掌握Future，轻松获取异步任务结果</a></li><li class="chapter-item expanded "><a href="../../MultiThreading/post_50.html"><strong aria-hidden="true">3.7.</strong> Java多线程系列--Fork&Join框架，分治的艺术</a></li><li class="chapter-item expanded "><a href="../../MultiThreading/post_54.html"><strong aria-hidden="true">3.8.</strong> Java多线程系列--掌握CompletableFuture，驾驭异步编程</a></li></ol></li><li class="chapter-item expanded "><a href="../../IO/index.html"><strong aria-hidden="true">4.</strong> Java IO系列</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../IO/post_55.html"><strong aria-hidden="true">4.1.</strong> Java IO 系列总纲</a></li><li class="chapter-item expanded "><a href="../../IO/post_56.html"><strong aria-hidden="true">4.2.</strong> Java IO系列 | 经典 IO</a></li><li class="chapter-item expanded "><a href="../../IO/post_57.html"><strong aria-hidden="true">4.3.</strong> Java IO 系列 | NIO-1.0一文速览</a></li><li class="chapter-item expanded "><a href="../../IO/post_58.html"><strong aria-hidden="true">4.4.</strong> Java IO系列 | NIO-1.0拾遗、NIO-2.0 & 零拷贝必吹的牛皮</a></li><li class="chapter-item expanded "><a href="../../IO/post_59.html"><strong aria-hidden="true">4.5.</strong> IO系列 | 一文掌握OKHTTP中的OKIO为什么这么OK</a></li></ol></li><li class="chapter-item expanded "><a href="../../Gradle/index.html"><strong aria-hidden="true">5.</strong> Gradle</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Gradle/Modularization/post_18.html"><strong aria-hidden="true">5.1.</strong> 组件化：三思系列：组件化场景下module依赖优雅实践方案</a></li><li class="chapter-item expanded "><a href="../../Gradle/Publish/post_17.html"><strong aria-hidden="true">5.2.</strong> MavenCentral发布：迁移到MavenCentral--再不行动起来，你的托管的library就没了</a></li><li class="chapter-item expanded "><a href="../../Gradle/post_22.html"><strong aria-hidden="true">5.3.</strong> Gradle | 依赖管理最佳实践</a></li></ol></li><li class="chapter-item expanded "><a href="../../Groovy/index.html"><strong aria-hidden="true">6.</strong> Groovy</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Groovy/why_write_groovy.html"><strong aria-hidden="true">6.1.</strong> 为什么撰写这个系列</a></li><li class="chapter-item expanded "><a href="../../Groovy/post_23.html"><strong aria-hidden="true">6.2.</strong> Groovy：MOP一文打尽</a></li></ol></li><li class="chapter-item expanded "><a href="../../Review/index.html"><strong aria-hidden="true">7.</strong> Review</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Review/post_10.html"><strong aria-hidden="true">7.1.</strong> 造完了这个轮子--Mocker，却让我感到很羞愧|项目复盘</a></li><li class="chapter-item expanded "><a href="../../Review/post_40.html"><strong aria-hidden="true">7.2.</strong> 三思系列：前人用GreenDao留下的坑，全线被扣了绩效</a></li><li class="chapter-item expanded "><a href="../../Review/post_44.html"><strong aria-hidden="true">7.3.</strong> 谈一谈在两个商业项目中使用MVI架构后的感悟</a></li><li class="chapter-item expanded "><a href="../../Review/post_45.html"><strong aria-hidden="true">7.4.</strong> Review | 这三个坑你遇到了吗？</a></li></ol></li><li class="chapter-item expanded "><a href="../../repo/index.html"><strong aria-hidden="true">8.</strong> 个人项目</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../repo/DaVinCi.html"><strong aria-hidden="true">8.1.</strong> DaVinCi,取代XML编写Shape或ColorStateList的方案</a></li><li class="chapter-item expanded "><a href="../../Android/Idea/post_32.html"><strong aria-hidden="true">8.2.</strong> 好玩系列：白嫖一个优雅的类图生成工具</a></li><li class="chapter-item expanded "><a href="../../Speculative/post_43.html"><strong aria-hidden="true">8.3.</strong> 初体验：动手搭建"小清新式"局域网文档系统</a></li><li class="chapter-item expanded "><a href="../../repo/post_48.html"><strong aria-hidden="true">8.4.</strong> 研究良久，终于发现了他代码写的快且bug少的原因</a></li><li class="chapter-item expanded "><a href="../../Speculative/post_61.html"><strong aria-hidden="true">8.5.</strong> 好玩系列 | 如果后端让你用SSE接收多次返回，那我们改造Retrofit吧</a></li></ol></li><li class="chapter-item expanded "><a href="../../Review/DataStructure/index.html"><strong aria-hidden="true">9.</strong> 数据结构</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Review/DataStructure/post_11.html"><strong aria-hidden="true">9.1.</strong> 温故：线性表</a></li><li class="chapter-item expanded "><a href="../../Review/DataStructure/post_12.html"><strong aria-hidden="true">9.2.</strong> 温故：栈</a></li><li class="chapter-item expanded "><a href="../../Review/DataStructure/post_13.html"><strong aria-hidden="true">9.3.</strong> 温故：队列</a></li></ol></li><li class="chapter-item expanded "><a href="../../Review/README2.html"><strong aria-hidden="true">10.</strong> 年终总结&计划</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Review/post_36.html"><strong aria-hidden="true">10.1.</strong> 2021年终总结</a></li><li class="chapter-item expanded "><a href="../../Review/post_51.html"><strong aria-hidden="true">10.2.</strong> 关于画一个句号--基于2022年终总结的反思与分享</a></li><li class="chapter-item expanded "><a href="../../Review/post_60.html"><strong aria-hidden="true">10.3.</strong> 突如其来的秋季反思</a></li><li class="chapter-item expanded "><a href="../../Review/post_63.html"><strong aria-hidden="true">10.4.</strong> 2023年总结 寻找到源于内心深处的无穷力量</a></li><li class="chapter-item expanded "><a href="../../Review/post_64.html"><strong aria-hidden="true">10.5.</strong> 2024年中思考，推倒樊笼重新出发</a></li></ol></li><li class="chapter-item expanded "><a href="../../Note/index.html"><strong aria-hidden="true">11.</strong> 读书笔记</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Note/post_41.html"><strong aria-hidden="true">11.1.</strong> 读书笔记：《简约至上--交互式设计四策略》</a></li></ol></li><li class="chapter-item expanded "><a href="../../Talk/index.html"><strong aria-hidden="true">12.</strong> 杂谈</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Talk/talk_1.html"><strong aria-hidden="true">12.1.</strong> 杂谈1-2022-11</a></li><li class="chapter-item expanded "><a href="../../Talk/talk_2_2023-03.html"><strong aria-hidden="true">12.2.</strong> 杂篇（二）-- 认识并战胜焦虑</a></li><li class="chapter-item expanded "><a href="../../Talk/talk_3_2024-08.html"><strong aria-hidden="true">12.3.</strong> 杂谈（三）-- 向钱看，你需要想明白企业在为什么而付钱</a></li></ol></li><li class="chapter-item expanded "><a href="../../Thought/index.html"><strong aria-hidden="true">13.</strong> 半成熟的思考</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../Thought/post_62.html"><strong aria-hidden="true">13.1.</strong> 好玩系列 | 当SPI 和 设计模式、依赖注入发生碰撞，可以擦出怎样的火花</a></li></ol></li><li class="chapter-item expanded "><a href="../../info/index.html"><strong aria-hidden="true">14.</strong> 系列说明</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../info/about_view_series.html"><strong aria-hidden="true">14.1.</strong> 关于View系列</a></li><li class="chapter-item expanded "><a href="../../info/about_sansi_series.html"><strong aria-hidden="true">14.2.</strong> 关于三思系列</a></li><li class="chapter-item expanded "><a href="../../info/about_haowan_series.html"><strong aria-hidden="true">14.3.</strong> 关于好玩系列</a></li><li class="chapter-item expanded "><a href="../../info/about_wengu_series.html"><strong aria-hidden="true">14.4.</strong> 关于温故系列</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">leobert&#x27;s blog</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="三思系列view体系认知一内容是如何正确被展现出来的--视觉呈现概览"><a class="header" href="#三思系列view体系认知一内容是如何正确被展现出来的--视觉呈现概览">三思系列：View体系认知(一)，内容是如何正确被展现出来的--视觉呈现概览</a></h1>
<h2 id="前言"><a class="header" href="#前言">前言</a></h2>
<blockquote>
<p>这是View体系认知子系列的第一篇，这一篇会探知Android中，是通过<code>怎么的设计</code>
让视图正确呈现在屏幕上的。</p>
</blockquote>
<p><a href="https://leobert-lan.github.io/info/about_sansi_series.html">关于三思系列</a></p>
<p><a href="https://github.com/leobert-lan/Blog/blob/main/info/%E5%85%B3%E4%BA%8EView%E7%B3%BB%E5%88%97.md">关于View系列</a>
极力建议读者了解一下 <code>为什么撰写这个系列</code></p>
<p>考虑到博客不适合做大量的代码展现，我会以 WorkShop 的形式展现这些代码。<a href="https://github.com/leobert-lan/ViewWorkShop">链接</a></p>
<p>我们知道，在GUI编程中，必然存在一套试图体系内容，Android中也有一套，抛开掉底层内容，和Compose中的内容， 我们这一篇，一同探究下 <code>Framework中</code>，View体系 <code>如何做视觉呈现</code>。</p>
<hr />
<p>补充：2021-02-22</p>
<p>感谢读者 <code>鲁班贼六</code>的建议，补充内容导图</p>
<p>这篇文章篇幅较长，在 View 的 measure 机制上花费了不少篇幅。本文尝试先抛开 <code>Android已有知识体系</code>，模拟 <code>从现实情况思考</code>，以建立认知体系的情况。</p>
<p>所以文章的内容编排和导图有一定出入。</p>
<p><img src="./%E4%B8%89%E6%80%9D%E7%B3%BB%E5%88%97%EF%BC%9AView%E4%BD%93%E7%B3%BB%E8%AE%A4%E7%9F%A5(%E4%B8%80)/display_content.png" alt="正确显示一个任意界面" /></p>
<blockquote>
<p>注:本文中不涉及：</p>
<ul>
<li>Canvas绘制基础</li>
<li>屏幕渲染底层机制</li>
</ul>
</blockquote>
<p>我们会先思考，如何描述一个任意的界面，引出 View 继承体系，和 View-Tree 视图树。</p>
<p>再逆推一波：当界面被描述后，需要正确显示存在以下三步：</p>
<ul>
<li>将 <code>正确内容</code> 绘制在 <code>正确位置</code>
<ul>
<li>本文中，Widget的内容绘制略</li>
</ul>
</li>
<li>依据布局规则，确定布局位置。 <strong>注</strong>：<code>显示大小</code> 也可以算作 <code>布局规则</code> 的范畴</li>
<li>测量显示大小</li>
</ul>
<p>我们会先从现实情况出发，思考并设计一种可行的 <code>测量规则</code> ，并不断完善它，重点在于：</p>
<ul>
<li><code>理解</code> 这种设计是如何 <code>演化</code> 得来的</li>
<li><code>明白</code> 测量本身就和 <code>布局规则</code> 有关，<code>布局规则</code> 会影响到测量过程</li>
</ul>
<p>如果读者对 某些内容 已经打下 坚实的基础，建议 选择性泛读。</p>
<hr />
<h2 id="如何描述一个任意的界面"><a class="header" href="#如何描述一个任意的界面">如何描述一个任意的界面</a></h2>
<p>假如我们现在对Android的内容一无所知，如何<code>描述</code> 一个 <code>任意的界面</code>。</p>
<ul>
<li>无论我们要达成什么效果，必然存在<code>一个虚拟窗体</code>，和物理屏幕相对应</li>
<li>系统层面抽象的绘制呈现过程，一定需要通过 这个 <code>虚拟窗体</code>，而我们描述的界面内容，会被放在窗体中</li>
<li>按照 <code>面向对象思想</code> 和 <code>单一职责原则</code>，描述 <code>这个窗体</code> 的类，假定被称为 <code>Window</code>，一定和描述视图的类 <code>不是同一个</code>。假定视图类被称为 <code>View</code></li>
<li>Window可以获知内部View的信息</li>
</ul>
<p>在此基础上，</p>
<p>方案1：构建一个上帝类，它全知全能，能够 <code>记录</code> 和 <code>表达</code> 任意的"文字"、"图片"、"区块"等信息。</p>
<p>方案2：构建一个简单类 <code>View</code>，它有方式知道自己多大，并抽象了视图内容绘制，可以在内部放置子 <code>View</code>，并有方式确定如何放置；</p>
<p>显然，方案1不可取。我们<code>细化方案2</code>.</p>
<p>此时，我们做出了一个假设：<code>View</code>拥有3个能力</p>
<ul>
<li>测算自身大小</li>
<li>可以放置<code>子View</code>；并知道其所在位置，即拥有 <code>布局能力</code></li>
<li>准确的知道如何绘制自身所代表的内容</li>
</ul>
<p>在此基础上，我们就可以将 <code>任意界面</code> 拆分结构，这个结构可以用 <code>树</code> 来表达。</p>
<p><a id="id_tree_rule">目前我们约定：</a></p>
<ul>
<li>每个 <code>View</code> 只能有 <code>一个</code> 双亲</li>
<li>作为双亲的 <code>View</code>，仅用来描述 <code>布局信息</code></li>
<li>实际 <code>可视</code> 、 <code>可交互</code> 的 <code>View</code>， 描述其代表的内容信息</li>
</ul>
<p>于是 <code>描述任意界面</code> 的问题，就可以用 <code>描述一棵树</code> 来解决。</p>
<blockquote>
<p>注：目前这个约定还很粗糙，但是不影响我们进行问题认知</p>
</blockquote>
<blockquote>
<p>树的存储方法有3种：</p>
<ul>
<li>双亲表示法</li>
<li>孩子表示法</li>
<li>孩子兄弟表示法</li>
</ul>
<p>以及基于以上方法的改进版本</p>
</blockquote>
<p>为了更加方便地向上和向下检索，我们使用 <code>双亲孩子表示法</code> 这一改进版本。</p>
<h3 id="细化方案2viewgroup和widget各司其职"><a class="header" href="#细化方案2viewgroup和widget各司其职">细化方案2，ViewGroup和Widget，各司其职</a></h3>
<p>按照我们上面对<a href="#id_tree_rule">树的约定</a></p>
<p>我们按职责细分：</p>
<ul>
<li>
<p>一部分View 专注于对子View的布局能力，而不再表达 "文字"、"图片"等内容信息，我们将其抽象为子类 <code>ViewGroup</code>。因为没有具体表达
<code>如何放置子View</code>的 <code>规则</code>，所以它是<code>抽象类</code>。</p>
</li>
<li>
<p>将 <code>非包含子View</code> 的，表达"文字"、"图片"等特定信息的View，归纳为Widget。</p>
</li>
</ul>
<blockquote>
<p>小结：在上面的阶段性成果中，我们已经细化了方案，用树的形式，描述了界面的结构和内容。
存在一个预设的ViewGroup，作为树的根节点。</p>
</blockquote>
<p>下面我们先给出一些伪代码。</p>
<pre><code class="language-kotlin">open class View {
    var parent: View? = null

    //绘制能力
    protected open fun onDraw(canvas: Canvas) {

    }

    //布局能力
    protected open fun onLayout(changed: Boolean, l: Int, t: Int, r: Int, b: Int) {

    }

    //测量能力
    protected open fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {

    }
}

abstract class ViewGroup : View() {
    protected val children = arrayListOf&lt;View&gt;()

    abstract override fun onLayout(changed: Boolean, l: Int, t: Int, r: Int, b: Int)

    fun addView(view: View) {
        if (view.parent != null) {
            throw IllegalArgumentException("view has a parent")
        }
        children.add(view)
        view.parent = this
    }

}

</code></pre>
<h2 id="测量大小"><a class="header" href="#测量大小">测量大小</a></h2>
<p>接下来我们设计测量大小的能力，</p>
<p>假定有一个显示文字的View，他可以测算自身的大小，但这有3种可能：</p>
<ul>
<li>恰好装下文字内容</li>
<li>被指定了大小，但和第一种大小不一致，这又分两个情况：
<ul>
<li>人为指定的明确值</li>
<li>被限定的区域，比如无法超过屏幕大小</li>
</ul>
</li>
</ul>
<p>此时仔细思考一下，对于一个 <code>View-tree</code> 而言,<code>测量</code>每一个节点大小的<code>意义</code>是什么？</p>
<blockquote>
<p><code>准确的完成布局</code> 并 <code>完成自身的绘制</code></p>
</blockquote>
<p>但是有很重要的一点： <code>屏幕的大小</code>，屏幕的大小是 <code>固定的</code> 、 <code>明确的</code>，这意味着，界面能够单次展示的最大 区域已经固定。</p>
<p>同理，对于一个有 Parent 的 View，原则上来说，它的展示区域也被限定在 Parent的区域中。</p>
<p>但是仔细一想，这并 <code>不合理</code> 啊，有一种革命式的交互： <code>滑动</code> ，可以用有限的窗口，展示无限的内容。</p>
<p>所以，我们先记住 <a id="issue_1">一个情况</a>：</p>
<blockquote>
<p>不同类型的ViewGroup，对应着不同的布局特性，他们对待 子View 的态度也是不同的，可以表现为</p>
<ul>
<li>子View 可以 要求 比自身大 的展示大小，最终满不满足以及如何满足是之后的事情。</li>
<li>子View 可以 要求 比自身大 的展示大小，但是要了也不给。</li>
</ul>
</blockquote>
<p>这时我们可以总结一个结论，展示和绘制一个内容时，有两组大小需要被考虑：</p>
<ul>
<li>内容本身的大小</li>
<li>用于展示的区域大小</li>
</ul>
<p>同样的，当一个 View 或者 ViewGroup，称之为A 被置于 ViewGroup B 中时。</p>
<p>A的大小就是内容本身的大小，B的大小就是用于展示的区域大小，递归思考之后，整个View-Tree都是这样。</p>
<p>显然，测量工作从树的 <code>根节点开始</code>，按照经验，可以使用 <code>深度优先</code> 完成整个测量工作。</p>
<p>我们希望得到的，是每个 View 所对应的 <code>展示区域大小</code>。按照刚才举的例子分析实际情况，我们可以用三种方式来指定View的展示大小：</p>
<ul>
<li>一个明确值</li>
<li>相对值：刚好能够放下它的内容 -- <code>wrap_content</code></li>
<li>相对值：撑满 Parent 的空间 -- <code>match_parent</code></li>
</ul>
<p>并在测量时，得到准确的结果。</p>
<p>我们再思考这几个取值场景：</p>
<p>对于Child而言，</p>
<ul>
<li>设置了 展示大小为 <code>明确值</code>，毋庸置疑，测量时一定可以得到这个明确值</li>
<li>设置了 展示大小为 <code>match_parent</code>, 因为测量是从 Parent 到 Child， 所以，<code>对于Child</code> 而言,只要Parent的测量工作已经完成， 即 <code>Parent</code> 已经测算出自己的 <code>精确大小</code>，
那么Child使用 <code>match_parent</code> 是可以得到明确值的。但如果Parent没有完成测算，我们先不思考这个问题</li>
<li>设置了 <code>wrap_content</code>，显然，要先测算出 <code>其内容</code> 的大小，才能得到 <code>显示区域</code> 的 <code>明确值</code></li>
</ul>
<blockquote>
<p>注 上面这一段内容，非常重要，值得仔细思考。另：上述的内容中，我们先忽略掉 <code>可能存在</code> 的 <code>内边距</code>。</p>
</blockquote>
<p>刚才我们还有一些没有考虑的内容：</p>
<blockquote>
<p>Parent 没有完成测算，Child 设置了 <code>match_parent</code></p>
</blockquote>
<p>那么，至少我们可以确定 Parent <code>不可能</code> 指定了 <code>显示大小</code> 的 <code>明确值</code>，至于其他的情况，需要用数学归纳法 <code>讨论嵌套</code>，我们换个角度思考。</p>
<p><code>根节点</code> 的ViewGroup，我们可以得到 <code>显示大小</code> 的 <code>明确值</code>，按照刚才的讨论，其子View，使用 <code>match_parent</code> 或者 <code>明确值</code> 时，结合Parent 信息，可以得到 <code>明确值</code>；</p>
<p>只有当其为 <code>wrap_content</code> 时，需要继续测量其内容，再根据内容的大小，确定自身显示大小。</p>
<p>可以确定，当树中的一个节点为<code>wrap_content</code> 时，将<code>该节点</code>作为根节点，取出子树，当该子树的 <code>所有分支</code> 都能够找到满足 <code>条件R</code> 的节点时， 该根节点能够确定自身需要的显示大小。</p>
<blockquote>
<p><a id="issue_1_rule">条件R</a>为：该View</p>
<ul>
<li>指定 显示大小为 <code>match_parent</code> 或者 <code>明确值</code></li>
<li>或者其 <code>布局要求</code> 能够让 parent 大小撑满至一个 <code>明确值</code></li>
</ul>
</blockquote>
<p><strong>上面这一段内容有点长，适当消化一下</strong></p>
<p>此时，我们可以做出一点约定：</p>
<blockquote>
<p>Parent 多承担一点责任，结合自身情况，和Child情况，先确定一下，Child是否可以得到明确的显示大小，</p>
<ul>
<li>如果不可以，就将自身信息传递给Child，让它向下继续处理</li>
<li>如果可以，那么 Parent 可以得出Child的显示大小, <strong>注意</strong> <code>不同类型的Parent</code>，应该有<code>不同的计算方式</code>。 这在<a href="#issue_1">前面</a>提到过</li>
</ul>
</blockquote>
<h3 id="确定测量规则"><a class="header" href="#确定测量规则">确定测量规则</a></h3>
<p>经过上面的思考，我们可以拟定测量规则了。</p>
<ol>
<li>测量必然从一个<code>明确自身展示大小</code> 的 ViewGroup 开始</li>
<li>对于一个<code>子View</code> -- <code>A</code>，当其 <code>Parent</code> -- <code>P</code> 判断出 <code>A</code>
<ul>
<li>可以得到 <code>明确的</code> 显示大小时，将 该信息： <code>可准确得到结果</code> + <code>结果值</code> 传递给 子View A； <em>注意，结果值是 Parent 按照自身规则计算的，和子View要求的可能不一致</em></li>
<li>否则，将 P 的 <code>自身大小</code> 和 <code>你还需要继续测量以得到结果</code> 的信息传递给 子View A。</li>
</ul>
</li>
<li>对于一个Parent，如果它是 <code>wrap_content</code>，则需要在子View 的显示大小都确定时，再计算自身大小。</li>
<li>只要View-Tree中还 存在 <code>未确定</code> 自身 显示大小 的节点。就需要从根节点开始，继续遍历处理测量。</li>
</ol>
<p>让表达更加准确一些，<code>可准确得到结果</code> 用 <code>EXACTLY</code> 代替。 <code>你还需要继续测量以得到结果</code> 用 <code>AT_MOST</code> 代替。</p>
<p>不言自明，<code>AT_MOST</code> 意味着会给定一个最大值。意味着：家族中的直系长辈 已经帮它 限定了人身自由。</p>
<blockquote>
<p>方便准确表达，将他们称为 <code>测量模式</code>，简称 <code>mode</code> ：</p>
<ul>
<li><code>EXACTLY</code>：Parent 已经为 Child 决定了显示大小，按照规则，Child 应当使用 Parent 给定的值</li>
<li><code>AT_MOST</code>：Parent 已经为 Child 决定了最大显示大小，按照规则，Child 自行决定使用 <code>最大不超过该值</code> 的显示大小</li>
</ul>
</blockquote>
<blockquote>
<p>方便表达, 将 <code>显示大小</code> 简称为 <code>size</code></p>
<p>显示和屏幕像素数量有关，显然，该数量是自然数范畴。size 在绝大多数情况下，可以用 Int值 准确表达，极少数情况下，大到越界，但极不合理。</p>
</blockquote>
<p>若使用对象封装 <code>mode</code> 和 <code>size</code>，会出现大量的对象创建，这一点都不优雅，可以将 Int 分为 <code>高位区域</code> 和 <code>低位区域</code> 分别表达 <code>mode</code> 和 <code>size</code>
<strong>这也是Android中采用的设计</strong></p>
<p>考虑到 <code>测量模式</code> 中，还可能存在 Parent 不约束 Child 的情况。</p>
<p>我们使用一个 <code>32位Int</code> 的 <code>高2位</code> 标识 <code>mode</code>，<code>低30位</code> 标识 <code>size</code></p>
<h3 id="进一步优化以减少遍历"><a class="header" href="#进一步优化以减少遍历">进一步优化以减少遍历</a></h3>
<p>规则的第4点中，是通过 <code>迭代</code> 的方式，完成整个树中所有节点的测量，按照实际分析，我们可以用 <code>递归</code>
来简化。</p>
<blockquote>
<p>我们约定, 对于一个 设置了 <code>wrap_content</code> 的尾端节点，如果它没有实质的内容物，我们也认为它 <code>已经测量出了</code> 需要的展示大小</p>
</blockquote>
<p>那么在一次递归中，我们就可以完成整个树的测量。</p>
<p>在 <code>递</code> 的过程中，仅有设置为 <code>wrap_content</code> 的 Parent角色 无法完成准确测量，而 <code>尾端节点</code> 必然完成了自身的测量。</p>
<p>开始 <code>归</code> 的过程，我们可以确定，每 <code>归</code> 到一个 Parent，</p>
<ul>
<li>已经完成测量的继续 <code>归</code>，</li>
<li>没有完成测量的，它的 Children 都完成了测量，则按照 <code>wrap_content</code> 的定义，它必然可以完成测量，然后继续 <code>归</code></li>
</ul>
<p>最终整棵树完成测量。</p>
<h3 id="完善规则再添加一种mode"><a class="header" href="#完善规则再添加一种mode">完善规则，再添加一种mode</a></h3>
<p>前面我们提到了 <code>滑动</code> 这一交互形式，可以利用 <code>有限的</code> 展示空间，显示 <code>无限的</code> 内容。</p>
<p>即，我们会遇到一些场景，Child 并不会收到 Parent 的制约。更加准确的说，是 <code>内容</code> 不受到 <code>呈现主体</code> 在显示空间上的制约。</p>
<p>而这个场景，超越了 <code>EXACTLY</code> 和 <code>AT_MOST</code> 两种测量模式的功能，我们还需要一种配套的测量模式：</p>
<p><code>UNSPECIFIED</code>，即 Parent 不约束 Child，Child按照自身情况，自行测算。</p>
<blockquote>
<p>注：对于 <code>UNSPECIFIED</code> ，<code>不要</code> 强行结合场景，尤其是 <code>不要</code> 利用 <code>warp_content</code>或者 <code>match_parent</code>的概念去理解。他们虽然有一些关联，
但并不是一个范畴的内容，也不可以相互推导。</p>
<p>因此，我单独将其拎了出来。</p>
</blockquote>
<h3 id="编码以验证"><a class="header" href="#编码以验证">编码以验证</a></h3>
<blockquote>
<p>参考Android中FrameLayout的布局规则，它对于Child要求的大小为：
子View 可以 要求 比自身大 的展示大小，但是超过自身显示范围的不予显示。
所以，不 按照自身情况 调整 子View的 size</p>
</blockquote>
<p>先给View添加一些必要的内容：</p>
<pre><code class="language-kotlin">open class View {

    companion object {
        const val layout_width = "layout_width"
        const val layout_height = "layout_height"
        var debug = true
    }

    var tag: Any? = null

    var parent: View? = null

    val layoutParams: MutableMap&lt;String, Int&gt; = mutableMapOf()

    var measuredWidth: Int = WRAP_CONTENT

    var measuredHeight: Int = WRAP_CONTENT

    val heightMeasuredSize: Int
        get() = android.view.View.MeasureSpec.getSize(measuredHeight)

    val widthMeasuredSize: Int
        get() = android.view.View.MeasureSpec.getSize(measuredWidth)

    val heightMeasureMode: Int
        get() = android.view.View.MeasureSpec.getMode(measuredHeight)

    val widthMeasureMode: Int
        get() = android.view.View.MeasureSpec.getMode(measuredWidth)


    private var measured: Boolean = false

    fun isMeasured() = measured

    //绘制能力
    protected open fun onDraw(canvas: Canvas) {

    }

    //布局能力
    protected open fun onLayout(changed: Boolean, l: Int, t: Int, r: Int, b: Int) {

    }

    fun measure(widthMeasureSpec: Int, heightMeasureSpec: Int) {
        if (!measured) {
            onMeasure(widthMeasureSpec, heightMeasureSpec)
        }
    }

    //测量能力
    protected open fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {
        setMeasuredDimensionRaw(widthMeasureSpec, heightMeasureSpec)
        debugMeasureInfo()
    }

    protected fun debugMeasureInfo() {
        if (debug) {
            Log.d(
                "view-debug",
                "$tag has measured: $measured, w mode:${getMode(widthMeasureMode)}, w size: $widthMeasuredSize " +
                        "h mode:${getMode(heightMeasureMode)}, h size: $heightMeasuredSize "
            )
        }
    }

    protected fun setMeasuredDimension(measuredWidth: Int, measuredHeight: Int) {
        setMeasuredDimensionRaw(measuredWidth, measuredHeight)
    }

    private fun setMeasuredDimensionRaw(measuredWidth: Int, measuredHeight: Int) {
        this.measuredWidth = measuredWidth
        this.measuredHeight = measuredHeight
        measured = true
        if (debug) {
            Log.d(
                "view-debug",
                "$tag mark has measured: $measured"
            )
        }
    }
}
</code></pre>
<p>添加一个FrameLayout：</p>
<pre><code class="language-kotlin">class FrameLayout : ViewGroup() {
    override fun onLayout(changed: Boolean, l: Int, t: Int, r: Int, b: Int) {
    }

    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {
        //handle horizon
        val widthMode = View.MeasureSpec.getMode(widthMeasureSpec)
        var widthSize = View.MeasureSpec.getSize(widthMeasureSpec)

        var wMeasured = false
        var hMeasured = false
        when (widthMode) {
            View.MeasureSpec.EXACTLY -&gt; {
                // widthSize 即为Parent 为此决定的准确值，直接采用
                wMeasured = true
            }
            View.MeasureSpec.AT_MOST -&gt; {
                // 需要再次测量，但可以保存该信息了
                measuredWidth = widthMeasureSpec
            }
            else -&gt; {
                throw IllegalStateException("暂不支持测量模式：$widthMode")
            }
        }

        //同理处理 vertical方向

        val heightMode = View.MeasureSpec.getMode(heightMeasureSpec)
        var heightSize = View.MeasureSpec.getSize(heightMeasureSpec)

        when (heightMode) {
            View.MeasureSpec.EXACTLY -&gt; {
                hMeasured = true
            }
            View.MeasureSpec.AT_MOST -&gt; {
                measuredHeight = heightMeasureSpec
            }
            else -&gt; {
                throw IllegalStateException("暂不支持测量模式：$widthMode")
            }
        }

        if (hMeasured &amp;&amp; wMeasured) {
            setMeasuredDimension(widthMeasureSpec, heightMeasureSpec)
        }

        children.forEach {
            val childWidthMeasureSpec = makeMeasureSpec(widthMode, widthSize, it.layoutWidth)
            val childHeightMeasureSpec = makeMeasureSpec(heightMode, heightSize, it.layoutHeight)
            it.measure(childWidthMeasureSpec, childHeightMeasureSpec)
        }


        if (!hMeasured || !wMeasured) {
            var w = 0
            var h = 0
            children.forEach {
                if (!wMeasured)
                    w = maxOf(w, it.widthMeasuredSize)

                if (!hMeasured)
                    h = maxOf(h, it.heightMeasuredSize)
            }

            if (wMeasured)
                w = widthSize

            if (hMeasured)
                h = heightSize

            setMeasuredDimension(
                View.MeasureSpec.makeMeasureSpec(w, widthMode),
                View.MeasureSpec.makeMeasureSpec(h, heightMode),
            )
        }
        if (!allChildHasMeasured())
            throw IllegalStateException("child 未全部完成测量")

        debugMeasureInfo()
    }

    private fun makeMeasureSpec(mode: Int, size: Int, childSize: Int): Int {
        // 参考Android中FrameLayout的布局规则，它对于Child要求的大小为：
        // 子View 可以 要求 比自身大 的展示大小，但是超过自身显示范围的不予显示。
        // 所以，不 按照自身情况 调整 子View的 size
        val childMode = when (childSize) {
            WRAP_CONTENT -&gt; View.MeasureSpec.AT_MOST
            else -&gt; View.MeasureSpec.EXACTLY

        }

        val childSize2 = when (childSize) {
            WRAP_CONTENT -&gt; size
            MATCH_PARENT -&gt; size
            else -&gt; childSize
        }
        return View.MeasureSpec.makeMeasureSpec(childSize2, childMode)
    }

    private fun allChildHasMeasured(): Boolean {
        val i = children.iterator()
        while (i.hasNext()) {
            if (!i.next().isMeasured())
                return false
        }

        return true
    }

}
</code></pre>
<p>以上代码 结合前面的规则 理解下即可</p>
<p>目前还没有到LayoutParam的阶段，我们将 必要的布局信息 声明在 map 中存储。</p>
<p>我们适当添加添加一些助手类，以建立View-tree</p>
<pre><code class="language-kotlin">enum class Mode(val v: Int) {

    /**
     * Measure specification mode: The parent has not imposed any constraint
     * on the child. It can be whatever size it wants.
     */
    UNSPECIFIED(0 shl 30),

    /**
     * Measure specification mode: The parent has determined an exact size
     * for the child. The child is going to be given those bounds regardless
     * of how big it wants to be.
     */
    EXACTLY(1 shl 30),

    /**
     * Measure specification mode: The child can be as large as it wants up
     * to the specified size.
     */
    AT_MOST(2 shl 30)
}

class A {
    companion object {
        fun getMode(v: Int): Mode {
            Mode.values().forEach {
                if (it.v == v)
                    return it
            }
            throw IllegalStateException()
        }
    }
}
</code></pre>
<p>以上代码不言自明</p>
<pre><code class="language-kotlin">typealias Decor&lt;T&gt; = (v: T) -&gt; Unit

val MATCH_PARENT: Int = android.view.ViewGroup.LayoutParams.MATCH_PARENT
val WRAP_CONTENT = android.view.ViewGroup.LayoutParams.WRAP_CONTENT

var View.layoutWidth: Int
    get() {
        return layoutParams[View.layout_width] ?: WRAP_CONTENT
    }
    set(value) {
        layoutParams[View.layout_width] = value
    }

var View.layoutHeight: Int
    get() {
        return layoutParams[View.layout_height] ?: WRAP_CONTENT
    }
    set(value) {
        layoutParams[View.layout_height] = value
    }


fun root(): ViewGroup = FrameLayout().apply {
    this.layoutWidth = 1080
    this.layoutHeight = 1920
}

inline fun ViewGroup?.frameLayout(decor: Decor&lt;FrameLayout&gt;): ViewGroup {
    val child = FrameLayout()
    child.let(decor)
    return this?.apply { addView(child) } ?: child
}

inline fun ViewGroup.view(decor: Decor&lt;View&gt;): ViewGroup {
    val child = View()
    child.let(decor)
    return this.apply { addView(child) }
}
</code></pre>
<p>用以实现树结构描述的助手，不言自明</p>
<p>偷个懒，不设计单元测试了，构建一个结构：</p>
<pre><code class="language-kotlin">class ViewTest {

    @Test
    fun testMeasure() {

        val tree = root().frameLayout { v1 -&gt;

            v1.tag = "v1"
            v1.layoutWidth = MATCH_PARENT
            v1.layoutHeight = WRAP_CONTENT

            v1.frameLayout { frameLayout -&gt;
                frameLayout.tag = "v2"
                frameLayout.layoutWidth = MATCH_PARENT
                frameLayout.layoutHeight = WRAP_CONTENT

                frameLayout.view {
                    it.tag = "v3"
                    it.layoutWidth = 200
                    it.layoutHeight = 300
                }

                frameLayout.frameLayout {
                    it.tag = "v4"
                    it.layoutWidth = WRAP_CONTENT
                    it.layoutHeight = WRAP_CONTENT
                }
            }
        }

        tree.tag = "root"


        tree.measure(
            View.MeasureSpec.makeMeasureSpec(1080, View.MeasureSpec.EXACTLY),
            View.MeasureSpec.makeMeasureSpec(1920, View.MeasureSpec.EXACTLY)
        )
        assert(tree is FrameLayout)
        assertEquals(true, (tree as FrameLayout).allChildHasMeasured())
    }
}
</code></pre>
<p>直接看一下日志输出的信息：</p>
<pre><code class="language-shell">I/TestRunner: started: testMeasure(osp.leobert.blog.code.ViewTest)
D/view-debug: root mark has measured: true
D/view-debug: v3 mark has measured: true
D/view-debug: v3 has measured: true, w mode:EXACTLY, w size: 200 h mode:EXACTLY, h size: 300 
D/view-debug: v4 mark has measured: true
D/view-debug: v4 has measured: true, w mode:AT_MOST, w size: 0 h mode:AT_MOST, h size: 0 
D/view-debug: v2 mark has measured: true
D/view-debug: v2 has measured: true, w mode:EXACTLY, w size: 1080 h mode:AT_MOST, h size: 300 
D/view-debug: v1 mark has measured: true
D/view-debug: v1 has measured: true, w mode:EXACTLY, w size: 1080 h mode:AT_MOST, h size: 300 
D/view-debug: root has measured: true, w mode:EXACTLY, w size: 1080 h mode:EXACTLY, h size: 1920 
I/TestRunner: finished: testMeasure(osp.leobert.blog.code.ViewTest)
</code></pre>
<p>考虑到 一组 Parent 和 Child 有9种组合，我们全部验证一下。限于篇幅就不放代码和结果了</p>
<hr />
<blockquote>
<p>小结：上面通过很长一段篇幅，让我们在 <code>抛开Android的知识</code> 的前提下：</p>
<blockquote>
<ol>
<li>思考了如何设计一套系统，用以描述任意的界面</li>
</ol>
</blockquote>
<p>根据经验确定了使用 <code>视图树</code> 的方式，进行界面的描述，并意识到，应用 <code>不同的类</code> 来封装不同的功能，相互配合，完成界面描述工作。</p>
<blockquote>
<ol start="2">
<li>思考了描述尺寸的 <code>两种方式</code> 、<code>三种取值类型</code>，并延伸出 <code>测量</code> <code>视图树</code> 每个节点的 <code>显示大小</code> 问题。</li>
</ol>
</blockquote>
<p>从现实角度出发，得出一种测量方式，并进行了优化，得出结论：</p>
<ul>
<li>
<p>测量过程从 Parent 到 Child。Parent 结合自身情况和 Child的情况，为 Child 决定测量的<code>模式</code> 即 <code>mode</code>， 以及 <code>EXACTLY</code> 模式下的精准值 和 <code>AT_MOST</code> 模式下的 <code>最大值</code> 参考值</p>
<ul>
<li>从 Parent 到 Child 表现为：测量的入口为 <code>measure()</code>，其中封装了调用自身<code>onMeasure()</code> 的逻辑, 具体ViewGroup 类覆写 <code>onMeasure()</code> 并调用 Child的 <code>measure()</code> 方法,传递测量过程</li>
<li>显示大小的 <code>测量</code> 和 <code>布局规则</code> 有关</li>
</ul>
</li>
<li>
<p>通过一次递归即可测量出视图树每个节点的显示大小</p>
</li>
</ul>
<p>至此，我们对这套测量机制已经有了足够的认知，但是请注意，它还没有被完善。</p>
</blockquote>
<h2 id="确定布局位置"><a class="header" href="#确定布局位置">确定布局位置</a></h2>
<p>在前面，我们思考了一套可行的测量方案，其中我们提到：<a href="#issue_1">一个情况</a></p>
<p>并且，提出了<a href="#issue_1_rule">条件R</a>, 我们在其中提到了一个概念： <code>布局规则</code></p>
<p>结合我们的经验，不同的GUI中，都会有布局规则体系。为了解决可能出现的布局需求，均抽象了不同的布局类，以实现不同的规则。</p>
<p>前面我们也提到了，不同的规则下，ViewGroup 对 子View 的测量是不同的。</p>
<p>这很合理，<code>测量的目的</code> 是为了 <code>正确布局</code>，不同的布局规则，具有特定的测量规则。</p>
<h3 id="使用-layoutparams-描述布局规则和信息"><a class="header" href="#使用-layoutparams-描述布局规则和信息">使用 LayoutParams 描述布局规则和信息</a></h3>
<p>在前面，我们参考Android 建立了 FrameLayout 类，实现了 <code>帧布局</code> 的规则， 当然，这一种规则还不足以处理各种界面布局需求，还有更多的ViewGroup子类 等着我们实现。</p>
<blockquote>
<p>换个说法：当 一个View 被 添加到 一个ViewGroup 中时，需要按照该ViewGroup的布局规则，阐述自身的布局信息.
必要信息不可缺省</p>
</blockquote>
<p>显然，</p>
<ul>
<li>按照面向对象思想，布局规则簇 应该被封装为类，称之为 <code>LayoutParams</code>。</li>
<li>按照单一职责原则，不同的布局规则，对应不同的ViewGroup子类，也对应不同的 <code>LayoutParams</code>类，显然这是一一对应的</li>
<li>按照依赖倒置原则，View 的 layoutParam 依赖于 抽象，而不是某个规则的具体类；</li>
<li>按照里氏代换原则，LayoutParams的继承关系，和ViewGroup的继承关系应当是对应的；</li>
</ul>
<p>按照经验，我们会写出如下代码，一个 <code>必须指定宽高规则</code> 的 <code>ViewGroup.LayoutParams 基类</code>。</p>
<p>而视图 <code>可以</code> 存在 <code>内、外边距</code>，这可以被认为是 <code>基本规则</code>。</p>
<p>继续为FrameLayout 加上 <code>重力</code> 规则。</p>
<p>我们很快写出如下代码：</p>
<pre><code class="language-kotlin">abstract class ViewGroup : View() {
    open class LayoutParams(var width: Int, var height: Int) {

    }

    open class MarginLayoutParams(width: Int, height: Int) : LayoutParams(width, height) {
        var leftMargin = 0

        var topMargin = 0

        var rightMargin = 0

        var bottomMargin = 0
    }
}

class FrameLayout : ViewGroup() {
    class LayoutParams(width: Int, height: Int) : ViewGroup.MarginLayoutParams(width, height) {
        val UNSPECIFIED_GRAVITY = -1

        var gravity = UNSPECIFIED_GRAVITY
    }

    override fun onLayout(changed: Boolean, l: Int, t: Int, r: Int, b: Int) {
    }

    override fun checkLayoutParams(layoutParams: ViewGroup.LayoutParams): Boolean {
        return layoutParams is LayoutParams
    }

    override fun generateDefaultLayoutParams(): ViewGroup.LayoutParams {
        return LayoutParams(MATCH_PARENT, MATCH_PARENT)
    }
}
</code></pre>
<p>并对原先的Demo工程进行重构， <em>限于篇幅，略去相关代码</em></p>
<blockquote>
<p>注：按照里氏代换原则，我们定义的 LayoutParams 体系在使用中时，可能会遇到 <code>输入不符合期望</code> 的问题。此时我们需要了解一下：
<code>契约式设计</code>：</p>
<blockquote>
<p>使用契约式设计，类中的方法需要声明前置条件和后置条件。前置条件为真，则方法才能被执行。而在方法调用完成之前，方法本身将确保后置条件也成立。</p>
</blockquote>
<p>于是，在ViewGroup 体系中，设计了：</p>
<ul>
<li>checkLayoutParams(layoutParams: ViewGroup.LayoutParams): Boolean</li>
<li>generateDefaultLayoutParams(): ViewGroup.LayoutParams</li>
</ul>
<p>我们可以采用两种契约：</p>
<ul>
<li>输入的LayoutParams 必须满足约束，否则抛出异常</li>
<li>输入的LayoutParams 需要满足约束，否则使用默认规则</li>
</ul>
</blockquote>
<h3 id="获得布局规则信息按照viewgroup-的布局规则进行布局"><a class="header" href="#获得布局规则信息按照viewgroup-的布局规则进行布局">获得布局规则信息、按照ViewGroup 的布局规则进行布局</a></h3>
<blockquote>
<p>至此，我们已经理解了：</p>
<ul>
<li>使用视图树描述一个任意视图</li>
<li>用不同的 ViewGroup 子类描述不同的布局，他们具有特定的布局规则；用不同的 Widget 展现不同的内容</li>
<li>一种 测量<code>视图树各个节点</code> 的 <code>显示大小</code> 的测量方式</li>
<li>不同的规则，决定了显示大小测算的细节有所不同</li>
<li>使用LayoutParams 描述布局规则信息</li>
</ul>
</blockquote>
<p>在此基础上，我们需要接受设定：</p>
<blockquote>
<p>存在一个机制，可以正确地解析 <code>视图树各个节点</code> 中申明的 <code>布局规则信息</code>，这些信息，会存储在正确的
LayoutParams 对象中，被对应的节点所持有，以待使用。</p>
<p>这个机制，我们先忽略。</p>
</blockquote>
<p>按照刚才获得的经验，布局和测量的过程类似，</p>
<p>我们定义 <code>layout()</code> 和 <code>onLayout()</code> 方法</p>
<pre><code class="language-kotlin">open class View {
    open fun layout(l: Int, t: Int, r: Int, b: Int) {
        //todo
    }

    //布局能力
    protected open fun onLayout(changed: Boolean, l: Int, t: Int, r: Int, b: Int) {

    }
}
</code></pre>
<p>对于参数，约定为：</p>
<ul>
<li>l Left position, relative to parent</li>
<li>t Top position, relative to parent</li>
<li>r Right position, relative to parent</li>
<li>b Bottom position, relative to parent</li>
</ul>
<p>在完成了 <code>大小测试</code> 和 <code>布局规则解析</code> 的前提下，这些相对值的计算并不复杂。</p>
<p>我们约定，实际的布局逻辑，在onLayout中完成，而layout方法，用于实现 <code>前置条件</code>，onLayout调用 和 <code>状态维护</code></p>
<p>对于 ViewGroup 而言，需要遍历Children，为每个 Child，使用其显示大小信息&amp;布局规则信息，确定其布局位置，即 l,t,r,b 四个参数值。
调用 Child 的 layout() 方法。</p>
<p>对于 Widget 而言，则是需要决定Content的展示区域，因为 Content 不再是 View，不再需要继续向下调用 layout 方法。</p>
<p>至此，所有的准备工作均已完成，接下来，就是绘制工作。</p>
<h2 id="最后一步绘制在正确位置"><a class="header" href="#最后一步绘制在正确位置">最后一步，绘制在正确位置</a></h2>
<p>在此之前，我们已经得到了视图树每个节点的正确位置，此时，只需要将内容绘制在对应位置，即可通过屏幕呈现在用户眼前。</p>
<p>按照之前的经验，我们定义：</p>
<ul>
<li>draw(canvas:Canvas) 方法，封装整个绘制流程</li>
<li>onDraw(canvas:Canvas) 方法，实现内容的绘制</li>
<li>如果在ViewGroup中覆写onDraw(canvas:Canvas) 同时 实现 <code>自身内容的绘制</code>，<em>例如背景</em> ，和 <code>分发 Child 的绘制</code>，这并不符合开闭原则
故而添加 dispatchDraw(canvas: Canvas) 用以实现 <code>分发 Child 的绘制</code></li>
</ul>
<p>其实到此为止，我们已经对 <code>正确展示内容</code> 有了比较完善的认知，绘制的内容，理解不复杂，但内容很庞杂，本篇就不再展开了。</p>
<h2 id="展望"><a class="header" href="#展望">展望</a></h2>
<p>本身还计划再写如下内容的：</p>
<ul>
<li>和Framework中的实现思路进行对比</li>
<li>编码验证布局规则 等</li>
</ul>
<p>限于篇幅，这些内容被择掉了。不过我会将一些 <code>编码验证</code>的内容以 <a href="https://github.com/leobert-lan/ViewWorkShop">WorkShop</a> 的形式展现。</p>
<p>下一篇，会对 <code>View</code>体系的 <code>交互</code> 功能进行探索。<code>点关注不迷路</code>。</p>
<blockquote>
<p>注：关于WorkShop的内容，原定计划是配合博客中的知识体系，独立建立一套 <code>简单的</code>，<code>可视交互</code> 系统。用以验证和帮助理解 Android-View 体系的知识。</p>
<p>希望今年的业务时间还能比较充裕。</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../Android/View/post_1.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../Android/View/post_7.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../Android/View/post_1.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../Android/View/post_7.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
